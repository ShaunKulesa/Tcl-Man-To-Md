<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://www.tcl.tk/man/tcl8.6.13/TclCmd/contents.html/info/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>NAME - Tcl/Tk</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "NAME";
        var mkdocs_page_input_path = "info.md";
        var mkdocs_page_url = "/man/tcl8.6.13/TclCmd/contents.html/info/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Tcl/Tk
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../command.md">Commands</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Tcl/Tk</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>NAME</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="name">NAME</h1>
<p>info - Information about the state of the Tcl interpreter</p>
<h1 id="synopsis">SYNOPSIS</h1>
<p><strong>info </strong><em>option </em>?<em>arg arg ...</em>?</p>
<h1 id="description">DESCRIPTION</h1>
<p>Available commands:</p>
<p><strong>info args </strong><em>procname</em></p>
<p>:   Returns the names of the parameters to the procedure named
    <em>procname</em>.</p>
<p><strong>info body </strong><em>procname</em></p>
<p>:   Returns the body of the procedure named <em>procname</em>.</p>
<p><strong>info class</strong><em> subcommand class</em> ?<em>arg ...</em></p>
<p>:   Returns information about the class named <em>class</em>. See <strong>CLASS
    INTROSPECTION</strong> below.</p>
<p><strong>info cmdcount</strong></p>
<p>:   Returns the total number of commands evaluated in this interpreter.</p>
<p><strong>info cmdtype </strong><em>commandName</em></p>
<p>:   </p>
<p>Returns a the type of the command named <em>commandName</em>. Built-in types
are:</p>
<blockquote>
<p>alias</p>
<p>:   <em>commandName</em> was created by <strong>interp alias</strong>. In a safe
    interpreter an alias is only visible if both the alias and the
    target are visible.</p>
<p>coroutine</p>
<p>:   <em>commandName</em> was created by <strong>coroutine</strong>.</p>
<p>ensemble</p>
<p>:   <em>commandName</em> was created by <strong>namespace ensemble</strong>.</p>
<p>import</p>
<p>:   <em>commandName</em> was created by <strong>namespace import</strong>.</p>
<p>native</p>
<p>:   <em>commandName</em> was created by the <strong>Tcl_CreateObjProc</strong> interface
    directly without further registration of the type of command.</p>
<p>object</p>
<p>:   <em>commandName</em> is the public command that represents an instance of
    <strong>oo::object</strong> or one of its subclasses.</p>
<p>privateObject</p>
<p>:   <em>commandName</em> is the private command, <strong>my</strong> by default, that
    represents an instance of <strong>oo::object</strong> or one of its subclasses.</p>
<p>proc</p>
<p>:   <em>commandName</em> was created by <strong>proc</strong>.</p>
<p>interp</p>
<p>:   <em>commandName</em> was created by <strong>interp create</strong>.</p>
<p>zlibStream</p>
<p>:   <em>commandName</em> was created by <strong>zlib stream</strong>.</p>
</blockquote>
<p><strong>info commands </strong>?<em>pattern</em>?</p>
<p>:   Returns the names of all commands visible in the current namespace.
    If <em>pattern</em> is given, returns only those names that match according
    to <strong>string match</strong>. Only the last component of <em>pattern</em> is a
    pattern. Other components identify a namespace. See <strong>NAMESPACE
    RESOLUTION</strong> in the <strong>namespace</strong>(n) documentation.</p>
<p><strong>info complete </strong><em>command</em></p>
<p>:   Returns 1 if <em>command</em> is a complete command, and <strong>0</strong> otherwise.
    Typically used in line-oriented input environments to allow users to
    type in commands that span multiple lines.</p>
<p><strong>info coroutine</strong></p>
<p>:   Returns the name of the current <strong>coroutine</strong>, or the empty string
    if there is no current coroutine or the current coroutine has been
    deleted.</p>
<p><strong>info default </strong><em>procname parameter varname</em></p>
<p>:   If the parameter <em>parameter</em> for the procedure named <em>procname</em> has
    a default value, stores that value in <em>varname</em> and returns <strong>1</strong>.
    Otherwise, returns <strong>0</strong>.</p>
<p><strong>info errorstack </strong>?<em>interp</em>?</p>
<p>:   Returns a description of the active command at each level for the
    last error in the current interpreter, or in the interpreter named
    <em>interp</em> if given.</p>
<pre><code>The description is a dictionary of tokens and parameters. Tokens are
currently either **CALL**, **UP**, or **INNER**, but other values
may be introduced in the future. **CALL** indicates a command call,
and its parameter is the corresponding **info level** **0**. **UP**
indicates a shift in variable frames generated by **uplevel** or
similar, and applies to the previous **CALL** item. Its parameter is
the level offset. **INNER** identifies the

which is the innermost atomic command or bytecode instruction that
raised the error, along with its arguments when available. While
**CALL** and **UP** provide a trail of the call path, **INNER**
provides details of the offending operation in the innermost
procedure call, even to sub-expression granularity.

This information is also present in the **-errorstack** entry of the
options dictionary returned by 3-argument **catch**; **info
errorstack** is a convenient way of retrieving it for uncaught
errors at top-level in an interactive **interpreter**.
</code></pre>
<p><strong>info exists </strong><em>varName</em></p>
<p>:   Returns <strong>1</strong> if a variable named <em>varName</em> is visible and has been
    defined, and <strong>0</strong> otherwise.</p>
<p><strong>info frame</strong> ?<em>depth</em>?</p>
<p>:   Returns the depth of the call to <strong>info frame</strong> itself. Otherwise,
    returns a dictionary describing the active command at the <em>depth</em>,
    which counts all commands visible to <strong>info level</strong>, plus commands
    that don\'t create a new level, such as <strong>eval</strong>, <strong>source</strong>, or
    <em>uplevel</em>. The frame depth is always greater than the current level.</p>
<pre><code>If *depth* is greater than **0** it is the frame at that depth.
Otherwise it is the number of frames up from the current frame.

As with **info level** and error traces, for nested commands like

only

is seen by **info frame** invoked within

The dictionary may contain the following keys:

**type**

:   Always present. Possible values are **source**, **proc**,
    **eval**, and **precompiled**.

    **source**

    :   A script loaded via the **source** command.

    **proc**

    :   The body of a procedure that could not be traced back to a
        line in a particular script.

    **eval**

    :   The body of a script provided to **eval** or **uplevel**.

    **precompiled**

    :   A precompiled script (loadable by the package **tbcload**),
        and no further information is available.

**line**

:   The line number of of the command inside its script. Not
    available for **precompiled** commands. When the type is
    **source**, the line number is relative to the beginning of the
    file, whereas for the last two types it is relative to the start
    of the script.

**file**

:   For type **source**, provides the normalized path of the file
    that contains the command.

**cmd**

:   The command before substitutions were performed.

**proc**

:   For type **prod**, the name of the procedure containing the
    command.

**lambda**

:   For a command in a script evaluated as the body of an unnamed
    routine via the **apply** command, the definition of that
    routine.

**level**

:   For a frame that corresponds to a level, (to be determined).

When a command can be traced to its literal definition in some
script, e.g. procedures nested in statically defined procedures, and
literal eval scripts in files or statically defined procedures, its
type is **source** and its location is the absolute line number in
the script. Otherwise, its type is **proc** and its location is its
line number within the body of the procedure.

In contrast, procedure definitions and **eval** within a dynamically
**eval**uated environment count line numbers relative to the start
of their script, even if they would be able to count relative to the
start of the outer dynamic script. That type of number usually makes
more sense.

A different way of describing this behaviour is that file-based
locations are tracked as deeply as possible, and where this is not
possible the lines are counted based on the smallest possible
**eval** or procedure body, as that scope is usually easier to find
than any dynamic outer scope.

The syntactic form **{\*}** is handled like **eval**. I.e. if it is
given a literal list argument the system tracks the line number
within the list words as well, and otherwise all line numbers are
counted relative to the start of each word (smallest scope)
</code></pre>
<p><strong>info functions </strong>?<em>pattern</em>?</p>
<p>:   If <em>pattern</em> is not given, returns a list of all the math functions
    currently defined. If <em>pattern</em> is given, returns only those names
    that match <em>pattern</em> according to <strong>string match</strong>.</p>
<p><strong>info globals </strong>?<em>pattern</em>?</p>
<p>:   If <em>pattern</em> is not given, returns a list of all the names of
    currently-defined global variables. Global variables are variables
    in the global namespace. If <em>pattern</em> is given, only those names
    matching <em>pattern</em> are returned. Matching is determined using the
    same rules as for <strong>string match</strong>.</p>
<p><strong>info hostname</strong></p>
<p>:   Returns the name of the current host.</p>
<p>This name is not guaranteed to be the fully-qualified domain name of the
host. Where machines have several different names, as is common on
systems with both TCP/IP (DNS) and NetBIOS-based networking installed,
it is the name that is suitable for TCP/IP networking that is returned.</p>
<p><strong>info level</strong> ?<em>level</em>?</p>
<p>:   If <em>number</em> is not given, the level this routine was called from.
    Otherwise returns the complete command active at the given level. If
    <em>number</em> is greater than <strong>0</strong>, it is the desired level. Otherwise,
    it is <em>number</em> levels up from the current level. A complete command
    is the words in the command, with all subsitutions performed,
    meaning that it is a list. See <strong>uplevel</strong> for more information on
    levels.</p>
<p><strong>info library</strong></p>
<p>:   Returns the value of <strong>tcl_library</strong>, which is the name of the
    library directory in which the scripts distributed with Tcl scripts
    are stored.</p>
<p><strong>info loaded </strong>?<em>interp</em>? ?<em>package</em>?</p>
<p>:   Returns the name of each file loaded in <em>interp</em> va <strong>load</strong> as part
    of <em>package</em> . If <em>package</em> is not given, returns a list where each
    item is the name of the loaded file and the name of the package for
    which the file was loaded. For a statically-loaded package the name
    of the file is the empty string. For <em>interp</em>, the empty string is
    the current interpreter.</p>
<p><strong>info locals </strong>?<em>pattern</em>?</p>
<p>:   If <em>pattern</em> is given, returns the name of each local variable
    matching <em>pattern</em> according to <strong>string match</strong>. Otherwise, returns
    the name of each local variable. A variables defined with the
    <strong>global</strong>, <strong>upvar</strong> or <strong>variable</strong> is not local.</p>
<p><strong>info nameofexecutable</strong></p>
<p>:   Returns the absolute pathname of the program for the current
    interpreter. If such a file can not be identified an empty string is
    returned.</p>
<p><strong>info object</strong><em> subcommand object</em> ?<em>arg ...</em></p>
<p>:   Returns information about the object named <em>object</em>. <em>subcommand</em> is
    described <strong>OBJECT INTROSPECTION</strong> below.</p>
<p><strong>info patchlevel</strong></p>
<p>:   Returns the value of the global variable <strong>tcl_patchLevel</strong>, in
    which the exact version of the Tcl library initially stored.</p>
<p><strong>info procs </strong>?<em>pattern</em>?</p>
<p>:   Returns the names of all visible procedures. If <em>pattern</em> is given,
    returns only those names that match according to <strong>string match</strong>.
    Only the final component in <em>pattern</em> is actually considered a
    pattern. Any qualifying components simply select a namespace. See
    <strong>NAMESPACE RESOLUTION</strong> in the <strong>namespace</strong>(n) documentation.</p>
<p><strong>info script</strong> ?<em>filename</em>?</p>
<p>:   Returns the pathname of the innermost script currently being
    evaluated, or the empty string if no pathname can be determined. If
    <em>filename</em> is given, sets the return value of any future calls to
    <strong>info script</strong> for the duration of the innermost active script.
    This is useful in virtual file system applications.</p>
<p><strong>info sharedlibextension</strong></p>
<p>:   Returns the extension used on this platform for names of shared
    libraries, e.g. <strong>.so</strong> under Solaris. Returns the empty string if
    shared libraries are not supported on this platform.</p>
<p><strong>info tclversion</strong></p>
<p>:   Returns the value of the global variable <strong>tcl_version</strong>, in which
    the major and minor version of the Tcl library are stored.</p>
<p><strong>info vars</strong> ?<em>pattern</em>?</p>
<p>:   If <em>pattern</em> is not given, returns the names of all visible
    variables. If <em>pattern</em> is given, returns only those names that
    match according to <strong>string match</strong>. Only the last component of
    <em>pattern</em> is a pattern. Other components identify a namespace. See
    <strong>NAMESPACE RESOLUTION</strong> in the <strong>namespace</strong>(n) documentation. When
    <em>pattern</em> is a qualified name, results are fully qualified.</p>
<p>A variable that has declared but not yet defined is included in the
results.</p>
<h2 id="class-introspection">CLASS INTROSPECTION</h2>
<p>The following <em>subcommand</em> values are supported by <strong>info class</strong>:</p>
<p><strong>info class call</strong><em> class method</em></p>
<p>:   Returns a description of the method implementations that are used to
    provide a stereotypical instance of <em>class</em>\'s implementation of
    <em>method</em> (stereotypical instances being objects instantiated by a
    class without having any object-specific definitions added). This
    consists of a list of lists of four elements, where each sublist
    consists of a word that describes the general type of method
    implementation (being one of <strong>method</strong> for an ordinary method,
    <strong>filter</strong> for an applied filter,</p>
<p><strong>private</strong> for a private method,</p>
<p>and <strong>unknown</strong> for a method that is invoked as part of unknown method
handling), a word giving the name of the particular method invoked
(which is always the same as <em>method</em> for the <strong>method</strong> type, and</p>
<p>for the <strong>unknown</strong> type), a word giving the fully qualified name of the
class that defined the method, and a word describing the type of method
implementation (see <strong>info class methodtype</strong>).</p>
<blockquote>
<p>Note that there is no inspection of whether the method implementations
actually use <strong>next</strong> to transfer control along the call chain,</p>
<p>and the call chains that this command files do not actually contain
private methods.</p>
</blockquote>
<p><strong>info class constructor</strong><em> class</em></p>
<p>:   This subcommand returns a description of the definition of the
    constructor of class <em>class</em>. The definition is described as a two
    element list; the first element is the list of arguments to the
    constructor in a form suitable for passing to another call to
    <strong>proc</strong> or a method definition, and the second element is the body
    of the constructor. If no constructor is present, this returns the
    empty list.</p>
<p><strong>info class definition</strong><em> class method</em></p>
<p>:   This subcommand returns a description of the definition of the
    method named <em>method</em> of class <em>class</em>. The definition is described
    as a two element list; the first element is the list of arguments to
    the method in a form suitable for passing to another call to
    <strong>proc</strong> or a method definition, and the second element is the body
    of the method.</p>
<p><strong>info class definitionnamespace</strong><em> class</em> ?<em>kind</em>?</p>
<p>:   </p>
<p>This subcommand returns the definition namespace for <em>kind</em> definitions
of the class <em>class</em>; the definition namespace only affects the
instances of <em>class</em>, not <em>class</em> itself. The <em>kind</em> can be either
<strong>-class</strong> to return the definition namespace used for <strong>oo::define</strong>,
or <strong>-instance</strong> to return the definition namespace used for
<strong>oo::objdefine</strong>; the <strong>-class</strong> kind is default (though this is only
actually useful on classes that are subclasses of <strong>oo::class</strong>).</p>
<blockquote>
<p>If <em>class</em> does not provide a definition namespace of the given kind,
this command returns the empty string. In those circumstances, the
<strong>oo::define</strong> and <strong>oo::objdefine</strong> commands look up which definition
namespace to use using the class inheritance hierarchy.</p>
</blockquote>
<p><strong>info class destructor</strong><em> class</em></p>
<p>:   This subcommand returns the body of the destructor of class <em>class</em>.
    If no destructor is present, this returns the empty string.</p>
<p><strong>info class filters</strong><em> class</em></p>
<p>:   This subcommand returns the list of filter methods set on the class.</p>
<p><strong>info class forward</strong><em> class method</em></p>
<p>:   This subcommand returns the argument list for the method forwarding
    called <em>method</em> that is set on the class called <em>class</em>.</p>
<p><strong>info class instances</strong><em> class</em> ?<em>pattern</em>?</p>
<p>:   This subcommand returns a list of instances of class <em>class</em>. If the
    optional <em>pattern</em> argument is present, it constrains the list of
    returned instances to those that match it according to the rules of
    <strong>string match</strong>.</p>
<p><strong>info class methods</strong><em> class</em> ?<em>options...</em>?</p>
<p>:   This subcommand returns a list of all public (i.e. exported) methods
    of the class called <em>class</em>. Any of the following <em>option</em>s may be
    given, controlling exactly which method names are returned:</p>
<pre><code>**-all**

:   If the **-all** flag is given,

and the **-scope** flag is not given,

the list of methods will include those methods defined not just by
the class, but also by the class\'s superclasses and mixins.

**-private**

:   If the **-private** flag is given,

and the **-scope** flag is not given,

the list of methods will also include the non-exported methods of
the class (and superclasses and mixins, if **-all** is also given).

Note that this naming is an unfortunate clash with true private
methods; this option name is retained for backward compatibility.

**-scope*** scope*

:

Returns a list of all methods on *class* that have the given
visibility *scope*. When this option is supplied, both the **-all**
and **-private** options are ignored. The valid values for *scope*
are:

&gt; public
&gt;
&gt; :   Only methods with *public* scope (i.e., callable from anywhere
&gt;     by any instance of this class) are to be returned.
&gt;
&gt; unexported
&gt;
&gt; :   Only methods with *unexported* scope (i.e., only callable via
&gt;     **my**) are to be returned.
&gt;
&gt; private
&gt;
&gt; :   Only methods with *private* scope (i.e., only callable from
&gt;     within this class\'s methods) are to be returned.
</code></pre>
<p><strong>info class methodtype</strong><em> class method</em></p>
<p>:   This subcommand returns a description of the type of implementation
    used for the method named <em>method</em> of class <em>class</em>. When the result
    is <strong>method</strong>, further information can be discovered with <strong>info
    class</strong> definition, and when the result is <strong>forward</strong>, further
    information can be discovered with <strong>info class forward</strong>.</p>
<p><strong>info class mixins</strong><em> class</em></p>
<p>:   This subcommand returns a list of all classes that have been mixed
    into the class named <em>class</em>.</p>
<p><strong>info class subclasses</strong><em> class</em> ?<em>pattern</em>?</p>
<p>:   This subcommand returns a list of direct subclasses of class
    <em>class</em>. If the optional <em>pattern</em> argument is present, it
    constrains the list of returned classes to those that match it
    according to the rules of <strong>string match</strong>.</p>
<p><strong>info class superclasses</strong><em> class</em></p>
<p>:   This subcommand returns a list of direct superclasses of class
    <em>class</em> in inheritance precedence order.</p>
<p><strong>info class variables</strong><em> class</em> ?<strong>-private</strong>?</p>
<p>:   This subcommand returns a list of all variables that have been
    declared for the class named <em>class</em> (i.e. that are automatically
    present in the class\'s methods, constructor and destructor).</p>
<p>If the <strong>-private</strong> option is given, this lists the private variables
declared instead.</p>
<h2 id="object-introspection">OBJECT INTROSPECTION</h2>
<p>The following <em>subcommand</em> values are supported by <strong>info object</strong>:</p>
<p><strong>info object call</strong><em> object method</em></p>
<p>:   Returns a description of the method implementations that are used to
    provide <em>object</em>\'s implementation of <em>method</em>. This consists of a
    list of lists of four elements, where each sublist consists of a
    word that describes the general type of method implementation (being
    one of <strong>method</strong> for an ordinary method, <strong>filter</strong> for an applied
    filter,</p>
<p><strong>private</strong> for a private method,</p>
<p>and <strong>unknown</strong> for a method that is invoked as part of unknown method
handling), a word giving the name of the particular method invoked
(which is always the same as <em>method</em> for the <strong>method</strong> type, and</p>
<p>for the <strong>unknown</strong> type), a word giving what defined the method (the
fully qualified name of the class, or the literal string <strong>object</strong> if
the method implementation is on an instance), and a word describing the
type of method implementation (see <strong>info object methodtype</strong>).</p>
<blockquote>
<p>Note that there is no inspection of whether the method implementations
actually use <strong>next</strong> to transfer control along the call chain,</p>
<p>and the call chains that this command files do not actually contain
private methods.</p>
</blockquote>
<p><strong>info object class</strong><em> object</em> ?<em>className</em>?</p>
<p>:   If <em>className</em> is not given, this subcommand returns class of the
    <em>object</em> object. If <em>className</em> is present, this subcommand returns
    a boolean value indicating whether the <em>object</em> is of that class.</p>
<p><strong>info object creationid</strong><em> object</em></p>
<p>:   </p>
<p>Returns the unique creation identifier for the <em>object</em> object. This
creation identifier is unique to the object (within a Tcl interpreter)
and cannot be controlled at object creation time or altered afterwards.</p>
<blockquote>
<p><em>Implementation note:</em> the creation identifier is used to generate
unique identifiers associated with the object, especially for private
variables.</p>
</blockquote>
<p><strong>info object definition</strong><em> object method</em></p>
<p>:   This subcommand returns a description of the definition of the
    method named <em>method</em> of object <em>object</em>. The definition is
    described as a two element list; the first element is the list of
    arguments to the method in a form suitable for passing to another
    call to <strong>proc</strong> or a method definition, and the second element is
    the body of the method.</p>
<p><strong>info object filters</strong><em> object</em></p>
<p>:   This subcommand returns the list of filter methods set on the
    object.</p>
<p><strong>info object forward</strong><em> object method</em></p>
<p>:   This subcommand returns the argument list for the method forwarding
    called <em>method</em> that is set on the object called <em>object</em>.</p>
<p><strong>info object isa</strong><em> category object</em> ?<em>arg</em>?</p>
<p>:   This subcommand tests whether an object belongs to a particular
    category, returning a boolean value that indicates whether the
    <em>object</em> argument meets the criteria for the category. The supported
    categories are:</p>
<pre><code>**info object isa class*** object*

:   This returns whether *object* is a class (i.e. an instance of
    **oo::class** or one of its subclasses).

**info object isa metaclass*** object*

:   This returns whether *object* is a class that can manufacture
    classes (i.e. is **oo::class** or a subclass of it).

**info object isa mixin*** object class*

:   This returns whether *class* is directly mixed into *object*.

**info object isa object*** object*

:   This returns whether *object* really is an object.

**info object isa typeof*** object class*

:   This returns whether *class* is the type of *object* (i.e.
    whether *object* is an instance of *class* or one of its
    subclasses, whether direct or indirect).
</code></pre>
<p><strong>info object methods</strong><em> object</em> ?<em>option...</em>?</p>
<p>:   This subcommand returns a list of all public (i.e. exported) methods
    of the object called <em>object</em>. Any of the following <em>option</em>s may be
    given, controlling exactly which method names are returned:</p>
<pre><code>**-all**

:   If the **-all** flag is given,

and the **-scope** flag is not given,

the list of methods will include those methods defined not just by
the object, but also by the object\'s class and mixins, plus the
superclasses of those classes.

**-private**

:   If the **-private** flag is given,

and the **-scope** flag is not given,

the list of methods will also include the non-exported methods of
the object (and classes, if **-all** is also given).

Note that this naming is an unfortunate clash with true private
methods; this option name is retained for backward compatibility.

**-scope*** scope*

:

Returns a list of all methods on *object* that have the given
visibility *scope*. When this option is supplied, both the **-all**
and **-private** options are ignored. The valid values for *scope*
are:

&gt; public
&gt;
&gt; :   Only methods with *public* scope (i.e., callable from
&gt;     anywhere) are to be returned.
&gt;
&gt; unexported
&gt;
&gt; :   Only methods with *unexported* scope (i.e., only callable via
&gt;     **my**) are to be returned.
&gt;
&gt; private
&gt;
&gt; :   Only methods with *private* scope (i.e., only callable from
&gt;     within this object\'s instance methods) are to be returned.
</code></pre>
<p><strong>info object methodtype</strong><em> object method</em></p>
<p>:   This subcommand returns a description of the type of implementation
    used for the method named <em>method</em> of object <em>object</em>. When the
    result is <strong>method</strong>, further information can be discovered with
    <strong>info object</strong> definition, and when the result is <strong>forward</strong>,
    further information can be discovered with <strong>info object forward</strong>.</p>
<p><strong>info object mixins</strong><em> object</em></p>
<p>:   This subcommand returns a list of all classes that have been mixed
    into the object named <em>object</em>.</p>
<p><strong>info object namespace</strong><em> object</em></p>
<p>:   This subcommand returns the name of the internal namespace of the
    object named <em>object</em>.</p>
<p><strong>info object variables</strong><em> object</em>R ?<strong>-private</strong>?</p>
<p>:   This subcommand returns a list of all variables that have been
    declared for the object named <em>object</em> (i.e. that are automatically
    present in the object\'s methods).</p>
<p>If the <strong>-private</strong> option is given, this lists the private variables
declared instead.</p>
<p><strong>info object vars</strong><em> object</em> ?<em>pattern</em>?</p>
<p>:   This subcommand returns a list of all variables in the private
    namespace of the object named <em>object</em>. If the optional <em>pattern</em>
    argument is given, it is a filter (in the syntax of a <strong>string
    match</strong> glob pattern) that constrains the list of variables
    returned. Note that this is different from the list returned by
    <strong>info object variables</strong>; that can include variables that are
    currently unset, whereas this can include variables that are not
    automatically included by any of <em>object</em>\'s methods (or those of
    its class, superclasses or mixins).</p>
<h1 id="examples">EXAMPLES</h1>
<p>This command prints out a procedure suitable for saving in a Tcl script:</p>
<p>proc printProc {procName} { set result [list proc \$procName] set
formals {} foreach var [<strong>info args</strong> \$procName] { if {[<strong>info
default</strong> \$procName \$var def]} { lappend formals [list \$var \$def]
} else { # Still need the list-quoting because variable # names may
properly contain spaces. lappend formals [list \$var] } } puts
[lappend result \$formals [<strong>info body</strong> \$procName]] }</p>
<h2 id="examples-with-objects">EXAMPLES WITH OBJECTS</h2>
<p>Every object necessarily knows what its class is; this information is
trivially extractable through introspection:</p>
<p>oo::class create c c create o puts [<strong>info object class</strong> o] <em>→ prints
\"::c\"</em> puts [<strong>info object class</strong> c] <em>→ prints \"::oo::class\"</em></p>
<p>The introspection capabilities can be used to discover what class
implements a method and get how it is defined. This procedure
illustrates how:</p>
<p>proc getDef {obj method} { foreach inf [<strong>info object call</strong> \$obj
\$method] { lassign \$inf calltype name locus methodtype</p>
<p># Assume no forwards or filters, and hence no \$calltype # or
\$methodtype checks...</p>
<p>if {\$locus eq \"object\"} { return [<strong>info object definition</strong> \$obj
\$name] } else { return [<strong>info class definition</strong> \$locus \$name] }
} error \"no definition for \$method\" }</p>
<p>This is an alternate way of looking up the definition; it is implemented
by manually scanning the list of methods up the inheritance tree. This
code assumes that only single inheritance is in use, and that there is
no complex use of mixed-in classes (in such cases, using <strong>info object
call</strong> as above is the simplest way of doing this by far):</p>
<p>proc getDef {obj method} { if {\$method in [<strong>info object methods</strong>
\$obj]} { # Assume no forwards return [<strong>info object definition</strong>
\$obj \$method] }</p>
<p>set cls [<strong>info object class</strong> \$obj]</p>
<p>while {\$method ni [<strong>info class methods</strong> \$cls]} { # Assume the
simple case set cls [lindex [<strong>info class superclass</strong> \$cls] 0] if
{\$cls eq \"\"} { error \"no definition for \$method\" } }</p>
<p># Assume no forwards return [<strong>info class definition</strong> \$cls
\$method] }</p>
<h1 id="see-also">SEE ALSO</h1>
<p>global(n), oo::class(n), oo::define(n), oo::object(n), proc(n), self(n),
tcl_library(n), tcl_patchLevel(n), tcl_version(n)</p>
<h1 id="keywords">KEYWORDS</h1>
<p>command, information, interpreter, introspection, level, namespace,
object, procedure, variable</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
