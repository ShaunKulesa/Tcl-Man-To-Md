{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Access/","text":"NAME Tcl_Access, Tcl_Stat - check file permissions and other attributes SYNOPSIS #include <tcl.h> int Tcl_Access(path, mode) int Tcl_Stat(path, statPtr) ARGUMENTS Native name of the file to check the attributes of. Mask consisting of one or more of R_OK , W_OK , X_OK and F_OK . R_OK , W_OK and X_OK request checking whether the file exists and has read, write and execute permissions, respectively. F_OK just requests a check for the existence of the file. The structure that contains the result. DESCRIPTION As of Tcl 8.4, the object-based APIs Tcl_FSAccess and Tcl_FSStat should be used in preference to Tcl_Access and Tcl_Stat , wherever possible. Those functions also support Tcl\\'s virtual filesystem layer, which these do not. OBSOLETE FUNCTIONS There are two reasons for calling Tcl_Access and Tcl_Stat rather than calling system level functions access and stat directly. First, the Windows implementation of both functions fixes some bugs in the system level calls. Second, both Tcl_Access and Tcl_Stat (as well as Tcl_OpenFileChannelProc ) hook into a linked list of functions. This allows the possibility to reroute file access to alternative media or access methods. Tcl_Access checks whether the process would be allowed to read, write or test for existence of the file (or other file system object) whose name is path . If path is a symbolic link on Unix, then permissions of the file referred by this symbolic link are tested. On success (all requested permissions granted), zero is returned. On error (at least one bit in mode asked for a permission that is denied, or some other error occurred), -1 is returned. Tcl_Stat fills the stat structure statPtr with information about the specified file. You do not need any access rights to the file to get this information but you need search rights to all directories named in the path leading to the file. The stat structure includes info regarding device, inode (always 0 on Windows), privilege mode, nlink (always 1 on Windows), user id (always 0 on Windows), group id (always 0 on Windows), rdev (same as device on Windows), size, last access time, last modification time, and creation time. If path exists, Tcl_Stat returns 0 and the stat structure is filled with data. Otherwise, -1 is returned, and no stat info is given. KEYWORDS stat, access SEE ALSO Tcl_FSAccess(3), Tcl_FSStat(3)","title":"NAME"},{"location":"Access/#name","text":"Tcl_Access, Tcl_Stat - check file permissions and other attributes","title":"NAME"},{"location":"Access/#synopsis","text":"#include <tcl.h> int Tcl_Access(path, mode) int Tcl_Stat(path, statPtr)","title":"SYNOPSIS"},{"location":"Access/#arguments","text":"Native name of the file to check the attributes of. Mask consisting of one or more of R_OK , W_OK , X_OK and F_OK . R_OK , W_OK and X_OK request checking whether the file exists and has read, write and execute permissions, respectively. F_OK just requests a check for the existence of the file. The structure that contains the result.","title":"ARGUMENTS"},{"location":"Access/#description","text":"As of Tcl 8.4, the object-based APIs Tcl_FSAccess and Tcl_FSStat should be used in preference to Tcl_Access and Tcl_Stat , wherever possible. Those functions also support Tcl\\'s virtual filesystem layer, which these do not.","title":"DESCRIPTION"},{"location":"Access/#obsolete-functions","text":"There are two reasons for calling Tcl_Access and Tcl_Stat rather than calling system level functions access and stat directly. First, the Windows implementation of both functions fixes some bugs in the system level calls. Second, both Tcl_Access and Tcl_Stat (as well as Tcl_OpenFileChannelProc ) hook into a linked list of functions. This allows the possibility to reroute file access to alternative media or access methods. Tcl_Access checks whether the process would be allowed to read, write or test for existence of the file (or other file system object) whose name is path . If path is a symbolic link on Unix, then permissions of the file referred by this symbolic link are tested. On success (all requested permissions granted), zero is returned. On error (at least one bit in mode asked for a permission that is denied, or some other error occurred), -1 is returned. Tcl_Stat fills the stat structure statPtr with information about the specified file. You do not need any access rights to the file to get this information but you need search rights to all directories named in the path leading to the file. The stat structure includes info regarding device, inode (always 0 on Windows), privilege mode, nlink (always 1 on Windows), user id (always 0 on Windows), group id (always 0 on Windows), rdev (same as device on Windows), size, last access time, last modification time, and creation time. If path exists, Tcl_Stat returns 0 and the stat structure is filled with data. Otherwise, -1 is returned, and no stat info is given.","title":"OBSOLETE FUNCTIONS"},{"location":"Access/#keywords","text":"stat, access","title":"KEYWORDS"},{"location":"Access/#see-also","text":"Tcl_FSAccess(3), Tcl_FSStat(3)","title":"SEE ALSO"},{"location":"AddErrInfo/","text":"NAME Tcl_GetReturnOptions, Tcl_SetReturnOptions, Tcl_AddErrorInfo, Tcl_AppendObjToErrorInfo, Tcl_AddObjErrorInfo, Tcl_SetObjErrorCode, Tcl_SetErrorCode, Tcl_SetErrorLine, Tcl_GetErrorLine, Tcl_PosixError, Tcl_LogCommandInfo - retrieve or record information about errors and other return options SYNOPSIS #include <tcl.h> Tcl_Obj * Tcl_GetReturnOptions(interp, code) int Tcl_SetReturnOptions(interp, options) Tcl_AddErrorInfo(interp, message) Tcl_AppendObjToErrorInfo(interp, objPtr) Tcl_AddObjErrorInfo(interp, message, length) Tcl_SetObjErrorCode(interp, errorObjPtr) Tcl_SetErrorCode(interp, element, element, ... (char *) NULL) Tcl_GetErrorLine(interp) Tcl_SetErrorLine(interp, lineNum) const char * Tcl_PosixError(interp) void Tcl_LogCommandInfo(interp, script, command, commandLength) ARGUMENTS Interpreter in which to record information. The code returned from script evaluation. A dictionary of return options. For Tcl_AddErrorInfo , this is a conventional C string to append to the -errorinfo return option. For Tcl_AddObjErrorInfo , this points to the first byte of an array of length bytes containing a string to append to the -errorinfo return option. This byte array may contain embedded null bytes unless length is negative. A message to be appended to the -errorinfo return option in the form of a Tcl_Obj value. The number of bytes to copy from message when appending to the -errorinfo return option. If negative, all bytes up to the first null byte are used. The -errorcode return option will be set to this value. String to record as one element of the -errorcode return option. Last element argument must be NULL. The line number of a script where an error occurred. Pointer to first character in script containing command (must be \\<= command) Pointer to first character in command that generated the error Number of bytes in command; a negative value means use all bytes up to first null byte DESCRIPTION The Tcl_SetReturnOptions and Tcl_GetReturnOptions routines expose the same capabilities as the return and catch commands, respectively, in the form of a C interface. Tcl_GetReturnOptions retrieves the dictionary of return options from an interpreter following a script evaluation. Routines such as Tcl_Eval are called to evaluate a script in an interpreter. These routines return an integer completion code. These routines also leave in the interpreter both a result and a dictionary of return options generated by script evaluation. Just as Tcl_GetObjResult retrieves the result, Tcl_GetReturnOptions retrieves the dictionary of return options. The integer completion code should be passed as the code argument to Tcl_GetReturnOptions so that all required options will be present in the dictionary. Specifically, a code value of TCL_ERROR will ensure that entries for the keys -errorinfo , -errorcode , and -errorline will appear in the dictionary. Also, the entries for the keys -code and -level will be adjusted if necessary to agree with the value of code . The (Tcl_Obj *) returned by Tcl_GetReturnOptions points to an unshared Tcl_Obj with reference count of zero. The dictionary may be written to, either adding, removing, or overwriting any entries in it, without the need to check for a shared value. As with any Tcl_Obj with reference count of zero, it is up to the caller to arrange for its disposal with Tcl_DecrRefCount or to a reference to it via Tcl_IncrRefCount (or one of the many functions that call that, notably including Tcl_SetObjResult and Tcl_SetVar2Ex ). A typical usage for Tcl_GetReturnOptions is to retrieve the stack trace when script evaluation returns TCL_ERROR , like so: int code = Tcl_EvalEx(interp, script, -1, 0); if (code == TCL_ERROR) { Tcl_Obj *options = Tcl_GetReturnOptions (interp, code); Tcl_Obj *key = Tcl_NewStringObj(\\\"-errorinfo\\\", -1); Tcl_Obj *stackTrace; Tcl_IncrRefCount(key); Tcl_DictObjGet(NULL, options, key, &stackTrace); Tcl_DecrRefCount(key); /* Do something with stackTrace */ Tcl_DecrRefCount(options); } Tcl_SetReturnOptions sets the return options of interp to be options . If options contains any invalid value for any key, TCL_ERROR will be returned, and the interp result will be set to an appropriate error message. Otherwise, a completion code in agreement with the -code and -level keys in options will be returned. As an example, Tcl\\'s return command itself could be implemented in terms of Tcl_SetReturnOptions like so: if ((objc % 2) == 0) { /* explicit result argument */ objc--; Tcl_SetObjResult(interp, objv[objc]); } return Tcl_SetReturnOptions (interp, Tcl_NewListObj(objc-1, objv+1)); (It is not really implemented that way. Internal access privileges allow for a more efficient alternative that meshes better with the bytecode compiler.) Note that a newly created Tcl_Obj may be passed in as the options argument without the need to tend to any reference counting. This is analogous to Tcl_SetObjResult . While Tcl_SetReturnOptions provides a general interface to set any collection of return options, there are a handful of return options that are very frequently used. Most notably the -errorinfo and -errorcode return options should be set properly when the command procedure of a command returns TCL_ERROR . The -errorline return option is also read by commands that evaluate scripts and wish to supply detailed error location information in the stack trace text they append to the -errorinfo option. Tcl provides several simpler interfaces to more directly set these return options. The -errorinfo option holds a stack trace of the operations that were in progress when an error occurred, and is intended to be human-readable. The -errorcode option holds a Tcl list of items that are intended to be machine-readable. The first item in the -errorcode value identifies the class of error that occurred (e.g., POSIX means an error occurred in a POSIX system call) and additional elements hold additional pieces of information that depend on the class. See the manual entry on the errorCode variable for details on the various formats for the -errorcode option used by Tcl\\'s built-in commands. The -errorinfo option value is gradually built up as an error unwinds through the nested operations. Each time an error code is returned to Tcl_Eval , or any of the routines that performs script evaluation, the procedure Tcl_AddErrorInfo is called to add additional text to the -errorinfo value describing the command that was being executed when the error occurred. By the time the error has been passed all the way back to the application, it will contain a complete trace of the activity in progress when the error occurred. It is sometimes useful to add additional information to the -errorinfo value beyond what can be supplied automatically by the script evaluation routines. Tcl_AddErrorInfo may be used for this purpose: its message argument is an additional string to be appended to the -errorinfo option. For example, when an error arises during the source command, the procedure Tcl_AddErrorInfo is called to record the name of the file being processed and the line number on which the error occurred. Likewise, when an error arises during evaluation of a Tcl procedures, the procedure name and line number within the procedure are recorded, and so on. The best time to call Tcl_AddErrorInfo is just after a script evaluation routine has returned TCL_ERROR . The value of the -errorline return option (retrieved via a call to Tcl_GetReturnOptions ) often makes up a useful part of the message passed to Tcl_AddErrorInfo . Tcl_AppendObjToErrorInfo is an alternative interface to the same functionality as Tcl_AddErrorInfo . Tcl_AppendObjToErrorInfo is called when the string value to be appended to the -errorinfo option is available as a Tcl_Obj instead of as a char array. Tcl_AddObjErrorInfo is nearly identical to Tcl_AddErrorInfo , except that it has an additional length argument. This allows the message string to contain embedded null bytes. This is essentially never a good idea. If the message needs to contain the null character U+0000 , Tcl\\'s usual internal encoding rules should be used to avoid the need for a null byte. If the Tcl_AddObjErrorInfo interface is used at all, it should be with a negative length value. The procedure Tcl_SetObjErrorCode is used to set the -errorcode return option to the list value errorObjPtr built up by the caller. Tcl_SetObjErrorCode is typically invoked just before returning an error. If an error is returned without calling Tcl_SetObjErrorCode or Tcl_SetErrorCode the Tcl interpreter automatically sets the -errorcode return option to NONE . The procedure Tcl_SetErrorCode is also used to set the -errorcode return option. However, it takes one or more strings to record instead of a value. Otherwise, it is similar to Tcl_SetObjErrorCode in behavior. The procedure Tcl_GetErrorLine is used to read the integer value of the -errorline return option without the overhead of a full call to Tcl_GetReturnOptions . Likewise, Tcl_SetErrorLine sets the -errorline return option value. Tcl_PosixError sets the -errorcode variable after an error in a POSIX kernel call. It reads the value of the errno C variable and calls Tcl_SetErrorCode to set the -errorcode return option in the POSIX format. The caller must previously have called Tcl_SetErrno to set errno ; this is necessary on some platforms (e.g. Windows) where Tcl is linked into an application as a shared library, or when the error occurs in a dynamically loaded extension. See the manual entry for Tcl_SetErrno for more information. Tcl_PosixError returns a human-readable diagnostic message for the error (this is the same value that will appear as the third element in the -errorcode value). It may be convenient to include this string as part of the error message returned to the application in the interpreter\\'s result. Tcl_LogCommandInfo is invoked after an error occurs in an interpreter. It adds information about the command that was being executed when the error occurred to the -errorinfo value, and the line number stored internally in the interpreter is set. In older releases of Tcl, there was no Tcl_GetReturnOptions routine. In its place, the global Tcl variables errorInfo and errorCode were the only place to retrieve the error information. Much existing code written for older Tcl releases still access this information via those global variables. It is important to realize that while reading from those global variables remains a supported way to access these return option values, it is important not to assume that writing to those global variables will properly set the corresponding return options. It has long been emphasized in this manual page that it is important to call the procedures described here rather than setting errorInfo or errorCode directly with Tcl_ObjSetVar2 . If the procedure Tcl_ResetResult is called, it clears all of the state of the interpreter associated with script evaluation, including the entire return options dictionary. In particular, the -errorinfo and -errorcode options are reset. If an error had occurred, the Tcl_ResetResult call will clear the error state to make it appear as if no error had occurred after all. The global variables errorInfo and errorCode are not modified by Tcl_ResetResult so they continue to hold a record of information about the most recent error seen in an interpreter. REFERENCE COUNT MANAGEMENT The result of Tcl_GetReturnOptions will have at least one reference to it from the Tcl interpreter. If not using it immediately, you should use Tcl_IncrRefCount to add your own reference. The options argument to Tcl_SetReturnOptions will have a reference added by the Tcl interpreter; it may safely be called with a zero-reference value. Tcl_AppendObjToErrorInfo only reads its objPtr argument; it does not modify its reference count at all. The errorObjPtr argument to Tcl_SetObjErrorCode will have a reference added by the Tcl interpreter; it may safely be called with a zero-reference value. SEE ALSO Tcl_DecrRefCount(3), Tcl_IncrRefCount(3), Tcl_Interp(3), Tcl_ResetResult(3), Tcl_SetErrno(3), errorCode(n), errorInfo(n) KEYWORDS error, value, value result, stack, trace, variable","title":"NAME"},{"location":"AddErrInfo/#name","text":"Tcl_GetReturnOptions, Tcl_SetReturnOptions, Tcl_AddErrorInfo, Tcl_AppendObjToErrorInfo, Tcl_AddObjErrorInfo, Tcl_SetObjErrorCode, Tcl_SetErrorCode, Tcl_SetErrorLine, Tcl_GetErrorLine, Tcl_PosixError, Tcl_LogCommandInfo - retrieve or record information about errors and other return options","title":"NAME"},{"location":"AddErrInfo/#synopsis","text":"#include <tcl.h> Tcl_Obj * Tcl_GetReturnOptions(interp, code) int Tcl_SetReturnOptions(interp, options) Tcl_AddErrorInfo(interp, message) Tcl_AppendObjToErrorInfo(interp, objPtr) Tcl_AddObjErrorInfo(interp, message, length) Tcl_SetObjErrorCode(interp, errorObjPtr) Tcl_SetErrorCode(interp, element, element, ... (char *) NULL) Tcl_GetErrorLine(interp) Tcl_SetErrorLine(interp, lineNum) const char * Tcl_PosixError(interp) void Tcl_LogCommandInfo(interp, script, command, commandLength)","title":"SYNOPSIS"},{"location":"AddErrInfo/#arguments","text":"Interpreter in which to record information. The code returned from script evaluation. A dictionary of return options. For Tcl_AddErrorInfo , this is a conventional C string to append to the -errorinfo return option. For Tcl_AddObjErrorInfo , this points to the first byte of an array of length bytes containing a string to append to the -errorinfo return option. This byte array may contain embedded null bytes unless length is negative. A message to be appended to the -errorinfo return option in the form of a Tcl_Obj value. The number of bytes to copy from message when appending to the -errorinfo return option. If negative, all bytes up to the first null byte are used. The -errorcode return option will be set to this value. String to record as one element of the -errorcode return option. Last element argument must be NULL. The line number of a script where an error occurred. Pointer to first character in script containing command (must be \\<= command) Pointer to first character in command that generated the error Number of bytes in command; a negative value means use all bytes up to first null byte","title":"ARGUMENTS"},{"location":"AddErrInfo/#description","text":"The Tcl_SetReturnOptions and Tcl_GetReturnOptions routines expose the same capabilities as the return and catch commands, respectively, in the form of a C interface. Tcl_GetReturnOptions retrieves the dictionary of return options from an interpreter following a script evaluation. Routines such as Tcl_Eval are called to evaluate a script in an interpreter. These routines return an integer completion code. These routines also leave in the interpreter both a result and a dictionary of return options generated by script evaluation. Just as Tcl_GetObjResult retrieves the result, Tcl_GetReturnOptions retrieves the dictionary of return options. The integer completion code should be passed as the code argument to Tcl_GetReturnOptions so that all required options will be present in the dictionary. Specifically, a code value of TCL_ERROR will ensure that entries for the keys -errorinfo , -errorcode , and -errorline will appear in the dictionary. Also, the entries for the keys -code and -level will be adjusted if necessary to agree with the value of code . The (Tcl_Obj *) returned by Tcl_GetReturnOptions points to an unshared Tcl_Obj with reference count of zero. The dictionary may be written to, either adding, removing, or overwriting any entries in it, without the need to check for a shared value. As with any Tcl_Obj with reference count of zero, it is up to the caller to arrange for its disposal with Tcl_DecrRefCount or to a reference to it via Tcl_IncrRefCount (or one of the many functions that call that, notably including Tcl_SetObjResult and Tcl_SetVar2Ex ). A typical usage for Tcl_GetReturnOptions is to retrieve the stack trace when script evaluation returns TCL_ERROR , like so: int code = Tcl_EvalEx(interp, script, -1, 0); if (code == TCL_ERROR) { Tcl_Obj *options = Tcl_GetReturnOptions (interp, code); Tcl_Obj *key = Tcl_NewStringObj(\\\"-errorinfo\\\", -1); Tcl_Obj *stackTrace; Tcl_IncrRefCount(key); Tcl_DictObjGet(NULL, options, key, &stackTrace); Tcl_DecrRefCount(key); /* Do something with stackTrace */ Tcl_DecrRefCount(options); } Tcl_SetReturnOptions sets the return options of interp to be options . If options contains any invalid value for any key, TCL_ERROR will be returned, and the interp result will be set to an appropriate error message. Otherwise, a completion code in agreement with the -code and -level keys in options will be returned. As an example, Tcl\\'s return command itself could be implemented in terms of Tcl_SetReturnOptions like so: if ((objc % 2) == 0) { /* explicit result argument */ objc--; Tcl_SetObjResult(interp, objv[objc]); } return Tcl_SetReturnOptions (interp, Tcl_NewListObj(objc-1, objv+1)); (It is not really implemented that way. Internal access privileges allow for a more efficient alternative that meshes better with the bytecode compiler.) Note that a newly created Tcl_Obj may be passed in as the options argument without the need to tend to any reference counting. This is analogous to Tcl_SetObjResult . While Tcl_SetReturnOptions provides a general interface to set any collection of return options, there are a handful of return options that are very frequently used. Most notably the -errorinfo and -errorcode return options should be set properly when the command procedure of a command returns TCL_ERROR . The -errorline return option is also read by commands that evaluate scripts and wish to supply detailed error location information in the stack trace text they append to the -errorinfo option. Tcl provides several simpler interfaces to more directly set these return options. The -errorinfo option holds a stack trace of the operations that were in progress when an error occurred, and is intended to be human-readable. The -errorcode option holds a Tcl list of items that are intended to be machine-readable. The first item in the -errorcode value identifies the class of error that occurred (e.g., POSIX means an error occurred in a POSIX system call) and additional elements hold additional pieces of information that depend on the class. See the manual entry on the errorCode variable for details on the various formats for the -errorcode option used by Tcl\\'s built-in commands. The -errorinfo option value is gradually built up as an error unwinds through the nested operations. Each time an error code is returned to Tcl_Eval , or any of the routines that performs script evaluation, the procedure Tcl_AddErrorInfo is called to add additional text to the -errorinfo value describing the command that was being executed when the error occurred. By the time the error has been passed all the way back to the application, it will contain a complete trace of the activity in progress when the error occurred. It is sometimes useful to add additional information to the -errorinfo value beyond what can be supplied automatically by the script evaluation routines. Tcl_AddErrorInfo may be used for this purpose: its message argument is an additional string to be appended to the -errorinfo option. For example, when an error arises during the source command, the procedure Tcl_AddErrorInfo is called to record the name of the file being processed and the line number on which the error occurred. Likewise, when an error arises during evaluation of a Tcl procedures, the procedure name and line number within the procedure are recorded, and so on. The best time to call Tcl_AddErrorInfo is just after a script evaluation routine has returned TCL_ERROR . The value of the -errorline return option (retrieved via a call to Tcl_GetReturnOptions ) often makes up a useful part of the message passed to Tcl_AddErrorInfo . Tcl_AppendObjToErrorInfo is an alternative interface to the same functionality as Tcl_AddErrorInfo . Tcl_AppendObjToErrorInfo is called when the string value to be appended to the -errorinfo option is available as a Tcl_Obj instead of as a char array. Tcl_AddObjErrorInfo is nearly identical to Tcl_AddErrorInfo , except that it has an additional length argument. This allows the message string to contain embedded null bytes. This is essentially never a good idea. If the message needs to contain the null character U+0000 , Tcl\\'s usual internal encoding rules should be used to avoid the need for a null byte. If the Tcl_AddObjErrorInfo interface is used at all, it should be with a negative length value. The procedure Tcl_SetObjErrorCode is used to set the -errorcode return option to the list value errorObjPtr built up by the caller. Tcl_SetObjErrorCode is typically invoked just before returning an error. If an error is returned without calling Tcl_SetObjErrorCode or Tcl_SetErrorCode the Tcl interpreter automatically sets the -errorcode return option to NONE . The procedure Tcl_SetErrorCode is also used to set the -errorcode return option. However, it takes one or more strings to record instead of a value. Otherwise, it is similar to Tcl_SetObjErrorCode in behavior. The procedure Tcl_GetErrorLine is used to read the integer value of the -errorline return option without the overhead of a full call to Tcl_GetReturnOptions . Likewise, Tcl_SetErrorLine sets the -errorline return option value. Tcl_PosixError sets the -errorcode variable after an error in a POSIX kernel call. It reads the value of the errno C variable and calls Tcl_SetErrorCode to set the -errorcode return option in the POSIX format. The caller must previously have called Tcl_SetErrno to set errno ; this is necessary on some platforms (e.g. Windows) where Tcl is linked into an application as a shared library, or when the error occurs in a dynamically loaded extension. See the manual entry for Tcl_SetErrno for more information. Tcl_PosixError returns a human-readable diagnostic message for the error (this is the same value that will appear as the third element in the -errorcode value). It may be convenient to include this string as part of the error message returned to the application in the interpreter\\'s result. Tcl_LogCommandInfo is invoked after an error occurs in an interpreter. It adds information about the command that was being executed when the error occurred to the -errorinfo value, and the line number stored internally in the interpreter is set. In older releases of Tcl, there was no Tcl_GetReturnOptions routine. In its place, the global Tcl variables errorInfo and errorCode were the only place to retrieve the error information. Much existing code written for older Tcl releases still access this information via those global variables. It is important to realize that while reading from those global variables remains a supported way to access these return option values, it is important not to assume that writing to those global variables will properly set the corresponding return options. It has long been emphasized in this manual page that it is important to call the procedures described here rather than setting errorInfo or errorCode directly with Tcl_ObjSetVar2 . If the procedure Tcl_ResetResult is called, it clears all of the state of the interpreter associated with script evaluation, including the entire return options dictionary. In particular, the -errorinfo and -errorcode options are reset. If an error had occurred, the Tcl_ResetResult call will clear the error state to make it appear as if no error had occurred after all. The global variables errorInfo and errorCode are not modified by Tcl_ResetResult so they continue to hold a record of information about the most recent error seen in an interpreter.","title":"DESCRIPTION"},{"location":"AddErrInfo/#reference-count-management","text":"The result of Tcl_GetReturnOptions will have at least one reference to it from the Tcl interpreter. If not using it immediately, you should use Tcl_IncrRefCount to add your own reference. The options argument to Tcl_SetReturnOptions will have a reference added by the Tcl interpreter; it may safely be called with a zero-reference value. Tcl_AppendObjToErrorInfo only reads its objPtr argument; it does not modify its reference count at all. The errorObjPtr argument to Tcl_SetObjErrorCode will have a reference added by the Tcl interpreter; it may safely be called with a zero-reference value.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"AddErrInfo/#see-also","text":"Tcl_DecrRefCount(3), Tcl_IncrRefCount(3), Tcl_Interp(3), Tcl_ResetResult(3), Tcl_SetErrno(3), errorCode(n), errorInfo(n)","title":"SEE ALSO"},{"location":"AddErrInfo/#keywords","text":"error, value, value result, stack, trace, variable","title":"KEYWORDS"},{"location":"Alloc/","text":"NAME Tcl_Alloc, Tcl_Free, Tcl_Realloc, Tcl_AttemptAlloc, Tcl_AttemptRealloc, Tcl_GetMemoryInfo - allocate or free heap memory SYNOPSIS #include <tcl.h> char * Tcl_Alloc(size) void Tcl_Free(ptr) void * Tcl_Realloc(ptr, size) void * Tcl_AttemptAlloc(size) void * Tcl_AttemptRealloc(ptr, size) void Tcl_GetMemoryInfo(dsPtr) ARGUMENTS Size in bytes of the memory block to allocate. Pointer to memory block to free or realloc. Initialized DString pointer. DESCRIPTION These procedures provide a platform and compiler independent interface for memory allocation. Programs that need to transfer ownership of memory blocks between Tcl and other modules should use these routines rather than the native malloc() and free() routines provided by the C run-time library. Tcl_Alloc returns a pointer to a block of at least size bytes suitably aligned for any use. Tcl_Free makes the space referred to by ptr available for further allocation. Tcl_Realloc changes the size of the block pointed to by ptr to size bytes and returns a pointer to the new block. The contents will be unchanged up to the lesser of the new and old sizes. The returned location may be different from ptr . If ptr is NULL, this is equivalent to calling Tcl_Alloc with just the size argument. Tcl_AttemptAlloc and Tcl_AttemptRealloc are identical in function to Tcl_Alloc and Tcl_Realloc , except that Tcl_AttemptAlloc and Tcl_AttemptRealloc will not cause the Tcl interpreter to panic if the memory allocation fails. If the allocation fails, these functions will return NULL. Note that on some platforms, but not all, attempting to allocate a zero-sized block of memory will also cause these functions to return NULL. When a module or Tcl itself is compiled with TCL_MEM_DEBUG defined, the procedures Tcl_Alloc , Tcl_Free , Tcl_Realloc , Tcl_AttemptAlloc , and Tcl_AttempRealloc are implemented as macros, redefined to be special debugging versions of these procedures. Tcl_GetMemoryInfo appends a list-of-lists of memory stats to the provided DString. This function cannot be used in stub-enabled extensions, and it is only available if Tcl is compiled with the threaded memory allocator When used in stub-enabled embedders, the stubs table must be first initialized using one of Tcl_InitSubsystems , Tcl_SetPanicProc , Tcl_FindExecutable or TclZipfs_AppHook . KEYWORDS alloc, allocation, free, malloc, memory, realloc, TCL_MEM_DEBUG","title":"NAME"},{"location":"Alloc/#name","text":"Tcl_Alloc, Tcl_Free, Tcl_Realloc, Tcl_AttemptAlloc, Tcl_AttemptRealloc, Tcl_GetMemoryInfo - allocate or free heap memory","title":"NAME"},{"location":"Alloc/#synopsis","text":"#include <tcl.h> char * Tcl_Alloc(size) void Tcl_Free(ptr) void * Tcl_Realloc(ptr, size) void * Tcl_AttemptAlloc(size) void * Tcl_AttemptRealloc(ptr, size) void Tcl_GetMemoryInfo(dsPtr)","title":"SYNOPSIS"},{"location":"Alloc/#arguments","text":"Size in bytes of the memory block to allocate. Pointer to memory block to free or realloc. Initialized DString pointer.","title":"ARGUMENTS"},{"location":"Alloc/#description","text":"These procedures provide a platform and compiler independent interface for memory allocation. Programs that need to transfer ownership of memory blocks between Tcl and other modules should use these routines rather than the native malloc() and free() routines provided by the C run-time library. Tcl_Alloc returns a pointer to a block of at least size bytes suitably aligned for any use. Tcl_Free makes the space referred to by ptr available for further allocation. Tcl_Realloc changes the size of the block pointed to by ptr to size bytes and returns a pointer to the new block. The contents will be unchanged up to the lesser of the new and old sizes. The returned location may be different from ptr . If ptr is NULL, this is equivalent to calling Tcl_Alloc with just the size argument. Tcl_AttemptAlloc and Tcl_AttemptRealloc are identical in function to Tcl_Alloc and Tcl_Realloc , except that Tcl_AttemptAlloc and Tcl_AttemptRealloc will not cause the Tcl interpreter to panic if the memory allocation fails. If the allocation fails, these functions will return NULL. Note that on some platforms, but not all, attempting to allocate a zero-sized block of memory will also cause these functions to return NULL. When a module or Tcl itself is compiled with TCL_MEM_DEBUG defined, the procedures Tcl_Alloc , Tcl_Free , Tcl_Realloc , Tcl_AttemptAlloc , and Tcl_AttempRealloc are implemented as macros, redefined to be special debugging versions of these procedures. Tcl_GetMemoryInfo appends a list-of-lists of memory stats to the provided DString. This function cannot be used in stub-enabled extensions, and it is only available if Tcl is compiled with the threaded memory allocator When used in stub-enabled embedders, the stubs table must be first initialized using one of Tcl_InitSubsystems , Tcl_SetPanicProc , Tcl_FindExecutable or TclZipfs_AppHook .","title":"DESCRIPTION"},{"location":"Alloc/#keywords","text":"alloc, allocation, free, malloc, memory, realloc, TCL_MEM_DEBUG","title":"KEYWORDS"},{"location":"AllowExc/","text":"NAME Tcl_AllowExceptions - allow all exceptions in next script evaluation SYNOPSIS #include <tcl.h> Tcl_AllowExceptions(interp) ARGUMENTS Interpreter in which script will be evaluated. DESCRIPTION If a script is evaluated at top-level (i.e. no other scripts are pending evaluation when the script is invoked), and if the script terminates with a completion code other than TCL_OK , TCL_ERROR or TCL_RETURN , then Tcl normally converts this into a TCL_ERROR return with an appropriate message. The particular script evaluation procedures of Tcl that act in the manner are Tcl_EvalObjEx , Tcl_EvalObjv , Tcl_Eval , Tcl_EvalEx , Tcl_GlobalEval , Tcl_GlobalEvalObj and Tcl_VarEval . However, if Tcl_AllowExceptions is invoked immediately before calling one of those a procedures, then arbitrary completion codes are permitted from the script, and they are returned without modification. This is useful in cases where the caller can deal with exceptions such as TCL_BREAK or TCL_CONTINUE in a meaningful way. KEYWORDS continue, break, exception, interpreter","title":"NAME"},{"location":"AllowExc/#name","text":"Tcl_AllowExceptions - allow all exceptions in next script evaluation","title":"NAME"},{"location":"AllowExc/#synopsis","text":"#include <tcl.h> Tcl_AllowExceptions(interp)","title":"SYNOPSIS"},{"location":"AllowExc/#arguments","text":"Interpreter in which script will be evaluated.","title":"ARGUMENTS"},{"location":"AllowExc/#description","text":"If a script is evaluated at top-level (i.e. no other scripts are pending evaluation when the script is invoked), and if the script terminates with a completion code other than TCL_OK , TCL_ERROR or TCL_RETURN , then Tcl normally converts this into a TCL_ERROR return with an appropriate message. The particular script evaluation procedures of Tcl that act in the manner are Tcl_EvalObjEx , Tcl_EvalObjv , Tcl_Eval , Tcl_EvalEx , Tcl_GlobalEval , Tcl_GlobalEvalObj and Tcl_VarEval . However, if Tcl_AllowExceptions is invoked immediately before calling one of those a procedures, then arbitrary completion codes are permitted from the script, and they are returned without modification. This is useful in cases where the caller can deal with exceptions such as TCL_BREAK or TCL_CONTINUE in a meaningful way.","title":"DESCRIPTION"},{"location":"AllowExc/#keywords","text":"continue, break, exception, interpreter","title":"KEYWORDS"},{"location":"AppInit/","text":"NAME Tcl_AppInit - perform application-specific initialization SYNOPSIS #include <tcl.h> int Tcl_AppInit(interp) ARGUMENTS Interpreter for the application. DESCRIPTION Tcl_AppInit is a procedure that is invoked by the main programs for Tcl applications such as tclsh and wish . Its purpose is to allow new Tcl applications to be created without modifying the main programs provided as part of Tcl and Tk. To create a new application you write a new version of Tcl_AppInit to replace the default version provided by Tcl, then link your new Tcl_AppInit with the Tcl library. Tcl_AppInit is invoked by Tcl_Main and Tk_Main after their own initialization and before entering the main loop to process commands. Here are some examples of things that Tcl_AppInit might do: [1] : Call initialization procedures for various packages used by the application. Each initialization procedure adds new commands to interp for its package and performs other package-specific initialization. [2] : Process command-line arguments, which can be accessed from the Tcl variables argv and argv0 in interp . [3] : Invoke a startup script to initialize the application. [4] : Use the routines Tcl_SetStartupScript and Tcl_GetStartupScript to set or query the file and encoding that the active Tcl_Main or Tk_Main routine will use as a startup script. Tcl_AppInit returns TCL_OK or TCL_ERROR . If it returns TCL_ERROR then it must leave an error message in for the interpreter\\'s result; otherwise the result is ignored. In addition to Tcl_AppInit , your application should also contain a procedure main that calls Tcl_Main as follows: Tcl_Main(argc, argv, Tcl_AppInit); The third argument to Tcl_Main gives the address of the application-specific initialization procedure to invoke. This means that you do not have to use the name Tcl_AppInit for the procedure, but in practice the name is nearly always Tcl_AppInit (in versions before Tcl 7.4 the name Tcl_AppInit was implicit; there was no way to specify the procedure explicitly). The best way to get started is to make a copy of the file tclAppInit.c from the Tcl library or source directory. It already contains a main procedure and a template for Tcl_AppInit that you can modify for your application. SEE ALSO Tcl_Main(3) KEYWORDS application, argument, command, initialization, interpreter","title":"NAME"},{"location":"AppInit/#name","text":"Tcl_AppInit - perform application-specific initialization","title":"NAME"},{"location":"AppInit/#synopsis","text":"#include <tcl.h> int Tcl_AppInit(interp)","title":"SYNOPSIS"},{"location":"AppInit/#arguments","text":"Interpreter for the application.","title":"ARGUMENTS"},{"location":"AppInit/#description","text":"Tcl_AppInit is a procedure that is invoked by the main programs for Tcl applications such as tclsh and wish . Its purpose is to allow new Tcl applications to be created without modifying the main programs provided as part of Tcl and Tk. To create a new application you write a new version of Tcl_AppInit to replace the default version provided by Tcl, then link your new Tcl_AppInit with the Tcl library. Tcl_AppInit is invoked by Tcl_Main and Tk_Main after their own initialization and before entering the main loop to process commands. Here are some examples of things that Tcl_AppInit might do: [1] : Call initialization procedures for various packages used by the application. Each initialization procedure adds new commands to interp for its package and performs other package-specific initialization. [2] : Process command-line arguments, which can be accessed from the Tcl variables argv and argv0 in interp . [3] : Invoke a startup script to initialize the application. [4] : Use the routines Tcl_SetStartupScript and Tcl_GetStartupScript to set or query the file and encoding that the active Tcl_Main or Tk_Main routine will use as a startup script. Tcl_AppInit returns TCL_OK or TCL_ERROR . If it returns TCL_ERROR then it must leave an error message in for the interpreter\\'s result; otherwise the result is ignored. In addition to Tcl_AppInit , your application should also contain a procedure main that calls Tcl_Main as follows: Tcl_Main(argc, argv, Tcl_AppInit); The third argument to Tcl_Main gives the address of the application-specific initialization procedure to invoke. This means that you do not have to use the name Tcl_AppInit for the procedure, but in practice the name is nearly always Tcl_AppInit (in versions before Tcl 7.4 the name Tcl_AppInit was implicit; there was no way to specify the procedure explicitly). The best way to get started is to make a copy of the file tclAppInit.c from the Tcl library or source directory. It already contains a main procedure and a template for Tcl_AppInit that you can modify for your application.","title":"DESCRIPTION"},{"location":"AppInit/#see-also","text":"Tcl_Main(3)","title":"SEE ALSO"},{"location":"AppInit/#keywords","text":"application, argument, command, initialization, interpreter","title":"KEYWORDS"},{"location":"AssocData/","text":"NAME Tcl_GetAssocData, Tcl_SetAssocData, Tcl_DeleteAssocData - manage associations of string keys and user specified data with Tcl interpreters SYNOPSIS #include <tcl.h> void * Tcl_GetAssocData(interp, key, delProcPtr) Tcl_SetAssocData(interp, key, delProc, clientData) Tcl_DeleteAssocData(interp, key) ARGUMENTS Interpreter in which to execute the specified command. Key for association with which to store data or from which to delete or retrieve data. Typically the module prefix for a package. Procedure to call when interp is deleted. Pointer to location in which to store address of current deletion procedure for association. Ignored if NULL. Arbitrary one-word value associated with the given key in this interpreter. This data is owned by the caller. DESCRIPTION These procedures allow extensions to associate their own data with a Tcl interpreter. An association consists of a string key, typically the name of the extension, and a one-word value, which is typically a pointer to a data structure holding data specific to the extension. Tcl makes no interpretation of either the key or the value for an association. Storage management is facilitated by storing with each association a procedure to call when the interpreter is deleted. This procedure can dispose of the storage occupied by the client\\'s data in any way it sees fit. Tcl_SetAssocData creates an association between a string key and a user specified datum in the given interpreter. If there is already an association with the given key , Tcl_SetAssocData overwrites it with the new information. It is up to callers to organize their use of names to avoid conflicts, for example, by using package names as the keys. If the deleteProc argument is non-NULL it specifies the address of a procedure to invoke if the interpreter is deleted before the association is deleted. DeleteProc should have arguments and result that match the type Tcl_InterpDeleteProc : typedef void Tcl_InterpDeleteProc ( void * clientData , Tcl_Interp * interp ); When deleteProc is invoked the clientData and interp arguments will be the same as the corresponding arguments passed to Tcl_SetAssocData . The deletion procedure will not be invoked if the association is deleted before the interpreter is deleted. Tcl_GetAssocData returns the datum stored in the association with the specified key in the given interpreter, and if the delProcPtr field is non- NULL , the address indicated by it gets the address of the delete procedure stored with this association. If no association with the specified key exists in the given interpreter Tcl_GetAssocData returns NULL . Tcl_DeleteAssocData deletes an association with a specified key in the given interpreter. Then it calls the deletion procedure. KEYWORDS association, data, deletion procedure, interpreter, key","title":"NAME"},{"location":"AssocData/#name","text":"Tcl_GetAssocData, Tcl_SetAssocData, Tcl_DeleteAssocData - manage associations of string keys and user specified data with Tcl interpreters","title":"NAME"},{"location":"AssocData/#synopsis","text":"#include <tcl.h> void * Tcl_GetAssocData(interp, key, delProcPtr) Tcl_SetAssocData(interp, key, delProc, clientData) Tcl_DeleteAssocData(interp, key)","title":"SYNOPSIS"},{"location":"AssocData/#arguments","text":"Interpreter in which to execute the specified command. Key for association with which to store data or from which to delete or retrieve data. Typically the module prefix for a package. Procedure to call when interp is deleted. Pointer to location in which to store address of current deletion procedure for association. Ignored if NULL. Arbitrary one-word value associated with the given key in this interpreter. This data is owned by the caller.","title":"ARGUMENTS"},{"location":"AssocData/#description","text":"These procedures allow extensions to associate their own data with a Tcl interpreter. An association consists of a string key, typically the name of the extension, and a one-word value, which is typically a pointer to a data structure holding data specific to the extension. Tcl makes no interpretation of either the key or the value for an association. Storage management is facilitated by storing with each association a procedure to call when the interpreter is deleted. This procedure can dispose of the storage occupied by the client\\'s data in any way it sees fit. Tcl_SetAssocData creates an association between a string key and a user specified datum in the given interpreter. If there is already an association with the given key , Tcl_SetAssocData overwrites it with the new information. It is up to callers to organize their use of names to avoid conflicts, for example, by using package names as the keys. If the deleteProc argument is non-NULL it specifies the address of a procedure to invoke if the interpreter is deleted before the association is deleted. DeleteProc should have arguments and result that match the type Tcl_InterpDeleteProc : typedef void Tcl_InterpDeleteProc ( void * clientData , Tcl_Interp * interp ); When deleteProc is invoked the clientData and interp arguments will be the same as the corresponding arguments passed to Tcl_SetAssocData . The deletion procedure will not be invoked if the association is deleted before the interpreter is deleted. Tcl_GetAssocData returns the datum stored in the association with the specified key in the given interpreter, and if the delProcPtr field is non- NULL , the address indicated by it gets the address of the delete procedure stored with this association. If no association with the specified key exists in the given interpreter Tcl_GetAssocData returns NULL . Tcl_DeleteAssocData deletes an association with a specified key in the given interpreter. Then it calls the deletion procedure.","title":"DESCRIPTION"},{"location":"AssocData/#keywords","text":"association, data, deletion procedure, interpreter, key","title":"KEYWORDS"},{"location":"Async/","text":"NAME Tcl_AsyncCreate, Tcl_AsyncMark, Tcl_AsyncMarkFromSignal, Tcl_AsyncInvoke, Tcl_AsyncDelete, Tcl_AsyncReady - handle asynchronous events SYNOPSIS #include <tcl.h> Tcl_AsyncHandler Tcl_AsyncCreate(proc, clientData) void Tcl_AsyncMark(async) int Tcl_AsyncMarkFromSignal(async, sigNumber) int Tcl_AsyncInvoke(interp, code) void Tcl_AsyncDelete(async) int Tcl_AsyncReady() ARGUMENTS Procedure to invoke to handle an asynchronous event. One-word value to pass to proc . Token for asynchronous event handler. POSIX signal number, when used in a signal context. Tcl interpreter in which command was being evaluated when handler was invoked, or NULL if handler was invoked when there was no interpreter active. Completion code from command that just completed in interp , or 0 if interp is NULL. DESCRIPTION These procedures provide a safe mechanism for dealing with asynchronous events such as signals. If an event such as a signal occurs while a Tcl script is being evaluated then it is not safe to take any substantive action to process the event. For example, it is not safe to evaluate a Tcl script since the interpreter may already be in the middle of evaluating a script; it may not even be safe to allocate memory, since a memory allocation could have been in progress when the event occurred. The only safe approach is to set a flag indicating that the event occurred, then handle the event later when the world has returned to a clean state, such as after the current Tcl command completes. Tcl_AsyncCreate , Tcl_AsyncDelete , and Tcl_AsyncReady are thread sensitive. They access and/or set a thread-specific data structure in the event of a core built with --enable-threads . The token created by Tcl_AsyncCreate contains the needed thread information it was called from so that calling Tcl_AsyncMarkFromSignal or Tcl_AsyncMark with this token will only yield the origin thread into the asynchronous handler. Tcl_AsyncCreate creates an asynchronous handler and returns a token for it. The asynchronous handler must be created before any occurrences of the asynchronous event that it is intended to handle (it is not safe to create a handler at the time of an event). When an asynchronous event occurs the code that detects the event (such as a POSIX signal handler) should call Tcl_AsyncMarkFromSignal with the token for the handler and the POSIX signal number. The return value of this function is true, when the handler will be marked, false otherwise. For non-signal contexts, Tcl_AsyncMark serves the same purpose. Tcl_AsyncMarkFromSignal and Tcl_AsyncMark will mark the handler as ready to execute, but will not invoke the handler immediately. Tcl will call the proc associated with the handler later, when the world is in a safe state, and proc can then carry out the actions associated with the asynchronous event. Proc should have arguments and result that match the type Tcl_AsyncProc : typedef int Tcl_AsyncProc ( void * clientData , Tcl_Interp * interp , int code ); The clientData will be the same as the clientData argument passed to Tcl_AsyncCreate when the handler was created. If proc is invoked just after a command has completed execution in an interpreter, then interp will identify the interpreter in which the command was evaluated and code will be the completion code returned by that command. The command\\'s result will be present in the interpreter\\'s result. When proc returns, whatever it leaves in the interpreter\\'s result will be returned as the result of the command and the integer value returned by proc will be used as the new completion code for the command. It is also possible for proc to be invoked when no interpreter is active. This can happen, for example, if an asynchronous event occurs while the application is waiting for interactive input or an X event. In this case interp will be NULL and code will be 0, and the return value from proc will be ignored. The procedure Tcl_AsyncInvoke is called to invoke all of the handlers that are ready. The procedure Tcl_AsyncReady will return non-zero whenever any asynchronous handlers are ready; it can be checked to avoid calls to Tcl_AsyncInvoke when there are no ready handlers. Tcl calls Tcl_AsyncReady after each command is evaluated and calls Tcl_AsyncInvoke if needed. Applications may also call Tcl_AsyncInvoke at interesting times for that application. For example, Tcl\\'s event handler calls Tcl_AsyncReady after each event and calls Tcl_AsyncInvoke if needed. The interp and code arguments to Tcl_AsyncInvoke have the same meaning as for proc : they identify the active interpreter, if any, and the completion code from the command that just completed. Tcl_AsyncDelete removes an asynchronous handler so that its proc will never be invoked again. A handler can be deleted even when ready, and it will still not be invoked. If multiple handlers become active at the same time, the handlers are invoked in the order they were created (oldest handler first). The code and the interpreter\\'s result for later handlers reflect the values returned by earlier handlers, so that the most recently created handler has last say about the interpreter\\'s result and completion code. If new handlers become ready while handlers are executing, Tcl_AsyncInvoke will invoke them all; at each point it invokes the highest-priority (oldest) ready handler, repeating this over and over until there are no longer any ready handlers. WARNING It is almost always a bad idea for an asynchronous event handler to modify the interpreter\\'s result or return a code different from its code argument. This sort of behavior can disrupt the execution of scripts in subtle ways and result in bugs that are extremely difficult to track down. If an asynchronous event handler needs to evaluate Tcl scripts then it should first save the interpreter\\'s state by calling Tcl_SaveInterpState , passing in the code argument. When the asynchronous handler is finished it should restore the interpreter\\'s state by calling Tcl_RestoreInterpState , and then returning the code argument. KEYWORDS asynchronous event, handler, signal, Tcl_SaveInterpState, thread","title":"NAME"},{"location":"Async/#name","text":"Tcl_AsyncCreate, Tcl_AsyncMark, Tcl_AsyncMarkFromSignal, Tcl_AsyncInvoke, Tcl_AsyncDelete, Tcl_AsyncReady - handle asynchronous events","title":"NAME"},{"location":"Async/#synopsis","text":"#include <tcl.h> Tcl_AsyncHandler Tcl_AsyncCreate(proc, clientData) void Tcl_AsyncMark(async) int Tcl_AsyncMarkFromSignal(async, sigNumber) int Tcl_AsyncInvoke(interp, code) void Tcl_AsyncDelete(async) int Tcl_AsyncReady()","title":"SYNOPSIS"},{"location":"Async/#arguments","text":"Procedure to invoke to handle an asynchronous event. One-word value to pass to proc . Token for asynchronous event handler. POSIX signal number, when used in a signal context. Tcl interpreter in which command was being evaluated when handler was invoked, or NULL if handler was invoked when there was no interpreter active. Completion code from command that just completed in interp , or 0 if interp is NULL.","title":"ARGUMENTS"},{"location":"Async/#description","text":"These procedures provide a safe mechanism for dealing with asynchronous events such as signals. If an event such as a signal occurs while a Tcl script is being evaluated then it is not safe to take any substantive action to process the event. For example, it is not safe to evaluate a Tcl script since the interpreter may already be in the middle of evaluating a script; it may not even be safe to allocate memory, since a memory allocation could have been in progress when the event occurred. The only safe approach is to set a flag indicating that the event occurred, then handle the event later when the world has returned to a clean state, such as after the current Tcl command completes. Tcl_AsyncCreate , Tcl_AsyncDelete , and Tcl_AsyncReady are thread sensitive. They access and/or set a thread-specific data structure in the event of a core built with --enable-threads . The token created by Tcl_AsyncCreate contains the needed thread information it was called from so that calling Tcl_AsyncMarkFromSignal or Tcl_AsyncMark with this token will only yield the origin thread into the asynchronous handler. Tcl_AsyncCreate creates an asynchronous handler and returns a token for it. The asynchronous handler must be created before any occurrences of the asynchronous event that it is intended to handle (it is not safe to create a handler at the time of an event). When an asynchronous event occurs the code that detects the event (such as a POSIX signal handler) should call Tcl_AsyncMarkFromSignal with the token for the handler and the POSIX signal number. The return value of this function is true, when the handler will be marked, false otherwise. For non-signal contexts, Tcl_AsyncMark serves the same purpose. Tcl_AsyncMarkFromSignal and Tcl_AsyncMark will mark the handler as ready to execute, but will not invoke the handler immediately. Tcl will call the proc associated with the handler later, when the world is in a safe state, and proc can then carry out the actions associated with the asynchronous event. Proc should have arguments and result that match the type Tcl_AsyncProc : typedef int Tcl_AsyncProc ( void * clientData , Tcl_Interp * interp , int code ); The clientData will be the same as the clientData argument passed to Tcl_AsyncCreate when the handler was created. If proc is invoked just after a command has completed execution in an interpreter, then interp will identify the interpreter in which the command was evaluated and code will be the completion code returned by that command. The command\\'s result will be present in the interpreter\\'s result. When proc returns, whatever it leaves in the interpreter\\'s result will be returned as the result of the command and the integer value returned by proc will be used as the new completion code for the command. It is also possible for proc to be invoked when no interpreter is active. This can happen, for example, if an asynchronous event occurs while the application is waiting for interactive input or an X event. In this case interp will be NULL and code will be 0, and the return value from proc will be ignored. The procedure Tcl_AsyncInvoke is called to invoke all of the handlers that are ready. The procedure Tcl_AsyncReady will return non-zero whenever any asynchronous handlers are ready; it can be checked to avoid calls to Tcl_AsyncInvoke when there are no ready handlers. Tcl calls Tcl_AsyncReady after each command is evaluated and calls Tcl_AsyncInvoke if needed. Applications may also call Tcl_AsyncInvoke at interesting times for that application. For example, Tcl\\'s event handler calls Tcl_AsyncReady after each event and calls Tcl_AsyncInvoke if needed. The interp and code arguments to Tcl_AsyncInvoke have the same meaning as for proc : they identify the active interpreter, if any, and the completion code from the command that just completed. Tcl_AsyncDelete removes an asynchronous handler so that its proc will never be invoked again. A handler can be deleted even when ready, and it will still not be invoked. If multiple handlers become active at the same time, the handlers are invoked in the order they were created (oldest handler first). The code and the interpreter\\'s result for later handlers reflect the values returned by earlier handlers, so that the most recently created handler has last say about the interpreter\\'s result and completion code. If new handlers become ready while handlers are executing, Tcl_AsyncInvoke will invoke them all; at each point it invokes the highest-priority (oldest) ready handler, repeating this over and over until there are no longer any ready handlers.","title":"DESCRIPTION"},{"location":"Async/#warning","text":"It is almost always a bad idea for an asynchronous event handler to modify the interpreter\\'s result or return a code different from its code argument. This sort of behavior can disrupt the execution of scripts in subtle ways and result in bugs that are extremely difficult to track down. If an asynchronous event handler needs to evaluate Tcl scripts then it should first save the interpreter\\'s state by calling Tcl_SaveInterpState , passing in the code argument. When the asynchronous handler is finished it should restore the interpreter\\'s state by calling Tcl_RestoreInterpState , and then returning the code argument.","title":"WARNING"},{"location":"Async/#keywords","text":"asynchronous event, handler, signal, Tcl_SaveInterpState, thread","title":"KEYWORDS"},{"location":"BackgdErr/","text":"NAME Tcl_BackgroundException, Tcl_BackgroundError - report Tcl exception that occurred in background processing SYNOPSIS #include <tcl.h> Tcl_BackgroundException(interp, code) Tcl_BackgroundError(interp) ARGUMENTS Interpreter in which the exception occurred. The exceptional return code to be reported. DESCRIPTION This procedure is typically invoked when a Tcl exception (any return code other than TCL_OK) occurs during such as executing an event handler. When such an exception occurs, the condition is reported to Tcl or to a widget or some other C code, and there is not usually any obvious way for that code to report the exception to the user. In these cases the code calls Tcl_BackgroundException with an interp argument identifying the interpreter in which the exception occurred, and a code argument holding the return code value of the exception. The state of the interpreter, including any error message in the interpreter result, and the values of any entries in the return options dictionary, is captured and saved. Tcl_BackgroundException then arranges for the event loop to invoke at some later time the command registered in that interpreter to handle background errors by the interp bgerror command, passing the captured values as arguments. The registered handler command is meant to report the exception in an application-specific fashion. The handler command receives two arguments, the result of the interp, and the return options of the interp at the time the error occurred. If the application registers no handler command, the default handler command will attempt to call bgerror to report the error. If an error condition arises while invoking the handler command, then Tcl_BackgroundException reports the error itself by printing a message on the standard error file. Tcl_BackgroundException does not invoke the handler command immediately because this could potentially interfere with scripts that are in process at the time the error occurred. Instead, it invokes the handler command later as an idle callback. It is possible for many background exceptions to accumulate before the handler command is invoked. When this happens, each of the exceptions is processed in order. However, if the handler command returns a break exception, then all remaining error reports for the interpreter are skipped. The Tcl_BackgroundError routine is an older and simpler interface useful when the exception code reported is TCL_ERROR . It is equivalent to: Tcl_BackgroundException(interp, TCL_ERROR); KEYWORDS background, bgerror, error, interp","title":"NAME"},{"location":"BackgdErr/#name","text":"Tcl_BackgroundException, Tcl_BackgroundError - report Tcl exception that occurred in background processing","title":"NAME"},{"location":"BackgdErr/#synopsis","text":"#include <tcl.h> Tcl_BackgroundException(interp, code) Tcl_BackgroundError(interp)","title":"SYNOPSIS"},{"location":"BackgdErr/#arguments","text":"Interpreter in which the exception occurred. The exceptional return code to be reported.","title":"ARGUMENTS"},{"location":"BackgdErr/#description","text":"This procedure is typically invoked when a Tcl exception (any return code other than TCL_OK) occurs during such as executing an event handler. When such an exception occurs, the condition is reported to Tcl or to a widget or some other C code, and there is not usually any obvious way for that code to report the exception to the user. In these cases the code calls Tcl_BackgroundException with an interp argument identifying the interpreter in which the exception occurred, and a code argument holding the return code value of the exception. The state of the interpreter, including any error message in the interpreter result, and the values of any entries in the return options dictionary, is captured and saved. Tcl_BackgroundException then arranges for the event loop to invoke at some later time the command registered in that interpreter to handle background errors by the interp bgerror command, passing the captured values as arguments. The registered handler command is meant to report the exception in an application-specific fashion. The handler command receives two arguments, the result of the interp, and the return options of the interp at the time the error occurred. If the application registers no handler command, the default handler command will attempt to call bgerror to report the error. If an error condition arises while invoking the handler command, then Tcl_BackgroundException reports the error itself by printing a message on the standard error file. Tcl_BackgroundException does not invoke the handler command immediately because this could potentially interfere with scripts that are in process at the time the error occurred. Instead, it invokes the handler command later as an idle callback. It is possible for many background exceptions to accumulate before the handler command is invoked. When this happens, each of the exceptions is processed in order. However, if the handler command returns a break exception, then all remaining error reports for the interpreter are skipped. The Tcl_BackgroundError routine is an older and simpler interface useful when the exception code reported is TCL_ERROR . It is equivalent to: Tcl_BackgroundException(interp, TCL_ERROR);","title":"DESCRIPTION"},{"location":"BackgdErr/#keywords","text":"background, bgerror, error, interp","title":"KEYWORDS"},{"location":"BoolObj/","text":"NAME Tcl_NewBooleanObj, Tcl_SetBooleanObj, Tcl_GetBooleanFromObj, Tcl_GetBoolFromObj - store/retrieve boolean value in a Tcl_Obj SYNOPSIS #include <tcl.h> Tcl_Obj * Tcl_NewBooleanObj(intValue) Tcl_SetBooleanObj(objPtr, intValue) int Tcl_GetBooleanFromObj(interp, objPtr, boolPtr) int Tcl_GetBoolFromObj(interp, objPtr, flags. charPtr) ARGUMENTS Integer value to be stored as a boolean value in a Tcl_Obj. Points to the Tcl_Obj in which to store, or from which to retrieve a boolean value. If a boolean value cannot be retrieved, an error message is left in the interpreter\\'s result value unless interp is NULL. Points to place where Tcl_GetBooleanFromObj stores the boolean value (0 or 1) obtained from objPtr . Points to place where Tcl_GetBoolFromObj stores the boolean value (0 or 1) obtained from objPtr . 0 or TCL_NULL_OK. If TCL_NULL_OK is used, then the empty string or NULL will result in Tcl_GetBoolFromObj return TCL_OK, the *charPtr filled with the value \\'\\xFF\\' ; DESCRIPTION These procedures are used to pass boolean values to and from Tcl as Tcl_Obj\\'s. When storing a boolean value into a Tcl_Obj, any non-zero integer value in intValue is taken to be the boolean value 1 , and the integer value 0 is taken to be the boolean value 0 . Tcl_NewBooleanObj creates a new Tcl_Obj, stores the boolean value intValue in it, and returns a pointer to the new Tcl_Obj. The new Tcl_Obj has reference count of zero. Tcl_SetBooleanObj accepts objPtr , a pointer to an existing Tcl_Obj, and stores in the Tcl_Obj *objPtr the boolean value intValue . This is a write operation on *objPtr , so objPtr must be unshared. Attempts to write to a shared Tcl_Obj will panic. A successful write of intValue into *objPtr implies the freeing of any former value stored in *objPtr . Tcl_GetBooleanFromObj attempts to retrieve a boolean value from the value stored in *objPtr . If objPtr holds a string value recognized by Tcl_GetBoolean , then the recognized boolean value is written at the address given by boolPtr . If objPtr holds any value recognized as a number by Tcl, then if that value is zero a 0 is written at the address given by boolPtr and if that value is non-zero a 1 is written at the address given by boolPtr . In all cases where a value is written at the address given by boolPtr , Tcl_GetBooleanFromObj returns TCL_OK . If the value of objPtr does not meet any of the conditions above, then TCL_ERROR is returned and an error message is left in the interpreter\\'s result unless interp is NULL. Tcl_GetBooleanFromObj may also make changes to the internal fields of *objPtr so that future calls to Tcl_GetBooleanFromObj on the same objPtr can be performed more efficiently. Tcl_GetBoolFromObj functions almost the same as Tcl_GetBooleanFromObj , but it has an additional parameter flags , which can be used to specify whether the empty string or NULL is accepted as valid. Note that the routines Tcl_GetBooleanFromObj and Tcl_GetBoolean are not functional equivalents. The set of values for which Tcl_GetBooleanFromObj will return TCL_OK is strictly larger than the set of values for which Tcl_GetBoolean will do the same. For example, the value passed to Tcl_GetBooleanFromObj will lead to a TCL_OK return (and the boolean value 1), while the same value passed to Tcl_GetBoolean will lead to a TCL_ERROR return. REFERENCE COUNT MANAGEMENT Tcl_NewBooleanObj always returns a zero-reference object, much like Tcl_NewObj . Tcl_SetBooleanObj does not modify the reference count of its objPtr argument, but does require that the object be unshared. Tcl_GetBooleanFromObj does not modify the reference count of its objPtr argument; it only reads. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to the object, it will be deleted. SEE ALSO Tcl_NewObj, Tcl_IsShared, Tcl_GetBoolean KEYWORDS boolean, value","title":"NAME"},{"location":"BoolObj/#name","text":"Tcl_NewBooleanObj, Tcl_SetBooleanObj, Tcl_GetBooleanFromObj, Tcl_GetBoolFromObj - store/retrieve boolean value in a Tcl_Obj","title":"NAME"},{"location":"BoolObj/#synopsis","text":"#include <tcl.h> Tcl_Obj * Tcl_NewBooleanObj(intValue) Tcl_SetBooleanObj(objPtr, intValue) int Tcl_GetBooleanFromObj(interp, objPtr, boolPtr) int Tcl_GetBoolFromObj(interp, objPtr, flags. charPtr)","title":"SYNOPSIS"},{"location":"BoolObj/#arguments","text":"Integer value to be stored as a boolean value in a Tcl_Obj. Points to the Tcl_Obj in which to store, or from which to retrieve a boolean value. If a boolean value cannot be retrieved, an error message is left in the interpreter\\'s result value unless interp is NULL. Points to place where Tcl_GetBooleanFromObj stores the boolean value (0 or 1) obtained from objPtr . Points to place where Tcl_GetBoolFromObj stores the boolean value (0 or 1) obtained from objPtr . 0 or TCL_NULL_OK. If TCL_NULL_OK is used, then the empty string or NULL will result in Tcl_GetBoolFromObj return TCL_OK, the *charPtr filled with the value \\'\\xFF\\' ;","title":"ARGUMENTS"},{"location":"BoolObj/#description","text":"These procedures are used to pass boolean values to and from Tcl as Tcl_Obj\\'s. When storing a boolean value into a Tcl_Obj, any non-zero integer value in intValue is taken to be the boolean value 1 , and the integer value 0 is taken to be the boolean value 0 . Tcl_NewBooleanObj creates a new Tcl_Obj, stores the boolean value intValue in it, and returns a pointer to the new Tcl_Obj. The new Tcl_Obj has reference count of zero. Tcl_SetBooleanObj accepts objPtr , a pointer to an existing Tcl_Obj, and stores in the Tcl_Obj *objPtr the boolean value intValue . This is a write operation on *objPtr , so objPtr must be unshared. Attempts to write to a shared Tcl_Obj will panic. A successful write of intValue into *objPtr implies the freeing of any former value stored in *objPtr . Tcl_GetBooleanFromObj attempts to retrieve a boolean value from the value stored in *objPtr . If objPtr holds a string value recognized by Tcl_GetBoolean , then the recognized boolean value is written at the address given by boolPtr . If objPtr holds any value recognized as a number by Tcl, then if that value is zero a 0 is written at the address given by boolPtr and if that value is non-zero a 1 is written at the address given by boolPtr . In all cases where a value is written at the address given by boolPtr , Tcl_GetBooleanFromObj returns TCL_OK . If the value of objPtr does not meet any of the conditions above, then TCL_ERROR is returned and an error message is left in the interpreter\\'s result unless interp is NULL. Tcl_GetBooleanFromObj may also make changes to the internal fields of *objPtr so that future calls to Tcl_GetBooleanFromObj on the same objPtr can be performed more efficiently. Tcl_GetBoolFromObj functions almost the same as Tcl_GetBooleanFromObj , but it has an additional parameter flags , which can be used to specify whether the empty string or NULL is accepted as valid. Note that the routines Tcl_GetBooleanFromObj and Tcl_GetBoolean are not functional equivalents. The set of values for which Tcl_GetBooleanFromObj will return TCL_OK is strictly larger than the set of values for which Tcl_GetBoolean will do the same. For example, the value passed to Tcl_GetBooleanFromObj will lead to a TCL_OK return (and the boolean value 1), while the same value passed to Tcl_GetBoolean will lead to a TCL_ERROR return.","title":"DESCRIPTION"},{"location":"BoolObj/#reference-count-management","text":"Tcl_NewBooleanObj always returns a zero-reference object, much like Tcl_NewObj . Tcl_SetBooleanObj does not modify the reference count of its objPtr argument, but does require that the object be unshared. Tcl_GetBooleanFromObj does not modify the reference count of its objPtr argument; it only reads. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to the object, it will be deleted.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"BoolObj/#see-also","text":"Tcl_NewObj, Tcl_IsShared, Tcl_GetBoolean","title":"SEE ALSO"},{"location":"BoolObj/#keywords","text":"boolean, value","title":"KEYWORDS"},{"location":"ByteArrObj/","text":"NAME Tcl_NewByteArrayObj, Tcl_SetByteArrayObj, Tcl_GetBytesFromObj, Tcl_GetByteArrayFromObj, Tcl_SetByteArrayLength - manipulate a Tcl value as an array of bytes SYNOPSIS #include <tcl.h> Tcl_Obj * Tcl_NewByteArrayObj(bytes, numBytes) void Tcl_SetByteArrayObj(objPtr, bytes, numBytes) unsigned char * Tcl_GetBytesFromObj(interp, objPtr, numBytesPtr) unsigned char * Tcl_GetByteArrayFromObj(objPtr, numBytesPtr) unsigned char * Tcl_SetByteArrayLength(objPtr, numBytes) ARGUMENTS The array of bytes used to initialize or set a byte-array value. May be NULL even if numBytes is non-zero. The number of bytes in the array. For Tcl_SetByteArrayObj , this points to an unshared value to be overwritten by a byte-array value. For Tcl_GetBytesFromObj , Tcl_GetByteArrayFromObj and Tcl_SetByteArrayLength , this points to the value from which to extract an array of bytes. Interpreter to use for error reporting. Points to space where the number of bytes in the array may be written. Caller may pass NULL when it does not need this information. DESCRIPTION These routines are used to create, modify, store, transfer, and retrieve arbitrary binary data in Tcl values. Specifically, data that can be represented as a sequence of arbitrary byte values is supported. This includes data read from binary channels, values created by the binary command, encrypted data, or other information representable as a finite byte sequence. A byte is an 8-bit quantity with no inherent meaning. When the 8 bits are interpreted as an integer value, the range of possible values is (0-255). The C type best suited to store a byte is the unsigned char . An unsigned char array of size N stores an aribtrary binary value of size N bytes. We call this representation a byte-array. Here we document the routines that allow us to operate on Tcl values as byte-arrays. All Tcl values must correspond to a string representation. When a byte-array value must be processed as a string, the sequence of N bytes is transformed into the corresponding sequence of N characters, where each byte value transforms to the same character codepoint value in the range (U+0000 - U+00FF). Obtaining the string representation of a byte-array value (by calling Tcl_GetStringFromObj ) produces this string in Tcl\\'s usual Modified UTF-8 encoding. Tcl_NewByteArrayObj and Tcl_SetByteArrayObj create a new value or overwrite an existing unshared value, respectively, to hold a byte-array value of numBytes bytes. When a caller passes a non-NULL value of bytes , it must point to memory from which numBytes bytes can be read. These routines allocate numBytes bytes of memory, copy numBytes bytes from bytes into it, and keep the result in the internal representation of the new or overwritten value. When the caller passes a NULL value of bytes , the data copying step is skipped, and the bytes stored in the value are undefined. A bytes value of NULL is useful only when the caller will arrange to write known contents into the byte-array through a pointer retrieved by a call to one of the routines explained below. Tcl_NewByteArrayObj returns a pointer to the created value with a reference count of zero. Tcl_SetByteArrayObj overwrites and invalidates any old contents of the unshared objPtr as appropriate, and keeps its reference count (0 or 1) unchanged. The value produced by these routines has no string representation. Any memory allocation failure may cause a panic. Tcl_GetBytesFromObj performs the opposite function of Tcl_SetByteArrayObj , providing access to read a byte-array from a Tcl value that was previously written into it. When objPtr is a value previously produced by Tcl_NewByteArrayObj or Tcl_SetByteArrayObj , then Tcl_GetBytesFromObj returns a pointer to the byte-array kept in the value\\'s internal representation. If the caller provides a non-NULL value for numBytesPtr , it must point to memory where Tcl_GetBytesFromObj can write the number of bytes in the value\\'s internal byte-array. With both pieces of information, the caller is able to retrieve any information about the contents of that byte-array that it seeks. When objPtr does not already contain an internal byte-array, Tcl_GetBytesFromObj will try to create one from the value\\'s string representation. Any string value that does not include any character codepoints outside the range (U+0000 - U+00FF) will successfully translate to a unique byte-array value. With the created byte-array, the routine returns as before. For any string representation which does contain a forbidden character codepoint, the conversion fails, and Tcl_GetBytesFromObj returns NULL to signal that failure. On failure, nothing will be written to numBytesPtr , and if the interp argument is non-NULL, then error messages and codes are left in it recording the error. Tcl_GetByteArrayFromObj performs exactly the same function as Tcl_GetBytesFromObj does when called with the interp argument passed the value NULL. This is incompatible with the way Tcl_GetByteArrayFromObj functioned in Tcl 8. Tcl_GetBytesFromObj is the more capable interface and should usually be favored for use over Tcl_GetByteArrayFromObj . On success, both Tcl_GetByteFromObj and Tcl_GetByteArrayFromObj return a pointer into the internal representation of a Tcl_Obj . That pointer must not be freed by the caller, and should not be retained for use beyond the known time the internal representation of the value has not been disturbed. The pointer may be used to overwrite the byte contents of the internal representation, so long as the value is unshared and any string representation is invalidated. On success, both Tcl_GetBytesFromObj and Tcl_GetByteArrayFromObj write the number of bytes in the byte-array value of objPtr to the space pointed to by numBytesPtr . This space may be of type Tcl_Size or of type int . It is recommended that callers provide a Tcl_Size space for this purpose. If the caller provides only an int space and the number of bytes in the byte-array value of objPtr is greater than INT_MAX , the routine will fail due to being unable to correctly report the byte-array size to the caller. The ability to provide an int space is best considered a migration aid for codebases constrained to continue operating with Tcl releases older than 8.7. Tcl_SetByteArrayLength enables a caller to change the size of a byte-array in the internal representation of an unshared objPtr to become numBytes bytes. This is most often useful after the bytes of the internal byte-array have been directly overwritten and it has been discovered that the required size differs from the first estimate used in the allocation. Tcl_SetByteArrayLength returns a pointer to the resized byte-array. Because resizing the byte-array changes the internal representation, Tcl_SetByteArrayLength also invalidates any string representation in objPtr . If resizing grows the byte-array, the new byte values are undefined. If objPtr does not already possess an internal byte-array, one is produced in the same way that Tcl_GetBytesFromObj does, also returning NULL when any characters of the value in objPtr (up to numBytes of them) are not valid bytes. REFERENCE COUNT MANAGEMENT Tcl_NewByteArrayObj always returns a zero-reference object, much like Tcl_NewObj . Tcl_SetByteArrayObj and Tcl_SetByteArrayLength do not modify the reference count of their objPtr arguments, but do require that the object be unshared. Tcl_GetBytesFromObj and Tcl_GetByteArrayFromObj do not modify the reference count of objPtr ; they only read. SEE ALSO Tcl_GetStringFromObj, Tcl_NewObj, Tcl_IncrRefCount, Tcl_DecrRefCount KEYWORDS value, binary data, byte array, utf, unicode","title":"NAME"},{"location":"ByteArrObj/#name","text":"Tcl_NewByteArrayObj, Tcl_SetByteArrayObj, Tcl_GetBytesFromObj, Tcl_GetByteArrayFromObj, Tcl_SetByteArrayLength - manipulate a Tcl value as an array of bytes","title":"NAME"},{"location":"ByteArrObj/#synopsis","text":"#include <tcl.h> Tcl_Obj * Tcl_NewByteArrayObj(bytes, numBytes) void Tcl_SetByteArrayObj(objPtr, bytes, numBytes) unsigned char * Tcl_GetBytesFromObj(interp, objPtr, numBytesPtr) unsigned char * Tcl_GetByteArrayFromObj(objPtr, numBytesPtr) unsigned char * Tcl_SetByteArrayLength(objPtr, numBytes)","title":"SYNOPSIS"},{"location":"ByteArrObj/#arguments","text":"The array of bytes used to initialize or set a byte-array value. May be NULL even if numBytes is non-zero. The number of bytes in the array. For Tcl_SetByteArrayObj , this points to an unshared value to be overwritten by a byte-array value. For Tcl_GetBytesFromObj , Tcl_GetByteArrayFromObj and Tcl_SetByteArrayLength , this points to the value from which to extract an array of bytes. Interpreter to use for error reporting. Points to space where the number of bytes in the array may be written. Caller may pass NULL when it does not need this information.","title":"ARGUMENTS"},{"location":"ByteArrObj/#description","text":"These routines are used to create, modify, store, transfer, and retrieve arbitrary binary data in Tcl values. Specifically, data that can be represented as a sequence of arbitrary byte values is supported. This includes data read from binary channels, values created by the binary command, encrypted data, or other information representable as a finite byte sequence. A byte is an 8-bit quantity with no inherent meaning. When the 8 bits are interpreted as an integer value, the range of possible values is (0-255). The C type best suited to store a byte is the unsigned char . An unsigned char array of size N stores an aribtrary binary value of size N bytes. We call this representation a byte-array. Here we document the routines that allow us to operate on Tcl values as byte-arrays. All Tcl values must correspond to a string representation. When a byte-array value must be processed as a string, the sequence of N bytes is transformed into the corresponding sequence of N characters, where each byte value transforms to the same character codepoint value in the range (U+0000 - U+00FF). Obtaining the string representation of a byte-array value (by calling Tcl_GetStringFromObj ) produces this string in Tcl\\'s usual Modified UTF-8 encoding. Tcl_NewByteArrayObj and Tcl_SetByteArrayObj create a new value or overwrite an existing unshared value, respectively, to hold a byte-array value of numBytes bytes. When a caller passes a non-NULL value of bytes , it must point to memory from which numBytes bytes can be read. These routines allocate numBytes bytes of memory, copy numBytes bytes from bytes into it, and keep the result in the internal representation of the new or overwritten value. When the caller passes a NULL value of bytes , the data copying step is skipped, and the bytes stored in the value are undefined. A bytes value of NULL is useful only when the caller will arrange to write known contents into the byte-array through a pointer retrieved by a call to one of the routines explained below. Tcl_NewByteArrayObj returns a pointer to the created value with a reference count of zero. Tcl_SetByteArrayObj overwrites and invalidates any old contents of the unshared objPtr as appropriate, and keeps its reference count (0 or 1) unchanged. The value produced by these routines has no string representation. Any memory allocation failure may cause a panic. Tcl_GetBytesFromObj performs the opposite function of Tcl_SetByteArrayObj , providing access to read a byte-array from a Tcl value that was previously written into it. When objPtr is a value previously produced by Tcl_NewByteArrayObj or Tcl_SetByteArrayObj , then Tcl_GetBytesFromObj returns a pointer to the byte-array kept in the value\\'s internal representation. If the caller provides a non-NULL value for numBytesPtr , it must point to memory where Tcl_GetBytesFromObj can write the number of bytes in the value\\'s internal byte-array. With both pieces of information, the caller is able to retrieve any information about the contents of that byte-array that it seeks. When objPtr does not already contain an internal byte-array, Tcl_GetBytesFromObj will try to create one from the value\\'s string representation. Any string value that does not include any character codepoints outside the range (U+0000 - U+00FF) will successfully translate to a unique byte-array value. With the created byte-array, the routine returns as before. For any string representation which does contain a forbidden character codepoint, the conversion fails, and Tcl_GetBytesFromObj returns NULL to signal that failure. On failure, nothing will be written to numBytesPtr , and if the interp argument is non-NULL, then error messages and codes are left in it recording the error. Tcl_GetByteArrayFromObj performs exactly the same function as Tcl_GetBytesFromObj does when called with the interp argument passed the value NULL. This is incompatible with the way Tcl_GetByteArrayFromObj functioned in Tcl 8. Tcl_GetBytesFromObj is the more capable interface and should usually be favored for use over Tcl_GetByteArrayFromObj . On success, both Tcl_GetByteFromObj and Tcl_GetByteArrayFromObj return a pointer into the internal representation of a Tcl_Obj . That pointer must not be freed by the caller, and should not be retained for use beyond the known time the internal representation of the value has not been disturbed. The pointer may be used to overwrite the byte contents of the internal representation, so long as the value is unshared and any string representation is invalidated. On success, both Tcl_GetBytesFromObj and Tcl_GetByteArrayFromObj write the number of bytes in the byte-array value of objPtr to the space pointed to by numBytesPtr . This space may be of type Tcl_Size or of type int . It is recommended that callers provide a Tcl_Size space for this purpose. If the caller provides only an int space and the number of bytes in the byte-array value of objPtr is greater than INT_MAX , the routine will fail due to being unable to correctly report the byte-array size to the caller. The ability to provide an int space is best considered a migration aid for codebases constrained to continue operating with Tcl releases older than 8.7. Tcl_SetByteArrayLength enables a caller to change the size of a byte-array in the internal representation of an unshared objPtr to become numBytes bytes. This is most often useful after the bytes of the internal byte-array have been directly overwritten and it has been discovered that the required size differs from the first estimate used in the allocation. Tcl_SetByteArrayLength returns a pointer to the resized byte-array. Because resizing the byte-array changes the internal representation, Tcl_SetByteArrayLength also invalidates any string representation in objPtr . If resizing grows the byte-array, the new byte values are undefined. If objPtr does not already possess an internal byte-array, one is produced in the same way that Tcl_GetBytesFromObj does, also returning NULL when any characters of the value in objPtr (up to numBytes of them) are not valid bytes.","title":"DESCRIPTION"},{"location":"ByteArrObj/#reference-count-management","text":"Tcl_NewByteArrayObj always returns a zero-reference object, much like Tcl_NewObj . Tcl_SetByteArrayObj and Tcl_SetByteArrayLength do not modify the reference count of their objPtr arguments, but do require that the object be unshared. Tcl_GetBytesFromObj and Tcl_GetByteArrayFromObj do not modify the reference count of objPtr ; they only read.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"ByteArrObj/#see-also","text":"Tcl_GetStringFromObj, Tcl_NewObj, Tcl_IncrRefCount, Tcl_DecrRefCount","title":"SEE ALSO"},{"location":"ByteArrObj/#keywords","text":"value, binary data, byte array, utf, unicode","title":"KEYWORDS"},{"location":"CallDel/","text":"NAME Tcl_CallWhenDeleted, Tcl_DontCallWhenDeleted - Arrange for callback when interpreter is deleted SYNOPSIS #include <tcl.h> Tcl_CallWhenDeleted(interp, proc, clientData) Tcl_DontCallWhenDeleted(interp, proc, clientData) ARGUMENTS Interpreter with which to associated callback. Procedure to call when interp is deleted. Arbitrary one-word value to pass to proc . DESCRIPTION Tcl_CallWhenDeleted arranges for proc to be called by Tcl_DeleteInterp if/when interp is deleted at some future time. Proc will be invoked just before the interpreter is deleted, but the interpreter will still be valid at the time of the call. Proc should have arguments and result that match the type Tcl_InterpDeleteProc : typedef void Tcl_InterpDeleteProc ( void * clientData , Tcl_Interp * interp ); The clientData and interp parameters are copies of the clientData and interp arguments given to Tcl_CallWhenDeleted . Typically, clientData points to an application-specific data structure that proc uses to perform cleanup when an interpreter is about to go away. Proc does not return a value. Tcl_DontCallWhenDeleted cancels a previous call to Tcl_CallWhenDeleted with the same arguments, so that proc will not be called after all when interp is deleted. If there is no deletion callback that matches interp , proc , and clientData then the call to Tcl_DontCallWhenDeleted has no effect. Note that if the callback is being used to delete a resource that must be released on exit, Tcl_CreateExitHandler should be used to ensure that a callback is received even if the application terminates without deleting the interpreter. SEE ALSO Tcl_CreateExitHandler(3), Tcl_CreateThreadExitHandler(3) KEYWORDS callback, cleanup, delete, interpreter","title":"NAME"},{"location":"CallDel/#name","text":"Tcl_CallWhenDeleted, Tcl_DontCallWhenDeleted - Arrange for callback when interpreter is deleted","title":"NAME"},{"location":"CallDel/#synopsis","text":"#include <tcl.h> Tcl_CallWhenDeleted(interp, proc, clientData) Tcl_DontCallWhenDeleted(interp, proc, clientData)","title":"SYNOPSIS"},{"location":"CallDel/#arguments","text":"Interpreter with which to associated callback. Procedure to call when interp is deleted. Arbitrary one-word value to pass to proc .","title":"ARGUMENTS"},{"location":"CallDel/#description","text":"Tcl_CallWhenDeleted arranges for proc to be called by Tcl_DeleteInterp if/when interp is deleted at some future time. Proc will be invoked just before the interpreter is deleted, but the interpreter will still be valid at the time of the call. Proc should have arguments and result that match the type Tcl_InterpDeleteProc : typedef void Tcl_InterpDeleteProc ( void * clientData , Tcl_Interp * interp ); The clientData and interp parameters are copies of the clientData and interp arguments given to Tcl_CallWhenDeleted . Typically, clientData points to an application-specific data structure that proc uses to perform cleanup when an interpreter is about to go away. Proc does not return a value. Tcl_DontCallWhenDeleted cancels a previous call to Tcl_CallWhenDeleted with the same arguments, so that proc will not be called after all when interp is deleted. If there is no deletion callback that matches interp , proc , and clientData then the call to Tcl_DontCallWhenDeleted has no effect. Note that if the callback is being used to delete a resource that must be released on exit, Tcl_CreateExitHandler should be used to ensure that a callback is received even if the application terminates without deleting the interpreter.","title":"DESCRIPTION"},{"location":"CallDel/#see-also","text":"Tcl_CreateExitHandler(3), Tcl_CreateThreadExitHandler(3)","title":"SEE ALSO"},{"location":"CallDel/#keywords","text":"callback, cleanup, delete, interpreter","title":"KEYWORDS"},{"location":"Cancel/","text":"NAME Tcl_CancelEval, Tcl_Canceled - cancel Tcl scripts SYNOPSIS #include <tcl.h> int Tcl_CancelEval(interp, resultObjPtr, clientData, flags) int Tcl_Canceled(interp, flags) ARGUMENTS Interpreter in which to cancel the script. Error message to use in the cancellation, or NULL to use a default message. If not NULL, this object will have its reference count decremented before Tcl_CancelEval returns. OR\\'ed combination of flag bits that specify additional options. For Tcl_CancelEval , only TCL_CANCEL_UNWIND is currently supported. For Tcl_Canceled , only TCL_LEAVE_ERR_MSG and TCL_CANCEL_UNWIND are currently supported. Currently reserved for future use. It should be set to NULL. DESCRIPTION Tcl_CancelEval cancels or unwinds the script in progress soon after the next invocation of asynchronous handlers, causing TCL_ERROR to be the return code for that script. This function is thread-safe and may be called from any thread in the process. Tcl_Canceled checks if the script in progress has been canceled and returns TCL_ERROR if it has. Otherwise, TCL_OK is returned. Extensions can use this function to check to see if they should abort a long running command. This function is thread sensitive and may only be called from the thread the interpreter was created in. FLAG BITS Any OR\\'ed combination of the following values may be used for the flags argument to procedures such as Tcl_CancelEval : TCL_CANCEL_UNWIND : This flag is used by Tcl_CancelEval and Tcl_Canceled . For Tcl_CancelEval , if this flag is set, the script in progress is canceled and the evaluation stack for the interpreter is unwound. For Tcl_Canceled , if this flag is set, the script in progress is considered to be canceled only if the evaluation stack for the interpreter is being unwound. TCL_LEAVE_ERR_MSG : This flag is only used by Tcl_Canceled ; it is ignored by other procedures. If an error is returned and this bit is set in flags , then an error message will be left in the interpreter\\'s result, where it can be retrieved with Tcl_GetObjResult or Tcl_GetStringResult . If this flag bit is not set then no error message is left and the interpreter\\'s result will not be modified. REFERENCE COUNT MANAGEMENT Tcl_CancelEval always decrements the reference count of its resultObjPtr argument (if that is non-NULL). It is expected to be usually called with an object with zero reference count. If the object is shared with some other location (including the Tcl evaluation stack) it should have its reference count incremented before calling this function. SEE ALSO interp(n), Tcl_Eval(3), TIP 285 KEYWORDS cancel, unwind","title":"NAME"},{"location":"Cancel/#name","text":"Tcl_CancelEval, Tcl_Canceled - cancel Tcl scripts","title":"NAME"},{"location":"Cancel/#synopsis","text":"#include <tcl.h> int Tcl_CancelEval(interp, resultObjPtr, clientData, flags) int Tcl_Canceled(interp, flags)","title":"SYNOPSIS"},{"location":"Cancel/#arguments","text":"Interpreter in which to cancel the script. Error message to use in the cancellation, or NULL to use a default message. If not NULL, this object will have its reference count decremented before Tcl_CancelEval returns. OR\\'ed combination of flag bits that specify additional options. For Tcl_CancelEval , only TCL_CANCEL_UNWIND is currently supported. For Tcl_Canceled , only TCL_LEAVE_ERR_MSG and TCL_CANCEL_UNWIND are currently supported. Currently reserved for future use. It should be set to NULL.","title":"ARGUMENTS"},{"location":"Cancel/#description","text":"Tcl_CancelEval cancels or unwinds the script in progress soon after the next invocation of asynchronous handlers, causing TCL_ERROR to be the return code for that script. This function is thread-safe and may be called from any thread in the process. Tcl_Canceled checks if the script in progress has been canceled and returns TCL_ERROR if it has. Otherwise, TCL_OK is returned. Extensions can use this function to check to see if they should abort a long running command. This function is thread sensitive and may only be called from the thread the interpreter was created in.","title":"DESCRIPTION"},{"location":"Cancel/#flag-bits","text":"Any OR\\'ed combination of the following values may be used for the flags argument to procedures such as Tcl_CancelEval : TCL_CANCEL_UNWIND : This flag is used by Tcl_CancelEval and Tcl_Canceled . For Tcl_CancelEval , if this flag is set, the script in progress is canceled and the evaluation stack for the interpreter is unwound. For Tcl_Canceled , if this flag is set, the script in progress is considered to be canceled only if the evaluation stack for the interpreter is being unwound. TCL_LEAVE_ERR_MSG : This flag is only used by Tcl_Canceled ; it is ignored by other procedures. If an error is returned and this bit is set in flags , then an error message will be left in the interpreter\\'s result, where it can be retrieved with Tcl_GetObjResult or Tcl_GetStringResult . If this flag bit is not set then no error message is left and the interpreter\\'s result will not be modified.","title":"FLAG BITS"},{"location":"Cancel/#reference-count-management","text":"Tcl_CancelEval always decrements the reference count of its resultObjPtr argument (if that is non-NULL). It is expected to be usually called with an object with zero reference count. If the object is shared with some other location (including the Tcl evaluation stack) it should have its reference count incremented before calling this function.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"Cancel/#see-also","text":"interp(n), Tcl_Eval(3), TIP 285","title":"SEE ALSO"},{"location":"Cancel/#keywords","text":"cancel, unwind","title":"KEYWORDS"},{"location":"ChnlStack/","text":"NAME Tcl_StackChannel, Tcl_UnstackChannel, Tcl_GetStackedChannel, Tcl_GetTopChannel - manipulate stacked I/O channels SYNOPSIS #include <tcl.h> Tcl_Channel Tcl_StackChannel(interp, typePtr, clientData, mask, channel) int Tcl_UnstackChannel(interp, channel) Tcl_Channel Tcl_GetStackedChannel(channel) Tcl_Channel Tcl_GetTopChannel(channel) ARGUMENTS Interpreter for error reporting. The new channel I/O procedures to use for channel . Arbitrary one-word value to pass to channel I/O procedures. Conditions under which channel will be used: OR-ed combination of TCL_READABLE , TCL_WRITABLE and TCL_EXCEPTION . This can be a subset of the operations currently allowed on channel . An existing Tcl channel such as returned by Tcl_CreateChannel . DESCRIPTION These functions are for use by extensions that add processing layers to Tcl I/O channels. Examples include compression and encryption modules. These functions transparently stack and unstack a new channel on top of an existing one. Any number of channels can be stacked together. The Tcl_ChannelType version currently supported is TCL_CHANNEL_VERSION_5 . See Tcl_CreateChannel for details. Tcl_StackChannel stacks a new channel on an existing channel with the same name that was registered for channel by Tcl_RegisterChannel . Tcl_StackChannel works by creating a new channel structure and placing itself on top of the channel stack. EOL translation, encoding and buffering options are shared between all channels in the stack. The hidden channel does no buffering, newline translations, or character set encoding. Instead, the buffering, newline translations, and encoding functions all remain at the top of the channel stack. A pointer to the new top channel structure is returned. If an error occurs when stacking the channel, NULL is returned instead. The mask parameter specifies the operations that are allowed on the new channel. These can be a subset of the operations allowed on the original channel. For example, a read-write channel may become read-only after the Tcl_StackChannel call. Closing a channel closes the channels stacked below it. The close of stacked channels is executed in a way that allows buffered data to be properly flushed. Tcl_UnstackChannel reverses the process. The old channel is associated with the channel name, and the processing module added by Tcl_StackChannel is destroyed. If there is no old channel, then Tcl_UnstackChannel is equivalent to Tcl_Close . If an error occurs unstacking the channel, TCL_ERROR is returned, otherwise TCL_OK is returned. Tcl_GetTopChannel returns the top channel in the stack of channels the supplied channel is part of. Tcl_GetStackedChannel returns the channel in the stack of channels which is just below the supplied channel. SEE ALSO Notifier(3), Tcl_CreateChannel(3), Tcl_OpenFileChannel(3), vwait(n). KEYWORDS channel, compression","title":"NAME"},{"location":"ChnlStack/#name","text":"Tcl_StackChannel, Tcl_UnstackChannel, Tcl_GetStackedChannel, Tcl_GetTopChannel - manipulate stacked I/O channels","title":"NAME"},{"location":"ChnlStack/#synopsis","text":"#include <tcl.h> Tcl_Channel Tcl_StackChannel(interp, typePtr, clientData, mask, channel) int Tcl_UnstackChannel(interp, channel) Tcl_Channel Tcl_GetStackedChannel(channel) Tcl_Channel Tcl_GetTopChannel(channel)","title":"SYNOPSIS"},{"location":"ChnlStack/#arguments","text":"Interpreter for error reporting. The new channel I/O procedures to use for channel . Arbitrary one-word value to pass to channel I/O procedures. Conditions under which channel will be used: OR-ed combination of TCL_READABLE , TCL_WRITABLE and TCL_EXCEPTION . This can be a subset of the operations currently allowed on channel . An existing Tcl channel such as returned by Tcl_CreateChannel .","title":"ARGUMENTS"},{"location":"ChnlStack/#description","text":"These functions are for use by extensions that add processing layers to Tcl I/O channels. Examples include compression and encryption modules. These functions transparently stack and unstack a new channel on top of an existing one. Any number of channels can be stacked together. The Tcl_ChannelType version currently supported is TCL_CHANNEL_VERSION_5 . See Tcl_CreateChannel for details. Tcl_StackChannel stacks a new channel on an existing channel with the same name that was registered for channel by Tcl_RegisterChannel . Tcl_StackChannel works by creating a new channel structure and placing itself on top of the channel stack. EOL translation, encoding and buffering options are shared between all channels in the stack. The hidden channel does no buffering, newline translations, or character set encoding. Instead, the buffering, newline translations, and encoding functions all remain at the top of the channel stack. A pointer to the new top channel structure is returned. If an error occurs when stacking the channel, NULL is returned instead. The mask parameter specifies the operations that are allowed on the new channel. These can be a subset of the operations allowed on the original channel. For example, a read-write channel may become read-only after the Tcl_StackChannel call. Closing a channel closes the channels stacked below it. The close of stacked channels is executed in a way that allows buffered data to be properly flushed. Tcl_UnstackChannel reverses the process. The old channel is associated with the channel name, and the processing module added by Tcl_StackChannel is destroyed. If there is no old channel, then Tcl_UnstackChannel is equivalent to Tcl_Close . If an error occurs unstacking the channel, TCL_ERROR is returned, otherwise TCL_OK is returned. Tcl_GetTopChannel returns the top channel in the stack of channels the supplied channel is part of. Tcl_GetStackedChannel returns the channel in the stack of channels which is just below the supplied channel.","title":"DESCRIPTION"},{"location":"ChnlStack/#see-also","text":"Notifier(3), Tcl_CreateChannel(3), Tcl_OpenFileChannel(3), vwait(n).","title":"SEE ALSO"},{"location":"ChnlStack/#keywords","text":"channel, compression","title":"KEYWORDS"},{"location":"Class/","text":"NAME oo::class - class of all classes SYNOPSIS package require tcl::oo oo::class method ?arg ...? CLASS HIERARCHY oo::object \u2192 oo::class DESCRIPTION Classes are objects that can manufacture other objects according to a pattern stored in the factory object (the class). An instance of the class is created by calling one of the class\\'s factory methods, typically either create if an explicit name is being given, or new if an arbitrary unique name is to be automatically selected. The oo::class class is the class of all classes; every class is an instance of this class, which is consequently an instance of itself. This class is a subclass of oo::object , so every class is also an object. Additional metaclasses (i.e., classes of classes) can be defined if necessary by subclassing oo::class . Note that the oo::class object hides the new method on itself, so new classes should always be made using the create method. CONSTRUCTOR The constructor of the oo::class class takes an optional argument which, if present, is sent to the oo::define command (along with the name of the newly-created class) to allow the class to be conveniently configured at creation time. DESTRUCTOR The oo::class class does not define an explicit destructor. However, when a class is destroyed, all its subclasses and instances are also destroyed, along with all objects that it has been mixed into. EXPORTED METHODS cls create name ? arg ... ? : This creates a new instance of the class cls called name (which is resolved within the calling context\\'s namespace if not fully qualified), passing the arguments, arg ... , to the constructor, and (if that returns a successful result) returning the fully qualified name of the created object (the result of the constructor is ignored). If the constructor fails (i.e. returns a non-OK result) then the object is destroyed and the error message is the result of this method call. cls new ? arg ... ? : This creates a new instance of the class cls with a new unique name, passing the arguments, arg ... , to the constructor, and (if that returns a successful result) returning the fully qualified name of the created object (the result of the constructor is ignored). If the constructor fails (i.e., returns a non-OK result) then the object is destroyed and the error message is the result of this method call. Note that this method is not exported by the **oo::class** object itself, so classes should not be created using this method. NON-EXPORTED METHODS The oo::class class supports the following non-exported methods: cls createWithNamespace name nsName ? arg ... ? : This creates a new instance of the class cls called name (which is resolved within the calling context\\'s namespace if not fully qualified), passing the arguments, arg ... , to the constructor, and (if that returns a successful result) returning the fully qualified name of the created object (the result of the constructor is ignored). The name of the instance\\'s internal namespace will be nsName unless that namespace already exists (when an arbitrary name will be chosen instead). If the constructor fails (i.e., returns a non-OK result) then the object is destroyed and the error message is the result of this method call. EXAMPLES This example defines a simple class hierarchy and creates a new instance of it. It then invokes a method of the object before destroying the hierarchy and showing that the destruction is transitive. oo::class create fruit { method eat {} { puts \\\"yummy!\\\" } } oo::class create banana { superclass fruit constructor {} { my variable peeled set peeled 0 } method peel {} { my variable peeled set peeled 1 puts \\\"skin now off\\\" } method edible? {} { my variable peeled return \\$peeled } method eat {} { if {![my edible?]} { my peel } next } } set b [banana new ] \\$b eat \u2192 prints \\\"skin now off\\\" and \\\"yummy!\\\" fruit destroy \\$b eat \u2192 error \\\"unknown command\\\" SEE ALSO oo::define(n), oo::object(n) KEYWORDS class, metaclass, object","title":"NAME"},{"location":"Class/#name","text":"oo::class - class of all classes","title":"NAME"},{"location":"Class/#synopsis","text":"package require tcl::oo oo::class method ?arg ...?","title":"SYNOPSIS"},{"location":"Class/#class-hierarchy","text":"oo::object \u2192 oo::class","title":"CLASS HIERARCHY"},{"location":"Class/#description","text":"Classes are objects that can manufacture other objects according to a pattern stored in the factory object (the class). An instance of the class is created by calling one of the class\\'s factory methods, typically either create if an explicit name is being given, or new if an arbitrary unique name is to be automatically selected. The oo::class class is the class of all classes; every class is an instance of this class, which is consequently an instance of itself. This class is a subclass of oo::object , so every class is also an object. Additional metaclasses (i.e., classes of classes) can be defined if necessary by subclassing oo::class . Note that the oo::class object hides the new method on itself, so new classes should always be made using the create method.","title":"DESCRIPTION"},{"location":"Class/#constructor","text":"The constructor of the oo::class class takes an optional argument which, if present, is sent to the oo::define command (along with the name of the newly-created class) to allow the class to be conveniently configured at creation time.","title":"CONSTRUCTOR"},{"location":"Class/#destructor","text":"The oo::class class does not define an explicit destructor. However, when a class is destroyed, all its subclasses and instances are also destroyed, along with all objects that it has been mixed into.","title":"DESTRUCTOR"},{"location":"Class/#exported-methods","text":"cls create name ? arg ... ? : This creates a new instance of the class cls called name (which is resolved within the calling context\\'s namespace if not fully qualified), passing the arguments, arg ... , to the constructor, and (if that returns a successful result) returning the fully qualified name of the created object (the result of the constructor is ignored). If the constructor fails (i.e. returns a non-OK result) then the object is destroyed and the error message is the result of this method call. cls new ? arg ... ? : This creates a new instance of the class cls with a new unique name, passing the arguments, arg ... , to the constructor, and (if that returns a successful result) returning the fully qualified name of the created object (the result of the constructor is ignored). If the constructor fails (i.e., returns a non-OK result) then the object is destroyed and the error message is the result of this method call. Note that this method is not exported by the **oo::class** object itself, so classes should not be created using this method.","title":"EXPORTED METHODS"},{"location":"Class/#non-exported-methods","text":"The oo::class class supports the following non-exported methods: cls createWithNamespace name nsName ? arg ... ? : This creates a new instance of the class cls called name (which is resolved within the calling context\\'s namespace if not fully qualified), passing the arguments, arg ... , to the constructor, and (if that returns a successful result) returning the fully qualified name of the created object (the result of the constructor is ignored). The name of the instance\\'s internal namespace will be nsName unless that namespace already exists (when an arbitrary name will be chosen instead). If the constructor fails (i.e., returns a non-OK result) then the object is destroyed and the error message is the result of this method call.","title":"NON-EXPORTED METHODS"},{"location":"Class/#examples","text":"This example defines a simple class hierarchy and creates a new instance of it. It then invokes a method of the object before destroying the hierarchy and showing that the destruction is transitive. oo::class create fruit { method eat {} { puts \\\"yummy!\\\" } } oo::class create banana { superclass fruit constructor {} { my variable peeled set peeled 0 } method peel {} { my variable peeled set peeled 1 puts \\\"skin now off\\\" } method edible? {} { my variable peeled return \\$peeled } method eat {} { if {![my edible?]} { my peel } next } } set b [banana new ] \\$b eat \u2192 prints \\\"skin now off\\\" and \\\"yummy!\\\" fruit destroy \\$b eat \u2192 error \\\"unknown command\\\"","title":"EXAMPLES"},{"location":"Class/#see-also","text":"oo::define(n), oo::object(n)","title":"SEE ALSO"},{"location":"Class/#keywords","text":"class, metaclass, object","title":"KEYWORDS"},{"location":"CmdCmplt/","text":"NAME Tcl_CommandComplete - Check for unmatched braces in a Tcl command SYNOPSIS #include <tcl.h> int Tcl_CommandComplete(cmd) ARGUMENTS Command string to test for completeness. DESCRIPTION Tcl_CommandComplete takes a Tcl command string as argument and determines whether it contains one or more complete commands (i.e. there are no unclosed quotes, braces, brackets, or variable references). If the command string is complete then it returns 1; otherwise it returns 0. KEYWORDS complete command, partial command","title":"NAME"},{"location":"CmdCmplt/#name","text":"Tcl_CommandComplete - Check for unmatched braces in a Tcl command","title":"NAME"},{"location":"CmdCmplt/#synopsis","text":"#include <tcl.h> int Tcl_CommandComplete(cmd)","title":"SYNOPSIS"},{"location":"CmdCmplt/#arguments","text":"Command string to test for completeness.","title":"ARGUMENTS"},{"location":"CmdCmplt/#description","text":"Tcl_CommandComplete takes a Tcl command string as argument and determines whether it contains one or more complete commands (i.e. there are no unclosed quotes, braces, brackets, or variable references). If the command string is complete then it returns 1; otherwise it returns 0.","title":"DESCRIPTION"},{"location":"CmdCmplt/#keywords","text":"complete command, partial command","title":"KEYWORDS"},{"location":"Concat/","text":"NAME concat - Join lists together SYNOPSIS concat ? arg arg ... ? DESCRIPTION This command joins each of its arguments together with spaces after trimming leading and trailing white-space from each of them. If all of the arguments are lists, this has the same effect as concatenating them into a single list. Arguments that are empty (after trimming) are ignored entirely. It permits any number of arguments; if no arg s are supplied, the result is an empty string. EXAMPLES Although concat will concatenate lists, flattening them in the process (so giving the following interactive session): % concat a b {c d e} {f {g h}} a b c d e f {g h} it will also concatenate things that are not lists, as can be seen from this session: % concat \\\" a b {c \\\" d \\\" e} f\\\" a b {c d e} f Note also that the concatenation does not remove spaces from the middle of values, as can be seen here: % concat \\\"a b c\\\" { d e f } a b c d e f (i.e., there are three spaces between each of the a , the b and the c ). SEE ALSO append(n), eval(n), join(n) KEYWORDS concatenate, join, list","title":"NAME"},{"location":"Concat/#name","text":"concat - Join lists together","title":"NAME"},{"location":"Concat/#synopsis","text":"concat ? arg arg ... ?","title":"SYNOPSIS"},{"location":"Concat/#description","text":"This command joins each of its arguments together with spaces after trimming leading and trailing white-space from each of them. If all of the arguments are lists, this has the same effect as concatenating them into a single list. Arguments that are empty (after trimming) are ignored entirely. It permits any number of arguments; if no arg s are supplied, the result is an empty string.","title":"DESCRIPTION"},{"location":"Concat/#examples","text":"Although concat will concatenate lists, flattening them in the process (so giving the following interactive session): % concat a b {c d e} {f {g h}} a b c d e f {g h} it will also concatenate things that are not lists, as can be seen from this session: % concat \\\" a b {c \\\" d \\\" e} f\\\" a b {c d e} f Note also that the concatenation does not remove spaces from the middle of values, as can be seen here: % concat \\\"a b c\\\" { d e f } a b c d e f (i.e., there are three spaces between each of the a , the b and the c ).","title":"EXAMPLES"},{"location":"Concat/#see-also","text":"append(n), eval(n), join(n)","title":"SEE ALSO"},{"location":"Concat/#keywords","text":"concatenate, join, list","title":"KEYWORDS"},{"location":"CrtAlias/","text":"NAME Tcl_IsSafe, Tcl_CreateChild, Tcl_GetChild, Tcl_GetParent, Tcl_GetInterpPath, Tcl_CreateAlias, Tcl_CreateAliasObj, Tcl_GetAlias, Tcl_GetAliasObj, Tcl_ExposeCommand, Tcl_HideCommand - manage multiple Tcl interpreters, aliases and hidden commands SYNOPSIS #include <tcl.h> int Tcl_IsSafe(interp) Tcl_Interp * Tcl_CreateChild(interp, name, isSafe) Tcl_Interp * Tcl_GetChild(interp, name) Tcl_Interp * Tcl_GetParent(interp) int Tcl_GetInterpPath(interp, childInterp) int Tcl_CreateAlias(childInterp, childCmd, targetInterp, targetCmd, argc, argv) int Tcl_CreateAliasObj(childInterp, childCmd, targetInterp, targetCmd, objc, objv) int Tcl_GetAlias(interp, childCmd, targetInterpPtr, targetCmdPtr, argcPtr, argvPtr) int Tcl_GetAliasObj(interp, childCmd, targetInterpPtr, targetCmdPtr, objcPtr, objvPtr) int Tcl_ExposeCommand(interp, hiddenCmdName, cmdName) int Tcl_HideCommand(interp, cmdName, hiddenCmdName) ARGUMENTS Interpreter in which to execute the specified command. Name of child interpreter to create or manipulate. If non-zero, a child that is suitable for running untrusted code is created, otherwise a trusted child is created. Interpreter to use for creating the source command for an alias (see below). Name of source command for alias. Interpreter that contains the target command for an alias. Name of target command for alias in targetInterp . Count of additional arguments to pass to the alias command. Vector of strings, the additional arguments to pass to the alias command. This storage is owned by the caller. Count of additional value arguments to pass to the aliased command. Vector of Tcl_Obj structures, the additional value arguments to pass to the aliased command. This storage is owned by the caller. Pointer to location to store the address of the interpreter where a target command is defined for an alias. Pointer to location to store the address of the name of the target command for an alias. Pointer to location to store count of additional arguments to be passed to the alias. The location is in storage owned by the caller. Pointer to location to store a vector of strings, the additional arguments to pass to an alias. The location is in storage owned by the caller, the vector of strings is owned by the called function. Pointer to location to store count of additional value arguments to be passed to the alias. The location is in storage owned by the caller. Pointer to location to store a vector of Tcl_Obj structures, the additional arguments to pass to an alias command. The location is in storage owned by the caller, the vector of Tcl_Obj structures is owned by the called function. Name of an exposed command to hide or create. Name under which a hidden command is stored and with which it can be exposed or invoked. DESCRIPTION These procedures are intended for access to the multiple interpreter facility from inside C programs. They enable managing multiple interpreters in a hierarchical relationship, and the management of aliases, commands that when invoked in one interpreter execute a command in another interpreter. The return value for those procedures that return an int is either TCL_OK or TCL_ERROR . If TCL_ERROR is returned then the interpreter\\'s result contains an error message. Tcl_CreateChild creates a new interpreter as a child of interp . It also creates a child command named name in interp which allows interp to manipulate the new child. If isSafe is zero, the command creates a trusted child in which Tcl code has access to all the Tcl commands. If it is 1 , the command creates a child in which Tcl code has access only to set of Tcl commands defined as see the manual entry for the Tcl interp command for details. If the creation of the new child interpreter failed, NULL is returned. Tcl_IsSafe returns 1 if interp is (was created with the TCL_SAFE_INTERPRETER flag specified), 0 otherwise. Tcl_GetChild returns a pointer to a child interpreter of interp . The child interpreter is identified by name . If no such child interpreter exists, NULL is returned. Tcl_GetParent returns a pointer to the parent interpreter of interp . If interp has no parent (it is a top-level interpreter) then NULL is returned. Tcl_GetInterpPath stores in the result of interp the relative path between interp and childInterp ; childInterp must be a child of interp . If the computation of the relative path succeeds, TCL_OK is returned, else TCL_ERROR is returned and an error message is stored as the result of interp . Tcl_CreateAlias creates a command named childCmd in childInterp that when invoked, will cause the command targetCmd to be invoked in targetInterp . The arguments specified by the strings contained in argv are always prepended to any arguments supplied in the invocation of childCmd and passed to targetCmd . This operation returns TCL_OK if it succeeds, or TCL_ERROR if it fails; in that case, an error message is left in the value result of childInterp . Note that there are no restrictions on the ancestry relationship (as created by Tcl_CreateChild ) between childInterp and targetInterp . Any two interpreters can be used, without any restrictions on how they are related. Tcl_CreateAliasObj is similar to Tcl_CreateAlias except that it takes a vector of values to pass as additional arguments instead of a vector of strings. Tcl_GetAlias returns information about an alias aliasName in interp . Any of the result fields can be NULL , in which case the corresponding datum is not returned. If a result field is non- NULL , the address indicated is set to the corresponding datum. For example, if targetNamePtr is non- NULL it is set to a pointer to the string containing the name of the target command. Tcl_GetAliasObj is similar to Tcl_GetAlias except that it returns a pointer to a vector of Tcl_Obj structures instead of a vector of strings. Tcl_ExposeCommand moves the command named hiddenCmdName from the set of hidden commands to the set of exposed commands, putting it under the name cmdName . HiddenCmdName must be the name of an existing hidden command, or the operation will return TCL_ERROR and leave an error message as the result of interp . If an exposed command named cmdName already exists, the operation returns TCL_ERROR and leaves an error message as the result of interp . If the operation succeeds, it returns TCL_OK . After executing this command, attempts to use cmdName in any script evaluation mechanism will again succeed. Tcl_HideCommand moves the command named cmdName from the set of exposed commands to the set of hidden commands, under the name hiddenCmdName . CmdName must be the name of an existing exposed command, or the operation will return TCL_ERROR and leave an error message as the result of interp . Currently both cmdName and hiddenCmdName must not contain namespace qualifiers, or the operation will return TCL_ERROR and leave an error message as the result of interp . The CmdName will be looked up in the global namespace, and not relative to the current namespace, even if the current namespace is not the global one. If a hidden command whose name is hiddenCmdName already exists, the operation also returns TCL_ERROR and an error message is left as the result of interp . If the operation succeeds, it returns TCL_OK . After executing this command, attempts to use cmdName in any script evaluation mechanism will fail. For a description of the Tcl interface to multiple interpreters, see interp(n) . REFERENCE COUNT MANAGEMENT Tcl_CreateAliasObj increments the reference counts of the values in its objv argument. (That reference lasts the same length of time as the owning alias.) Tcl_GetAliasObj returns (via its objvPtr argument) a pointer to values that it holds a reference to. SEE ALSO interp(n) KEYWORDS alias, command, exposed commands, hidden commands, interpreter, invoke, parent, child","title":"NAME"},{"location":"CrtAlias/#name","text":"Tcl_IsSafe, Tcl_CreateChild, Tcl_GetChild, Tcl_GetParent, Tcl_GetInterpPath, Tcl_CreateAlias, Tcl_CreateAliasObj, Tcl_GetAlias, Tcl_GetAliasObj, Tcl_ExposeCommand, Tcl_HideCommand - manage multiple Tcl interpreters, aliases and hidden commands","title":"NAME"},{"location":"CrtAlias/#synopsis","text":"#include <tcl.h> int Tcl_IsSafe(interp) Tcl_Interp * Tcl_CreateChild(interp, name, isSafe) Tcl_Interp * Tcl_GetChild(interp, name) Tcl_Interp * Tcl_GetParent(interp) int Tcl_GetInterpPath(interp, childInterp) int Tcl_CreateAlias(childInterp, childCmd, targetInterp, targetCmd, argc, argv) int Tcl_CreateAliasObj(childInterp, childCmd, targetInterp, targetCmd, objc, objv) int Tcl_GetAlias(interp, childCmd, targetInterpPtr, targetCmdPtr, argcPtr, argvPtr) int Tcl_GetAliasObj(interp, childCmd, targetInterpPtr, targetCmdPtr, objcPtr, objvPtr) int Tcl_ExposeCommand(interp, hiddenCmdName, cmdName) int Tcl_HideCommand(interp, cmdName, hiddenCmdName)","title":"SYNOPSIS"},{"location":"CrtAlias/#arguments","text":"Interpreter in which to execute the specified command. Name of child interpreter to create or manipulate. If non-zero, a child that is suitable for running untrusted code is created, otherwise a trusted child is created. Interpreter to use for creating the source command for an alias (see below). Name of source command for alias. Interpreter that contains the target command for an alias. Name of target command for alias in targetInterp . Count of additional arguments to pass to the alias command. Vector of strings, the additional arguments to pass to the alias command. This storage is owned by the caller. Count of additional value arguments to pass to the aliased command. Vector of Tcl_Obj structures, the additional value arguments to pass to the aliased command. This storage is owned by the caller. Pointer to location to store the address of the interpreter where a target command is defined for an alias. Pointer to location to store the address of the name of the target command for an alias. Pointer to location to store count of additional arguments to be passed to the alias. The location is in storage owned by the caller. Pointer to location to store a vector of strings, the additional arguments to pass to an alias. The location is in storage owned by the caller, the vector of strings is owned by the called function. Pointer to location to store count of additional value arguments to be passed to the alias. The location is in storage owned by the caller. Pointer to location to store a vector of Tcl_Obj structures, the additional arguments to pass to an alias command. The location is in storage owned by the caller, the vector of Tcl_Obj structures is owned by the called function. Name of an exposed command to hide or create. Name under which a hidden command is stored and with which it can be exposed or invoked.","title":"ARGUMENTS"},{"location":"CrtAlias/#description","text":"These procedures are intended for access to the multiple interpreter facility from inside C programs. They enable managing multiple interpreters in a hierarchical relationship, and the management of aliases, commands that when invoked in one interpreter execute a command in another interpreter. The return value for those procedures that return an int is either TCL_OK or TCL_ERROR . If TCL_ERROR is returned then the interpreter\\'s result contains an error message. Tcl_CreateChild creates a new interpreter as a child of interp . It also creates a child command named name in interp which allows interp to manipulate the new child. If isSafe is zero, the command creates a trusted child in which Tcl code has access to all the Tcl commands. If it is 1 , the command creates a child in which Tcl code has access only to set of Tcl commands defined as see the manual entry for the Tcl interp command for details. If the creation of the new child interpreter failed, NULL is returned. Tcl_IsSafe returns 1 if interp is (was created with the TCL_SAFE_INTERPRETER flag specified), 0 otherwise. Tcl_GetChild returns a pointer to a child interpreter of interp . The child interpreter is identified by name . If no such child interpreter exists, NULL is returned. Tcl_GetParent returns a pointer to the parent interpreter of interp . If interp has no parent (it is a top-level interpreter) then NULL is returned. Tcl_GetInterpPath stores in the result of interp the relative path between interp and childInterp ; childInterp must be a child of interp . If the computation of the relative path succeeds, TCL_OK is returned, else TCL_ERROR is returned and an error message is stored as the result of interp . Tcl_CreateAlias creates a command named childCmd in childInterp that when invoked, will cause the command targetCmd to be invoked in targetInterp . The arguments specified by the strings contained in argv are always prepended to any arguments supplied in the invocation of childCmd and passed to targetCmd . This operation returns TCL_OK if it succeeds, or TCL_ERROR if it fails; in that case, an error message is left in the value result of childInterp . Note that there are no restrictions on the ancestry relationship (as created by Tcl_CreateChild ) between childInterp and targetInterp . Any two interpreters can be used, without any restrictions on how they are related. Tcl_CreateAliasObj is similar to Tcl_CreateAlias except that it takes a vector of values to pass as additional arguments instead of a vector of strings. Tcl_GetAlias returns information about an alias aliasName in interp . Any of the result fields can be NULL , in which case the corresponding datum is not returned. If a result field is non- NULL , the address indicated is set to the corresponding datum. For example, if targetNamePtr is non- NULL it is set to a pointer to the string containing the name of the target command. Tcl_GetAliasObj is similar to Tcl_GetAlias except that it returns a pointer to a vector of Tcl_Obj structures instead of a vector of strings. Tcl_ExposeCommand moves the command named hiddenCmdName from the set of hidden commands to the set of exposed commands, putting it under the name cmdName . HiddenCmdName must be the name of an existing hidden command, or the operation will return TCL_ERROR and leave an error message as the result of interp . If an exposed command named cmdName already exists, the operation returns TCL_ERROR and leaves an error message as the result of interp . If the operation succeeds, it returns TCL_OK . After executing this command, attempts to use cmdName in any script evaluation mechanism will again succeed. Tcl_HideCommand moves the command named cmdName from the set of exposed commands to the set of hidden commands, under the name hiddenCmdName . CmdName must be the name of an existing exposed command, or the operation will return TCL_ERROR and leave an error message as the result of interp . Currently both cmdName and hiddenCmdName must not contain namespace qualifiers, or the operation will return TCL_ERROR and leave an error message as the result of interp . The CmdName will be looked up in the global namespace, and not relative to the current namespace, even if the current namespace is not the global one. If a hidden command whose name is hiddenCmdName already exists, the operation also returns TCL_ERROR and an error message is left as the result of interp . If the operation succeeds, it returns TCL_OK . After executing this command, attempts to use cmdName in any script evaluation mechanism will fail. For a description of the Tcl interface to multiple interpreters, see interp(n) .","title":"DESCRIPTION"},{"location":"CrtAlias/#reference-count-management","text":"Tcl_CreateAliasObj increments the reference counts of the values in its objv argument. (That reference lasts the same length of time as the owning alias.) Tcl_GetAliasObj returns (via its objvPtr argument) a pointer to values that it holds a reference to.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"CrtAlias/#see-also","text":"interp(n)","title":"SEE ALSO"},{"location":"CrtAlias/#keywords","text":"alias, command, exposed commands, hidden commands, interpreter, invoke, parent, child","title":"KEYWORDS"},{"location":"CrtChannel/","text":"NAME Tcl_CreateChannel, Tcl_GetChannelInstanceData, Tcl_GetChannelType, Tcl_GetChannelName, Tcl_GetChannelHandle, Tcl_GetChannelMode, Tcl_GetChannelBufferSize, Tcl_SetChannelBufferSize, Tcl_NotifyChannel, Tcl_BadChannelOption, Tcl_ChannelName, Tcl_ChannelVersion, Tcl_ChannelBlockModeProc, Tcl_ChannelClose2Proc, Tcl_ChannelInputProc, Tcl_ChannelOutputProc, Tcl_ChannelWideSeekProc, Tcl_ChannelTruncateProc, Tcl_ChannelSetOptionProc, Tcl_ChannelGetOptionProc, Tcl_ChannelWatchProc, Tcl_ChannelGetHandleProc, Tcl_ChannelFlushProc, Tcl_ChannelHandlerProc, Tcl_ChannelThreadActionProc, Tcl_IsChannelShared, Tcl_IsChannelRegistered, Tcl_CutChannel, Tcl_SpliceChannel, Tcl_IsChannelExisting, Tcl_ClearChannelHandlers, Tcl_GetChannelThread, Tcl_ChannelBuffered - procedures for creating and manipulating channels SYNOPSIS #include <tcl.h> Tcl_Channel Tcl_CreateChannel(typePtr, channelName, instanceData, mask) void * Tcl_GetChannelInstanceData(channel) const Tcl_ChannelType * Tcl_GetChannelType(channel) const char * Tcl_GetChannelName(channel) int Tcl_GetChannelHandle(channel, direction, handlePtr) Tcl_ThreadId Tcl_GetChannelThread(channel) int Tcl_GetChannelMode(channel) int Tcl_RemoveChannelMode(interp, channel, mode) int Tcl_GetChannelBufferSize(channel) Tcl_SetChannelBufferSize(channel, size) Tcl_NotifyChannel(channel, mask) int Tcl_BadChannelOption(interp, optionName, optionList) int Tcl_IsChannelShared(channel) int Tcl_IsChannelRegistered(interp, channel) int Tcl_IsChannelExisting(channelName) void Tcl_CutChannel(channel) void Tcl_SpliceChannel(channel) void Tcl_ClearChannelHandlers(channel) int Tcl_ChannelBuffered(channel) const char * Tcl_ChannelName(typePtr) Tcl_ChannelTypeVersion Tcl_ChannelVersion(typePtr) Tcl_DriverBlockModeProc * Tcl_ChannelBlockModeProc(typePtr) Tcl_DriverClose2Proc * Tcl_ChannelClose2Proc(typePtr) Tcl_DriverInputProc * Tcl_ChannelInputProc(typePtr) Tcl_DriverOutputProc * Tcl_ChannelOutputProc(typePtr) Tcl_DriverWideSeekProc * Tcl_ChannelWideSeekProc(typePtr) Tcl_DriverThreadActionProc * Tcl_ChannelThreadActionProc(typePtr) Tcl_DriverTruncateProc * Tcl_ChannelTruncateProc(typePtr) Tcl_DriverSetOptionProc * Tcl_ChannelSetOptionProc(typePtr) Tcl_DriverGetOptionProc * Tcl_ChannelGetOptionProc(typePtr) Tcl_DriverWatchProc * Tcl_ChannelWatchProc(typePtr) Tcl_DriverGetHandleProc * Tcl_ChannelGetHandleProc(typePtr) Tcl_DriverFlushProc * Tcl_ChannelFlushProc(typePtr) Tcl_DriverHandlerProc * Tcl_ChannelHandlerProc(typePtr) ARGUMENTS Points to a structure containing the addresses of procedures that can be called to perform I/O and other functions on the channel. The name of this channel, such as file3 ; must not be in use by any other channel. Can be NULL, in which case the channel is created without a name. If the created channel is assigned to one of the standard channels ( stdin , stdout or stderr ), the assigned channel name will be the name of the standard channel. Arbitrary one-word value to be associated with this channel. This value is passed to procedures in typePtr when they are invoked. OR-ed combination of TCL_READABLE and TCL_WRITABLE to indicate whether a channel is readable and writable. The channel to operate on. TCL_READABLE means the input handle is wanted; TCL_WRITABLE means the output handle is wanted. Points to the location where the desired OS-specific handle should be stored. The size, in bytes, of buffers to allocate in this channel. An OR-ed combination of TCL_READABLE , TCL_WRITABLE and TCL_EXCEPTION that indicates events that have occurred on this channel. Current interpreter. (can be NULL) Name of the invalid option. Specific options list (space separated words, without to append to the standard generic options list. Can be NULL for generic options error message only. DESCRIPTION Tcl uses a two-layered channel architecture. It provides a generic upper layer to enable C and Tcl programs to perform input and output using the same APIs for a variety of files, devices, sockets etc. The generic C APIs are described in the manual entry for Tcl_OpenFileChannel . The lower layer provides type-specific channel drivers for each type of device supported on each platform. This manual entry describes the C APIs used to communicate between the generic layer and the type-specific channel drivers. It also explains how new types of channels can be added by providing new channel drivers. Channel drivers consist of a number of components: First, each channel driver provides a Tcl_ChannelType structure containing pointers to functions implementing the various operations used by the generic layer to communicate with the channel driver. The Tcl_ChannelType structure and the functions referenced by it are described in the section TCL_CHANNELTYPE , below. Second, channel drivers usually provide a Tcl command to create instances of that type of channel. For example, the Tcl open command creates channels that use the file and command channel drivers, and the Tcl socket command creates channels that use TCP sockets for network communication. Third, a channel driver optionally provides a C function to open channel instances of that type. For example, Tcl_OpenFileChannel opens a channel that uses the file channel driver, and Tcl_OpenTcpClient opens a channel that uses the TCP network protocol. These creation functions typically use Tcl_CreateChannel internally to open the channel. To add a new type of channel you must implement a C API or a Tcl command that opens a channel by invoking Tcl_CreateChannel . When your driver calls Tcl_CreateChannel it passes in a Tcl_ChannelType structure describing the driver\\'s I/O procedures. The generic layer will then invoke the functions referenced in that structure to perform operations on the channel. Tcl_CreateChannel opens a new channel and associates the supplied typePtr and instanceData with it. The channel is opened in the mode indicated by mask . For a discussion of channel drivers, their operations and the Tcl_ChannelType structure, see the section TCL_CHANNELTYPE , below. Tcl_CreateChannel interacts with the code managing the standard channels. Once a standard channel was initialized either through a call to Tcl_GetStdChannel or a call to Tcl_SetStdChannel closing this standard channel will cause the next call to Tcl_CreateChannel to make the new channel the new standard channel too. See Tcl_StandardChannels for a general treatise about standard channels and the behavior of the Tcl library with regard to them. Tcl_GetChannelInstanceData returns the instance data associated with the channel in channel . This is the same as the instanceData argument in the call to Tcl_CreateChannel that created this channel. Tcl_GetChannelType returns a pointer to the Tcl_ChannelType structure used by the channel in the channel argument. This is the same as the typePtr argument in the call to Tcl_CreateChannel that created this channel. Tcl_GetChannelName returns a string containing the name associated with the channel, or NULL if the channelName argument to Tcl_CreateChannel was NULL. Tcl_GetChannelHandle places the OS-specific device handle associated with channel for the given direction in the location specified by handlePtr and returns TCL_OK . If the channel does not have a device handle for the specified direction, then TCL_ERROR is returned instead. Different channel drivers will return different types of handle. Refer to the manual entries for each driver to determine what type of handle is returned. Tcl_GetChannelThread returns the id of the thread currently managing the specified channel . This allows channel drivers to send their file events to the correct event queue even for a multi-threaded core. Tcl_GetChannelMode returns an OR-ed combination of TCL_READABLE and TCL_WRITABLE , indicating whether the channel is open for input and output. Tcl_RemoveChannelMode removes an access privilege from the channel, either TCL_READABLE or TCL_WRITABLE , and returns a regular Tcl result code, TCL_OK , or TCL_ERROR . The function throws an error if either an invalid mode is specified or the result of the removal would be an inaccessible channel. In that case an error message is left in the interp argument, if not NULL. Tcl_GetChannelBufferSize returns the size, in bytes, of buffers allocated to store input or output in channel . If the value was not set by a previous call to Tcl_SetChannelBufferSize , described below, then the default value of 4096 is returned. Tcl_SetChannelBufferSize sets the size, in bytes, of buffers that will be allocated in subsequent operations on the channel to store input or output. The size argument should be between one and one million, allowing buffers of one byte to one million bytes. If size is outside this range, Tcl_SetChannelBufferSize sets the buffer size to 4096. Tcl_NotifyChannel is called by a channel driver to indicate to the generic layer that the events specified by mask have occurred on the channel. Channel drivers are responsible for invoking this function whenever the channel handlers need to be called for the channel (or other pending tasks like a write flush should be performed). See WATCHPROC below for more details. Tcl_BadChannelOption is called from driver specific setOptionProc or getOptionProc to generate a complete error message. Tcl_ChannelBuffered returns the number of bytes of input currently buffered in the internal buffer (push back area) of the channel itself. It does not report about the data in the overall buffers for the stack of channels the supplied channel is part of. Tcl_IsChannelShared checks the refcount of the specified channel and returns whether the channel was shared among multiple interpreters (result == 1) or not (result == 0). Tcl_IsChannelRegistered checks whether the specified channel is registered in the given interp reter (result == 1) or not (result == 0). Tcl_IsChannelExisting checks whether a channel with the specified name is registered in the (thread)-global list of all channels (result == 1) or not (result == 0). Tcl_CutChannel removes the specified channel from the (thread)global list of all channels (of the current thread). Application to a channel still registered in some interpreter is not allowed. Also notifies the driver if Tcl_DriverThreadActionProc is defined for it. Tcl_SpliceChannel adds the specified channel to the (thread)global list of all channels (of the current thread). Application to a channel registered in some interpreter is not allowed. Also notifies the driver if Tcl_DriverThreadActionProc is defined for it. Tcl_ClearChannelHandlers removes all channel handlers and event scripts associated with the specified channel , thus shutting down all event processing for this channel. TCL_CHANNELTYPE A channel driver provides a Tcl_ChannelType structure that contains pointers to functions that implement the various operations on a channel; these operations are invoked as needed by the generic layer. The structure was versioned starting in Tcl 8.3.2/8.4 to correct a problem with stacked channel drivers. See the OLD CHANNEL TYPES section below for details about the old structure. The Tcl_ChannelType structure contains the following fields: typedef struct Tcl_ChannelType { const char * typeName ; Tcl_ChannelTypeVersion version ; void * closeProc ; /* Not used any more*/ Tcl_DriverInputProc * inputProc ; Tcl_DriverOutputProc * outputProc ; void * seekProc ; /* Not used any more */ Tcl_DriverSetOptionProc * setOptionProc ; Tcl_DriverGetOptionProc * getOptionProc ; Tcl_DriverWatchProc * watchProc ; Tcl_DriverGetHandleProc * getHandleProc ; Tcl_DriverClose2Proc * close2Proc ; Tcl_DriverBlockModeProc * blockModeProc ; Tcl_DriverFlushProc * flushProc ; Tcl_DriverHandlerProc * handlerProc ; Tcl_DriverWideSeekProc * wideSeekProc ; Tcl_DriverThreadActionProc * threadActionProc ; Tcl_DriverTruncateProc * truncateProc ; } Tcl_ChannelType ; It is not necessary to provide implementations for all channel operations. Those which are not necessary may be set to NULL in the struct: blockModeProc , seekProc , setOptionProc , getOptionProc , getHandleProc , and close2Proc , in addition to flushProc , handlerProc , threadActionProc , and truncateProc . Other functions that cannot be implemented in a meaningful way should return EINVAL when called, to indicate that the operations they represent are not available. Also note that wideSeekProc can be NULL if seekProc is. The user should only use the above structure for Tcl_ChannelType instantiation. When referencing fields in a Tcl_ChannelType structure, the following functions should be used to obtain the values: Tcl_ChannelName , Tcl_ChannelVersion , Tcl_ChannelBlockModeProc , Tcl_ChannelClose2Proc , Tcl_ChannelInputProc , Tcl_ChannelOutputProc , Tcl_ChannelWideSeekProc , Tcl_ChannelThreadActionProc , Tcl_ChannelTruncateProc , Tcl_ChannelSetOptionProc , Tcl_ChannelGetOptionProc , Tcl_ChannelWatchProc , Tcl_ChannelGetHandleProc , Tcl_ChannelFlushProc , or Tcl_ChannelHandlerProc . The change to the structures was made in such a way that standard channel types are binary compatible. However, channel types that use stacked channels (i.e. TLS, Trf) have new versions to correspond to the above change since the previous code for stacked channels had problems. TYPENAME The typeName field contains a null-terminated string that identifies the type of the device implemented by this driver, e.g. file or socket . This value can be retrieved with Tcl_ChannelName , which returns a pointer to the string. VERSION The version field should be set to the version of the structure that you require. TCL_CHANNEL_VERSION_5 is the minimum supported. This value can be retrieved with Tcl_ChannelVersion . BLOCKMODEPROC The blockModeProc field contains the address of a function called by the generic layer to set blocking and nonblocking mode on the device. BlockModeProc should match the following prototype: typedef int Tcl_DriverBlockModeProc ( void * instanceData , int mode ); The instanceData is the same as the value passed to Tcl_CreateChannel when this channel was created. The mode argument is either TCL_MODE_BLOCKING or TCL_MODE_NONBLOCKING to set the device into blocking or nonblocking mode. The function should return zero if the operation was successful, or a nonzero POSIX error code if the operation failed. If the operation is successful, the function can modify the supplied instanceData to record that the channel entered blocking or nonblocking mode and to implement the blocking or nonblocking behavior. For some device types, the blocking and nonblocking behavior can be implemented by the underlying operating system; for other device types, the behavior must be emulated in the channel driver. This value can be retrieved with Tcl_ChannelBlockModeProc , which returns a pointer to the function. A channel driver not supplying a blockModeProc has to be very, very careful. It has to tell the generic layer exactly which blocking mode is acceptable to it, and should this also document for the user so that the blocking mode of the channel is not changed to an unacceptable value. Any confusion here may lead the interpreter into a (spurious and difficult to find) deadlock. CLOSE2PROC The close2Proc field contains the address of a function called by the generic layer to clean up driver-related information when the channel is closed. Close2Proc must match the following prototype: typedef int Tcl_DriverClose2Proc ( void * instanceData , Tcl_Interp * interp , int flags ); If flags is 0, the instanceData argument is the same as the value provided to Tcl_CreateChannel when the channel was created. The function should release any storage maintained by the channel driver for this channel, and close the input and output devices encapsulated by this channel. All queued output will have been flushed to the device before this function is called, and no further driver operations will be invoked on this instance after calling the closeProc . If the close operation is successful, the procedure should return zero; otherwise it should return a nonzero POSIX error code. In addition, if an error occurs and interp is not NULL, the procedure should store an error message in the interpreter\\'s result. Alternatively, channels that support closing the read and write sides independently may accept other flag values than 0. Then close2Proc will be called with flags set to an OR\\'ed combination of TCL_CLOSE_READ or TCL_CLOSE_WRITE to indicate that the driver should close the read and/or write side of the channel. The channel driver may be invoked to perform additional operations on the channel after close2Proc is called to close one or both sides of the channel. In all cases, the close2Proc function should return zero if the close operation was successful; otherwise it should return a nonzero POSIX error code. In addition, if an error occurs and interp is not NULL, the procedure should store an error message in the interpreter\\'s result. The close2Proc value can be retrieved with Tcl_ChannelClose2Proc , which returns a pointer to the function. INPUTPROC The inputProc field contains the address of a function called by the generic layer to read data from the file or device and store it in an internal buffer. InputProc must match the following prototype: typedef int Tcl_DriverInputProc ( void * instanceData , char * buf , int bufSize , int * errorCodePtr ); InstanceData is the same as the value passed to Tcl_CreateChannel when the channel was created. The buf argument points to an array of bytes in which to store input from the device, and the bufSize argument indicates how many bytes are available at buf . The errorCodePtr argument points to an integer variable provided by the generic layer. If an error occurs, the function should set the variable to a POSIX error code that identifies the error that occurred. The function should read data from the input device encapsulated by the channel and store it at buf . On success, the function should return a nonnegative integer indicating how many bytes were read from the input device and stored at buf . On error, the function should return -1. If an error occurs after some data has been read from the device, that data is lost. If inputProc can determine that the input device has some data available but less than requested by the bufSize argument, the function should only attempt to read as much data as is available and return without blocking. If the input device has no data available whatsoever and the channel is in nonblocking mode, the function should return an EAGAIN error. If the input device has no data available whatsoever and the channel is in blocking mode, the function should block for the shortest possible time until at least one byte of data can be read from the device; then, it should return as much data as it can read without blocking. This value can be retrieved with Tcl_ChannelInputProc , which returns a pointer to the function. OUTPUTPROC The outputProc field contains the address of a function called by the generic layer to transfer data from an internal buffer to the output device. OutputProc must match the following prototype: typedef int Tcl_DriverOutputProc ( void * instanceData , const char * buf , int toWrite , int * errorCodePtr ); InstanceData is the same as the value passed to Tcl_CreateChannel when the channel was created. The buf argument contains an array of bytes to be written to the device, and the toWrite argument indicates how many bytes are to be written from the buf argument. The errorCodePtr argument points to an integer variable provided by the generic layer. If an error occurs, the function should set this variable to a POSIX error code that identifies the error. The function should write the data at buf to the output device encapsulated by the channel. On success, the function should return a nonnegative integer indicating how many bytes were written to the output device. The return value is normally the same as toWrite , but may be less in some cases such as if the output operation is interrupted by a signal. If an error occurs the function should return -1. In case of error, some data may have been written to the device. If the channel is nonblocking and the output device is unable to absorb any data whatsoever, the function should return -1 with an EAGAIN error without writing any data. This value can be retrieved with Tcl_ChannelOutputProc , which returns a pointer to the function. WIDESEEKPROC The wideSeekProc field contains the address of a function called by the generic layer to move the access point at which subsequent input or output operations will be applied. WideSeekProc must match the following prototype: typedef long long Tcl_DriverWideSeekProc ( void * instanceData , long long offset , int seekMode , int * errorCodePtr ); The instanceData argument is the same as the value given to Tcl_CreateChannel when this channel was created. Offset and seekMode have the same meaning as for the Tcl_Seek procedure (described in the manual entry for Tcl_OpenFileChannel ). The errorCodePtr argument points to an integer variable provided by the generic layer for returning errno values from the function. The function should set this variable to a POSIX error code if an error occurs. The function should store an EINVAL error code if the channel type does not implement seeking. The return value is the new access point or -1 in case of error. If an error occurred, the function should not move the access point. The wideSseekProc value can be retrieved with Tcl_ChannelWideSeekProc , which returns a pointer to the function. SETOPTIONPROC The setOptionProc field contains the address of a function called by the generic layer to set a channel type specific option on a channel. setOptionProc must match the following prototype: typedef int Tcl_DriverSetOptionProc ( void * instanceData , Tcl_Interp * interp , const char * optionName , const char * newValue ); optionName is the name of an option to set, and newValue is the new value for that option, as a string. The instanceData is the same as the value given to Tcl_CreateChannel when this channel was created. The function should do whatever channel type specific action is required to implement the new value of the option. Some options are handled by the generic code and this function is never called to set them, e.g. -blockmode . Other options are specific to each channel type and the setOptionProc procedure of the channel driver will get called to implement them. The setOptionProc field can be NULL, which indicates that this channel type supports no type specific options. If the option value is successfully modified to the new value, the function returns TCL_OK . It should call Tcl_BadChannelOption which itself returns TCL_ERROR if the optionName is unrecognized. If newValue specifies a value for the option that is not supported or if a system call error occurs, the function should leave an error message in the result of interp if interp is not NULL. The function should also call Tcl_SetErrno to store an appropriate POSIX error code. This value can be retrieved with Tcl_ChannelSetOptionProc , which returns a pointer to the function. GETOPTIONPROC The getOptionProc field contains the address of a function called by the generic layer to get the value of a channel type specific option on a channel. getOptionProc must match the following prototype: typedef int Tcl_DriverGetOptionProc ( void * instanceData , Tcl_Interp * interp , const char * optionName , Tcl_DString * optionValue ); OptionName is the name of an option supported by this type of channel. If the option name is not NULL, the function stores its current value, as a string, in the Tcl dynamic string optionValue . If optionName is NULL, the function stores in optionValue an alternating list of all supported options and their current values. On success, the function returns TCL_OK . It should call Tcl_BadChannelOption which itself returns TCL_ERROR if the optionName is unrecognized. If a system call error occurs, the function should leave an error message in the result of interp if interp is not NULL. The function should also call Tcl_SetErrno to store an appropriate POSIX error code. Some options are handled by the generic code and this function is never called to retrieve their value, e.g. -blockmode . Other options are specific to each channel type and the getOptionProc procedure of the channel driver will get called to implement them. The getOptionProc field can be NULL, which indicates that this channel type supports no type specific options. This value can be retrieved with Tcl_ChannelGetOptionProc , which returns a pointer to the function. WATCHPROC The watchProc field contains the address of a function called by the generic layer to initialize the event notification mechanism to notice events of interest on this channel. WatchProc should match the following prototype: typedef void Tcl_DriverWatchProc ( void * instanceData , int mask ); The instanceData is the same as the value passed to Tcl_CreateChannel when this channel was created. The mask argument is an OR-ed combination of TCL_READABLE , TCL_WRITABLE and TCL_EXCEPTION ; it indicates events the caller is interested in noticing on this channel. The function should initialize device type specific mechanisms to notice when an event of interest is present on the channel. When one or more of the designated events occurs on the channel, the channel driver is responsible for calling Tcl_NotifyChannel to inform the generic channel module. The driver should take care not to starve other channel drivers or sources of callbacks by invoking Tcl_NotifyChannel too frequently. Fairness can be insured by using the Tcl event queue to allow the channel event to be scheduled in sequence with other events. See the description of Tcl_QueueEvent for details on how to queue an event. This value can be retrieved with Tcl_ChannelWatchProc , which returns a pointer to the function. GETHANDLEPROC The getHandleProc field contains the address of a function called by the generic layer to retrieve a device-specific handle from the channel. GetHandleProc should match the following prototype: typedef int Tcl_DriverGetHandleProc ( void * instanceData , int direction , void ** handlePtr ); InstanceData is the same as the value passed to Tcl_CreateChannel when this channel was created. The direction argument is either TCL_READABLE to retrieve the handle used for input, or TCL_WRITABLE to retrieve the handle used for output. If the channel implementation has device-specific handles, the function should retrieve the appropriate handle associated with the channel, according the direction argument. The handle should be stored in the location referred to by handlePtr , and TCL_OK should be returned. If the channel is not open for the specified direction, or if the channel implementation does not use device handles, the function should return TCL_ERROR . This value can be retrieved with Tcl_ChannelGetHandleProc , which returns a pointer to the function. FLUSHPROC The flushProc field is currently reserved for future use. It should be set to NULL. FlushProc should match the following prototype: typedef int Tcl_DriverFlushProc ( void * instanceData ); This value can be retrieved with Tcl_ChannelFlushProc , which returns a pointer to the function. HANDLERPROC The handlerProc field contains the address of a function called by the generic layer to notify the channel that an event occurred. It should be defined for stacked channel drivers that wish to be notified of events that occur on the underlying (stacked) channel. HandlerProc should match the following prototype: typedef int Tcl_DriverHandlerProc ( void * instanceData , int interestMask ); InstanceData is the same as the value passed to Tcl_CreateChannel when this channel was created. The interestMask is an OR-ed combination of TCL_READABLE or TCL_WRITABLE ; it indicates what type of event occurred on this channel. This value can be retrieved with Tcl_ChannelHandlerProc , which returns a pointer to the function. THREADACTIONPROC The threadActionProc field contains the address of the function called by the generic layer when a channel is created, closed, or going to move to a different thread, i.e. whenever thread-specific driver state might have to initialized or updated. It can be NULL. The action TCL_CHANNEL_THREAD_REMOVE is used to notify the driver that it should update or remove any thread-specific data it might be maintaining for the channel. The action TCL_CHANNEL_THREAD_INSERT is used to notify the driver that it should update or initialize any thread-specific data it might be maintaining using the calling thread as the associate. See Tcl_CutChannel and Tcl_SpliceChannel for more detail. typedef void Tcl_DriverThreadActionProc ( void * instanceData , int action ); InstanceData is the same as the value passed to Tcl_CreateChannel when this channel was created. These values can be retrieved with Tcl_ChannelThreadActionProc , which returns a pointer to the function. TRUNCATEPROC The truncateProc field contains the address of the function called by the generic layer when a channel is truncated to some length. It can be NULL. typedef int Tcl_DriverTruncateProc ( void * instanceData , long long length ); InstanceData is the same as the value passed to Tcl_CreateChannel when this channel was created, and length is the new length of the underlying file, which should not be negative. The result should be 0 on success or an errno code (suitable for use with Tcl_SetErrno ) on failure. These values can be retrieved with Tcl_ChannelTruncateProc , which returns a pointer to the function. TCL_BADCHANNELOPTION This procedure generates a error message in an (optional) interpreter. It is used by channel drivers when an invalid Set/Get option is requested. Its purpose is to concatenate the generic options list to the specific ones and factorize the generic options error message string. It always returns TCL_ERROR An error message is generated in interp \\'s result value to indicate that a command was invoked with a bad option. The message has the form bad option \\\"blah\\\": should be one of \\<...generic options...>+\\<...specific options...> so you get for instance: bad option \\\"-blah\\\": should be one of -blocking, -buffering, -buffersize, -eofchar, -translation, -peername, or -sockname when called with optionList equal to is the optionName argument and is a space separated list of specific option words. The function takes good care of inserting minus signs before each option, commas after, and an before the last option. SEE ALSO Tcl_Close(3), Tcl_OpenFileChannel(3), Tcl_SetErrno(3), Tcl_QueueEvent(3), Tcl_StackChannel(3), Tcl_GetStdChannel(3) KEYWORDS blocking, channel driver, channel registration, channel type, nonblocking","title":"NAME"},{"location":"CrtChannel/#name","text":"Tcl_CreateChannel, Tcl_GetChannelInstanceData, Tcl_GetChannelType, Tcl_GetChannelName, Tcl_GetChannelHandle, Tcl_GetChannelMode, Tcl_GetChannelBufferSize, Tcl_SetChannelBufferSize, Tcl_NotifyChannel, Tcl_BadChannelOption, Tcl_ChannelName, Tcl_ChannelVersion, Tcl_ChannelBlockModeProc, Tcl_ChannelClose2Proc, Tcl_ChannelInputProc, Tcl_ChannelOutputProc, Tcl_ChannelWideSeekProc, Tcl_ChannelTruncateProc, Tcl_ChannelSetOptionProc, Tcl_ChannelGetOptionProc, Tcl_ChannelWatchProc, Tcl_ChannelGetHandleProc, Tcl_ChannelFlushProc, Tcl_ChannelHandlerProc, Tcl_ChannelThreadActionProc, Tcl_IsChannelShared, Tcl_IsChannelRegistered, Tcl_CutChannel, Tcl_SpliceChannel, Tcl_IsChannelExisting, Tcl_ClearChannelHandlers, Tcl_GetChannelThread, Tcl_ChannelBuffered - procedures for creating and manipulating channels","title":"NAME"},{"location":"CrtChannel/#synopsis","text":"#include <tcl.h> Tcl_Channel Tcl_CreateChannel(typePtr, channelName, instanceData, mask) void * Tcl_GetChannelInstanceData(channel) const Tcl_ChannelType * Tcl_GetChannelType(channel) const char * Tcl_GetChannelName(channel) int Tcl_GetChannelHandle(channel, direction, handlePtr) Tcl_ThreadId Tcl_GetChannelThread(channel) int Tcl_GetChannelMode(channel) int Tcl_RemoveChannelMode(interp, channel, mode) int Tcl_GetChannelBufferSize(channel) Tcl_SetChannelBufferSize(channel, size) Tcl_NotifyChannel(channel, mask) int Tcl_BadChannelOption(interp, optionName, optionList) int Tcl_IsChannelShared(channel) int Tcl_IsChannelRegistered(interp, channel) int Tcl_IsChannelExisting(channelName) void Tcl_CutChannel(channel) void Tcl_SpliceChannel(channel) void Tcl_ClearChannelHandlers(channel) int Tcl_ChannelBuffered(channel) const char * Tcl_ChannelName(typePtr) Tcl_ChannelTypeVersion Tcl_ChannelVersion(typePtr) Tcl_DriverBlockModeProc * Tcl_ChannelBlockModeProc(typePtr) Tcl_DriverClose2Proc * Tcl_ChannelClose2Proc(typePtr) Tcl_DriverInputProc * Tcl_ChannelInputProc(typePtr) Tcl_DriverOutputProc * Tcl_ChannelOutputProc(typePtr) Tcl_DriverWideSeekProc * Tcl_ChannelWideSeekProc(typePtr) Tcl_DriverThreadActionProc * Tcl_ChannelThreadActionProc(typePtr) Tcl_DriverTruncateProc * Tcl_ChannelTruncateProc(typePtr) Tcl_DriverSetOptionProc * Tcl_ChannelSetOptionProc(typePtr) Tcl_DriverGetOptionProc * Tcl_ChannelGetOptionProc(typePtr) Tcl_DriverWatchProc * Tcl_ChannelWatchProc(typePtr) Tcl_DriverGetHandleProc * Tcl_ChannelGetHandleProc(typePtr) Tcl_DriverFlushProc * Tcl_ChannelFlushProc(typePtr) Tcl_DriverHandlerProc * Tcl_ChannelHandlerProc(typePtr)","title":"SYNOPSIS"},{"location":"CrtChannel/#arguments","text":"Points to a structure containing the addresses of procedures that can be called to perform I/O and other functions on the channel. The name of this channel, such as file3 ; must not be in use by any other channel. Can be NULL, in which case the channel is created without a name. If the created channel is assigned to one of the standard channels ( stdin , stdout or stderr ), the assigned channel name will be the name of the standard channel. Arbitrary one-word value to be associated with this channel. This value is passed to procedures in typePtr when they are invoked. OR-ed combination of TCL_READABLE and TCL_WRITABLE to indicate whether a channel is readable and writable. The channel to operate on. TCL_READABLE means the input handle is wanted; TCL_WRITABLE means the output handle is wanted. Points to the location where the desired OS-specific handle should be stored. The size, in bytes, of buffers to allocate in this channel. An OR-ed combination of TCL_READABLE , TCL_WRITABLE and TCL_EXCEPTION that indicates events that have occurred on this channel. Current interpreter. (can be NULL) Name of the invalid option. Specific options list (space separated words, without to append to the standard generic options list. Can be NULL for generic options error message only.","title":"ARGUMENTS"},{"location":"CrtChannel/#description","text":"Tcl uses a two-layered channel architecture. It provides a generic upper layer to enable C and Tcl programs to perform input and output using the same APIs for a variety of files, devices, sockets etc. The generic C APIs are described in the manual entry for Tcl_OpenFileChannel . The lower layer provides type-specific channel drivers for each type of device supported on each platform. This manual entry describes the C APIs used to communicate between the generic layer and the type-specific channel drivers. It also explains how new types of channels can be added by providing new channel drivers. Channel drivers consist of a number of components: First, each channel driver provides a Tcl_ChannelType structure containing pointers to functions implementing the various operations used by the generic layer to communicate with the channel driver. The Tcl_ChannelType structure and the functions referenced by it are described in the section TCL_CHANNELTYPE , below. Second, channel drivers usually provide a Tcl command to create instances of that type of channel. For example, the Tcl open command creates channels that use the file and command channel drivers, and the Tcl socket command creates channels that use TCP sockets for network communication. Third, a channel driver optionally provides a C function to open channel instances of that type. For example, Tcl_OpenFileChannel opens a channel that uses the file channel driver, and Tcl_OpenTcpClient opens a channel that uses the TCP network protocol. These creation functions typically use Tcl_CreateChannel internally to open the channel. To add a new type of channel you must implement a C API or a Tcl command that opens a channel by invoking Tcl_CreateChannel . When your driver calls Tcl_CreateChannel it passes in a Tcl_ChannelType structure describing the driver\\'s I/O procedures. The generic layer will then invoke the functions referenced in that structure to perform operations on the channel. Tcl_CreateChannel opens a new channel and associates the supplied typePtr and instanceData with it. The channel is opened in the mode indicated by mask . For a discussion of channel drivers, their operations and the Tcl_ChannelType structure, see the section TCL_CHANNELTYPE , below. Tcl_CreateChannel interacts with the code managing the standard channels. Once a standard channel was initialized either through a call to Tcl_GetStdChannel or a call to Tcl_SetStdChannel closing this standard channel will cause the next call to Tcl_CreateChannel to make the new channel the new standard channel too. See Tcl_StandardChannels for a general treatise about standard channels and the behavior of the Tcl library with regard to them. Tcl_GetChannelInstanceData returns the instance data associated with the channel in channel . This is the same as the instanceData argument in the call to Tcl_CreateChannel that created this channel. Tcl_GetChannelType returns a pointer to the Tcl_ChannelType structure used by the channel in the channel argument. This is the same as the typePtr argument in the call to Tcl_CreateChannel that created this channel. Tcl_GetChannelName returns a string containing the name associated with the channel, or NULL if the channelName argument to Tcl_CreateChannel was NULL. Tcl_GetChannelHandle places the OS-specific device handle associated with channel for the given direction in the location specified by handlePtr and returns TCL_OK . If the channel does not have a device handle for the specified direction, then TCL_ERROR is returned instead. Different channel drivers will return different types of handle. Refer to the manual entries for each driver to determine what type of handle is returned. Tcl_GetChannelThread returns the id of the thread currently managing the specified channel . This allows channel drivers to send their file events to the correct event queue even for a multi-threaded core. Tcl_GetChannelMode returns an OR-ed combination of TCL_READABLE and TCL_WRITABLE , indicating whether the channel is open for input and output. Tcl_RemoveChannelMode removes an access privilege from the channel, either TCL_READABLE or TCL_WRITABLE , and returns a regular Tcl result code, TCL_OK , or TCL_ERROR . The function throws an error if either an invalid mode is specified or the result of the removal would be an inaccessible channel. In that case an error message is left in the interp argument, if not NULL. Tcl_GetChannelBufferSize returns the size, in bytes, of buffers allocated to store input or output in channel . If the value was not set by a previous call to Tcl_SetChannelBufferSize , described below, then the default value of 4096 is returned. Tcl_SetChannelBufferSize sets the size, in bytes, of buffers that will be allocated in subsequent operations on the channel to store input or output. The size argument should be between one and one million, allowing buffers of one byte to one million bytes. If size is outside this range, Tcl_SetChannelBufferSize sets the buffer size to 4096. Tcl_NotifyChannel is called by a channel driver to indicate to the generic layer that the events specified by mask have occurred on the channel. Channel drivers are responsible for invoking this function whenever the channel handlers need to be called for the channel (or other pending tasks like a write flush should be performed). See WATCHPROC below for more details. Tcl_BadChannelOption is called from driver specific setOptionProc or getOptionProc to generate a complete error message. Tcl_ChannelBuffered returns the number of bytes of input currently buffered in the internal buffer (push back area) of the channel itself. It does not report about the data in the overall buffers for the stack of channels the supplied channel is part of. Tcl_IsChannelShared checks the refcount of the specified channel and returns whether the channel was shared among multiple interpreters (result == 1) or not (result == 0). Tcl_IsChannelRegistered checks whether the specified channel is registered in the given interp reter (result == 1) or not (result == 0). Tcl_IsChannelExisting checks whether a channel with the specified name is registered in the (thread)-global list of all channels (result == 1) or not (result == 0). Tcl_CutChannel removes the specified channel from the (thread)global list of all channels (of the current thread). Application to a channel still registered in some interpreter is not allowed. Also notifies the driver if Tcl_DriverThreadActionProc is defined for it. Tcl_SpliceChannel adds the specified channel to the (thread)global list of all channels (of the current thread). Application to a channel registered in some interpreter is not allowed. Also notifies the driver if Tcl_DriverThreadActionProc is defined for it. Tcl_ClearChannelHandlers removes all channel handlers and event scripts associated with the specified channel , thus shutting down all event processing for this channel.","title":"DESCRIPTION"},{"location":"CrtChannel/#tcl_channeltype","text":"A channel driver provides a Tcl_ChannelType structure that contains pointers to functions that implement the various operations on a channel; these operations are invoked as needed by the generic layer. The structure was versioned starting in Tcl 8.3.2/8.4 to correct a problem with stacked channel drivers. See the OLD CHANNEL TYPES section below for details about the old structure. The Tcl_ChannelType structure contains the following fields: typedef struct Tcl_ChannelType { const char * typeName ; Tcl_ChannelTypeVersion version ; void * closeProc ; /* Not used any more*/ Tcl_DriverInputProc * inputProc ; Tcl_DriverOutputProc * outputProc ; void * seekProc ; /* Not used any more */ Tcl_DriverSetOptionProc * setOptionProc ; Tcl_DriverGetOptionProc * getOptionProc ; Tcl_DriverWatchProc * watchProc ; Tcl_DriverGetHandleProc * getHandleProc ; Tcl_DriverClose2Proc * close2Proc ; Tcl_DriverBlockModeProc * blockModeProc ; Tcl_DriverFlushProc * flushProc ; Tcl_DriverHandlerProc * handlerProc ; Tcl_DriverWideSeekProc * wideSeekProc ; Tcl_DriverThreadActionProc * threadActionProc ; Tcl_DriverTruncateProc * truncateProc ; } Tcl_ChannelType ; It is not necessary to provide implementations for all channel operations. Those which are not necessary may be set to NULL in the struct: blockModeProc , seekProc , setOptionProc , getOptionProc , getHandleProc , and close2Proc , in addition to flushProc , handlerProc , threadActionProc , and truncateProc . Other functions that cannot be implemented in a meaningful way should return EINVAL when called, to indicate that the operations they represent are not available. Also note that wideSeekProc can be NULL if seekProc is. The user should only use the above structure for Tcl_ChannelType instantiation. When referencing fields in a Tcl_ChannelType structure, the following functions should be used to obtain the values: Tcl_ChannelName , Tcl_ChannelVersion , Tcl_ChannelBlockModeProc , Tcl_ChannelClose2Proc , Tcl_ChannelInputProc , Tcl_ChannelOutputProc , Tcl_ChannelWideSeekProc , Tcl_ChannelThreadActionProc , Tcl_ChannelTruncateProc , Tcl_ChannelSetOptionProc , Tcl_ChannelGetOptionProc , Tcl_ChannelWatchProc , Tcl_ChannelGetHandleProc , Tcl_ChannelFlushProc , or Tcl_ChannelHandlerProc . The change to the structures was made in such a way that standard channel types are binary compatible. However, channel types that use stacked channels (i.e. TLS, Trf) have new versions to correspond to the above change since the previous code for stacked channels had problems.","title":"TCL_CHANNELTYPE"},{"location":"CrtChannel/#typename","text":"The typeName field contains a null-terminated string that identifies the type of the device implemented by this driver, e.g. file or socket . This value can be retrieved with Tcl_ChannelName , which returns a pointer to the string.","title":"TYPENAME"},{"location":"CrtChannel/#version","text":"The version field should be set to the version of the structure that you require. TCL_CHANNEL_VERSION_5 is the minimum supported. This value can be retrieved with Tcl_ChannelVersion .","title":"VERSION"},{"location":"CrtChannel/#blockmodeproc","text":"The blockModeProc field contains the address of a function called by the generic layer to set blocking and nonblocking mode on the device. BlockModeProc should match the following prototype: typedef int Tcl_DriverBlockModeProc ( void * instanceData , int mode ); The instanceData is the same as the value passed to Tcl_CreateChannel when this channel was created. The mode argument is either TCL_MODE_BLOCKING or TCL_MODE_NONBLOCKING to set the device into blocking or nonblocking mode. The function should return zero if the operation was successful, or a nonzero POSIX error code if the operation failed. If the operation is successful, the function can modify the supplied instanceData to record that the channel entered blocking or nonblocking mode and to implement the blocking or nonblocking behavior. For some device types, the blocking and nonblocking behavior can be implemented by the underlying operating system; for other device types, the behavior must be emulated in the channel driver. This value can be retrieved with Tcl_ChannelBlockModeProc , which returns a pointer to the function. A channel driver not supplying a blockModeProc has to be very, very careful. It has to tell the generic layer exactly which blocking mode is acceptable to it, and should this also document for the user so that the blocking mode of the channel is not changed to an unacceptable value. Any confusion here may lead the interpreter into a (spurious and difficult to find) deadlock.","title":"BLOCKMODEPROC"},{"location":"CrtChannel/#close2proc","text":"The close2Proc field contains the address of a function called by the generic layer to clean up driver-related information when the channel is closed. Close2Proc must match the following prototype: typedef int Tcl_DriverClose2Proc ( void * instanceData , Tcl_Interp * interp , int flags ); If flags is 0, the instanceData argument is the same as the value provided to Tcl_CreateChannel when the channel was created. The function should release any storage maintained by the channel driver for this channel, and close the input and output devices encapsulated by this channel. All queued output will have been flushed to the device before this function is called, and no further driver operations will be invoked on this instance after calling the closeProc . If the close operation is successful, the procedure should return zero; otherwise it should return a nonzero POSIX error code. In addition, if an error occurs and interp is not NULL, the procedure should store an error message in the interpreter\\'s result. Alternatively, channels that support closing the read and write sides independently may accept other flag values than 0. Then close2Proc will be called with flags set to an OR\\'ed combination of TCL_CLOSE_READ or TCL_CLOSE_WRITE to indicate that the driver should close the read and/or write side of the channel. The channel driver may be invoked to perform additional operations on the channel after close2Proc is called to close one or both sides of the channel. In all cases, the close2Proc function should return zero if the close operation was successful; otherwise it should return a nonzero POSIX error code. In addition, if an error occurs and interp is not NULL, the procedure should store an error message in the interpreter\\'s result. The close2Proc value can be retrieved with Tcl_ChannelClose2Proc , which returns a pointer to the function.","title":"CLOSE2PROC"},{"location":"CrtChannel/#inputproc","text":"The inputProc field contains the address of a function called by the generic layer to read data from the file or device and store it in an internal buffer. InputProc must match the following prototype: typedef int Tcl_DriverInputProc ( void * instanceData , char * buf , int bufSize , int * errorCodePtr ); InstanceData is the same as the value passed to Tcl_CreateChannel when the channel was created. The buf argument points to an array of bytes in which to store input from the device, and the bufSize argument indicates how many bytes are available at buf . The errorCodePtr argument points to an integer variable provided by the generic layer. If an error occurs, the function should set the variable to a POSIX error code that identifies the error that occurred. The function should read data from the input device encapsulated by the channel and store it at buf . On success, the function should return a nonnegative integer indicating how many bytes were read from the input device and stored at buf . On error, the function should return -1. If an error occurs after some data has been read from the device, that data is lost. If inputProc can determine that the input device has some data available but less than requested by the bufSize argument, the function should only attempt to read as much data as is available and return without blocking. If the input device has no data available whatsoever and the channel is in nonblocking mode, the function should return an EAGAIN error. If the input device has no data available whatsoever and the channel is in blocking mode, the function should block for the shortest possible time until at least one byte of data can be read from the device; then, it should return as much data as it can read without blocking. This value can be retrieved with Tcl_ChannelInputProc , which returns a pointer to the function.","title":"INPUTPROC"},{"location":"CrtChannel/#outputproc","text":"The outputProc field contains the address of a function called by the generic layer to transfer data from an internal buffer to the output device. OutputProc must match the following prototype: typedef int Tcl_DriverOutputProc ( void * instanceData , const char * buf , int toWrite , int * errorCodePtr ); InstanceData is the same as the value passed to Tcl_CreateChannel when the channel was created. The buf argument contains an array of bytes to be written to the device, and the toWrite argument indicates how many bytes are to be written from the buf argument. The errorCodePtr argument points to an integer variable provided by the generic layer. If an error occurs, the function should set this variable to a POSIX error code that identifies the error. The function should write the data at buf to the output device encapsulated by the channel. On success, the function should return a nonnegative integer indicating how many bytes were written to the output device. The return value is normally the same as toWrite , but may be less in some cases such as if the output operation is interrupted by a signal. If an error occurs the function should return -1. In case of error, some data may have been written to the device. If the channel is nonblocking and the output device is unable to absorb any data whatsoever, the function should return -1 with an EAGAIN error without writing any data. This value can be retrieved with Tcl_ChannelOutputProc , which returns a pointer to the function.","title":"OUTPUTPROC"},{"location":"CrtChannel/#wideseekproc","text":"The wideSeekProc field contains the address of a function called by the generic layer to move the access point at which subsequent input or output operations will be applied. WideSeekProc must match the following prototype: typedef long long Tcl_DriverWideSeekProc ( void * instanceData , long long offset , int seekMode , int * errorCodePtr ); The instanceData argument is the same as the value given to Tcl_CreateChannel when this channel was created. Offset and seekMode have the same meaning as for the Tcl_Seek procedure (described in the manual entry for Tcl_OpenFileChannel ). The errorCodePtr argument points to an integer variable provided by the generic layer for returning errno values from the function. The function should set this variable to a POSIX error code if an error occurs. The function should store an EINVAL error code if the channel type does not implement seeking. The return value is the new access point or -1 in case of error. If an error occurred, the function should not move the access point. The wideSseekProc value can be retrieved with Tcl_ChannelWideSeekProc , which returns a pointer to the function.","title":"WIDESEEKPROC"},{"location":"CrtChannel/#setoptionproc","text":"The setOptionProc field contains the address of a function called by the generic layer to set a channel type specific option on a channel. setOptionProc must match the following prototype: typedef int Tcl_DriverSetOptionProc ( void * instanceData , Tcl_Interp * interp , const char * optionName , const char * newValue ); optionName is the name of an option to set, and newValue is the new value for that option, as a string. The instanceData is the same as the value given to Tcl_CreateChannel when this channel was created. The function should do whatever channel type specific action is required to implement the new value of the option. Some options are handled by the generic code and this function is never called to set them, e.g. -blockmode . Other options are specific to each channel type and the setOptionProc procedure of the channel driver will get called to implement them. The setOptionProc field can be NULL, which indicates that this channel type supports no type specific options. If the option value is successfully modified to the new value, the function returns TCL_OK . It should call Tcl_BadChannelOption which itself returns TCL_ERROR if the optionName is unrecognized. If newValue specifies a value for the option that is not supported or if a system call error occurs, the function should leave an error message in the result of interp if interp is not NULL. The function should also call Tcl_SetErrno to store an appropriate POSIX error code. This value can be retrieved with Tcl_ChannelSetOptionProc , which returns a pointer to the function.","title":"SETOPTIONPROC"},{"location":"CrtChannel/#getoptionproc","text":"The getOptionProc field contains the address of a function called by the generic layer to get the value of a channel type specific option on a channel. getOptionProc must match the following prototype: typedef int Tcl_DriverGetOptionProc ( void * instanceData , Tcl_Interp * interp , const char * optionName , Tcl_DString * optionValue ); OptionName is the name of an option supported by this type of channel. If the option name is not NULL, the function stores its current value, as a string, in the Tcl dynamic string optionValue . If optionName is NULL, the function stores in optionValue an alternating list of all supported options and their current values. On success, the function returns TCL_OK . It should call Tcl_BadChannelOption which itself returns TCL_ERROR if the optionName is unrecognized. If a system call error occurs, the function should leave an error message in the result of interp if interp is not NULL. The function should also call Tcl_SetErrno to store an appropriate POSIX error code. Some options are handled by the generic code and this function is never called to retrieve their value, e.g. -blockmode . Other options are specific to each channel type and the getOptionProc procedure of the channel driver will get called to implement them. The getOptionProc field can be NULL, which indicates that this channel type supports no type specific options. This value can be retrieved with Tcl_ChannelGetOptionProc , which returns a pointer to the function.","title":"GETOPTIONPROC"},{"location":"CrtChannel/#watchproc","text":"The watchProc field contains the address of a function called by the generic layer to initialize the event notification mechanism to notice events of interest on this channel. WatchProc should match the following prototype: typedef void Tcl_DriverWatchProc ( void * instanceData , int mask ); The instanceData is the same as the value passed to Tcl_CreateChannel when this channel was created. The mask argument is an OR-ed combination of TCL_READABLE , TCL_WRITABLE and TCL_EXCEPTION ; it indicates events the caller is interested in noticing on this channel. The function should initialize device type specific mechanisms to notice when an event of interest is present on the channel. When one or more of the designated events occurs on the channel, the channel driver is responsible for calling Tcl_NotifyChannel to inform the generic channel module. The driver should take care not to starve other channel drivers or sources of callbacks by invoking Tcl_NotifyChannel too frequently. Fairness can be insured by using the Tcl event queue to allow the channel event to be scheduled in sequence with other events. See the description of Tcl_QueueEvent for details on how to queue an event. This value can be retrieved with Tcl_ChannelWatchProc , which returns a pointer to the function.","title":"WATCHPROC"},{"location":"CrtChannel/#gethandleproc","text":"The getHandleProc field contains the address of a function called by the generic layer to retrieve a device-specific handle from the channel. GetHandleProc should match the following prototype: typedef int Tcl_DriverGetHandleProc ( void * instanceData , int direction , void ** handlePtr ); InstanceData is the same as the value passed to Tcl_CreateChannel when this channel was created. The direction argument is either TCL_READABLE to retrieve the handle used for input, or TCL_WRITABLE to retrieve the handle used for output. If the channel implementation has device-specific handles, the function should retrieve the appropriate handle associated with the channel, according the direction argument. The handle should be stored in the location referred to by handlePtr , and TCL_OK should be returned. If the channel is not open for the specified direction, or if the channel implementation does not use device handles, the function should return TCL_ERROR . This value can be retrieved with Tcl_ChannelGetHandleProc , which returns a pointer to the function.","title":"GETHANDLEPROC"},{"location":"CrtChannel/#flushproc","text":"The flushProc field is currently reserved for future use. It should be set to NULL. FlushProc should match the following prototype: typedef int Tcl_DriverFlushProc ( void * instanceData ); This value can be retrieved with Tcl_ChannelFlushProc , which returns a pointer to the function.","title":"FLUSHPROC"},{"location":"CrtChannel/#handlerproc","text":"The handlerProc field contains the address of a function called by the generic layer to notify the channel that an event occurred. It should be defined for stacked channel drivers that wish to be notified of events that occur on the underlying (stacked) channel. HandlerProc should match the following prototype: typedef int Tcl_DriverHandlerProc ( void * instanceData , int interestMask ); InstanceData is the same as the value passed to Tcl_CreateChannel when this channel was created. The interestMask is an OR-ed combination of TCL_READABLE or TCL_WRITABLE ; it indicates what type of event occurred on this channel. This value can be retrieved with Tcl_ChannelHandlerProc , which returns a pointer to the function.","title":"HANDLERPROC"},{"location":"CrtChannel/#threadactionproc","text":"The threadActionProc field contains the address of the function called by the generic layer when a channel is created, closed, or going to move to a different thread, i.e. whenever thread-specific driver state might have to initialized or updated. It can be NULL. The action TCL_CHANNEL_THREAD_REMOVE is used to notify the driver that it should update or remove any thread-specific data it might be maintaining for the channel. The action TCL_CHANNEL_THREAD_INSERT is used to notify the driver that it should update or initialize any thread-specific data it might be maintaining using the calling thread as the associate. See Tcl_CutChannel and Tcl_SpliceChannel for more detail. typedef void Tcl_DriverThreadActionProc ( void * instanceData , int action ); InstanceData is the same as the value passed to Tcl_CreateChannel when this channel was created. These values can be retrieved with Tcl_ChannelThreadActionProc , which returns a pointer to the function.","title":"THREADACTIONPROC"},{"location":"CrtChannel/#truncateproc","text":"The truncateProc field contains the address of the function called by the generic layer when a channel is truncated to some length. It can be NULL. typedef int Tcl_DriverTruncateProc ( void * instanceData , long long length ); InstanceData is the same as the value passed to Tcl_CreateChannel when this channel was created, and length is the new length of the underlying file, which should not be negative. The result should be 0 on success or an errno code (suitable for use with Tcl_SetErrno ) on failure. These values can be retrieved with Tcl_ChannelTruncateProc , which returns a pointer to the function.","title":"TRUNCATEPROC"},{"location":"CrtChannel/#tcl_badchanneloption","text":"This procedure generates a error message in an (optional) interpreter. It is used by channel drivers when an invalid Set/Get option is requested. Its purpose is to concatenate the generic options list to the specific ones and factorize the generic options error message string. It always returns TCL_ERROR An error message is generated in interp \\'s result value to indicate that a command was invoked with a bad option. The message has the form bad option \\\"blah\\\": should be one of \\<...generic options...>+\\<...specific options...> so you get for instance: bad option \\\"-blah\\\": should be one of -blocking, -buffering, -buffersize, -eofchar, -translation, -peername, or -sockname when called with optionList equal to is the optionName argument and is a space separated list of specific option words. The function takes good care of inserting minus signs before each option, commas after, and an before the last option.","title":"TCL_BADCHANNELOPTION"},{"location":"CrtChannel/#see-also","text":"Tcl_Close(3), Tcl_OpenFileChannel(3), Tcl_SetErrno(3), Tcl_QueueEvent(3), Tcl_StackChannel(3), Tcl_GetStdChannel(3)","title":"SEE ALSO"},{"location":"CrtChannel/#keywords","text":"blocking, channel driver, channel registration, channel type, nonblocking","title":"KEYWORDS"},{"location":"CrtChnlHdlr/","text":"NAME Tcl_CreateChannelHandler, Tcl_DeleteChannelHandler - call a procedure when a channel becomes readable or writable SYNOPSIS #include <tcl.h> void Tcl_CreateChannelHandler(channel, mask, proc, clientData) void Tcl_DeleteChannelHandler(channel, proc, clientData) ARGUMENTS Tcl channel such as returned by Tcl_CreateChannel . Conditions under which proc should be called: OR-ed combination of TCL_READABLE , TCL_WRITABLE and TCL_EXCEPTION . Specify a zero value to temporarily disable an existing handler. Procedure to invoke whenever the channel indicated by channel meets the conditions specified by mask . Arbitrary one-word value to pass to proc . DESCRIPTION Tcl_CreateChannelHandler arranges for proc to be called in the future whenever input or output becomes possible on the channel identified by channel , or whenever an exceptional condition exists for channel . The conditions of interest under which proc will be invoked are specified by the mask argument. See the manual entry for fileevent for a precise description of what it means for a channel to be readable or writable. Proc must conform to the following prototype: typedef void Tcl_ChannelProc ( void * clientData , int mask ); The clientData argument is the same as the value passed to Tcl_CreateChannelHandler when the handler was created. Typically, clientData points to a data structure containing application-specific information about the channel. Mask is an integer mask indicating which of the requested conditions actually exists for the channel; it will contain a subset of the bits from the mask argument to Tcl_CreateChannelHandler when the handler was created. Each channel handler is identified by a unique combination of channel , proc and clientData . There may be many handlers for a given channel as long as they do not have the same channel , proc , and clientData . If Tcl_CreateChannelHandler is invoked when there is already a handler for channel , proc , and clientData , then no new handler is created; instead, the mask is changed for the existing handler. Tcl_DeleteChannelHandler deletes a channel handler identified by channel , proc and clientData ; if no such handler exists, the call has no effect. Channel handlers are invoked via the Tcl event mechanism, so they are only useful in applications that are event-driven. Note also that the conditions specified in the mask argument to proc may no longer exist when proc is invoked: for example, if there are two handlers for TCL_READABLE on the same channel, the first handler could consume all of the available input so that the channel is no longer readable when the second handler is invoked. For this reason it may be useful to use nonblocking I/O on channels for which there are event handlers. SEE ALSO Notifier(3), Tcl_CreateChannel(3), Tcl_OpenFileChannel(3), vwait(n). KEYWORDS blocking, callback, channel, events, handler, nonblocking.","title":"NAME"},{"location":"CrtChnlHdlr/#name","text":"Tcl_CreateChannelHandler, Tcl_DeleteChannelHandler - call a procedure when a channel becomes readable or writable","title":"NAME"},{"location":"CrtChnlHdlr/#synopsis","text":"#include <tcl.h> void Tcl_CreateChannelHandler(channel, mask, proc, clientData) void Tcl_DeleteChannelHandler(channel, proc, clientData)","title":"SYNOPSIS"},{"location":"CrtChnlHdlr/#arguments","text":"Tcl channel such as returned by Tcl_CreateChannel . Conditions under which proc should be called: OR-ed combination of TCL_READABLE , TCL_WRITABLE and TCL_EXCEPTION . Specify a zero value to temporarily disable an existing handler. Procedure to invoke whenever the channel indicated by channel meets the conditions specified by mask . Arbitrary one-word value to pass to proc .","title":"ARGUMENTS"},{"location":"CrtChnlHdlr/#description","text":"Tcl_CreateChannelHandler arranges for proc to be called in the future whenever input or output becomes possible on the channel identified by channel , or whenever an exceptional condition exists for channel . The conditions of interest under which proc will be invoked are specified by the mask argument. See the manual entry for fileevent for a precise description of what it means for a channel to be readable or writable. Proc must conform to the following prototype: typedef void Tcl_ChannelProc ( void * clientData , int mask ); The clientData argument is the same as the value passed to Tcl_CreateChannelHandler when the handler was created. Typically, clientData points to a data structure containing application-specific information about the channel. Mask is an integer mask indicating which of the requested conditions actually exists for the channel; it will contain a subset of the bits from the mask argument to Tcl_CreateChannelHandler when the handler was created. Each channel handler is identified by a unique combination of channel , proc and clientData . There may be many handlers for a given channel as long as they do not have the same channel , proc , and clientData . If Tcl_CreateChannelHandler is invoked when there is already a handler for channel , proc , and clientData , then no new handler is created; instead, the mask is changed for the existing handler. Tcl_DeleteChannelHandler deletes a channel handler identified by channel , proc and clientData ; if no such handler exists, the call has no effect. Channel handlers are invoked via the Tcl event mechanism, so they are only useful in applications that are event-driven. Note also that the conditions specified in the mask argument to proc may no longer exist when proc is invoked: for example, if there are two handlers for TCL_READABLE on the same channel, the first handler could consume all of the available input so that the channel is no longer readable when the second handler is invoked. For this reason it may be useful to use nonblocking I/O on channels for which there are event handlers.","title":"DESCRIPTION"},{"location":"CrtChnlHdlr/#see-also","text":"Notifier(3), Tcl_CreateChannel(3), Tcl_OpenFileChannel(3), vwait(n).","title":"SEE ALSO"},{"location":"CrtChnlHdlr/#keywords","text":"blocking, callback, channel, events, handler, nonblocking.","title":"KEYWORDS"},{"location":"CrtCloseHdlr/","text":"NAME Tcl_CreateCloseHandler, Tcl_DeleteCloseHandler - arrange for callbacks when channels are closed SYNOPSIS #include <tcl.h> void Tcl_CreateCloseHandler(channel, proc, clientData) void Tcl_DeleteCloseHandler(channel, proc, clientData) ARGUMENTS The channel for which to create or delete a close callback. The procedure to call as the callback. Arbitrary one-word value to pass to proc . DESCRIPTION Tcl_CreateCloseHandler arranges for proc to be called when channel is closed with Tcl_Close or Tcl_UnregisterChannel , or using the Tcl close command. Proc should match the following prototype: typedef void Tcl_CloseProc ( void * clientData ); The clientData is the same as the value provided in the call to Tcl_CreateCloseHandler . Tcl_DeleteCloseHandler removes a close callback for channel . The proc and clientData identify which close callback to remove; Tcl_DeleteCloseHandler does nothing if its proc and clientData arguments do not match the proc and clientData for a close handler for channel . SEE ALSO close(n), Tcl_Close(3), Tcl_UnregisterChannel(3) KEYWORDS callback, channel closing","title":"NAME"},{"location":"CrtCloseHdlr/#name","text":"Tcl_CreateCloseHandler, Tcl_DeleteCloseHandler - arrange for callbacks when channels are closed","title":"NAME"},{"location":"CrtCloseHdlr/#synopsis","text":"#include <tcl.h> void Tcl_CreateCloseHandler(channel, proc, clientData) void Tcl_DeleteCloseHandler(channel, proc, clientData)","title":"SYNOPSIS"},{"location":"CrtCloseHdlr/#arguments","text":"The channel for which to create or delete a close callback. The procedure to call as the callback. Arbitrary one-word value to pass to proc .","title":"ARGUMENTS"},{"location":"CrtCloseHdlr/#description","text":"Tcl_CreateCloseHandler arranges for proc to be called when channel is closed with Tcl_Close or Tcl_UnregisterChannel , or using the Tcl close command. Proc should match the following prototype: typedef void Tcl_CloseProc ( void * clientData ); The clientData is the same as the value provided in the call to Tcl_CreateCloseHandler . Tcl_DeleteCloseHandler removes a close callback for channel . The proc and clientData identify which close callback to remove; Tcl_DeleteCloseHandler does nothing if its proc and clientData arguments do not match the proc and clientData for a close handler for channel .","title":"DESCRIPTION"},{"location":"CrtCloseHdlr/#see-also","text":"close(n), Tcl_Close(3), Tcl_UnregisterChannel(3)","title":"SEE ALSO"},{"location":"CrtCloseHdlr/#keywords","text":"callback, channel closing","title":"KEYWORDS"},{"location":"CrtCommand/","text":"NAME Tcl_CreateCommand - implement new commands in C SYNOPSIS #include <tcl.h> Tcl_Command Tcl_CreateCommand(interp, cmdName, proc, clientData, deleteProc) ARGUMENTS Interpreter in which to create new command. Name of command. Implementation of new command: proc will be called whenever cmdName is invoked as a command. Arbitrary one-word value to pass to proc and deleteProc . Procedure to call before cmdName is deleted from the interpreter; allows for command-specific cleanup. If NULL, then no procedure is called before the command is deleted. DESCRIPTION Tcl_CreateCommand defines a new command in interp and associates it with procedure proc such that whenever cmdName is invoked as a Tcl command (via a call to Tcl_Eval ) the Tcl interpreter will call proc to process the command. It differs from Tcl_CreateObjCommand in that a new string-based command is defined; that is, a command procedure is defined that takes an array of argument strings instead of values. The value-based command procedures registered by Tcl_CreateObjCommand can execute significantly faster than the string-based command procedures defined by Tcl_CreateCommand . This is because they take Tcl values as arguments and those values can retain an internal representation that can be manipulated more efficiently. Also, Tcl\\'s interpreter now uses values internally. In order to invoke a string-based command procedure registered by Tcl_CreateCommand , it must generate and fetch a string representation from each argument value before the call. New commands should be defined using Tcl_CreateObjCommand . We support Tcl_CreateCommand for backwards compatibility. The procedures Tcl_DeleteCommand , Tcl_GetCommandInfo , and Tcl_SetCommandInfo are used in conjunction with Tcl_CreateCommand . Tcl_CreateCommand will delete an existing command cmdName , if one is already associated with the interpreter. It returns a token that may be used to refer to the command in subsequent calls to Tcl_GetCommandName . If cmdName contains any :: namespace qualifiers, then the command is added to the specified namespace; otherwise the command is added to the global namespace. If Tcl_CreateCommand is called for an interpreter that is in the process of being deleted, then it does not create a new command and it returns NULL. Proc should have arguments and result that match the type Tcl_CmdProc : typedef int Tcl_CmdProc ( void * clientData , Tcl_Interp * interp , int argc , const char * argv []); When proc is invoked the clientData and interp parameters will be copies of the clientData and interp arguments given to Tcl_CreateCommand . Typically, clientData points to an application-specific data structure that describes what to do when the command procedure is invoked. Argc and argv describe the arguments to the command, argc giving the number of arguments (including the command name) and argv giving the values of the arguments as strings. The argv array will contain argc +1 values; the first argc values point to the argument strings, and the last value is NULL. Note that the argument strings should not be modified as they may point to constant strings or may be shared with other parts of the interpreter. Note that the argument strings are encoded in normalized UTF-8 since version 8.1 of Tcl. Proc must return an integer code that is expected to be one of TCL_OK , TCL_ERROR , TCL_RETURN , TCL_BREAK , or TCL_CONTINUE . See the Tcl overview man page for details on what these codes mean. Most normal commands will only return TCL_OK or TCL_ERROR . In addition, proc must set the interpreter result; in the case of a TCL_OK return code this gives the result of the command, and in the case of TCL_ERROR it gives an error message. The Tcl_SetResult procedure provides an easy interface for setting the return value; for complete details on how the interpreter result field is managed, see the Tcl_Interp man page. Before invoking a command procedure, Tcl_Eval sets the interpreter result to point to an empty string, so simple commands can return an empty result by doing nothing at all. The contents of the argv array belong to Tcl and are not guaranteed to persist once proc returns: proc should not modify them, nor should it set the interpreter result to point anywhere within the argv values. Call Tcl_SetResult with status TCL_VOLATILE if you want to return something from the argv array. DeleteProc will be invoked when (if) cmdName is deleted. This can occur through a call to Tcl_DeleteCommand or Tcl_DeleteInterp , or by replacing cmdName in another call to Tcl_CreateCommand . DeleteProc is invoked before the command is deleted, and gives the application an opportunity to release any structures associated with the command. DeleteProc should have arguments and result that match the type Tcl_CmdDeleteProc : typedef void Tcl_CmdDeleteProc ( void * clientData ); The clientData argument will be the same as the clientData argument passed to Tcl_CreateCommand . SEE ALSO Tcl_CreateObjCommand, Tcl_DeleteCommand, Tcl_GetCommandInfo, Tcl_SetCommandInfo, Tcl_GetCommandName, Tcl_SetObjResult KEYWORDS bind, command, create, delete, interpreter, namespace","title":"NAME"},{"location":"CrtCommand/#name","text":"Tcl_CreateCommand - implement new commands in C","title":"NAME"},{"location":"CrtCommand/#synopsis","text":"#include <tcl.h> Tcl_Command Tcl_CreateCommand(interp, cmdName, proc, clientData, deleteProc)","title":"SYNOPSIS"},{"location":"CrtCommand/#arguments","text":"Interpreter in which to create new command. Name of command. Implementation of new command: proc will be called whenever cmdName is invoked as a command. Arbitrary one-word value to pass to proc and deleteProc . Procedure to call before cmdName is deleted from the interpreter; allows for command-specific cleanup. If NULL, then no procedure is called before the command is deleted.","title":"ARGUMENTS"},{"location":"CrtCommand/#description","text":"Tcl_CreateCommand defines a new command in interp and associates it with procedure proc such that whenever cmdName is invoked as a Tcl command (via a call to Tcl_Eval ) the Tcl interpreter will call proc to process the command. It differs from Tcl_CreateObjCommand in that a new string-based command is defined; that is, a command procedure is defined that takes an array of argument strings instead of values. The value-based command procedures registered by Tcl_CreateObjCommand can execute significantly faster than the string-based command procedures defined by Tcl_CreateCommand . This is because they take Tcl values as arguments and those values can retain an internal representation that can be manipulated more efficiently. Also, Tcl\\'s interpreter now uses values internally. In order to invoke a string-based command procedure registered by Tcl_CreateCommand , it must generate and fetch a string representation from each argument value before the call. New commands should be defined using Tcl_CreateObjCommand . We support Tcl_CreateCommand for backwards compatibility. The procedures Tcl_DeleteCommand , Tcl_GetCommandInfo , and Tcl_SetCommandInfo are used in conjunction with Tcl_CreateCommand . Tcl_CreateCommand will delete an existing command cmdName , if one is already associated with the interpreter. It returns a token that may be used to refer to the command in subsequent calls to Tcl_GetCommandName . If cmdName contains any :: namespace qualifiers, then the command is added to the specified namespace; otherwise the command is added to the global namespace. If Tcl_CreateCommand is called for an interpreter that is in the process of being deleted, then it does not create a new command and it returns NULL. Proc should have arguments and result that match the type Tcl_CmdProc : typedef int Tcl_CmdProc ( void * clientData , Tcl_Interp * interp , int argc , const char * argv []); When proc is invoked the clientData and interp parameters will be copies of the clientData and interp arguments given to Tcl_CreateCommand . Typically, clientData points to an application-specific data structure that describes what to do when the command procedure is invoked. Argc and argv describe the arguments to the command, argc giving the number of arguments (including the command name) and argv giving the values of the arguments as strings. The argv array will contain argc +1 values; the first argc values point to the argument strings, and the last value is NULL. Note that the argument strings should not be modified as they may point to constant strings or may be shared with other parts of the interpreter. Note that the argument strings are encoded in normalized UTF-8 since version 8.1 of Tcl. Proc must return an integer code that is expected to be one of TCL_OK , TCL_ERROR , TCL_RETURN , TCL_BREAK , or TCL_CONTINUE . See the Tcl overview man page for details on what these codes mean. Most normal commands will only return TCL_OK or TCL_ERROR . In addition, proc must set the interpreter result; in the case of a TCL_OK return code this gives the result of the command, and in the case of TCL_ERROR it gives an error message. The Tcl_SetResult procedure provides an easy interface for setting the return value; for complete details on how the interpreter result field is managed, see the Tcl_Interp man page. Before invoking a command procedure, Tcl_Eval sets the interpreter result to point to an empty string, so simple commands can return an empty result by doing nothing at all. The contents of the argv array belong to Tcl and are not guaranteed to persist once proc returns: proc should not modify them, nor should it set the interpreter result to point anywhere within the argv values. Call Tcl_SetResult with status TCL_VOLATILE if you want to return something from the argv array. DeleteProc will be invoked when (if) cmdName is deleted. This can occur through a call to Tcl_DeleteCommand or Tcl_DeleteInterp , or by replacing cmdName in another call to Tcl_CreateCommand . DeleteProc is invoked before the command is deleted, and gives the application an opportunity to release any structures associated with the command. DeleteProc should have arguments and result that match the type Tcl_CmdDeleteProc : typedef void Tcl_CmdDeleteProc ( void * clientData ); The clientData argument will be the same as the clientData argument passed to Tcl_CreateCommand .","title":"DESCRIPTION"},{"location":"CrtCommand/#see-also","text":"Tcl_CreateObjCommand, Tcl_DeleteCommand, Tcl_GetCommandInfo, Tcl_SetCommandInfo, Tcl_GetCommandName, Tcl_SetObjResult","title":"SEE ALSO"},{"location":"CrtCommand/#keywords","text":"bind, command, create, delete, interpreter, namespace","title":"KEYWORDS"},{"location":"CrtFileHdlr/","text":"NAME Tcl_CreateFileHandler, Tcl_DeleteFileHandler - associate procedure callbacks with files or devices (Unix only) SYNOPSIS #include <tcl.h> Tcl_CreateFileHandler(fd, mask, proc, clientData) Tcl_DeleteFileHandler(fd) ARGUMENTS Unix file descriptor for an open file or device. Conditions under which proc should be called: OR-ed combination of TCL_READABLE , TCL_WRITABLE , and TCL_EXCEPTION . May be set to 0 to temporarily disable a handler. Procedure to invoke whenever the file or device indicated by file meets the conditions specified by mask . Arbitrary one-word value to pass to proc . DESCRIPTION Tcl_CreateFileHandler arranges for proc to be invoked in the future whenever I/O becomes possible on a file or an exceptional condition exists for the file. The file is indicated by fd , and the conditions of interest are indicated by mask . For example, if mask is TCL_READABLE , proc will be called when the file is readable. The callback to proc is made by Tcl_DoOneEvent , so Tcl_CreateFileHandler is only useful in programs that dispatch events through Tcl_DoOneEvent or through Tcl commands such as vwait . Proc should have arguments and result that match the type Tcl_FileProc : typedef void Tcl_FileProc ( void * clientData , int mask ); The clientData parameter to proc is a copy of the clientData argument given to Tcl_CreateFileHandler when the callback was created. Typically, clientData points to a data structure containing application-specific information about the file. Mask is an integer mask indicating which of the requested conditions actually exists for the file; it will contain a subset of the bits in the mask argument to Tcl_CreateFileHandler . There may exist only one handler for a given file at a given time. If Tcl_CreateFileHandler is called when a handler already exists for fd , then the new callback replaces the information that was previously recorded. Tcl_DeleteFileHandler may be called to delete the file handler for fd ; if no handler exists for the file given by fd then the procedure has no effect. The purpose of file handlers is to enable an application to respond to events while waiting for files to become ready for I/O. For this to work correctly, the application may need to use non-blocking I/O operations on the files for which handlers are declared. Otherwise the application may block if it reads or writes too much data; while waiting for the I/O to complete the application will not be able to service other events. Use Tcl_SetChannelOption with -blocking to set the channel into blocking or nonblocking mode as required. Note that these interfaces are only supported by the Unix implementation of the Tcl notifier. SEE ALSO fileevent(n), Tcl_CreateTimerHandler(3), Tcl_DoWhenIdle(3) KEYWORDS callback, file, handler","title":"NAME"},{"location":"CrtFileHdlr/#name","text":"Tcl_CreateFileHandler, Tcl_DeleteFileHandler - associate procedure callbacks with files or devices (Unix only)","title":"NAME"},{"location":"CrtFileHdlr/#synopsis","text":"#include <tcl.h> Tcl_CreateFileHandler(fd, mask, proc, clientData) Tcl_DeleteFileHandler(fd)","title":"SYNOPSIS"},{"location":"CrtFileHdlr/#arguments","text":"Unix file descriptor for an open file or device. Conditions under which proc should be called: OR-ed combination of TCL_READABLE , TCL_WRITABLE , and TCL_EXCEPTION . May be set to 0 to temporarily disable a handler. Procedure to invoke whenever the file or device indicated by file meets the conditions specified by mask . Arbitrary one-word value to pass to proc .","title":"ARGUMENTS"},{"location":"CrtFileHdlr/#description","text":"Tcl_CreateFileHandler arranges for proc to be invoked in the future whenever I/O becomes possible on a file or an exceptional condition exists for the file. The file is indicated by fd , and the conditions of interest are indicated by mask . For example, if mask is TCL_READABLE , proc will be called when the file is readable. The callback to proc is made by Tcl_DoOneEvent , so Tcl_CreateFileHandler is only useful in programs that dispatch events through Tcl_DoOneEvent or through Tcl commands such as vwait . Proc should have arguments and result that match the type Tcl_FileProc : typedef void Tcl_FileProc ( void * clientData , int mask ); The clientData parameter to proc is a copy of the clientData argument given to Tcl_CreateFileHandler when the callback was created. Typically, clientData points to a data structure containing application-specific information about the file. Mask is an integer mask indicating which of the requested conditions actually exists for the file; it will contain a subset of the bits in the mask argument to Tcl_CreateFileHandler . There may exist only one handler for a given file at a given time. If Tcl_CreateFileHandler is called when a handler already exists for fd , then the new callback replaces the information that was previously recorded. Tcl_DeleteFileHandler may be called to delete the file handler for fd ; if no handler exists for the file given by fd then the procedure has no effect. The purpose of file handlers is to enable an application to respond to events while waiting for files to become ready for I/O. For this to work correctly, the application may need to use non-blocking I/O operations on the files for which handlers are declared. Otherwise the application may block if it reads or writes too much data; while waiting for the I/O to complete the application will not be able to service other events. Use Tcl_SetChannelOption with -blocking to set the channel into blocking or nonblocking mode as required. Note that these interfaces are only supported by the Unix implementation of the Tcl notifier.","title":"DESCRIPTION"},{"location":"CrtFileHdlr/#see-also","text":"fileevent(n), Tcl_CreateTimerHandler(3), Tcl_DoWhenIdle(3)","title":"SEE ALSO"},{"location":"CrtFileHdlr/#keywords","text":"callback, file, handler","title":"KEYWORDS"},{"location":"CrtInterp/","text":"NAME Tcl_CreateInterp, Tcl_DeleteInterp, Tcl_InterpActive, Tcl_InterpDeleted - create and delete Tcl command interpreters SYNOPSIS #include <tcl.h> Tcl_Interp * Tcl_CreateInterp() Tcl_DeleteInterp(interp) int Tcl_InterpDeleted(interp) int Tcl_InterpActive(interp) ARGUMENTS Token for interpreter to be destroyed or queried. DESCRIPTION Tcl_CreateInterp creates a new interpreter structure and returns a token for it. The token is required in calls to most other Tcl procedures, such as Tcl_CreateCommand , Tcl_Eval , and Tcl_DeleteInterp . The token returned by Tcl_CreateInterp may only be passed to Tcl routines called from the same thread as the original Tcl_CreateInterp call. It is not safe for multiple threads to pass the same token to Tcl\\'s routines. The new interpreter is initialized with the built-in Tcl commands and with standard variables like tcl_platform and env . To bind in additional commands, call Tcl_CreateCommand , and to create additional variables, call Tcl_SetVar . Tcl_DeleteInterp marks an interpreter as deleted; the interpreter will eventually be deleted when all calls to Tcl_Preserve for it have been matched by calls to Tcl_Release . At that time, all of the resources associated with it, including variables, procedures, and application-specific command bindings, will be deleted. After Tcl_DeleteInterp returns any attempt to use Tcl_Eval on the interpreter will fail and return TCL_ERROR . After the call to Tcl_DeleteInterp it is safe to examine the interpreter\\'s result, query or set the values of variables, define, undefine or retrieve procedures, and examine the runtime evaluation stack. See below, in the section INTERPRETERS AND MEMORY MANAGEMENT for details. Tcl_InterpDeleted returns nonzero if Tcl_DeleteInterp was called with interp as its argument; this indicates that the interpreter will eventually be deleted, when the last call to Tcl_Preserve for it is matched by a call to Tcl_Release . If nonzero is returned, further calls to Tcl_Eval in this interpreter will return TCL_ERROR . Tcl_InterpDeleted is useful in deletion callbacks to distinguish between when only the memory the callback is responsible for is being deleted and when the whole interpreter is being deleted. In the former case the callback may recreate the data being deleted, but this would lead to an infinite loop if the interpreter were being deleted. Tcl_InterpActive is useful for determining whether there is any execution of scripts ongoing in an interpreter, which is a useful piece of information when Tcl is embedded in a garbage-collected environment and it becomes necessary to determine whether the interpreter is a candidate for deletion. The function returns a true value if the interpreter has at least one active execution running inside it, and a false value otherwise. INTERPRETERS AND MEMORY MANAGEMENT Tcl_DeleteInterp can be called at any time on an interpreter that may be used by nested evaluations and C code in various extensions. Tcl implements a simple mechanism that allows callers to use interpreters without worrying about the interpreter being deleted in a nested call, and without requiring special code to protect the interpreter, in most cases. This mechanism ensures that nested uses of an interpreter can safely continue using it even after Tcl_DeleteInterp is called. The mechanism relies on matching up calls to Tcl_Preserve with calls to Tcl_Release . If Tcl_DeleteInterp has been called, only when the last call to Tcl_Preserve is matched by a call to Tcl_Release , will the interpreter be freed. See the manual entry for Tcl_Preserve for a description of these functions. The rules for when the user of an interpreter must call Tcl_Preserve and Tcl_Release are simple: Interpreters Passed As Arguments : Functions that are passed an interpreter as an argument can safely use the interpreter without any special protection. Thus, when you write an extension consisting of new Tcl commands, no special code is needed to protect interpreters received as arguments. This covers the majority of all uses. Interpreter Creation And Deletion : When a new interpreter is created and used in a call to Tcl_Eval , Tcl_VarEval , Tcl_GlobalEval , Tcl_SetVar , or Tcl_GetVar , a pair of calls to Tcl_Preserve and Tcl_Release should be wrapped around all uses of the interpreter. Remember that it is unsafe to use the interpreter once Tcl_Release has been called. To ensure that the interpreter is properly deleted when it is no longer needed, call Tcl_InterpDeleted to test if some other code already called Tcl_DeleteInterp ; if not, call Tcl_DeleteInterp before calling Tcl_Release in your own code. Retrieving An Interpreter From A Data Structure : When an interpreter is retrieved from a data structure (e.g. the client data of a callback) for use in one of the evaluation functions ( Tcl_Eval , Tcl_VarEval , Tcl_GlobalEval , Tcl_EvalObjv , etc.) or variable access functions ( Tcl_SetVar , Tcl_GetVar , Tcl_SetVar2Ex , etc.), a pair of calls to Tcl_Preserve and Tcl_Release should be wrapped around all uses of the interpreter; it is unsafe to reuse the interpreter once Tcl_Release has been called. If an interpreter is stored inside a callback data structure, an appropriate deletion cleanup mechanism should be set up by the code that creates the data structure so that the interpreter is removed from the data structure (e.g. by setting the field to NULL) when the interpreter is deleted. Otherwise, you may be using an interpreter that has been freed and whose memory may already have been reused. All uses of interpreters in Tcl and Tk have already been protected. Extension writers should ensure that their code also properly protects any additional interpreters used, as described above. Note that the protection mechanisms do not work well with conventional garbage collection systems. When in such a managed environment, Tcl_InterpActive should be used to determine when an interpreter is a candidate for deletion due to inactivity. SEE ALSO Tcl_Preserve(3), Tcl_Release(3) KEYWORDS command, create, delete, interpreter","title":"NAME"},{"location":"CrtInterp/#name","text":"Tcl_CreateInterp, Tcl_DeleteInterp, Tcl_InterpActive, Tcl_InterpDeleted - create and delete Tcl command interpreters","title":"NAME"},{"location":"CrtInterp/#synopsis","text":"#include <tcl.h> Tcl_Interp * Tcl_CreateInterp() Tcl_DeleteInterp(interp) int Tcl_InterpDeleted(interp) int Tcl_InterpActive(interp)","title":"SYNOPSIS"},{"location":"CrtInterp/#arguments","text":"Token for interpreter to be destroyed or queried.","title":"ARGUMENTS"},{"location":"CrtInterp/#description","text":"Tcl_CreateInterp creates a new interpreter structure and returns a token for it. The token is required in calls to most other Tcl procedures, such as Tcl_CreateCommand , Tcl_Eval , and Tcl_DeleteInterp . The token returned by Tcl_CreateInterp may only be passed to Tcl routines called from the same thread as the original Tcl_CreateInterp call. It is not safe for multiple threads to pass the same token to Tcl\\'s routines. The new interpreter is initialized with the built-in Tcl commands and with standard variables like tcl_platform and env . To bind in additional commands, call Tcl_CreateCommand , and to create additional variables, call Tcl_SetVar . Tcl_DeleteInterp marks an interpreter as deleted; the interpreter will eventually be deleted when all calls to Tcl_Preserve for it have been matched by calls to Tcl_Release . At that time, all of the resources associated with it, including variables, procedures, and application-specific command bindings, will be deleted. After Tcl_DeleteInterp returns any attempt to use Tcl_Eval on the interpreter will fail and return TCL_ERROR . After the call to Tcl_DeleteInterp it is safe to examine the interpreter\\'s result, query or set the values of variables, define, undefine or retrieve procedures, and examine the runtime evaluation stack. See below, in the section INTERPRETERS AND MEMORY MANAGEMENT for details. Tcl_InterpDeleted returns nonzero if Tcl_DeleteInterp was called with interp as its argument; this indicates that the interpreter will eventually be deleted, when the last call to Tcl_Preserve for it is matched by a call to Tcl_Release . If nonzero is returned, further calls to Tcl_Eval in this interpreter will return TCL_ERROR . Tcl_InterpDeleted is useful in deletion callbacks to distinguish between when only the memory the callback is responsible for is being deleted and when the whole interpreter is being deleted. In the former case the callback may recreate the data being deleted, but this would lead to an infinite loop if the interpreter were being deleted. Tcl_InterpActive is useful for determining whether there is any execution of scripts ongoing in an interpreter, which is a useful piece of information when Tcl is embedded in a garbage-collected environment and it becomes necessary to determine whether the interpreter is a candidate for deletion. The function returns a true value if the interpreter has at least one active execution running inside it, and a false value otherwise.","title":"DESCRIPTION"},{"location":"CrtInterp/#interpreters-and-memory-management","text":"Tcl_DeleteInterp can be called at any time on an interpreter that may be used by nested evaluations and C code in various extensions. Tcl implements a simple mechanism that allows callers to use interpreters without worrying about the interpreter being deleted in a nested call, and without requiring special code to protect the interpreter, in most cases. This mechanism ensures that nested uses of an interpreter can safely continue using it even after Tcl_DeleteInterp is called. The mechanism relies on matching up calls to Tcl_Preserve with calls to Tcl_Release . If Tcl_DeleteInterp has been called, only when the last call to Tcl_Preserve is matched by a call to Tcl_Release , will the interpreter be freed. See the manual entry for Tcl_Preserve for a description of these functions. The rules for when the user of an interpreter must call Tcl_Preserve and Tcl_Release are simple: Interpreters Passed As Arguments : Functions that are passed an interpreter as an argument can safely use the interpreter without any special protection. Thus, when you write an extension consisting of new Tcl commands, no special code is needed to protect interpreters received as arguments. This covers the majority of all uses. Interpreter Creation And Deletion : When a new interpreter is created and used in a call to Tcl_Eval , Tcl_VarEval , Tcl_GlobalEval , Tcl_SetVar , or Tcl_GetVar , a pair of calls to Tcl_Preserve and Tcl_Release should be wrapped around all uses of the interpreter. Remember that it is unsafe to use the interpreter once Tcl_Release has been called. To ensure that the interpreter is properly deleted when it is no longer needed, call Tcl_InterpDeleted to test if some other code already called Tcl_DeleteInterp ; if not, call Tcl_DeleteInterp before calling Tcl_Release in your own code. Retrieving An Interpreter From A Data Structure : When an interpreter is retrieved from a data structure (e.g. the client data of a callback) for use in one of the evaluation functions ( Tcl_Eval , Tcl_VarEval , Tcl_GlobalEval , Tcl_EvalObjv , etc.) or variable access functions ( Tcl_SetVar , Tcl_GetVar , Tcl_SetVar2Ex , etc.), a pair of calls to Tcl_Preserve and Tcl_Release should be wrapped around all uses of the interpreter; it is unsafe to reuse the interpreter once Tcl_Release has been called. If an interpreter is stored inside a callback data structure, an appropriate deletion cleanup mechanism should be set up by the code that creates the data structure so that the interpreter is removed from the data structure (e.g. by setting the field to NULL) when the interpreter is deleted. Otherwise, you may be using an interpreter that has been freed and whose memory may already have been reused. All uses of interpreters in Tcl and Tk have already been protected. Extension writers should ensure that their code also properly protects any additional interpreters used, as described above. Note that the protection mechanisms do not work well with conventional garbage collection systems. When in such a managed environment, Tcl_InterpActive should be used to determine when an interpreter is a candidate for deletion due to inactivity.","title":"INTERPRETERS AND MEMORY MANAGEMENT"},{"location":"CrtInterp/#see-also","text":"Tcl_Preserve(3), Tcl_Release(3)","title":"SEE ALSO"},{"location":"CrtInterp/#keywords","text":"command, create, delete, interpreter","title":"KEYWORDS"},{"location":"CrtObjCmd/","text":"NAME Tcl_CreateObjCommand, Tcl_CreateObjCommand2, Tcl_DeleteCommand, Tcl_DeleteCommandFromToken, Tcl_GetCommandInfo, Tcl_GetCommandInfoFromToken, Tcl_SetCommandInfo, Tcl_SetCommandInfoFromToken, Tcl_GetCommandName, Tcl_GetCommandFullName, Tcl_GetCommandFromObj - implement new commands in C SYNOPSIS #include <tcl.h> Tcl_Command Tcl_CreateObjCommand(interp, cmdName, proc, clientData, deleteProc) Tcl_Command Tcl_CreateObjCommand2(interp, cmdName, proc2, clientData, deleteProc) int Tcl_DeleteCommand(interp, cmdName) int Tcl_DeleteCommandFromToken(interp, token) int Tcl_GetCommandInfo(interp, cmdName, infoPtr) int Tcl_SetCommandInfo(interp, cmdName, infoPtr) int Tcl_GetCommandInfoFromToken(token, infoPtr) int Tcl_SetCommandInfoFromToken(token, infoPtr) const char * Tcl_GetCommandName(interp, token) void Tcl_GetCommandFullName(interp, token, objPtr) Tcl_Command Tcl_GetCommandFromObj(interp, objPtr) ARGUMENTS Interpreter in which to create a new command or that contains a command. Name of command. Implementation of the new command: proc will be called whenever cmdName is invoked as a command. Implementation of the new command: proc2 will be called whenever cmdName is invoked as a command. Arbitrary one-word value to pass to proc and deleteProc . Procedure to call before cmdName is deleted from the interpreter; allows for command-specific cleanup. If NULL, then no procedure is called before the command is deleted. Token for command, returned by previous call to Tcl_CreateObjCommand . The command must not have been deleted. Pointer to structure containing various information about a Tcl command. Value containing the name of a Tcl command. Indicates the name of the type of command implementation associated with a particular proc , or NULL to break the association. DESCRIPTION Tcl_CreateObjCommand defines a new command in interp and associates it with procedure proc such that whenever name is invoked as a Tcl command (e.g., via a call to Tcl_EvalObjEx ) the Tcl interpreter will call proc to process the command. Tcl_CreateObjCommand deletes any existing command name already associated with the interpreter (however see below for an exception where the existing command is not deleted). It returns a token that may be used to refer to the command in subsequent calls to Tcl_GetCommandName . If name contains any :: namespace qualifiers, then the command is added to the specified namespace; otherwise the command is added to the global namespace. If Tcl_CreateObjCommand is called for an interpreter that is in the process of being deleted, then it does not create a new command and it returns NULL. proc should have arguments and result that match the type Tcl_ObjCmdProc : typedef int Tcl_ObjCmdProc ( void * clientData , Tcl_Interp * interp , int objc , Tcl_Obj *const objv []); When proc is invoked, the clientData and interp parameters will be copies of the clientData and interp arguments given to Tcl_CreateObjCommand . Typically, clientData points to an application-specific data structure that describes what to do when the command procedure is invoked. Objc and objv describe the arguments to the command, objc giving the number of argument values (including the command name) and objv giving the values of the arguments. The objv array will contain objc values, pointing to the argument values. Unlike argv [ argv ] used in a string-based command procedure, objv [ objc ] will not contain NULL. Additionally, when proc is invoked, it must not modify the contents of the objv array by assigning new pointer values to any element of the array (for example, objv [ 2 ] = NULL ) because this will cause memory to be lost and the runtime stack to be corrupted. The const in the declaration of objv will cause ANSI-compliant compilers to report any such attempted assignment as an error. However, it is acceptable to modify the internal representation of any individual value argument. For instance, the user may call Tcl_GetIntFromObj on objv [ 2 ] to obtain the integer representation of that value; that call may change the type of the value that objv [ 2 ] points at, but will not change where objv [ 2 ] points. proc must return an integer code that is either TCL_OK , TCL_ERROR , TCL_RETURN , TCL_BREAK , or TCL_CONTINUE . See the Tcl overview man page for details on what these codes mean. Most normal commands will only return TCL_OK or TCL_ERROR . In addition, if proc needs to return a non-empty result, it can call Tcl_SetObjResult to set the interpreter\\'s result. In the case of a TCL_OK return code this gives the result of the command, and in the case of TCL_ERROR this gives an error message. Before invoking a command procedure, Tcl_EvalObjEx sets interpreter\\'s result to point to a value representing an empty string, so simple commands can return an empty result by doing nothing at all. The contents of the objv array belong to Tcl and are not guaranteed to persist once proc returns: proc should not modify them. Call Tcl_SetObjResult if you want to return something from the objv array. Ordinarily, Tcl_CreateObjCommand deletes any existing command name already associated with the interpreter. However, if the existing command was created by a previous call to Tcl_CreateCommand , Tcl_CreateObjCommand does not delete the command but instead arranges for the Tcl interpreter to call the Tcl_ObjCmdProc proc in the future. The old string-based Tcl_CmdProc associated with the command is retained and its address can be obtained by subsequent Tcl_GetCommandInfo calls. This is done for backwards compatibility. DeleteProc will be invoked when (if) name is deleted. This can occur through a call to Tcl_DeleteCommand , Tcl_DeleteCommandFromToken , or Tcl_DeleteInterp , or by replacing name in another call to Tcl_CreateObjCommand . DeleteProc is invoked before the command is deleted, and gives the application an opportunity to release any structures associated with the command. DeleteProc should have arguments and result that match the type Tcl_CmdDeleteProc : typedef void Tcl_CmdDeleteProc ( void * clientData ); The clientData argument will be the same as the clientData argument passed to Tcl_CreateObjCommand . Tcl_CreateObjCommand2 does the same as Tcl_CreateObjCommand , except its proc2 argument is of type Tcl_ObjCmdProc2 . typedef int Tcl_ObjCmdProc2 ( void * clientData , Tcl_Interp * interp , ptrdiff_t objc , Tcl_Obj *const objv []); Tcl_DeleteCommand deletes a command from a command interpreter. Once the call completes, attempts to invoke cmdName in interp will result in errors. If cmdName is not bound as a command in interp then Tcl_DeleteCommand does nothing and returns -1; otherwise it returns 0. There are no restrictions on cmdName : it may refer to a built-in command, an application-specific command, or a Tcl procedure. If name contains any :: namespace qualifiers, the command is deleted from the specified namespace. Given a token returned by Tcl_CreateObjCommand , Tcl_DeleteCommandFromToken deletes the command from a command interpreter. It will delete a command even if that command has been renamed. Once the call completes, attempts to invoke the command in interp will result in errors. If the command corresponding to token has already been deleted from interp then Tcl_DeleteCommand does nothing and returns -1; otherwise it returns 0. Tcl_GetCommandInfo checks to see whether its cmdName argument exists as a command in interp . cmdName may include :: namespace qualifiers to identify a command in a particular namespace. If the command is not found, then it returns 0. Otherwise it places information about the command in the Tcl_CmdInfo structure pointed to by infoPtr and returns 1. A Tcl_CmdInfo structure has the following fields: typedef struct { int isNativeObjectProc ; Tcl_ObjCmdProc * objProc ; void * objClientData ; Tcl_CmdProc * proc ; void * clientData ; Tcl_CmdDeleteProc * deleteProc ; void * deleteData ; Tcl_Namespace * namespacePtr ; Tcl_ObjCmdProc2 * objProc2 ; void * objClientData2 ; } Tcl_CmdInfo ; The isNativeObjectProc field has the value 2 if Tcl_CreateObjCommand2 was called to register the command; it has the value 1 if Tcl_CreateObjCommand was called to register the command; it is 0 if only Tcl_CreateCommand was called. It allows a program to determine whether it is faster to call objProc2 , objProc or proc : objProc2 / objProc is normally faster if isNativeObjectProc has the value 2; objProc / objProc is normally faster if isNativeObjectProc has the value 1. The fields objProc and objClientData have the same meaning as the proc and clientData arguments to Tcl_CreateObjCommand ; they hold information about the value-based command procedure that the Tcl interpreter calls to implement the command. The fields proc and clientData hold information about the string-based command procedure that implements the command. If Tcl_CreateCommand was called for this command, this is the procedure passed to it; otherwise, this is a compatibility procedure registered by Tcl_CreateObjCommand that simply calls the command\\'s value-based procedure after converting its string arguments to Tcl values. The field deleteData is the clientData value to pass to deleteProc ; it is normally the same as clientData but may be set independently using the Tcl_SetCommandInfo procedure. The field namespacePtr holds a pointer to the Tcl_Namespace that contains the command. Tcl_GetCommandInfoFromToken is identical to Tcl_GetCommandInfo except that it uses a command token returned from Tcl_CreateObjCommand in place of the command name. If the token parameter is NULL, it returns 0; otherwise, it returns 1 and fills in the structure designated by infoPtr . Tcl_SetCommandInfo is used to modify the procedures and clientData values associated with a command. Its cmdName argument is the name of a command in interp . cmdName may include :: namespace qualifiers to identify a command in a particular namespace. If this command does not exist then Tcl_SetCommandInfo returns 0. Otherwise, it copies the information from *infoPtr to Tcl\\'s internal structure for the command and returns 1. Tcl_SetCommandInfoFromToken is identical to Tcl_SetCommandInfo except that it takes a command token as returned by Tcl_CreateObjCommand instead of the command name. If the token parameter is NULL, it returns 0. Otherwise, it copies the information from *infoPtr to Tcl\\'s internal structure for the command and returns 1. Note that Tcl_SetCommandInfo and Tcl_SetCommandInfoFromToken both allow the clientData for a command\\'s deletion procedure to be given a different value than the clientData for its command procedure. Note that neither Tcl_SetCommandInfo nor Tcl_SetCommandInfoFromToken will change a command\\'s namespace. Use Tcl_Eval to call the rename command to do that. Tcl_GetCommandName provides a mechanism for tracking commands that have been renamed. Given a token returned by Tcl_CreateObjCommand when the command was created, Tcl_GetCommandName returns the string name of the command. If the command has been renamed since it was created, then Tcl_GetCommandName returns the current name. This name does not include any :: namespace qualifiers. The command corresponding to token must not have been deleted. The string returned by Tcl_GetCommandName is in dynamic memory owned by Tcl and is only guaranteed to retain its value as long as the command is not deleted or renamed; callers should copy the string if they need to keep it for a long time. Tcl_GetCommandFullName produces the fully qualified name of a command from a command token. The name, including all namespace prefixes, is appended to the value specified by objPtr . Tcl_GetCommandFromObj returns a token for the command specified by the name in a Tcl_Obj . The command name is resolved relative to the current namespace. Returns NULL if the command is not found. REFERENCE COUNT MANAGEMENT When the proc passed to Tcl_CreateObjCommand is called, the values in its objv argument will have a reference count of at least 1, with that guaranteed reference being from the Tcl evaluation stack. You should not call Tcl_DecrRefCount on any of those values unless you call Tcl_IncrRefCount on them first. Also, when the proc is called, the interpreter result is guaranteed to be an empty string value with a reference count of 1. Tcl_GetCommandFullName does not modify the reference count of its objPtr argument, but does require that the object be unshared. Tcl_GetCommandFromObj does not modify the reference count of its objPtr argument; it only reads. SEE ALSO Tcl_CreateCommand(3), Tcl_ResetResult(3), Tcl_SetObjResult(3) KEYWORDS bind, command, create, delete, namespace, value","title":"NAME"},{"location":"CrtObjCmd/#name","text":"Tcl_CreateObjCommand, Tcl_CreateObjCommand2, Tcl_DeleteCommand, Tcl_DeleteCommandFromToken, Tcl_GetCommandInfo, Tcl_GetCommandInfoFromToken, Tcl_SetCommandInfo, Tcl_SetCommandInfoFromToken, Tcl_GetCommandName, Tcl_GetCommandFullName, Tcl_GetCommandFromObj - implement new commands in C","title":"NAME"},{"location":"CrtObjCmd/#synopsis","text":"#include <tcl.h> Tcl_Command Tcl_CreateObjCommand(interp, cmdName, proc, clientData, deleteProc) Tcl_Command Tcl_CreateObjCommand2(interp, cmdName, proc2, clientData, deleteProc) int Tcl_DeleteCommand(interp, cmdName) int Tcl_DeleteCommandFromToken(interp, token) int Tcl_GetCommandInfo(interp, cmdName, infoPtr) int Tcl_SetCommandInfo(interp, cmdName, infoPtr) int Tcl_GetCommandInfoFromToken(token, infoPtr) int Tcl_SetCommandInfoFromToken(token, infoPtr) const char * Tcl_GetCommandName(interp, token) void Tcl_GetCommandFullName(interp, token, objPtr) Tcl_Command Tcl_GetCommandFromObj(interp, objPtr)","title":"SYNOPSIS"},{"location":"CrtObjCmd/#arguments","text":"Interpreter in which to create a new command or that contains a command. Name of command. Implementation of the new command: proc will be called whenever cmdName is invoked as a command. Implementation of the new command: proc2 will be called whenever cmdName is invoked as a command. Arbitrary one-word value to pass to proc and deleteProc . Procedure to call before cmdName is deleted from the interpreter; allows for command-specific cleanup. If NULL, then no procedure is called before the command is deleted. Token for command, returned by previous call to Tcl_CreateObjCommand . The command must not have been deleted. Pointer to structure containing various information about a Tcl command. Value containing the name of a Tcl command. Indicates the name of the type of command implementation associated with a particular proc , or NULL to break the association.","title":"ARGUMENTS"},{"location":"CrtObjCmd/#description","text":"Tcl_CreateObjCommand defines a new command in interp and associates it with procedure proc such that whenever name is invoked as a Tcl command (e.g., via a call to Tcl_EvalObjEx ) the Tcl interpreter will call proc to process the command. Tcl_CreateObjCommand deletes any existing command name already associated with the interpreter (however see below for an exception where the existing command is not deleted). It returns a token that may be used to refer to the command in subsequent calls to Tcl_GetCommandName . If name contains any :: namespace qualifiers, then the command is added to the specified namespace; otherwise the command is added to the global namespace. If Tcl_CreateObjCommand is called for an interpreter that is in the process of being deleted, then it does not create a new command and it returns NULL. proc should have arguments and result that match the type Tcl_ObjCmdProc : typedef int Tcl_ObjCmdProc ( void * clientData , Tcl_Interp * interp , int objc , Tcl_Obj *const objv []); When proc is invoked, the clientData and interp parameters will be copies of the clientData and interp arguments given to Tcl_CreateObjCommand . Typically, clientData points to an application-specific data structure that describes what to do when the command procedure is invoked. Objc and objv describe the arguments to the command, objc giving the number of argument values (including the command name) and objv giving the values of the arguments. The objv array will contain objc values, pointing to the argument values. Unlike argv [ argv ] used in a string-based command procedure, objv [ objc ] will not contain NULL. Additionally, when proc is invoked, it must not modify the contents of the objv array by assigning new pointer values to any element of the array (for example, objv [ 2 ] = NULL ) because this will cause memory to be lost and the runtime stack to be corrupted. The const in the declaration of objv will cause ANSI-compliant compilers to report any such attempted assignment as an error. However, it is acceptable to modify the internal representation of any individual value argument. For instance, the user may call Tcl_GetIntFromObj on objv [ 2 ] to obtain the integer representation of that value; that call may change the type of the value that objv [ 2 ] points at, but will not change where objv [ 2 ] points. proc must return an integer code that is either TCL_OK , TCL_ERROR , TCL_RETURN , TCL_BREAK , or TCL_CONTINUE . See the Tcl overview man page for details on what these codes mean. Most normal commands will only return TCL_OK or TCL_ERROR . In addition, if proc needs to return a non-empty result, it can call Tcl_SetObjResult to set the interpreter\\'s result. In the case of a TCL_OK return code this gives the result of the command, and in the case of TCL_ERROR this gives an error message. Before invoking a command procedure, Tcl_EvalObjEx sets interpreter\\'s result to point to a value representing an empty string, so simple commands can return an empty result by doing nothing at all. The contents of the objv array belong to Tcl and are not guaranteed to persist once proc returns: proc should not modify them. Call Tcl_SetObjResult if you want to return something from the objv array. Ordinarily, Tcl_CreateObjCommand deletes any existing command name already associated with the interpreter. However, if the existing command was created by a previous call to Tcl_CreateCommand , Tcl_CreateObjCommand does not delete the command but instead arranges for the Tcl interpreter to call the Tcl_ObjCmdProc proc in the future. The old string-based Tcl_CmdProc associated with the command is retained and its address can be obtained by subsequent Tcl_GetCommandInfo calls. This is done for backwards compatibility. DeleteProc will be invoked when (if) name is deleted. This can occur through a call to Tcl_DeleteCommand , Tcl_DeleteCommandFromToken , or Tcl_DeleteInterp , or by replacing name in another call to Tcl_CreateObjCommand . DeleteProc is invoked before the command is deleted, and gives the application an opportunity to release any structures associated with the command. DeleteProc should have arguments and result that match the type Tcl_CmdDeleteProc : typedef void Tcl_CmdDeleteProc ( void * clientData ); The clientData argument will be the same as the clientData argument passed to Tcl_CreateObjCommand . Tcl_CreateObjCommand2 does the same as Tcl_CreateObjCommand , except its proc2 argument is of type Tcl_ObjCmdProc2 . typedef int Tcl_ObjCmdProc2 ( void * clientData , Tcl_Interp * interp , ptrdiff_t objc , Tcl_Obj *const objv []); Tcl_DeleteCommand deletes a command from a command interpreter. Once the call completes, attempts to invoke cmdName in interp will result in errors. If cmdName is not bound as a command in interp then Tcl_DeleteCommand does nothing and returns -1; otherwise it returns 0. There are no restrictions on cmdName : it may refer to a built-in command, an application-specific command, or a Tcl procedure. If name contains any :: namespace qualifiers, the command is deleted from the specified namespace. Given a token returned by Tcl_CreateObjCommand , Tcl_DeleteCommandFromToken deletes the command from a command interpreter. It will delete a command even if that command has been renamed. Once the call completes, attempts to invoke the command in interp will result in errors. If the command corresponding to token has already been deleted from interp then Tcl_DeleteCommand does nothing and returns -1; otherwise it returns 0. Tcl_GetCommandInfo checks to see whether its cmdName argument exists as a command in interp . cmdName may include :: namespace qualifiers to identify a command in a particular namespace. If the command is not found, then it returns 0. Otherwise it places information about the command in the Tcl_CmdInfo structure pointed to by infoPtr and returns 1. A Tcl_CmdInfo structure has the following fields: typedef struct { int isNativeObjectProc ; Tcl_ObjCmdProc * objProc ; void * objClientData ; Tcl_CmdProc * proc ; void * clientData ; Tcl_CmdDeleteProc * deleteProc ; void * deleteData ; Tcl_Namespace * namespacePtr ; Tcl_ObjCmdProc2 * objProc2 ; void * objClientData2 ; } Tcl_CmdInfo ; The isNativeObjectProc field has the value 2 if Tcl_CreateObjCommand2 was called to register the command; it has the value 1 if Tcl_CreateObjCommand was called to register the command; it is 0 if only Tcl_CreateCommand was called. It allows a program to determine whether it is faster to call objProc2 , objProc or proc : objProc2 / objProc is normally faster if isNativeObjectProc has the value 2; objProc / objProc is normally faster if isNativeObjectProc has the value 1. The fields objProc and objClientData have the same meaning as the proc and clientData arguments to Tcl_CreateObjCommand ; they hold information about the value-based command procedure that the Tcl interpreter calls to implement the command. The fields proc and clientData hold information about the string-based command procedure that implements the command. If Tcl_CreateCommand was called for this command, this is the procedure passed to it; otherwise, this is a compatibility procedure registered by Tcl_CreateObjCommand that simply calls the command\\'s value-based procedure after converting its string arguments to Tcl values. The field deleteData is the clientData value to pass to deleteProc ; it is normally the same as clientData but may be set independently using the Tcl_SetCommandInfo procedure. The field namespacePtr holds a pointer to the Tcl_Namespace that contains the command. Tcl_GetCommandInfoFromToken is identical to Tcl_GetCommandInfo except that it uses a command token returned from Tcl_CreateObjCommand in place of the command name. If the token parameter is NULL, it returns 0; otherwise, it returns 1 and fills in the structure designated by infoPtr . Tcl_SetCommandInfo is used to modify the procedures and clientData values associated with a command. Its cmdName argument is the name of a command in interp . cmdName may include :: namespace qualifiers to identify a command in a particular namespace. If this command does not exist then Tcl_SetCommandInfo returns 0. Otherwise, it copies the information from *infoPtr to Tcl\\'s internal structure for the command and returns 1. Tcl_SetCommandInfoFromToken is identical to Tcl_SetCommandInfo except that it takes a command token as returned by Tcl_CreateObjCommand instead of the command name. If the token parameter is NULL, it returns 0. Otherwise, it copies the information from *infoPtr to Tcl\\'s internal structure for the command and returns 1. Note that Tcl_SetCommandInfo and Tcl_SetCommandInfoFromToken both allow the clientData for a command\\'s deletion procedure to be given a different value than the clientData for its command procedure. Note that neither Tcl_SetCommandInfo nor Tcl_SetCommandInfoFromToken will change a command\\'s namespace. Use Tcl_Eval to call the rename command to do that. Tcl_GetCommandName provides a mechanism for tracking commands that have been renamed. Given a token returned by Tcl_CreateObjCommand when the command was created, Tcl_GetCommandName returns the string name of the command. If the command has been renamed since it was created, then Tcl_GetCommandName returns the current name. This name does not include any :: namespace qualifiers. The command corresponding to token must not have been deleted. The string returned by Tcl_GetCommandName is in dynamic memory owned by Tcl and is only guaranteed to retain its value as long as the command is not deleted or renamed; callers should copy the string if they need to keep it for a long time. Tcl_GetCommandFullName produces the fully qualified name of a command from a command token. The name, including all namespace prefixes, is appended to the value specified by objPtr . Tcl_GetCommandFromObj returns a token for the command specified by the name in a Tcl_Obj . The command name is resolved relative to the current namespace. Returns NULL if the command is not found.","title":"DESCRIPTION"},{"location":"CrtObjCmd/#reference-count-management","text":"When the proc passed to Tcl_CreateObjCommand is called, the values in its objv argument will have a reference count of at least 1, with that guaranteed reference being from the Tcl evaluation stack. You should not call Tcl_DecrRefCount on any of those values unless you call Tcl_IncrRefCount on them first. Also, when the proc is called, the interpreter result is guaranteed to be an empty string value with a reference count of 1. Tcl_GetCommandFullName does not modify the reference count of its objPtr argument, but does require that the object be unshared. Tcl_GetCommandFromObj does not modify the reference count of its objPtr argument; it only reads.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"CrtObjCmd/#see-also","text":"Tcl_CreateCommand(3), Tcl_ResetResult(3), Tcl_SetObjResult(3)","title":"SEE ALSO"},{"location":"CrtObjCmd/#keywords","text":"bind, command, create, delete, namespace, value","title":"KEYWORDS"},{"location":"CrtTimerHdlr/","text":"NAME Tcl_CreateTimerHandler, Tcl_DeleteTimerHandler - call a procedure at a given time SYNOPSIS #include <tcl.h> Tcl_TimerToken Tcl_CreateTimerHandler(milliseconds, proc, clientData) Tcl_DeleteTimerHandler(token) ARGUMENTS How many milliseconds to wait before invoking proc . Procedure to invoke after milliseconds have elapsed. Arbitrary one-word value to pass to proc . Token for previously created timer handler (the return value from some previous call to Tcl_CreateTimerHandler ). DESCRIPTION Tcl_CreateTimerHandler arranges for proc to be invoked at a time milliseconds milliseconds in the future. The callback to proc will be made by Tcl_DoOneEvent , so Tcl_CreateTimerHandler is only useful in programs that dispatch events through Tcl_DoOneEvent or through Tcl commands such as vwait . The call to proc may not be made at the exact time given by milliseconds : it will be made at the next opportunity after that time. For example, if Tcl_DoOneEvent is not called until long after the time has elapsed, or if there are other pending events to process before the call to proc , then the call to proc will be delayed. Proc should have arguments and return value that match the type Tcl_TimerProc : typedef void Tcl_TimerProc ( void * clientData ); The clientData parameter to proc is a copy of the clientData argument given to Tcl_CreateTimerHandler when the callback was created. Typically, clientData points to a data structure containing application-specific information about what to do in proc . Tcl_DeleteTimerHandler may be called to delete a previously created timer handler. It deletes the handler indicated by token so that no call to proc will be made; if that handler no longer exists (e.g. because the time period has already elapsed and proc has been invoked then Tcl_DeleteTimerHandler does nothing. The tokens returned by Tcl_CreateTimerHandler never have a value of NULL, so if NULL is passed to Tcl_DeleteTimerHandler then the procedure does nothing. SEE ALSO after(n), Tcl_CreateFileHandler(3), Tcl_DoWhenIdle(3) KEYWORDS callback, clock, handler, timer","title":"NAME"},{"location":"CrtTimerHdlr/#name","text":"Tcl_CreateTimerHandler, Tcl_DeleteTimerHandler - call a procedure at a given time","title":"NAME"},{"location":"CrtTimerHdlr/#synopsis","text":"#include <tcl.h> Tcl_TimerToken Tcl_CreateTimerHandler(milliseconds, proc, clientData) Tcl_DeleteTimerHandler(token)","title":"SYNOPSIS"},{"location":"CrtTimerHdlr/#arguments","text":"How many milliseconds to wait before invoking proc . Procedure to invoke after milliseconds have elapsed. Arbitrary one-word value to pass to proc . Token for previously created timer handler (the return value from some previous call to Tcl_CreateTimerHandler ).","title":"ARGUMENTS"},{"location":"CrtTimerHdlr/#description","text":"Tcl_CreateTimerHandler arranges for proc to be invoked at a time milliseconds milliseconds in the future. The callback to proc will be made by Tcl_DoOneEvent , so Tcl_CreateTimerHandler is only useful in programs that dispatch events through Tcl_DoOneEvent or through Tcl commands such as vwait . The call to proc may not be made at the exact time given by milliseconds : it will be made at the next opportunity after that time. For example, if Tcl_DoOneEvent is not called until long after the time has elapsed, or if there are other pending events to process before the call to proc , then the call to proc will be delayed. Proc should have arguments and return value that match the type Tcl_TimerProc : typedef void Tcl_TimerProc ( void * clientData ); The clientData parameter to proc is a copy of the clientData argument given to Tcl_CreateTimerHandler when the callback was created. Typically, clientData points to a data structure containing application-specific information about what to do in proc . Tcl_DeleteTimerHandler may be called to delete a previously created timer handler. It deletes the handler indicated by token so that no call to proc will be made; if that handler no longer exists (e.g. because the time period has already elapsed and proc has been invoked then Tcl_DeleteTimerHandler does nothing. The tokens returned by Tcl_CreateTimerHandler never have a value of NULL, so if NULL is passed to Tcl_DeleteTimerHandler then the procedure does nothing.","title":"DESCRIPTION"},{"location":"CrtTimerHdlr/#see-also","text":"after(n), Tcl_CreateFileHandler(3), Tcl_DoWhenIdle(3)","title":"SEE ALSO"},{"location":"CrtTimerHdlr/#keywords","text":"callback, clock, handler, timer","title":"KEYWORDS"},{"location":"CrtTrace/","text":"NAME Tcl_CreateTrace, Tcl_CreateObjTrace, Tcl_CreateObjTrace2, Tcl_DeleteTrace - arrange for command execution to be traced SYNOPSIS #include <tcl.h> Tcl_Trace Tcl_CreateTrace(interp, level, proc, clientData) Tcl_Trace Tcl_CreateObjTrace(interp, level, flags, objProc, clientData, deleteProc) Tcl_Trace Tcl_CreateObjTrace2(interp, level, flags, objProc2, clientData, deleteProc) Tcl_DeleteTrace(interp, trace) ARGUMENTS Interpreter containing command to be traced or untraced. Only commands at or below this nesting level will be traced unless 0 is specified. 1 means top-level commands only, 2 means top-level commands or those that are invoked as immediate consequences of executing top-level commands (procedure bodies, bracketed commands, etc.) and so on. A value of 0 means that commands at any level are traced. Flags governing the trace execution. See below for details. Procedure to call for each command that is executed. See below for details of the calling sequence. Procedure to call for each command that is executed. See below for details of the calling sequence. Procedure to call for each command that is executed. See below for details on the calling sequence. Arbitrary one-word value to pass to objProc , objProc2 or proc . Procedure to call when the trace is deleted. See below for details of the calling sequence. A NULL pointer is permissible and results in no callback when the trace is deleted. Token for trace to be removed (return value from previous call to Tcl_CreateTrace ). DESCRIPTION Tcl_CreateObjTrace arranges for command tracing. After it is called, objProc will be invoked before the Tcl interpreter calls any command procedure when evaluating commands in interp . The return value from Tcl_CreateObjTrace is a token for the trace, which may be passed to Tcl_DeleteTrace to remove the trace. There may be many traces in effect simultaneously for the same interpreter. objProc should have arguments and result that match the type, Tcl_CmdObjTraceProc : typedef int Tcl_CmdObjTraceProc ( void * clientData , Tcl_Interp * interp , int level , const char * command , Tcl_Command commandToken , int objc , Tcl_Obj *const objv []); objProc2 should have arguments and result that match the type, Tcl_CmdObjTraceProc2 : typedef int Tcl_CmdObjTraceProc2 ( void * clientData , Tcl_Interp * interp , ptrdiff_t level , const char * command , Tcl_Command commandToken , ptrdiff_t objc , Tcl_Obj *const objv []); The clientData and interp parameters are copies of the corresponding arguments given to Tcl_CreateTrace . clientData typically points to an application-specific data structure that describes what to do when objProc is invoked. The level parameter gives the nesting level of the command (1 for top-level commands passed to Tcl_Eval by the application, 2 for the next-level commands passed to Tcl_Eval as part of parsing or interpreting level-1 commands, and so on). The command parameter points to a string containing the text of the command, before any argument substitution. The commandToken parameter is a Tcl command token that identifies the command to be invoked. The token may be passed to Tcl_GetCommandName , Tcl_GetCommandInfoFromToken , or Tcl_SetCommandInfoFromToken to manipulate the definition of the command. The objc and objv parameters designate the final parameter count and parameter vector that will be passed to the command, and have had all substitutions performed. The objProc callback is expected to return a standard Tcl status return code. If this code is TCL_OK (the normal case), then the Tcl interpreter will invoke the command. Any other return code is treated as if the command returned that status, and the command is not invoked. The objProc callback must not modify objv in any way. Tracing will only occur for commands at nesting level less than or equal to the level parameter (i.e. the level parameter to objProc will always be less than or equal to the level parameter to Tcl_CreateTrace ). Tracing has a significant effect on runtime performance because it causes the bytecode compiler to refrain from generating in-line code for Tcl commands such as if and while in order that they may be traced. If traces for the built-in commands are not required, the flags parameter may be set to the constant value TCL_ALLOW_INLINE_COMPILATION . In this case, traces on built-in commands may or may not result in trace callbacks, depending on the state of the interpreter, but run-time performance will be improved significantly. (This functionality is desirable, for example, when using Tcl_CreateObjTrace to implement an execution time profiler.) Calls to objProc will be made by the Tcl parser immediately before it calls the command procedure for the command ( cmdProc ). This occurs after argument parsing and substitution, so tracing for substituted commands occurs before tracing of the commands containing the substitutions. If there is a syntax error in a command, or if there is no command procedure associated with a command name, then no tracing will occur for that command. If a string passed to Tcl_Eval contains multiple commands (bracketed, or on different lines) then multiple calls to objProc will occur, one for each command. Tcl_DeleteTrace removes a trace, so that no future calls will be made to the procedure associated with the trace. After Tcl_DeleteTrace returns, the caller should never again use the trace token. When Tcl_DeleteTrace is called, the interpreter invokes the deleteProc that was passed as a parameter to Tcl_CreateObjTrace . The deleteProc must match the type, Tcl_CmdObjTraceDeleteProc : typedef void Tcl_CmdObjTraceDeleteProc ( void * clientData ); The clientData parameter will be the same as the clientData parameter that was originally passed to Tcl_CreateObjTrace . Tcl_CreateTrace is an alternative interface for command tracing, not recommended for new applications . It is provided for backward compatibility with code that was developed for older versions of the Tcl interpreter. It is similar to Tcl_CreateObjTrace , except that its proc parameter should have arguments and result that match the type Tcl_CmdTraceProc : typedef void Tcl_CmdTraceProc ( void * clientData , Tcl_Interp * interp , int level , char * command , Tcl_CmdProc * cmdProc , void * cmdClientData , int argc , const char * argv []); The parameters to the proc callback are similar to those of the objProc callback above. The commandToken is replaced with cmdProc , a pointer to the (string-based) command procedure that will be invoked; and cmdClientData , the client data that will be passed to the procedure. The objc parameter is replaced with an argv parameter, that gives the arguments to the command as character strings. Proc must not modify the command or argv strings. If a trace created with Tcl_CreateTrace is in effect, inline compilation of Tcl commands such as if and while is always disabled. There is no notification when a trace created with Tcl_CreateTrace is deleted. There is no way to be notified when the trace created by Tcl_CreateTrace is deleted. There is no way for the proc associated with a call to Tcl_CreateTrace to abort execution of command . REFERENCE COUNT MANAGEMENT When the proc passed to Tcl_CreateObjTrace is called, the values in its objv argument will have a reference count of at least 1, with that guaranteed reference being from the Tcl evaluation stack. You should not call Tcl_DecrRefCount on any of those values unless you call Tcl_IncrRefCount on them first. SEE ALSO trace(n) KEYWORDS command, create, delete, interpreter, trace","title":"NAME"},{"location":"CrtTrace/#name","text":"Tcl_CreateTrace, Tcl_CreateObjTrace, Tcl_CreateObjTrace2, Tcl_DeleteTrace - arrange for command execution to be traced","title":"NAME"},{"location":"CrtTrace/#synopsis","text":"#include <tcl.h> Tcl_Trace Tcl_CreateTrace(interp, level, proc, clientData) Tcl_Trace Tcl_CreateObjTrace(interp, level, flags, objProc, clientData, deleteProc) Tcl_Trace Tcl_CreateObjTrace2(interp, level, flags, objProc2, clientData, deleteProc) Tcl_DeleteTrace(interp, trace)","title":"SYNOPSIS"},{"location":"CrtTrace/#arguments","text":"Interpreter containing command to be traced or untraced. Only commands at or below this nesting level will be traced unless 0 is specified. 1 means top-level commands only, 2 means top-level commands or those that are invoked as immediate consequences of executing top-level commands (procedure bodies, bracketed commands, etc.) and so on. A value of 0 means that commands at any level are traced. Flags governing the trace execution. See below for details. Procedure to call for each command that is executed. See below for details of the calling sequence. Procedure to call for each command that is executed. See below for details of the calling sequence. Procedure to call for each command that is executed. See below for details on the calling sequence. Arbitrary one-word value to pass to objProc , objProc2 or proc . Procedure to call when the trace is deleted. See below for details of the calling sequence. A NULL pointer is permissible and results in no callback when the trace is deleted. Token for trace to be removed (return value from previous call to Tcl_CreateTrace ).","title":"ARGUMENTS"},{"location":"CrtTrace/#description","text":"Tcl_CreateObjTrace arranges for command tracing. After it is called, objProc will be invoked before the Tcl interpreter calls any command procedure when evaluating commands in interp . The return value from Tcl_CreateObjTrace is a token for the trace, which may be passed to Tcl_DeleteTrace to remove the trace. There may be many traces in effect simultaneously for the same interpreter. objProc should have arguments and result that match the type, Tcl_CmdObjTraceProc : typedef int Tcl_CmdObjTraceProc ( void * clientData , Tcl_Interp * interp , int level , const char * command , Tcl_Command commandToken , int objc , Tcl_Obj *const objv []); objProc2 should have arguments and result that match the type, Tcl_CmdObjTraceProc2 : typedef int Tcl_CmdObjTraceProc2 ( void * clientData , Tcl_Interp * interp , ptrdiff_t level , const char * command , Tcl_Command commandToken , ptrdiff_t objc , Tcl_Obj *const objv []); The clientData and interp parameters are copies of the corresponding arguments given to Tcl_CreateTrace . clientData typically points to an application-specific data structure that describes what to do when objProc is invoked. The level parameter gives the nesting level of the command (1 for top-level commands passed to Tcl_Eval by the application, 2 for the next-level commands passed to Tcl_Eval as part of parsing or interpreting level-1 commands, and so on). The command parameter points to a string containing the text of the command, before any argument substitution. The commandToken parameter is a Tcl command token that identifies the command to be invoked. The token may be passed to Tcl_GetCommandName , Tcl_GetCommandInfoFromToken , or Tcl_SetCommandInfoFromToken to manipulate the definition of the command. The objc and objv parameters designate the final parameter count and parameter vector that will be passed to the command, and have had all substitutions performed. The objProc callback is expected to return a standard Tcl status return code. If this code is TCL_OK (the normal case), then the Tcl interpreter will invoke the command. Any other return code is treated as if the command returned that status, and the command is not invoked. The objProc callback must not modify objv in any way. Tracing will only occur for commands at nesting level less than or equal to the level parameter (i.e. the level parameter to objProc will always be less than or equal to the level parameter to Tcl_CreateTrace ). Tracing has a significant effect on runtime performance because it causes the bytecode compiler to refrain from generating in-line code for Tcl commands such as if and while in order that they may be traced. If traces for the built-in commands are not required, the flags parameter may be set to the constant value TCL_ALLOW_INLINE_COMPILATION . In this case, traces on built-in commands may or may not result in trace callbacks, depending on the state of the interpreter, but run-time performance will be improved significantly. (This functionality is desirable, for example, when using Tcl_CreateObjTrace to implement an execution time profiler.) Calls to objProc will be made by the Tcl parser immediately before it calls the command procedure for the command ( cmdProc ). This occurs after argument parsing and substitution, so tracing for substituted commands occurs before tracing of the commands containing the substitutions. If there is a syntax error in a command, or if there is no command procedure associated with a command name, then no tracing will occur for that command. If a string passed to Tcl_Eval contains multiple commands (bracketed, or on different lines) then multiple calls to objProc will occur, one for each command. Tcl_DeleteTrace removes a trace, so that no future calls will be made to the procedure associated with the trace. After Tcl_DeleteTrace returns, the caller should never again use the trace token. When Tcl_DeleteTrace is called, the interpreter invokes the deleteProc that was passed as a parameter to Tcl_CreateObjTrace . The deleteProc must match the type, Tcl_CmdObjTraceDeleteProc : typedef void Tcl_CmdObjTraceDeleteProc ( void * clientData ); The clientData parameter will be the same as the clientData parameter that was originally passed to Tcl_CreateObjTrace . Tcl_CreateTrace is an alternative interface for command tracing, not recommended for new applications . It is provided for backward compatibility with code that was developed for older versions of the Tcl interpreter. It is similar to Tcl_CreateObjTrace , except that its proc parameter should have arguments and result that match the type Tcl_CmdTraceProc : typedef void Tcl_CmdTraceProc ( void * clientData , Tcl_Interp * interp , int level , char * command , Tcl_CmdProc * cmdProc , void * cmdClientData , int argc , const char * argv []); The parameters to the proc callback are similar to those of the objProc callback above. The commandToken is replaced with cmdProc , a pointer to the (string-based) command procedure that will be invoked; and cmdClientData , the client data that will be passed to the procedure. The objc parameter is replaced with an argv parameter, that gives the arguments to the command as character strings. Proc must not modify the command or argv strings. If a trace created with Tcl_CreateTrace is in effect, inline compilation of Tcl commands such as if and while is always disabled. There is no notification when a trace created with Tcl_CreateTrace is deleted. There is no way to be notified when the trace created by Tcl_CreateTrace is deleted. There is no way for the proc associated with a call to Tcl_CreateTrace to abort execution of command .","title":"DESCRIPTION"},{"location":"CrtTrace/#reference-count-management","text":"When the proc passed to Tcl_CreateObjTrace is called, the values in its objv argument will have a reference count of at least 1, with that guaranteed reference being from the Tcl evaluation stack. You should not call Tcl_DecrRefCount on any of those values unless you call Tcl_IncrRefCount on them first.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"CrtTrace/#see-also","text":"trace(n)","title":"SEE ALSO"},{"location":"CrtTrace/#keywords","text":"command, create, delete, interpreter, trace","title":"KEYWORDS"},{"location":"DString/","text":"NAME Tcl_DStringInit, Tcl_DStringAppend, Tcl_DStringAppendElement, Tcl_DStringStartSublist, Tcl_DStringEndSublist, Tcl_DStringLength, Tcl_DStringValue, Tcl_DStringSetLength, Tcl_DStringFree, Tcl_DStringResult, Tcl_DStringGetResult - manipulate dynamic strings SYNOPSIS #include <tcl.h> Tcl_DStringInit(dsPtr) char * Tcl_DStringAppend(dsPtr, bytes, length) char * Tcl_DStringAppendElement(dsPtr, element) Tcl_DStringStartSublist(dsPtr) Tcl_DStringEndSublist(dsPtr) Tcl_Size Tcl_DStringLength(dsPtr) char * Tcl_DStringValue(dsPtr) Tcl_DStringSetLength(dsPtr, newLength) Tcl_DStringFree(dsPtr) Tcl_DStringResult(interp, dsPtr) Tcl_DStringGetResult(interp, dsPtr) Tcl_Obj * Tcl_DStringToObj(dsPtr) ARGUMENTS Pointer to structure that is used to manage a dynamic string. Pointer to characters to append to dynamic string. Pointer to characters to append as list element to dynamic string. Number of bytes from bytes to add to dynamic string. If negative, add all characters up to null terminating character. New length for dynamic string, not including null terminating character. Interpreter whose result is to be set from or moved to the dynamic string. DESCRIPTION Dynamic strings provide a mechanism for building up arbitrarily long strings by gradually appending information. If the dynamic string is short then there will be no memory allocation overhead; as the string gets larger, additional space will be allocated as needed. Tcl_DStringInit initializes a dynamic string to zero length. The Tcl_DString structure must have been allocated by the caller. No assumptions are made about the current state of the structure; anything already in it is discarded. If the structure has been used previously, Tcl_DStringFree should be called first to free up any memory allocated for the old string. Tcl_DStringAppend adds new information to a dynamic string, allocating more memory for the string if needed. If length is less than zero then everything in bytes is appended to the dynamic string; otherwise length specifies the number of bytes to append. Tcl_DStringAppend returns a pointer to the characters of the new string. The string can also be retrieved from the string field of the Tcl_DString structure. Tcl_DStringAppendElement is similar to Tcl_DStringAppend except that it does not take a length argument (it appends all of element ) and it converts the string to a proper list element before appending. Tcl_DStringAppendElement adds a separator space before the new list element unless the new list element is the first in a list or sub-list (i.e. either the current string is empty, or it contains the single character or the last two characters of the current string are Tcl_DStringAppendElement returns a pointer to the characters of the new string. Tcl_DStringStartSublist and Tcl_DStringEndSublist can be used to create nested lists. To append a list element that is itself a sublist, first call Tcl_DStringStartSublist , then call Tcl_DStringAppendElement for each of the elements in the sublist, then call Tcl_DStringEndSublist to end the sublist. Tcl_DStringStartSublist appends a space character if needed, followed by an open brace; Tcl_DStringEndSublist appends a close brace. Lists can be nested to any depth. Tcl_DStringLength is a macro that returns the current length of a dynamic string (not including the terminating null character). Tcl_DStringValue is a macro that returns a pointer to the current contents of a dynamic string. Tcl_DStringSetLength changes the length of a dynamic string. If newLength is less than the string\\'s current length, then the string is truncated. If newLength is greater than the string\\'s current length, then the string will become longer and new space will be allocated for the string if needed. However, Tcl_DStringSetLength will not initialize the new space except to provide a terminating null character; it is up to the caller to fill in the new space. Tcl_DStringSetLength does not free up the string\\'s storage space even if the string is truncated to zero length, so Tcl_DStringFree will still need to be called. Tcl_DStringFree should be called when you are finished using the string. It frees up any memory that was allocated for the string and reinitializes the string\\'s value to an empty string. Tcl_DStringResult sets the result of interp to the value of the dynamic string given by dsPtr . It does this by moving a pointer from dsPtr to the interpreter\\'s result. This saves the cost of allocating new memory and copying the string. Tcl_DStringResult also reinitializes the dynamic string to an empty string. Since the dynamic string is reinitialized, there is no need to further call Tcl_DStringFree on it and it can be reused without calling Tcl_DStringInit . The caller must ensure that the dynamic string stored in dsPtr is encoded in Tcl\\'s internal UTF-8 format. Tcl_DStringGetResult does the opposite of Tcl_DStringResult . It sets the value of dsPtr to the result of interp and it clears interp \\'s result. If possible it does this by moving a pointer rather than by copying the string. Tcl_DStringToObj returns a Tcl_Obj containing the value of the dynamic string given by dsPtr . It does this by moving a pointer from dsPtr to a newly allocated Tcl_Obj and reinitializing to dynamic string to an empty string. This saves the cost of allocating new memory and copying the string. Since the dynamic string is reinitialized, there is no need to further call Tcl_DStringFree on it and it can be reused without calling Tcl_DStringInit . The returned Tcl_Obj has a reference count of 0. The caller must ensure that the dynamic string stored in dsPtr is encoded in Tcl\\'s internal UTF-8 format. KEYWORDS append, dynamic string, free, result","title":"NAME"},{"location":"DString/#name","text":"Tcl_DStringInit, Tcl_DStringAppend, Tcl_DStringAppendElement, Tcl_DStringStartSublist, Tcl_DStringEndSublist, Tcl_DStringLength, Tcl_DStringValue, Tcl_DStringSetLength, Tcl_DStringFree, Tcl_DStringResult, Tcl_DStringGetResult - manipulate dynamic strings","title":"NAME"},{"location":"DString/#synopsis","text":"#include <tcl.h> Tcl_DStringInit(dsPtr) char * Tcl_DStringAppend(dsPtr, bytes, length) char * Tcl_DStringAppendElement(dsPtr, element) Tcl_DStringStartSublist(dsPtr) Tcl_DStringEndSublist(dsPtr) Tcl_Size Tcl_DStringLength(dsPtr) char * Tcl_DStringValue(dsPtr) Tcl_DStringSetLength(dsPtr, newLength) Tcl_DStringFree(dsPtr) Tcl_DStringResult(interp, dsPtr) Tcl_DStringGetResult(interp, dsPtr) Tcl_Obj * Tcl_DStringToObj(dsPtr)","title":"SYNOPSIS"},{"location":"DString/#arguments","text":"Pointer to structure that is used to manage a dynamic string. Pointer to characters to append to dynamic string. Pointer to characters to append as list element to dynamic string. Number of bytes from bytes to add to dynamic string. If negative, add all characters up to null terminating character. New length for dynamic string, not including null terminating character. Interpreter whose result is to be set from or moved to the dynamic string.","title":"ARGUMENTS"},{"location":"DString/#description","text":"Dynamic strings provide a mechanism for building up arbitrarily long strings by gradually appending information. If the dynamic string is short then there will be no memory allocation overhead; as the string gets larger, additional space will be allocated as needed. Tcl_DStringInit initializes a dynamic string to zero length. The Tcl_DString structure must have been allocated by the caller. No assumptions are made about the current state of the structure; anything already in it is discarded. If the structure has been used previously, Tcl_DStringFree should be called first to free up any memory allocated for the old string. Tcl_DStringAppend adds new information to a dynamic string, allocating more memory for the string if needed. If length is less than zero then everything in bytes is appended to the dynamic string; otherwise length specifies the number of bytes to append. Tcl_DStringAppend returns a pointer to the characters of the new string. The string can also be retrieved from the string field of the Tcl_DString structure. Tcl_DStringAppendElement is similar to Tcl_DStringAppend except that it does not take a length argument (it appends all of element ) and it converts the string to a proper list element before appending. Tcl_DStringAppendElement adds a separator space before the new list element unless the new list element is the first in a list or sub-list (i.e. either the current string is empty, or it contains the single character or the last two characters of the current string are Tcl_DStringAppendElement returns a pointer to the characters of the new string. Tcl_DStringStartSublist and Tcl_DStringEndSublist can be used to create nested lists. To append a list element that is itself a sublist, first call Tcl_DStringStartSublist , then call Tcl_DStringAppendElement for each of the elements in the sublist, then call Tcl_DStringEndSublist to end the sublist. Tcl_DStringStartSublist appends a space character if needed, followed by an open brace; Tcl_DStringEndSublist appends a close brace. Lists can be nested to any depth. Tcl_DStringLength is a macro that returns the current length of a dynamic string (not including the terminating null character). Tcl_DStringValue is a macro that returns a pointer to the current contents of a dynamic string. Tcl_DStringSetLength changes the length of a dynamic string. If newLength is less than the string\\'s current length, then the string is truncated. If newLength is greater than the string\\'s current length, then the string will become longer and new space will be allocated for the string if needed. However, Tcl_DStringSetLength will not initialize the new space except to provide a terminating null character; it is up to the caller to fill in the new space. Tcl_DStringSetLength does not free up the string\\'s storage space even if the string is truncated to zero length, so Tcl_DStringFree will still need to be called. Tcl_DStringFree should be called when you are finished using the string. It frees up any memory that was allocated for the string and reinitializes the string\\'s value to an empty string. Tcl_DStringResult sets the result of interp to the value of the dynamic string given by dsPtr . It does this by moving a pointer from dsPtr to the interpreter\\'s result. This saves the cost of allocating new memory and copying the string. Tcl_DStringResult also reinitializes the dynamic string to an empty string. Since the dynamic string is reinitialized, there is no need to further call Tcl_DStringFree on it and it can be reused without calling Tcl_DStringInit . The caller must ensure that the dynamic string stored in dsPtr is encoded in Tcl\\'s internal UTF-8 format. Tcl_DStringGetResult does the opposite of Tcl_DStringResult . It sets the value of dsPtr to the result of interp and it clears interp \\'s result. If possible it does this by moving a pointer rather than by copying the string. Tcl_DStringToObj returns a Tcl_Obj containing the value of the dynamic string given by dsPtr . It does this by moving a pointer from dsPtr to a newly allocated Tcl_Obj and reinitializing to dynamic string to an empty string. This saves the cost of allocating new memory and copying the string. Since the dynamic string is reinitialized, there is no need to further call Tcl_DStringFree on it and it can be reused without calling Tcl_DStringInit . The returned Tcl_Obj has a reference count of 0. The caller must ensure that the dynamic string stored in dsPtr is encoded in Tcl\\'s internal UTF-8 format.","title":"DESCRIPTION"},{"location":"DString/#keywords","text":"append, dynamic string, free, result","title":"KEYWORDS"},{"location":"DetachPids/","text":"NAME Tcl_DetachPids, Tcl_ReapDetachedProcs, Tcl_WaitPid - manage child processes in background SYNOPSIS #include <tcl.h> Tcl_DetachPids(numPids, pidPtr) Tcl_ReapDetachedProcs() Tcl_Pid Tcl_WaitPid(pid, statusPtr, options) ARGUMENTS Number of process ids contained in the array pointed to by pidPtr . Address of array containing numPids process ids. The id of the process (pipe) to wait for. The result of waiting on a process (pipe). Either 0 or ECHILD. The options controlling the wait. WNOHANG specifies not to wait when checking the process. DESCRIPTION Tcl_DetachPids and Tcl_ReapDetachedProcs provide a mechanism for managing subprocesses that are running in background. These procedures are needed because the parent of a process must eventually invoke the waitpid kernel call (or one of a few other similar kernel calls) to wait for the child to exit. Until the parent waits for the child, the child\\'s state cannot be completely reclaimed by the system. If a parent continually creates children and doesn\\'t wait on them, the system\\'s process table will eventually overflow, even if all the children have exited. Tcl_DetachPids may be called to ask Tcl to take responsibility for one or more processes whose process ids are contained in the pidPtr array passed as argument. The caller presumably has started these processes running in background and does not want to have to deal with them again. Tcl_ReapDetachedProcs invokes the waitpid kernel call on each of the background processes so that its state can be cleaned up if it has exited. If the process has not exited yet, Tcl_ReapDetachedProcs does not wait for it to exit; it will check again the next time it is invoked. Tcl automatically calls Tcl_ReapDetachedProcs each time the exec command is executed, so in most cases it is not necessary for any code outside of Tcl to invoke Tcl_ReapDetachedProcs . However, if you call Tcl_DetachPids in situations where the exec command may never get executed, you may wish to call Tcl_ReapDetachedProcs from time to time so that background processes can be cleaned up. Tcl_WaitPid is a thin wrapper around the facilities provided by the operating system to wait on the end of a spawned process and to check a whether spawned process is still running. It is used by Tcl_ReapDetachedProcs and the channel system to portably access the operating system. KEYWORDS background, child, detach, process, wait","title":"NAME"},{"location":"DetachPids/#name","text":"Tcl_DetachPids, Tcl_ReapDetachedProcs, Tcl_WaitPid - manage child processes in background","title":"NAME"},{"location":"DetachPids/#synopsis","text":"#include <tcl.h> Tcl_DetachPids(numPids, pidPtr) Tcl_ReapDetachedProcs() Tcl_Pid Tcl_WaitPid(pid, statusPtr, options)","title":"SYNOPSIS"},{"location":"DetachPids/#arguments","text":"Number of process ids contained in the array pointed to by pidPtr . Address of array containing numPids process ids. The id of the process (pipe) to wait for. The result of waiting on a process (pipe). Either 0 or ECHILD. The options controlling the wait. WNOHANG specifies not to wait when checking the process.","title":"ARGUMENTS"},{"location":"DetachPids/#description","text":"Tcl_DetachPids and Tcl_ReapDetachedProcs provide a mechanism for managing subprocesses that are running in background. These procedures are needed because the parent of a process must eventually invoke the waitpid kernel call (or one of a few other similar kernel calls) to wait for the child to exit. Until the parent waits for the child, the child\\'s state cannot be completely reclaimed by the system. If a parent continually creates children and doesn\\'t wait on them, the system\\'s process table will eventually overflow, even if all the children have exited. Tcl_DetachPids may be called to ask Tcl to take responsibility for one or more processes whose process ids are contained in the pidPtr array passed as argument. The caller presumably has started these processes running in background and does not want to have to deal with them again. Tcl_ReapDetachedProcs invokes the waitpid kernel call on each of the background processes so that its state can be cleaned up if it has exited. If the process has not exited yet, Tcl_ReapDetachedProcs does not wait for it to exit; it will check again the next time it is invoked. Tcl automatically calls Tcl_ReapDetachedProcs each time the exec command is executed, so in most cases it is not necessary for any code outside of Tcl to invoke Tcl_ReapDetachedProcs . However, if you call Tcl_DetachPids in situations where the exec command may never get executed, you may wish to call Tcl_ReapDetachedProcs from time to time so that background processes can be cleaned up. Tcl_WaitPid is a thin wrapper around the facilities provided by the operating system to wait on the end of a spawned process and to check a whether spawned process is still running. It is used by Tcl_ReapDetachedProcs and the channel system to portably access the operating system.","title":"DESCRIPTION"},{"location":"DetachPids/#keywords","text":"background, child, detach, process, wait","title":"KEYWORDS"},{"location":"DictObj/","text":"NAME Tcl_NewDictObj, Tcl_DictObjPut, Tcl_DictObjGet, Tcl_DictObjRemove, Tcl_DictObjSize, Tcl_DictObjFirst, Tcl_DictObjNext, Tcl_DictObjDone, Tcl_DictObjPutKeyList, Tcl_DictObjRemoveKeyList - manipulate Tcl values as dictionaries SYNOPSIS #include <tcl.h> Tcl_Obj * Tcl_NewDictObj() int Tcl_DictObjGet(interp, dictPtr, keyPtr, valuePtrPtr) int Tcl_DictObjPut(interp, dictPtr, keyPtr, valuePtr) int Tcl_DictObjRemove(interp, dictPtr, keyPtr) int Tcl_DictObjSize(interp, dictPtr, sizePtr) int Tcl_DictObjFirst(interp, dictPtr, searchPtr, keyPtrPtr, valuePtrPtr, donePtr) void Tcl_DictObjNext(searchPtr, keyPtrPtr, valuePtrPtr, donePtr) void Tcl_DictObjDone(searchPtr) int Tcl_DictObjPutKeyList(interp, dictPtr, keyc, keyv, valuePtr) int Tcl_DictObjRemoveKeyList(interp, dictPtr, keyc, keyv) ARGUMENTS If an error occurs while converting a value to be a dictionary value, an error message is left in the interpreter\\'s result value unless interp is NULL. Points to the dictionary value to be manipulated. If dictPtr does not already point to a dictionary value, an attempt will be made to convert it to one. Points to the key for the key/value pair being manipulated within the dictionary value. Points to a variable that will have the key from a key/value pair placed within it. May be NULL to indicate that the caller is not interested in the key. Points to the value for the key/value pair being manipulated within the dictionary value (or sub-value, in the case of Tcl_DictObjPutKeyList .) Points to a variable that will have the value from a key/value pair placed within it. For Tcl_DictObjFirst and Tcl_DictObjNext , this may be NULL to indicate that the caller is not interested in the value. Points to a variable that will have the number of key/value pairs contained within the dictionary placed within it. Pointer to record to use to keep track of progress in enumerating all key/value pairs in a dictionary. The contents of the record will be initialized by the call to Tcl_DictObjFirst . If the enumerating is to be terminated before all values in the dictionary have been returned, the search record must be passed to Tcl_DictObjDone to enable the internal locks to be released. Points to a variable that will have a non-zero value written into it when the enumeration of the key/value pairs in a dictionary has completed, and a zero otherwise. Indicates the number of keys that will be supplied in the keyv array. Array of keyc pointers to values that Tcl_DictObjPutKeyList and Tcl_DictObjRemoveKeyList will use to locate the key/value pair to manipulate within the sub-dictionaries of the main dictionary value passed to them. DESCRIPTION Tcl dictionary values have an internal representation that supports efficient mapping from keys to values and which guarantees that the particular ordering of keys within the dictionary remains the same modulo any keys being deleted (which removes them from the order) or added (which adds them to the end of the order). If reinterpreted as a list, the values at the even-valued indices in the list will be the keys of the dictionary, and each will be followed (in the odd-valued index) by the value associated with that key. The procedures described in this man page are used to create, modify, index, and iterate over dictionary values from C code. Tcl_NewDictObj creates a new, empty dictionary value. The string representation of the value will be invalid, and the reference count of the value will be zero. Tcl_DictObjGet looks up the given key within the given dictionary and writes a pointer to the value associated with that key into the variable pointed to by valuePtrPtr , or a NULL if the key has no mapping within the dictionary. The result of this procedure is TCL_OK , or TCL_ERROR if the dictPtr cannot be converted to a dictionary. Tcl_DictObjPut updates the given dictionary so that the given key maps to the given value; any key may exist at most once in any particular dictionary. The dictionary must not be shared, but the key and value may be. This procedure may increase the reference count of both key and value if it proves necessary to store them. Neither key nor value should be NULL. The result of this procedure is TCL_OK , or TCL_ERROR if the dictPtr cannot be converted to a dictionary. Tcl_DictObjRemove updates the given dictionary so that the given key has no mapping to any value. The dictionary must not be shared, but the key may be. The key actually stored in the dictionary will have its reference count decremented if it was present. It is not an error if the key did not previously exist. The result of this procedure is TCL_OK , or TCL_ERROR if the dictPtr cannot be converted to a dictionary. Tcl_DictObjSize updates the given variable with the number of key/value pairs currently in the given dictionary. The result of this procedure is TCL_OK , or TCL_ERROR if the dictPtr cannot be converted to a dictionary or if sizePtr points to a variable of type int and the dict contains more than 2**31 key/value pairs. Tcl_DictObjFirst commences an iteration across all the key/value pairs in the given dictionary, placing the key and value in the variables pointed to by the keyPtrPtr and valuePtrPtr arguments (which may be NULL to indicate that the caller is uninterested in they key or variable respectively.) The next key/value pair in the dictionary may be retrieved with Tcl_DictObjNext . Concurrent updates of the dictionary\\'s internal representation will not modify the iteration processing unless the dictionary is unshared, when this will trigger premature termination of the iteration instead (which Tcl scripts cannot trigger via the dict command.) The searchPtr argument points to a piece of context that is used to identify which particular iteration is being performed, and is initialized by the call to Tcl_DictObjFirst . The donePtr argument points to a variable that is updated to be zero of there are further key/value pairs to be iterated over, or non-zero if the iteration is complete. The order of iteration is implementation-defined. If the dictPtr argument cannot be converted to a dictionary, Tcl_DictObjFirst returns TCL_ERROR and the iteration is not commenced, and otherwise it returns TCL_OK . When Tcl_DictObjFirst is called upon a dictionary, a lock is placed on the dictionary to enable that dictionary to be iterated over safely without regard for whether the dictionary is modified during the iteration. Because of this, once the iteration over a dictionary\\'s keys has finished (whether because all values have been iterated over as indicated by the variable indicated by the donePtr argument being set to one, or because no further values are required) the Tcl_DictObjDone function must be called with the same searchPtr as was passed to Tcl_DictObjFirst so that the internal locks can be released. Once a particular searchPtr is passed to Tcl_DictObjDone , passing it to Tcl_DictObjNext (without first initializing it with Tcl_DictObjFirst ) will result in no values being produced and the variable pointed to by donePtr being set to one. It is safe to call Tcl_DictObjDone multiple times on the same searchPtr for each call to Tcl_DictObjFirst . The procedures Tcl_DictObjPutKeyList and Tcl_DictObjRemoveKeyList are the close analogues of Tcl_DictObjPut and Tcl_DictObjRemove respectively, except that instead of working with a single dictionary, they are designed to operate on a nested tree of dictionaries, with inner dictionaries stored as values inside outer dictionaries. The keyc and keyv arguments specify a list of keys (with outermost keys first) that acts as a path to the key/value pair to be affected. Note that there is no corresponding operation for reading a value for a path as this is easy to construct from repeated use of Tcl_DictObjGet . With Tcl_DictObjPutKeyList , nested dictionaries are created for non-terminal keys where they do not already exist. With Tcl_DictObjRemoveKeyList , all non-terminal keys must exist and have dictionaries as their values. REFERENCE COUNT MANAGEMENT Tcl_NewDictObj always returns a zero-reference object, much like Tcl_NewObj . Tcl_DictObjPut does not modify the reference count of its dictPtr argument, but does require that the object be unshared. If Tcl_DictObjPut returns TCL_ERROR it does not manipulate any reference counts; but if it returns TCL_OK then it definitely increments the reference count of valuePtr and may increment the reference count of keyPtr ; the latter case happens exactly when the key did not previously exist in the dictionary. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to an object, it will be deleted. Tcl_DictObjGet only reads from its dictPtr and keyPtr arguments, and does not manipulate their reference counts at all. If the valuePtrPtr argument is not set to NULL (and the function doesn\\'t return TCL_ERROR ), it will be set to a value with a reference count of at least 1, with a reference owned by the dictionary. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to an object, it will be deleted. Tcl_DictObjRemove does not modify the reference count of its dictPtr argument, but does require that the object be unshared. It does not manipulate the reference count of its keyPtr argument at all. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to an object, it will be deleted. Tcl_DictObjSize does not modify the reference count of its dictPtr argument; it only reads. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to the dictionary object, it will be deleted. Tcl_DictObjFirst does not modify the reference count of its dictPtr argument; it only reads. The variables given by the keyPtrPtr and valuePtrPtr arguments (if not NULL) will be updated to contain references to the relevant values in the dictionary; their reference counts will be at least 1 (due to the dictionary holding a reference to them). It may also manipulate internal references; these are not exposed to user code, but require a matching Tcl_DictObjDone call. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to the dictionary object, it will be deleted. Similarly for Tcl_DictObjNext ; the variables given by the keyPtrPtr and valuePtrPtr arguments (if not NULL) will be updated to contain references to the relevant values in the dictionary; their reference counts will be at least 1 (due to the dictionary holding a reference to them). Tcl_DictObjDone does not manipulate (user-visible) reference counts. Tcl_DictObjPutKeyList is similar to Tcl_DictObjPut ; it does not modify the reference count of its dictPtr argument, but does require that the object be unshared. It may increment the reference count of any value passed in the keyv argument, and will increment the reference count of the valuePtr argument on success. It is recommended that values passed via keyv and valuePtr do not have zero reference counts. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to an object, it will be deleted. Tcl_DictObjRemoveKeyList is similar to Tcl_DictObjRemove ; it does not modify the reference count of its dictPtr argument, but does require that the object be unshared, and does not modify the reference counts of any of the values passed in the keyv argument. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to an object, it will be deleted. EXAMPLE Using the dictionary iteration interface to search determine if there is a key that maps to itself: Tcl_DictSearch search; Tcl_Obj *key, *value; int done; /* * Assume interp and objPtr are parameters. This is the * idiomatic way to start an iteration over the dictionary; it * sets a lock on the internal representation that ensures that * there are no concurrent modification issues when normal * reference count management is also used. The lock is * released automatically when the loop is finished, but must * be released manually when an exceptional exit from the loop * is performed. However it is safe to try to release the lock * even if we\\'ve finished iterating over the loop. */ if ( Tcl_DictObjFirst (interp, objPtr, &search, &key, &value, &done) != TCL_OK) { return TCL_ERROR; } for (; !done ; Tcl_DictObjNext (&search, &key, &value, &done)) { /* * Note that strcmp() is not a good way of comparing * values and is just used here for demonstration * purposes. */ if (!strcmp(Tcl_GetString(key), Tcl_GetString(value))) { break; } } Tcl_DictObjDone (&search); Tcl_SetObjResult(interp, Tcl_NewBooleanObj(!done)); return TCL_OK; SEE ALSO Tcl_NewObj, Tcl_DecrRefCount, Tcl_IncrRefCount, Tcl_InitObjHashTable KEYWORDS dict, dict value, dictionary, dictionary value, hash table, iteration, value","title":"NAME"},{"location":"DictObj/#name","text":"Tcl_NewDictObj, Tcl_DictObjPut, Tcl_DictObjGet, Tcl_DictObjRemove, Tcl_DictObjSize, Tcl_DictObjFirst, Tcl_DictObjNext, Tcl_DictObjDone, Tcl_DictObjPutKeyList, Tcl_DictObjRemoveKeyList - manipulate Tcl values as dictionaries","title":"NAME"},{"location":"DictObj/#synopsis","text":"#include <tcl.h> Tcl_Obj * Tcl_NewDictObj() int Tcl_DictObjGet(interp, dictPtr, keyPtr, valuePtrPtr) int Tcl_DictObjPut(interp, dictPtr, keyPtr, valuePtr) int Tcl_DictObjRemove(interp, dictPtr, keyPtr) int Tcl_DictObjSize(interp, dictPtr, sizePtr) int Tcl_DictObjFirst(interp, dictPtr, searchPtr, keyPtrPtr, valuePtrPtr, donePtr) void Tcl_DictObjNext(searchPtr, keyPtrPtr, valuePtrPtr, donePtr) void Tcl_DictObjDone(searchPtr) int Tcl_DictObjPutKeyList(interp, dictPtr, keyc, keyv, valuePtr) int Tcl_DictObjRemoveKeyList(interp, dictPtr, keyc, keyv)","title":"SYNOPSIS"},{"location":"DictObj/#arguments","text":"If an error occurs while converting a value to be a dictionary value, an error message is left in the interpreter\\'s result value unless interp is NULL. Points to the dictionary value to be manipulated. If dictPtr does not already point to a dictionary value, an attempt will be made to convert it to one. Points to the key for the key/value pair being manipulated within the dictionary value. Points to a variable that will have the key from a key/value pair placed within it. May be NULL to indicate that the caller is not interested in the key. Points to the value for the key/value pair being manipulated within the dictionary value (or sub-value, in the case of Tcl_DictObjPutKeyList .) Points to a variable that will have the value from a key/value pair placed within it. For Tcl_DictObjFirst and Tcl_DictObjNext , this may be NULL to indicate that the caller is not interested in the value. Points to a variable that will have the number of key/value pairs contained within the dictionary placed within it. Pointer to record to use to keep track of progress in enumerating all key/value pairs in a dictionary. The contents of the record will be initialized by the call to Tcl_DictObjFirst . If the enumerating is to be terminated before all values in the dictionary have been returned, the search record must be passed to Tcl_DictObjDone to enable the internal locks to be released. Points to a variable that will have a non-zero value written into it when the enumeration of the key/value pairs in a dictionary has completed, and a zero otherwise. Indicates the number of keys that will be supplied in the keyv array. Array of keyc pointers to values that Tcl_DictObjPutKeyList and Tcl_DictObjRemoveKeyList will use to locate the key/value pair to manipulate within the sub-dictionaries of the main dictionary value passed to them.","title":"ARGUMENTS"},{"location":"DictObj/#description","text":"Tcl dictionary values have an internal representation that supports efficient mapping from keys to values and which guarantees that the particular ordering of keys within the dictionary remains the same modulo any keys being deleted (which removes them from the order) or added (which adds them to the end of the order). If reinterpreted as a list, the values at the even-valued indices in the list will be the keys of the dictionary, and each will be followed (in the odd-valued index) by the value associated with that key. The procedures described in this man page are used to create, modify, index, and iterate over dictionary values from C code. Tcl_NewDictObj creates a new, empty dictionary value. The string representation of the value will be invalid, and the reference count of the value will be zero. Tcl_DictObjGet looks up the given key within the given dictionary and writes a pointer to the value associated with that key into the variable pointed to by valuePtrPtr , or a NULL if the key has no mapping within the dictionary. The result of this procedure is TCL_OK , or TCL_ERROR if the dictPtr cannot be converted to a dictionary. Tcl_DictObjPut updates the given dictionary so that the given key maps to the given value; any key may exist at most once in any particular dictionary. The dictionary must not be shared, but the key and value may be. This procedure may increase the reference count of both key and value if it proves necessary to store them. Neither key nor value should be NULL. The result of this procedure is TCL_OK , or TCL_ERROR if the dictPtr cannot be converted to a dictionary. Tcl_DictObjRemove updates the given dictionary so that the given key has no mapping to any value. The dictionary must not be shared, but the key may be. The key actually stored in the dictionary will have its reference count decremented if it was present. It is not an error if the key did not previously exist. The result of this procedure is TCL_OK , or TCL_ERROR if the dictPtr cannot be converted to a dictionary. Tcl_DictObjSize updates the given variable with the number of key/value pairs currently in the given dictionary. The result of this procedure is TCL_OK , or TCL_ERROR if the dictPtr cannot be converted to a dictionary or if sizePtr points to a variable of type int and the dict contains more than 2**31 key/value pairs. Tcl_DictObjFirst commences an iteration across all the key/value pairs in the given dictionary, placing the key and value in the variables pointed to by the keyPtrPtr and valuePtrPtr arguments (which may be NULL to indicate that the caller is uninterested in they key or variable respectively.) The next key/value pair in the dictionary may be retrieved with Tcl_DictObjNext . Concurrent updates of the dictionary\\'s internal representation will not modify the iteration processing unless the dictionary is unshared, when this will trigger premature termination of the iteration instead (which Tcl scripts cannot trigger via the dict command.) The searchPtr argument points to a piece of context that is used to identify which particular iteration is being performed, and is initialized by the call to Tcl_DictObjFirst . The donePtr argument points to a variable that is updated to be zero of there are further key/value pairs to be iterated over, or non-zero if the iteration is complete. The order of iteration is implementation-defined. If the dictPtr argument cannot be converted to a dictionary, Tcl_DictObjFirst returns TCL_ERROR and the iteration is not commenced, and otherwise it returns TCL_OK . When Tcl_DictObjFirst is called upon a dictionary, a lock is placed on the dictionary to enable that dictionary to be iterated over safely without regard for whether the dictionary is modified during the iteration. Because of this, once the iteration over a dictionary\\'s keys has finished (whether because all values have been iterated over as indicated by the variable indicated by the donePtr argument being set to one, or because no further values are required) the Tcl_DictObjDone function must be called with the same searchPtr as was passed to Tcl_DictObjFirst so that the internal locks can be released. Once a particular searchPtr is passed to Tcl_DictObjDone , passing it to Tcl_DictObjNext (without first initializing it with Tcl_DictObjFirst ) will result in no values being produced and the variable pointed to by donePtr being set to one. It is safe to call Tcl_DictObjDone multiple times on the same searchPtr for each call to Tcl_DictObjFirst . The procedures Tcl_DictObjPutKeyList and Tcl_DictObjRemoveKeyList are the close analogues of Tcl_DictObjPut and Tcl_DictObjRemove respectively, except that instead of working with a single dictionary, they are designed to operate on a nested tree of dictionaries, with inner dictionaries stored as values inside outer dictionaries. The keyc and keyv arguments specify a list of keys (with outermost keys first) that acts as a path to the key/value pair to be affected. Note that there is no corresponding operation for reading a value for a path as this is easy to construct from repeated use of Tcl_DictObjGet . With Tcl_DictObjPutKeyList , nested dictionaries are created for non-terminal keys where they do not already exist. With Tcl_DictObjRemoveKeyList , all non-terminal keys must exist and have dictionaries as their values.","title":"DESCRIPTION"},{"location":"DictObj/#reference-count-management","text":"Tcl_NewDictObj always returns a zero-reference object, much like Tcl_NewObj . Tcl_DictObjPut does not modify the reference count of its dictPtr argument, but does require that the object be unshared. If Tcl_DictObjPut returns TCL_ERROR it does not manipulate any reference counts; but if it returns TCL_OK then it definitely increments the reference count of valuePtr and may increment the reference count of keyPtr ; the latter case happens exactly when the key did not previously exist in the dictionary. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to an object, it will be deleted. Tcl_DictObjGet only reads from its dictPtr and keyPtr arguments, and does not manipulate their reference counts at all. If the valuePtrPtr argument is not set to NULL (and the function doesn\\'t return TCL_ERROR ), it will be set to a value with a reference count of at least 1, with a reference owned by the dictionary. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to an object, it will be deleted. Tcl_DictObjRemove does not modify the reference count of its dictPtr argument, but does require that the object be unshared. It does not manipulate the reference count of its keyPtr argument at all. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to an object, it will be deleted. Tcl_DictObjSize does not modify the reference count of its dictPtr argument; it only reads. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to the dictionary object, it will be deleted. Tcl_DictObjFirst does not modify the reference count of its dictPtr argument; it only reads. The variables given by the keyPtrPtr and valuePtrPtr arguments (if not NULL) will be updated to contain references to the relevant values in the dictionary; their reference counts will be at least 1 (due to the dictionary holding a reference to them). It may also manipulate internal references; these are not exposed to user code, but require a matching Tcl_DictObjDone call. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to the dictionary object, it will be deleted. Similarly for Tcl_DictObjNext ; the variables given by the keyPtrPtr and valuePtrPtr arguments (if not NULL) will be updated to contain references to the relevant values in the dictionary; their reference counts will be at least 1 (due to the dictionary holding a reference to them). Tcl_DictObjDone does not manipulate (user-visible) reference counts. Tcl_DictObjPutKeyList is similar to Tcl_DictObjPut ; it does not modify the reference count of its dictPtr argument, but does require that the object be unshared. It may increment the reference count of any value passed in the keyv argument, and will increment the reference count of the valuePtr argument on success. It is recommended that values passed via keyv and valuePtr do not have zero reference counts. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to an object, it will be deleted. Tcl_DictObjRemoveKeyList is similar to Tcl_DictObjRemove ; it does not modify the reference count of its dictPtr argument, but does require that the object be unshared, and does not modify the reference counts of any of the values passed in the keyv argument. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to an object, it will be deleted.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"DictObj/#example","text":"Using the dictionary iteration interface to search determine if there is a key that maps to itself: Tcl_DictSearch search; Tcl_Obj *key, *value; int done; /* * Assume interp and objPtr are parameters. This is the * idiomatic way to start an iteration over the dictionary; it * sets a lock on the internal representation that ensures that * there are no concurrent modification issues when normal * reference count management is also used. The lock is * released automatically when the loop is finished, but must * be released manually when an exceptional exit from the loop * is performed. However it is safe to try to release the lock * even if we\\'ve finished iterating over the loop. */ if ( Tcl_DictObjFirst (interp, objPtr, &search, &key, &value, &done) != TCL_OK) { return TCL_ERROR; } for (; !done ; Tcl_DictObjNext (&search, &key, &value, &done)) { /* * Note that strcmp() is not a good way of comparing * values and is just used here for demonstration * purposes. */ if (!strcmp(Tcl_GetString(key), Tcl_GetString(value))) { break; } } Tcl_DictObjDone (&search); Tcl_SetObjResult(interp, Tcl_NewBooleanObj(!done)); return TCL_OK;","title":"EXAMPLE"},{"location":"DictObj/#see-also","text":"Tcl_NewObj, Tcl_DecrRefCount, Tcl_IncrRefCount, Tcl_InitObjHashTable","title":"SEE ALSO"},{"location":"DictObj/#keywords","text":"dict, dict value, dictionary, dictionary value, hash table, iteration, value","title":"KEYWORDS"},{"location":"DoOneEvent/","text":"NAME Tcl_DoOneEvent - wait for events and invoke event handlers SYNOPSIS #include <tcl.h> int Tcl_DoOneEvent(flags) ARGUMENTS This parameter is normally zero. It may be an OR-ed combination of any of the following flag bits: TCL_WINDOW_EVENTS , TCL_FILE_EVENTS , TCL_TIMER_EVENTS , TCL_IDLE_EVENTS , TCL_ALL_EVENTS , or TCL_DONT_WAIT . DESCRIPTION This procedure is the entry point to Tcl\\'s event loop; it is responsible for waiting for events and dispatching event handlers created with procedures such as Tk_CreateEventHandler , Tcl_CreateFileHandler , Tcl_CreateTimerHandler , and Tcl_DoWhenIdle . Tcl_DoOneEvent checks to see if events are already present on the Tcl event queue; if so, it calls the handler(s) for the first (oldest) event, removes it from the queue, and returns. If there are no events ready to be handled, then Tcl_DoOneEvent checks for new events from all possible sources. If any are found, it puts all of them on Tcl\\'s event queue, calls handlers for the first event on the queue, and returns. If no events are found, Tcl_DoOneEvent checks for Tcl_DoWhenIdle callbacks; if any are found, it invokes all of them and returns. Finally, if no events or idle callbacks have been found, then Tcl_DoOneEvent sleeps until an event occurs; then it adds any new events to the Tcl event queue, calls handlers for the first event, and returns. The normal return value is 1 to signify that some event was processed (see below for other alternatives). If the flags argument to Tcl_DoOneEvent is non-zero, it restricts the kinds of events that will be processed by Tcl_DoOneEvent . Flags may be an OR-ed combination of any of the following bits: TCL_WINDOW_EVENTS - : Process window system events. TCL_FILE_EVENTS - : Process file events. TCL_TIMER_EVENTS - : Process timer events. TCL_IDLE_EVENTS - : Process idle callbacks. TCL_ALL_EVENTS - : Process all kinds of events: equivalent to OR-ing together all of the above flags or specifying none of them. TCL_DONT_WAIT - : Do not sleep: process only events that are ready at the time of the call. If any of the flags TCL_WINDOW_EVENTS , TCL_FILE_EVENTS , TCL_TIMER_EVENTS , or TCL_IDLE_EVENTS is set, then the only events that will be considered are those for which flags are set. Setting none of these flags is equivalent to the value TCL_ALL_EVENTS , which causes all event types to be processed. If an application has defined additional event sources with Tcl_CreateEventSource , then additional flag values may also be valid, depending on those event sources. The TCL_DONT_WAIT flag causes Tcl_DoOneEvent not to put the process to sleep: it will check for events but if none are found then it returns immediately with a return value of 0 to indicate that no work was done. Tcl_DoOneEvent will also return 0 without doing anything if the only alternative is to block forever (this can happen, for example, if flags is TCL_IDLE_EVENTS and there are no Tcl_DoWhenIdle callbacks pending, or if no event handlers or timer handlers exist). Tcl_DoOneEvent may be invoked recursively. For example, it is possible to invoke Tcl_DoOneEvent recursively from a handler called by Tcl_DoOneEvent . This sort of operation is useful in some modal situations, such as when a notification dialog has been popped up and an application wishes to wait for the user to click a button in the dialog before doing anything else. KEYWORDS callback, event, handler, idle, timer","title":"NAME"},{"location":"DoOneEvent/#name","text":"Tcl_DoOneEvent - wait for events and invoke event handlers","title":"NAME"},{"location":"DoOneEvent/#synopsis","text":"#include <tcl.h> int Tcl_DoOneEvent(flags)","title":"SYNOPSIS"},{"location":"DoOneEvent/#arguments","text":"This parameter is normally zero. It may be an OR-ed combination of any of the following flag bits: TCL_WINDOW_EVENTS , TCL_FILE_EVENTS , TCL_TIMER_EVENTS , TCL_IDLE_EVENTS , TCL_ALL_EVENTS , or TCL_DONT_WAIT .","title":"ARGUMENTS"},{"location":"DoOneEvent/#description","text":"This procedure is the entry point to Tcl\\'s event loop; it is responsible for waiting for events and dispatching event handlers created with procedures such as Tk_CreateEventHandler , Tcl_CreateFileHandler , Tcl_CreateTimerHandler , and Tcl_DoWhenIdle . Tcl_DoOneEvent checks to see if events are already present on the Tcl event queue; if so, it calls the handler(s) for the first (oldest) event, removes it from the queue, and returns. If there are no events ready to be handled, then Tcl_DoOneEvent checks for new events from all possible sources. If any are found, it puts all of them on Tcl\\'s event queue, calls handlers for the first event on the queue, and returns. If no events are found, Tcl_DoOneEvent checks for Tcl_DoWhenIdle callbacks; if any are found, it invokes all of them and returns. Finally, if no events or idle callbacks have been found, then Tcl_DoOneEvent sleeps until an event occurs; then it adds any new events to the Tcl event queue, calls handlers for the first event, and returns. The normal return value is 1 to signify that some event was processed (see below for other alternatives). If the flags argument to Tcl_DoOneEvent is non-zero, it restricts the kinds of events that will be processed by Tcl_DoOneEvent . Flags may be an OR-ed combination of any of the following bits: TCL_WINDOW_EVENTS - : Process window system events. TCL_FILE_EVENTS - : Process file events. TCL_TIMER_EVENTS - : Process timer events. TCL_IDLE_EVENTS - : Process idle callbacks. TCL_ALL_EVENTS - : Process all kinds of events: equivalent to OR-ing together all of the above flags or specifying none of them. TCL_DONT_WAIT - : Do not sleep: process only events that are ready at the time of the call. If any of the flags TCL_WINDOW_EVENTS , TCL_FILE_EVENTS , TCL_TIMER_EVENTS , or TCL_IDLE_EVENTS is set, then the only events that will be considered are those for which flags are set. Setting none of these flags is equivalent to the value TCL_ALL_EVENTS , which causes all event types to be processed. If an application has defined additional event sources with Tcl_CreateEventSource , then additional flag values may also be valid, depending on those event sources. The TCL_DONT_WAIT flag causes Tcl_DoOneEvent not to put the process to sleep: it will check for events but if none are found then it returns immediately with a return value of 0 to indicate that no work was done. Tcl_DoOneEvent will also return 0 without doing anything if the only alternative is to block forever (this can happen, for example, if flags is TCL_IDLE_EVENTS and there are no Tcl_DoWhenIdle callbacks pending, or if no event handlers or timer handlers exist). Tcl_DoOneEvent may be invoked recursively. For example, it is possible to invoke Tcl_DoOneEvent recursively from a handler called by Tcl_DoOneEvent . This sort of operation is useful in some modal situations, such as when a notification dialog has been popped up and an application wishes to wait for the user to click a button in the dialog before doing anything else.","title":"DESCRIPTION"},{"location":"DoOneEvent/#keywords","text":"callback, event, handler, idle, timer","title":"KEYWORDS"},{"location":"DoWhenIdle/","text":"NAME Tcl_DoWhenIdle, Tcl_CancelIdleCall - invoke a procedure when there are no pending events SYNOPSIS #include <tcl.h> Tcl_DoWhenIdle(proc, clientData) Tcl_CancelIdleCall(proc, clientData) ARGUMENTS Procedure to invoke. Arbitrary one-word value to pass to proc . DESCRIPTION Tcl_DoWhenIdle arranges for proc to be invoked when the application becomes idle. The application is considered to be idle when Tcl_DoOneEvent has been called, could not find any events to handle, and is about to go to sleep waiting for an event to occur. At this point all pending Tcl_DoWhenIdle handlers are invoked. For each call to Tcl_DoWhenIdle there will be a single call to proc ; after proc is invoked the handler is automatically removed. Tcl_DoWhenIdle is only usable in programs that use Tcl_DoOneEvent to dispatch events. Proc should have arguments and result that match the type Tcl_IdleProc : typedef void Tcl_IdleProc ( void * clientData ); The clientData parameter to proc is a copy of the clientData argument given to Tcl_DoWhenIdle . Typically, clientData points to a data structure containing application-specific information about what proc should do. Tcl_CancelIdleCall may be used to cancel one or more previous calls to Tcl_DoWhenIdle : if there is a Tcl_DoWhenIdle handler registered for proc and clientData , then it is removed without invoking it. If there is more than one handler on the idle list that refers to proc and clientData , all of the handlers are removed. If no existing handlers match proc and clientData then nothing happens. Tcl_DoWhenIdle is most useful in situations where (a) a piece of work will have to be done but (b) it is possible that something will happen in the near future that will change what has to be done or require something different to be done. Tcl_DoWhenIdle allows the actual work to be deferred until all pending events have been processed. At this point the exact work to be done will presumably be known and it can be done exactly once. For example, Tcl_DoWhenIdle might be used by an editor to defer display updates until all pending commands have been processed. Without this feature, redundant redisplays might occur in some situations, such as the processing of a command file. BUGS At present it is not safe for an idle callback to reschedule itself continuously. This will interact badly with certain features of Tk that attempt to wait for all idle callbacks to complete. If you would like for an idle callback to reschedule itself continuously, it is better to use a timer handler with a zero timeout period. SEE ALSO after(n), Tcl_CreateFileHandler(3), Tcl_CreateTimerHandler(3) KEYWORDS callback, defer, idle callback","title":"NAME"},{"location":"DoWhenIdle/#name","text":"Tcl_DoWhenIdle, Tcl_CancelIdleCall - invoke a procedure when there are no pending events","title":"NAME"},{"location":"DoWhenIdle/#synopsis","text":"#include <tcl.h> Tcl_DoWhenIdle(proc, clientData) Tcl_CancelIdleCall(proc, clientData)","title":"SYNOPSIS"},{"location":"DoWhenIdle/#arguments","text":"Procedure to invoke. Arbitrary one-word value to pass to proc .","title":"ARGUMENTS"},{"location":"DoWhenIdle/#description","text":"Tcl_DoWhenIdle arranges for proc to be invoked when the application becomes idle. The application is considered to be idle when Tcl_DoOneEvent has been called, could not find any events to handle, and is about to go to sleep waiting for an event to occur. At this point all pending Tcl_DoWhenIdle handlers are invoked. For each call to Tcl_DoWhenIdle there will be a single call to proc ; after proc is invoked the handler is automatically removed. Tcl_DoWhenIdle is only usable in programs that use Tcl_DoOneEvent to dispatch events. Proc should have arguments and result that match the type Tcl_IdleProc : typedef void Tcl_IdleProc ( void * clientData ); The clientData parameter to proc is a copy of the clientData argument given to Tcl_DoWhenIdle . Typically, clientData points to a data structure containing application-specific information about what proc should do. Tcl_CancelIdleCall may be used to cancel one or more previous calls to Tcl_DoWhenIdle : if there is a Tcl_DoWhenIdle handler registered for proc and clientData , then it is removed without invoking it. If there is more than one handler on the idle list that refers to proc and clientData , all of the handlers are removed. If no existing handlers match proc and clientData then nothing happens. Tcl_DoWhenIdle is most useful in situations where (a) a piece of work will have to be done but (b) it is possible that something will happen in the near future that will change what has to be done or require something different to be done. Tcl_DoWhenIdle allows the actual work to be deferred until all pending events have been processed. At this point the exact work to be done will presumably be known and it can be done exactly once. For example, Tcl_DoWhenIdle might be used by an editor to defer display updates until all pending commands have been processed. Without this feature, redundant redisplays might occur in some situations, such as the processing of a command file.","title":"DESCRIPTION"},{"location":"DoWhenIdle/#bugs","text":"At present it is not safe for an idle callback to reschedule itself continuously. This will interact badly with certain features of Tk that attempt to wait for all idle callbacks to complete. If you would like for an idle callback to reschedule itself continuously, it is better to use a timer handler with a zero timeout period.","title":"BUGS"},{"location":"DoWhenIdle/#see-also","text":"after(n), Tcl_CreateFileHandler(3), Tcl_CreateTimerHandler(3)","title":"SEE ALSO"},{"location":"DoWhenIdle/#keywords","text":"callback, defer, idle callback","title":"KEYWORDS"},{"location":"DoubleObj/","text":"NAME Tcl_NewDoubleObj, Tcl_SetDoubleObj, Tcl_GetDoubleFromObj - manipulate Tcl values as floating-point values SYNOPSIS #include <tcl.h> Tcl_Obj * Tcl_NewDoubleObj(doubleValue) Tcl_SetDoubleObj(objPtr, doubleValue) int Tcl_GetDoubleFromObj(interp, objPtr, doublePtr) ARGUMENTS A double-precision floating-point value used to initialize or set a Tcl value. For Tcl_SetDoubleObj , this points to the value in which to store a double value. For Tcl_GetDoubleFromObj , this refers to the value from which to retrieve a double value. When non-NULL, an error message is left here when double value retrieval fails. Points to place to store the double value obtained from objPtr . DESCRIPTION These procedures are used to create, modify, and read Tcl values that hold double-precision floating-point values. Tcl_NewDoubleObj creates and returns a new Tcl value initialized to the double value doubleValue . The returned Tcl value is unshared. Tcl_SetDoubleObj sets the value of an existing Tcl value pointed to by objPtr to the double value doubleValue . The objPtr argument must point to an unshared Tcl value. Any attempt to set the value of a shared Tcl value violates Tcl\\'s copy-on-write policy. Any existing string representation or internal representation in the unshared Tcl value will be freed as a consequence of setting the new value. Tcl_GetDoubleFromObj attempts to retrieve a double value from the Tcl value objPtr . If the attempt succeeds, then TCL_OK is returned, and the double value is written to the storage pointed to by doublePtr . If the attempt fails, then TCL_ERROR is returned, and if interp is non-NULL, an error message is left in interp . The Tcl_ObjType of objPtr may be changed to make subsequent calls to Tcl_GetDoubleFromObj more efficient. REFERENCE COUNT MANAGEMENT Tcl_NewDoubleObj always returns a zero-reference object, much like Tcl_NewObj . Tcl_SetDoubleObj does not modify the reference count of its objPtr argument, but does require that the object be unshared. Tcl_GetDoubleFromObj does not modify the reference count of its objPtr argument; it only reads. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to the object, it will be deleted. SEE ALSO Tcl_NewObj, Tcl_DecrRefCount, Tcl_IncrRefCount, Tcl_GetObjResult KEYWORDS double, double value, double type, internal representation, value, value type, string representation","title":"NAME"},{"location":"DoubleObj/#name","text":"Tcl_NewDoubleObj, Tcl_SetDoubleObj, Tcl_GetDoubleFromObj - manipulate Tcl values as floating-point values","title":"NAME"},{"location":"DoubleObj/#synopsis","text":"#include <tcl.h> Tcl_Obj * Tcl_NewDoubleObj(doubleValue) Tcl_SetDoubleObj(objPtr, doubleValue) int Tcl_GetDoubleFromObj(interp, objPtr, doublePtr)","title":"SYNOPSIS"},{"location":"DoubleObj/#arguments","text":"A double-precision floating-point value used to initialize or set a Tcl value. For Tcl_SetDoubleObj , this points to the value in which to store a double value. For Tcl_GetDoubleFromObj , this refers to the value from which to retrieve a double value. When non-NULL, an error message is left here when double value retrieval fails. Points to place to store the double value obtained from objPtr .","title":"ARGUMENTS"},{"location":"DoubleObj/#description","text":"These procedures are used to create, modify, and read Tcl values that hold double-precision floating-point values. Tcl_NewDoubleObj creates and returns a new Tcl value initialized to the double value doubleValue . The returned Tcl value is unshared. Tcl_SetDoubleObj sets the value of an existing Tcl value pointed to by objPtr to the double value doubleValue . The objPtr argument must point to an unshared Tcl value. Any attempt to set the value of a shared Tcl value violates Tcl\\'s copy-on-write policy. Any existing string representation or internal representation in the unshared Tcl value will be freed as a consequence of setting the new value. Tcl_GetDoubleFromObj attempts to retrieve a double value from the Tcl value objPtr . If the attempt succeeds, then TCL_OK is returned, and the double value is written to the storage pointed to by doublePtr . If the attempt fails, then TCL_ERROR is returned, and if interp is non-NULL, an error message is left in interp . The Tcl_ObjType of objPtr may be changed to make subsequent calls to Tcl_GetDoubleFromObj more efficient.","title":"DESCRIPTION"},{"location":"DoubleObj/#reference-count-management","text":"Tcl_NewDoubleObj always returns a zero-reference object, much like Tcl_NewObj . Tcl_SetDoubleObj does not modify the reference count of its objPtr argument, but does require that the object be unshared. Tcl_GetDoubleFromObj does not modify the reference count of its objPtr argument; it only reads. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to the object, it will be deleted.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"DoubleObj/#see-also","text":"Tcl_NewObj, Tcl_DecrRefCount, Tcl_IncrRefCount, Tcl_GetObjResult","title":"SEE ALSO"},{"location":"DoubleObj/#keywords","text":"double, double value, double type, internal representation, value, value type, string representation","title":"KEYWORDS"},{"location":"DumpActiveMemory/","text":"NAME Tcl_DumpActiveMemory, Tcl_InitMemory, Tcl_ValidateAllMemory - Validated memory allocation interface SYNOPSIS #include <tcl.h> int Tcl_DumpActiveMemory(fileName) void Tcl_InitMemory(interp) void Tcl_ValidateAllMemory(fileName, line) ARGUMENTS Tcl interpreter in which to add commands. For Tcl_DumpActiveMemory , name of the file to which memory information will be written. For Tcl_ValidateAllMemory , name of the file from which the call is being made (normally __FILE__ ). Line number at which the call to Tcl_ValidateAllMemory is made (normally __LINE__ ). DESCRIPTION These functions provide access to Tcl memory debugging information. They are only functional when Tcl has been compiled with TCL_MEM_DEBUG defined at compile-time. When TCL_MEM_DEBUG is not defined, these functions are all no-ops. Tcl_DumpActiveMemory will output a list of all currently allocated memory to the specified file. The information output for each allocated block of memory is: starting and ending addresses (excluding guard zone), size, source file where Tcl_Alloc was called to allocate the block and line number in that file. It is especially useful to call Tcl_DumpActiveMemory after the Tcl interpreter has been deleted. Tcl_InitMemory adds the Tcl memory command to the interpreter given by interp . Tcl_InitMemory is called by Tcl_Main . Tcl_ValidateAllMemory forces a validation of the guard zones of all currently allocated blocks of memory. Normally validation of a block occurs when its freed, unless full validation is enabled, in which case validation of all blocks occurs when Tcl_Alloc and Tcl_Free are called. This function forces the validation to occur at any point. SEE ALSO TCL_MEM_DEBUG, memory KEYWORDS memory, debug","title":"NAME"},{"location":"DumpActiveMemory/#name","text":"Tcl_DumpActiveMemory, Tcl_InitMemory, Tcl_ValidateAllMemory - Validated memory allocation interface","title":"NAME"},{"location":"DumpActiveMemory/#synopsis","text":"#include <tcl.h> int Tcl_DumpActiveMemory(fileName) void Tcl_InitMemory(interp) void Tcl_ValidateAllMemory(fileName, line)","title":"SYNOPSIS"},{"location":"DumpActiveMemory/#arguments","text":"Tcl interpreter in which to add commands. For Tcl_DumpActiveMemory , name of the file to which memory information will be written. For Tcl_ValidateAllMemory , name of the file from which the call is being made (normally __FILE__ ). Line number at which the call to Tcl_ValidateAllMemory is made (normally __LINE__ ).","title":"ARGUMENTS"},{"location":"DumpActiveMemory/#description","text":"These functions provide access to Tcl memory debugging information. They are only functional when Tcl has been compiled with TCL_MEM_DEBUG defined at compile-time. When TCL_MEM_DEBUG is not defined, these functions are all no-ops. Tcl_DumpActiveMemory will output a list of all currently allocated memory to the specified file. The information output for each allocated block of memory is: starting and ending addresses (excluding guard zone), size, source file where Tcl_Alloc was called to allocate the block and line number in that file. It is especially useful to call Tcl_DumpActiveMemory after the Tcl interpreter has been deleted. Tcl_InitMemory adds the Tcl memory command to the interpreter given by interp . Tcl_InitMemory is called by Tcl_Main . Tcl_ValidateAllMemory forces a validation of the guard zones of all currently allocated blocks of memory. Normally validation of a block occurs when its freed, unless full validation is enabled, in which case validation of all blocks occurs when Tcl_Alloc and Tcl_Free are called. This function forces the validation to occur at any point.","title":"DESCRIPTION"},{"location":"DumpActiveMemory/#see-also","text":"TCL_MEM_DEBUG, memory","title":"SEE ALSO"},{"location":"DumpActiveMemory/#keywords","text":"memory, debug","title":"KEYWORDS"},{"location":"Encoding/","text":"NAME encoding - Work with encodings SYNOPSIS encoding operation ? arg arg ... ? INTRODUCTION In Tcl every string is composed of Unicode values. Text may be encoded into an encoding such as cp1252, iso8859-1, Shitf-JIS, utf-8, utf-16, etc. Not every Unicode vealue is encodable in every encoding, and some encodings can encode values that are not available in Unicode. Even though Unicode is for encoding the written texts of human languages, any sequence of bytes can be encoded as the first 255 Unicode values. iso8859-1 an encoding for a subset of Unicode in which each byte is a Unicode value of 255 or less. Thus, any sequence of bytes can be considered to be a Unicode string encoded in iso8859-1. To work with binary data in Tcl, decode it from iso8859-1 when reading it in, and encode it into iso8859-1 when writing it out, ensuring that each character in the string has a value of 255 or less. Decoding such a string does nothing, and encoding encoding such a string also does nothing. For example, the following is true: set text {In Tcl binary data is treated as Unicode text and it just works.} set encoded [encoding convertto iso8859-1 \\$text] expr {\\$text eq \\$encoded}; #-> 1 The following is also true: set decoded [encoding convertfrom iso8859-1 \\$text] expr {\\$text eq \\$decoded}; #-> 1 DESCRIPTION Performs one of the following encoding operations : encoding convertfrom ? encoding ? data : encoding convertfrom ? -profile profile ? ? -failindex var ? encoding data : Decodes data encoded in encoding . If encoding is not specified the current system encoding is used. -profile determines how invalid data for the encoding are handled. See the PROFILES section below for details. Returns an error if decoding fails. However, if -failindex given, returns the result of the conversion up to the point of termination, and stores in var the index of the character that could not be converted. If no errors are encountered the entire result of the conversion is returned and the value -1 is stored in var . encoding convertto ? encoding ? data : encoding convertto ? -profile profile ? ? -failindex var ? encoding data : Converts string to encoding . If encoding is not given, the current system encoding is used. See encoding convertfrom for the meaning of -profile and -failindex . encoding dirs ? directoryList ? : Sets the search path for *.enc encoding data files to the list of directories given by directoryList . If directoryList is not given, returns the current list of directories that make up the search path. It is not an error for an item in directoryList to not refer to a readable, searchable directory. encoding names : Returns a list of the names of available encodings. The encodings and are guaranteed to be present in the list. encoding profiles : Returns a list of names of available encoding profiles. See PROFILES below. <!-- --> encoding system ? encoding ? : Sets the system encoding to encoding . If encoding is not given, returns the current system encoding. The system encoding is used to pass strings to system calls. PROFILES Each profile is a distinct strategy for dealing with invalid data for an encoding. The following profiles are currently implemented. tcl8 : The default profile. Provides for behaviour identical to that of Tcl 8.6: When decoding, for encodings other than utf-8 , each invalid byte is interpreted as the Unicode value given by that one byte. For example, the byte 0x80, which is invalid in the ASCII encoding would be mapped to the Unicode value U+0080. For utf-8 , each invalid byte that is a valid CP1252 character is interpreted as the Unicode value for that character, while each byte that is not is treated as the Unicode value given by that one byte. For example, byte 0x80 is defined by CP1252 and is therefore mapped to its Unicode equivalent U+20AC while byte 0x81 which is not defined by CP1252 is mapped to U+0081. As an additional special case, the sequence 0xC0 0x80 is mapped to U+0000. When encoding, each character that cannot be represented in the encoding is replaced by an encoding-dependent character, usually the question mark ? . strict : The operation fails when invalid data for the encoding are encountered. replace : When decoding, invalid bytes are replaced by U+FFFD, the Unicode REPLACEMENT CHARACTER. When encoding, Unicode values that cannot be represented in the target encoding are transformed to an encoding-specific fallback character, U+FFFD REPLACEMENT CHARACTER for UTF targets, and generally `?` for other encodings. EXAMPLES These examples use the utility proc below that prints the Unicode value for each character in a string. proc codepoints s {join [lmap c [split \\$s {}] { string cat U+ [format %.6X [scan \\$c %c]]}] } Example 1: Convert from euc-jp: \\% codepoints [ encoding convertfrom euc-jp \\xA4\\xCF] U+00306F The result is the Unicode value which is the Hiragana letter HA. Example 2: Error handling based on profiles: The letter A is Unicode character U+0041 and the byte \\\"\\x80\\\" is invalid in ASCII encoding. \\% codepoints [encoding convertfrom -profile tcl8 ascii A\\x80] U+000041 U+000080 % codepoints [encoding convertfrom -profile replace ascii A\\x80] U+000041 U+00FFFD % codepoints [encoding convertfrom -profile strict ascii A\\x80] unexpected byte sequence starting at index 1: \\'\\x80\\' Example 3: Get partial data and the error location: \\% codepoints [encoding convertfrom -profile strict -failindex idx ascii AB\\x80] U+000041 U+000042 % set idx 2 Example 4: Encode a character that is not representable in ISO8859-1: \\% encoding convertto iso8859-1 A\\u0141 A? % encoding convertto -profile strict iso8859-1 A\\u0141 unexpected character at index 1: \\'U+000141\\' % encoding convertto -profile strict -failindex idx iso8859-1 A\\u0141 A % set idx 1 SEE ALSO Tcl_GetEncoding(3), fconfigure(n) KEYWORDS encoding, unicode","title":"NAME"},{"location":"Encoding/#name","text":"encoding - Work with encodings","title":"NAME"},{"location":"Encoding/#synopsis","text":"encoding operation ? arg arg ... ?","title":"SYNOPSIS"},{"location":"Encoding/#introduction","text":"In Tcl every string is composed of Unicode values. Text may be encoded into an encoding such as cp1252, iso8859-1, Shitf-JIS, utf-8, utf-16, etc. Not every Unicode vealue is encodable in every encoding, and some encodings can encode values that are not available in Unicode. Even though Unicode is for encoding the written texts of human languages, any sequence of bytes can be encoded as the first 255 Unicode values. iso8859-1 an encoding for a subset of Unicode in which each byte is a Unicode value of 255 or less. Thus, any sequence of bytes can be considered to be a Unicode string encoded in iso8859-1. To work with binary data in Tcl, decode it from iso8859-1 when reading it in, and encode it into iso8859-1 when writing it out, ensuring that each character in the string has a value of 255 or less. Decoding such a string does nothing, and encoding encoding such a string also does nothing. For example, the following is true: set text {In Tcl binary data is treated as Unicode text and it just works.} set encoded [encoding convertto iso8859-1 \\$text] expr {\\$text eq \\$encoded}; #-> 1 The following is also true: set decoded [encoding convertfrom iso8859-1 \\$text] expr {\\$text eq \\$decoded}; #-> 1","title":"INTRODUCTION"},{"location":"Encoding/#description","text":"Performs one of the following encoding operations : encoding convertfrom ? encoding ? data : encoding convertfrom ? -profile profile ? ? -failindex var ? encoding data : Decodes data encoded in encoding . If encoding is not specified the current system encoding is used. -profile determines how invalid data for the encoding are handled. See the PROFILES section below for details. Returns an error if decoding fails. However, if -failindex given, returns the result of the conversion up to the point of termination, and stores in var the index of the character that could not be converted. If no errors are encountered the entire result of the conversion is returned and the value -1 is stored in var . encoding convertto ? encoding ? data : encoding convertto ? -profile profile ? ? -failindex var ? encoding data : Converts string to encoding . If encoding is not given, the current system encoding is used. See encoding convertfrom for the meaning of -profile and -failindex . encoding dirs ? directoryList ? : Sets the search path for *.enc encoding data files to the list of directories given by directoryList . If directoryList is not given, returns the current list of directories that make up the search path. It is not an error for an item in directoryList to not refer to a readable, searchable directory. encoding names : Returns a list of the names of available encodings. The encodings and are guaranteed to be present in the list. encoding profiles : Returns a list of names of available encoding profiles. See PROFILES below. <!-- --> encoding system ? encoding ? : Sets the system encoding to encoding . If encoding is not given, returns the current system encoding. The system encoding is used to pass strings to system calls.","title":"DESCRIPTION"},{"location":"Encoding/#profiles","text":"Each profile is a distinct strategy for dealing with invalid data for an encoding. The following profiles are currently implemented. tcl8 : The default profile. Provides for behaviour identical to that of Tcl 8.6: When decoding, for encodings other than utf-8 , each invalid byte is interpreted as the Unicode value given by that one byte. For example, the byte 0x80, which is invalid in the ASCII encoding would be mapped to the Unicode value U+0080. For utf-8 , each invalid byte that is a valid CP1252 character is interpreted as the Unicode value for that character, while each byte that is not is treated as the Unicode value given by that one byte. For example, byte 0x80 is defined by CP1252 and is therefore mapped to its Unicode equivalent U+20AC while byte 0x81 which is not defined by CP1252 is mapped to U+0081. As an additional special case, the sequence 0xC0 0x80 is mapped to U+0000. When encoding, each character that cannot be represented in the encoding is replaced by an encoding-dependent character, usually the question mark ? . strict : The operation fails when invalid data for the encoding are encountered. replace : When decoding, invalid bytes are replaced by U+FFFD, the Unicode REPLACEMENT CHARACTER. When encoding, Unicode values that cannot be represented in the target encoding are transformed to an encoding-specific fallback character, U+FFFD REPLACEMENT CHARACTER for UTF targets, and generally `?` for other encodings.","title":"PROFILES"},{"location":"Encoding/#examples","text":"These examples use the utility proc below that prints the Unicode value for each character in a string. proc codepoints s {join [lmap c [split \\$s {}] { string cat U+ [format %.6X [scan \\$c %c]]}] } Example 1: Convert from euc-jp: \\% codepoints [ encoding convertfrom euc-jp \\xA4\\xCF] U+00306F The result is the Unicode value which is the Hiragana letter HA. Example 2: Error handling based on profiles: The letter A is Unicode character U+0041 and the byte \\\"\\x80\\\" is invalid in ASCII encoding. \\% codepoints [encoding convertfrom -profile tcl8 ascii A\\x80] U+000041 U+000080 % codepoints [encoding convertfrom -profile replace ascii A\\x80] U+000041 U+00FFFD % codepoints [encoding convertfrom -profile strict ascii A\\x80] unexpected byte sequence starting at index 1: \\'\\x80\\' Example 3: Get partial data and the error location: \\% codepoints [encoding convertfrom -profile strict -failindex idx ascii AB\\x80] U+000041 U+000042 % set idx 2 Example 4: Encode a character that is not representable in ISO8859-1: \\% encoding convertto iso8859-1 A\\u0141 A? % encoding convertto -profile strict iso8859-1 A\\u0141 unexpected character at index 1: \\'U+000141\\' % encoding convertto -profile strict -failindex idx iso8859-1 A\\u0141 A % set idx 1","title":"EXAMPLES"},{"location":"Encoding/#see-also","text":"Tcl_GetEncoding(3), fconfigure(n)","title":"SEE ALSO"},{"location":"Encoding/#keywords","text":"encoding, unicode","title":"KEYWORDS"},{"location":"Ensemble/","text":"NAME Tcl_CreateEnsemble, Tcl_FindEnsemble, Tcl_GetEnsembleFlags, Tcl_GetEnsembleMappingDict, Tcl_GetEnsembleNamespace, Tcl_GetEnsembleParameterList, Tcl_GetEnsembleUnknownHandler, Tcl_GetEnsembleSubcommandList, Tcl_IsEnsemble, Tcl_SetEnsembleFlags, Tcl_SetEnsembleMappingDict, Tcl_SetEnsembleParameterList, Tcl_SetEnsembleSubcommandList, Tcl_SetEnsembleUnknownHandler - manipulate ensemble commands SYNOPSIS #include <tcl.h> Tcl_Command Tcl_CreateEnsemble(interp, name, namespacePtr, ensFlags) Tcl_Command Tcl_FindEnsemble(interp, cmdNameObj, flags) int Tcl_IsEnsemble(token) int Tcl_GetEnsembleFlags(interp, token, ensFlagsPtr) int Tcl_SetEnsembleFlags(interp, token, ensFlags) int Tcl_GetEnsembleMappingDict(interp, token, dictObjPtr) int Tcl_SetEnsembleMappingDict(interp, token, dictObj) int Tcl_GetEnsembleParameterList(interp, token, listObjPtr) int Tcl_SetEnsembleParameterList(interp, token, listObj) int Tcl_GetEnsembleSubcommandList(interp, token, listObjPtr) int Tcl_SetEnsembleSubcommandList(interp, token, listObj) int Tcl_GetEnsembleUnknownHandler(interp, token, listObjPtr) int Tcl_SetEnsembleUnknownHandler(interp, token, listObj) int Tcl_GetEnsembleNamespace(interp, token, namespacePtrPtr) ARGUMENTS The interpreter in which the ensemble is to be created or found. Also where error result messages are written. The functions whose names start with Tcl_GetEnsemble may have a NULL for the interp , but all other functions must not. The name of the ensemble command to be created. The namespace to which the ensemble command is to be bound, or NULL for the current namespace. An OR\\'ed set of flag bits describing the basic configuration of the ensemble. Currently only one bit has meaning, TCL_ENSEMBLE_PREFIX , which is present when the ensemble command should also match unambiguous prefixes of subcommands. A value holding the name of the ensemble command to look up. An OR\\'ed set of flag bits controlling the behavior of Tcl_FindEnsemble . Currently only TCL_LEAVE_ERR_MSG is supported. A normal command token that refers to an ensemble command, or which you wish to use for testing as an ensemble command in Tcl_IsEnsemble . Pointer to a variable into which to write the current ensemble flag bits; currently only the bit TCL_ENSEMBLE_PREFIX is defined. A dictionary value to use for the subcommand to implementation command prefix mapping dictionary in the ensemble. May be NULL if the mapping dictionary is to be removed. Pointer to a variable into which to write the current ensemble mapping dictionary. A list value to use for the list of formal pre-subcommand parameters, the defined list of subcommands in the dictionary or the unknown subcommand handler command prefix. May be NULL if the subcommand list or unknown handler are to be removed. Pointer to a variable into which to write the current list of formal pre-subcommand parameters, the defined list of subcommands or the current unknown handler prefix. Pointer to a variable into which to write the handle of the namespace to which the ensemble is bound. DESCRIPTION An ensemble is a command, bound to some namespace, which consists of a collection of subcommands implemented by other Tcl commands. The first argument to the ensemble command is always interpreted as a selector that states what subcommand to execute. Ensembles are created using Tcl_CreateEnsemble , which takes four arguments: the interpreter to work within, the name of the ensemble to create, the namespace within the interpreter to bind the ensemble to, and the default set of ensemble flags. The result of the function is the command token for the ensemble, which may be used to further configure the ensemble using the API described below in ENSEMBLE PROPERTIES . Given the name of an ensemble command, the token for that command may be retrieved using Tcl_FindEnsemble . If the given command name (in cmdNameObj ) does not refer to an ensemble command, the result of the function is NULL and (if the TCL_LEAVE_ERR_MSG bit is set in flags ) an error message is left in the interpreter result. A command token may be checked to see if it refers to an ensemble using Tcl_IsEnsemble . This returns 1 if the token refers to an ensemble, or 0 otherwise. ENSEMBLE PROPERTIES Every ensemble has four read-write properties and a read-only property. The properties are: flags (read-write) : The set of flags for the ensemble, expressed as a bit-field. Currently, the only public flag is TCL_ENSEMBLE_PREFIX which is set when unambiguous prefixes of subcommands are permitted to be resolved to implementations as well as exact matches. The flags may be read and written using Tcl_GetEnsembleFlags and Tcl_SetEnsembleFlags respectively. The result of both of those functions is a Tcl result code ( TCL_OK , or TCL_ERROR if the token does not refer to an ensemble). mapping dictionary (read-write) : A dictionary containing a mapping from subcommand names to lists of words to use as a command prefix (replacing the first two words of the command which are the ensemble command itself and the subcommand name), or NULL if every subcommand is to be mapped to the command with the same unqualified name in the ensemble\\'s bound namespace. Defaults to NULL. May be read and written using Tcl_GetEnsembleMappingDict and Tcl_SetEnsembleMappingDict respectively. The result of both of those functions is a Tcl result code ( TCL_OK , or TCL_ERROR if the token does not refer to an ensemble) and the dictionary obtained from Tcl_GetEnsembleMappingDict should always be treated as immutable even if it is unshared. All command names in prefixes set via Tcl_SetEnsembleMappingDict must be fully qualified. formal pre-subcommand parameter list (read-write) : A list of formal parameter names (the names only being used when generating error messages) that come at invocation of the ensemble between the name of the ensemble and the subcommand argument. NULL (the default) is equivalent to the empty list. May be read and written using Tcl_GetEnsembleParameterList and Tcl_SetEnsembleParameterList respectively. The result of both of those functions is a Tcl result code ( TCL_OK , or TCL_ERROR if the token does not refer to an ensemble) and the dictionary obtained from Tcl_GetEnsembleParameterList should always be treated as immutable even if it is unshared. subcommand list (read-write) : A list of all the subcommand names for the ensemble, or NULL if this is to be derived from either the keys of the mapping dictionary (see above) or (if that is also NULL) from the set of commands exported by the bound namespace. May be read and written using Tcl_GetEnsembleSubcommandList and Tcl_SetEnsembleSubcommandList respectively. The result of both of those functions is a Tcl result code ( TCL_OK , or TCL_ERROR if the token does not refer to an ensemble) and the list obtained from Tcl_GetEnsembleSubcommandList should always be treated as immutable even if it is unshared. unknown subcommand handler command prefix (read-write) : A list of words to prepend on the front of any subcommand when the subcommand is unknown to the ensemble (according to the current prefix handling rule); see the namespace ensemble command for more details. If NULL, the default behavior - generate a suitable error message - will be used when an unknown subcommand is encountered. May be read and written using Tcl_GetEnsembleUnknownHandler and Tcl_SetEnsembleUnknownHandler respectively. The result of both functions is a Tcl result code ( TCL_OK , or TCL_ERROR if the token does not refer to an ensemble) and the list obtained from Tcl_GetEnsembleUnknownHandler should always be treated as immutable even if it is unshared. bound namespace (read-only) : The namespace to which the ensemble is bound; when the namespace is deleted, so too will the ensemble, and this namespace is also the namespace whose list of exported commands is used if both the mapping dictionary and the subcommand list properties are NULL. May be read using Tcl_GetEnsembleNamespace which returns a Tcl result code ( TCL_OK , or TCL_ERROR if the token does not refer to an ensemble). REFERENCE COUNT MANAGEMENT Tcl_FindEnsemble does not modify the reference count of its cmdNameObj argument; it only reads. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to the object, it will be deleted. The ensemble property getters ( Tcl_GetEnsembleMappingDict , Tcl_GetEnsembleParameterList , Tcl_GetEnsembleSubcommandList , and Tcl_GetEnsembleUnknownHandler ) do not manipulate the reference count of the values they provide out; if those are non-NULL, they will have a reference count of at least 1. Note that these functions may set the interpreter result. The ensemble property setters ( Tcl_SetEnsembleMappingDict , Tcl_SetEnsembleParameterList , Tcl_SetEnsembleSubcommandList , and Tcl_SetEnsembleUnknownHandler ) will increment the reference count of the new value of the property they are given if they succeed (and decrement the reference count of the old value of the property, if relevant). If the property setters return TCL_ERROR , the reference count of the Tcl_Obj argument is left unchanged. SEE ALSO namespace(n), Tcl_DeleteCommandFromToken(3) KEYWORDS command, ensemble","title":"NAME"},{"location":"Ensemble/#name","text":"Tcl_CreateEnsemble, Tcl_FindEnsemble, Tcl_GetEnsembleFlags, Tcl_GetEnsembleMappingDict, Tcl_GetEnsembleNamespace, Tcl_GetEnsembleParameterList, Tcl_GetEnsembleUnknownHandler, Tcl_GetEnsembleSubcommandList, Tcl_IsEnsemble, Tcl_SetEnsembleFlags, Tcl_SetEnsembleMappingDict, Tcl_SetEnsembleParameterList, Tcl_SetEnsembleSubcommandList, Tcl_SetEnsembleUnknownHandler - manipulate ensemble commands","title":"NAME"},{"location":"Ensemble/#synopsis","text":"#include <tcl.h> Tcl_Command Tcl_CreateEnsemble(interp, name, namespacePtr, ensFlags) Tcl_Command Tcl_FindEnsemble(interp, cmdNameObj, flags) int Tcl_IsEnsemble(token) int Tcl_GetEnsembleFlags(interp, token, ensFlagsPtr) int Tcl_SetEnsembleFlags(interp, token, ensFlags) int Tcl_GetEnsembleMappingDict(interp, token, dictObjPtr) int Tcl_SetEnsembleMappingDict(interp, token, dictObj) int Tcl_GetEnsembleParameterList(interp, token, listObjPtr) int Tcl_SetEnsembleParameterList(interp, token, listObj) int Tcl_GetEnsembleSubcommandList(interp, token, listObjPtr) int Tcl_SetEnsembleSubcommandList(interp, token, listObj) int Tcl_GetEnsembleUnknownHandler(interp, token, listObjPtr) int Tcl_SetEnsembleUnknownHandler(interp, token, listObj) int Tcl_GetEnsembleNamespace(interp, token, namespacePtrPtr)","title":"SYNOPSIS"},{"location":"Ensemble/#arguments","text":"The interpreter in which the ensemble is to be created or found. Also where error result messages are written. The functions whose names start with Tcl_GetEnsemble may have a NULL for the interp , but all other functions must not. The name of the ensemble command to be created. The namespace to which the ensemble command is to be bound, or NULL for the current namespace. An OR\\'ed set of flag bits describing the basic configuration of the ensemble. Currently only one bit has meaning, TCL_ENSEMBLE_PREFIX , which is present when the ensemble command should also match unambiguous prefixes of subcommands. A value holding the name of the ensemble command to look up. An OR\\'ed set of flag bits controlling the behavior of Tcl_FindEnsemble . Currently only TCL_LEAVE_ERR_MSG is supported. A normal command token that refers to an ensemble command, or which you wish to use for testing as an ensemble command in Tcl_IsEnsemble . Pointer to a variable into which to write the current ensemble flag bits; currently only the bit TCL_ENSEMBLE_PREFIX is defined. A dictionary value to use for the subcommand to implementation command prefix mapping dictionary in the ensemble. May be NULL if the mapping dictionary is to be removed. Pointer to a variable into which to write the current ensemble mapping dictionary. A list value to use for the list of formal pre-subcommand parameters, the defined list of subcommands in the dictionary or the unknown subcommand handler command prefix. May be NULL if the subcommand list or unknown handler are to be removed. Pointer to a variable into which to write the current list of formal pre-subcommand parameters, the defined list of subcommands or the current unknown handler prefix. Pointer to a variable into which to write the handle of the namespace to which the ensemble is bound.","title":"ARGUMENTS"},{"location":"Ensemble/#description","text":"An ensemble is a command, bound to some namespace, which consists of a collection of subcommands implemented by other Tcl commands. The first argument to the ensemble command is always interpreted as a selector that states what subcommand to execute. Ensembles are created using Tcl_CreateEnsemble , which takes four arguments: the interpreter to work within, the name of the ensemble to create, the namespace within the interpreter to bind the ensemble to, and the default set of ensemble flags. The result of the function is the command token for the ensemble, which may be used to further configure the ensemble using the API described below in ENSEMBLE PROPERTIES . Given the name of an ensemble command, the token for that command may be retrieved using Tcl_FindEnsemble . If the given command name (in cmdNameObj ) does not refer to an ensemble command, the result of the function is NULL and (if the TCL_LEAVE_ERR_MSG bit is set in flags ) an error message is left in the interpreter result. A command token may be checked to see if it refers to an ensemble using Tcl_IsEnsemble . This returns 1 if the token refers to an ensemble, or 0 otherwise.","title":"DESCRIPTION"},{"location":"Ensemble/#ensemble-properties","text":"Every ensemble has four read-write properties and a read-only property. The properties are: flags (read-write) : The set of flags for the ensemble, expressed as a bit-field. Currently, the only public flag is TCL_ENSEMBLE_PREFIX which is set when unambiguous prefixes of subcommands are permitted to be resolved to implementations as well as exact matches. The flags may be read and written using Tcl_GetEnsembleFlags and Tcl_SetEnsembleFlags respectively. The result of both of those functions is a Tcl result code ( TCL_OK , or TCL_ERROR if the token does not refer to an ensemble). mapping dictionary (read-write) : A dictionary containing a mapping from subcommand names to lists of words to use as a command prefix (replacing the first two words of the command which are the ensemble command itself and the subcommand name), or NULL if every subcommand is to be mapped to the command with the same unqualified name in the ensemble\\'s bound namespace. Defaults to NULL. May be read and written using Tcl_GetEnsembleMappingDict and Tcl_SetEnsembleMappingDict respectively. The result of both of those functions is a Tcl result code ( TCL_OK , or TCL_ERROR if the token does not refer to an ensemble) and the dictionary obtained from Tcl_GetEnsembleMappingDict should always be treated as immutable even if it is unshared. All command names in prefixes set via Tcl_SetEnsembleMappingDict must be fully qualified. formal pre-subcommand parameter list (read-write) : A list of formal parameter names (the names only being used when generating error messages) that come at invocation of the ensemble between the name of the ensemble and the subcommand argument. NULL (the default) is equivalent to the empty list. May be read and written using Tcl_GetEnsembleParameterList and Tcl_SetEnsembleParameterList respectively. The result of both of those functions is a Tcl result code ( TCL_OK , or TCL_ERROR if the token does not refer to an ensemble) and the dictionary obtained from Tcl_GetEnsembleParameterList should always be treated as immutable even if it is unshared. subcommand list (read-write) : A list of all the subcommand names for the ensemble, or NULL if this is to be derived from either the keys of the mapping dictionary (see above) or (if that is also NULL) from the set of commands exported by the bound namespace. May be read and written using Tcl_GetEnsembleSubcommandList and Tcl_SetEnsembleSubcommandList respectively. The result of both of those functions is a Tcl result code ( TCL_OK , or TCL_ERROR if the token does not refer to an ensemble) and the list obtained from Tcl_GetEnsembleSubcommandList should always be treated as immutable even if it is unshared. unknown subcommand handler command prefix (read-write) : A list of words to prepend on the front of any subcommand when the subcommand is unknown to the ensemble (according to the current prefix handling rule); see the namespace ensemble command for more details. If NULL, the default behavior - generate a suitable error message - will be used when an unknown subcommand is encountered. May be read and written using Tcl_GetEnsembleUnknownHandler and Tcl_SetEnsembleUnknownHandler respectively. The result of both functions is a Tcl result code ( TCL_OK , or TCL_ERROR if the token does not refer to an ensemble) and the list obtained from Tcl_GetEnsembleUnknownHandler should always be treated as immutable even if it is unshared. bound namespace (read-only) : The namespace to which the ensemble is bound; when the namespace is deleted, so too will the ensemble, and this namespace is also the namespace whose list of exported commands is used if both the mapping dictionary and the subcommand list properties are NULL. May be read using Tcl_GetEnsembleNamespace which returns a Tcl result code ( TCL_OK , or TCL_ERROR if the token does not refer to an ensemble).","title":"ENSEMBLE PROPERTIES"},{"location":"Ensemble/#reference-count-management","text":"Tcl_FindEnsemble does not modify the reference count of its cmdNameObj argument; it only reads. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to the object, it will be deleted. The ensemble property getters ( Tcl_GetEnsembleMappingDict , Tcl_GetEnsembleParameterList , Tcl_GetEnsembleSubcommandList , and Tcl_GetEnsembleUnknownHandler ) do not manipulate the reference count of the values they provide out; if those are non-NULL, they will have a reference count of at least 1. Note that these functions may set the interpreter result. The ensemble property setters ( Tcl_SetEnsembleMappingDict , Tcl_SetEnsembleParameterList , Tcl_SetEnsembleSubcommandList , and Tcl_SetEnsembleUnknownHandler ) will increment the reference count of the new value of the property they are given if they succeed (and decrement the reference count of the old value of the property, if relevant). If the property setters return TCL_ERROR , the reference count of the Tcl_Obj argument is left unchanged.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"Ensemble/#see-also","text":"namespace(n), Tcl_DeleteCommandFromToken(3)","title":"SEE ALSO"},{"location":"Ensemble/#keywords","text":"command, ensemble","title":"KEYWORDS"},{"location":"Environment/","text":"NAME Tcl_PutEnv - procedures to manipulate the environment SYNOPSIS #include <tcl.h> int Tcl_PutEnv(assignment) ARGUMENTS Info about environment variable in the format The assignment argument is in the system encoding. DESCRIPTION Tcl_PutEnv sets an environment variable. The information is passed in a single string of the form This procedure is intended to be a stand-in for the UNIX putenv system call. All Tcl-based applications using putenv should redefine it to Tcl_PutEnv so that they will interface properly to the Tcl runtime. SEE ALSO env(n) KEYWORDS environment, variable","title":"NAME"},{"location":"Environment/#name","text":"Tcl_PutEnv - procedures to manipulate the environment","title":"NAME"},{"location":"Environment/#synopsis","text":"#include <tcl.h> int Tcl_PutEnv(assignment)","title":"SYNOPSIS"},{"location":"Environment/#arguments","text":"Info about environment variable in the format The assignment argument is in the system encoding.","title":"ARGUMENTS"},{"location":"Environment/#description","text":"Tcl_PutEnv sets an environment variable. The information is passed in a single string of the form This procedure is intended to be a stand-in for the UNIX putenv system call. All Tcl-based applications using putenv should redefine it to Tcl_PutEnv so that they will interface properly to the Tcl runtime.","title":"DESCRIPTION"},{"location":"Environment/#see-also","text":"env(n)","title":"SEE ALSO"},{"location":"Environment/#keywords","text":"environment, variable","title":"KEYWORDS"},{"location":"Eval/","text":"NAME eval - Evaluate a Tcl script SYNOPSIS eval arg ? arg ... ? DESCRIPTION Eval takes one or more arguments, which together comprise a Tcl script containing one or more commands. Eval concatenates all its arguments in the same fashion as the concat command, passes the concatenated string to the Tcl interpreter recursively, and returns the result of that evaluation (or any error generated by it). Note that the list command quotes sequences of words in such a way that they are not further expanded by the eval command. EXAMPLES Often, it is useful to store a fragment of a script in a variable and execute it later on with extra values appended. This technique is used in a number of places throughout the Tcl core (e.g. in fcopy , lsort and trace command callbacks). This example shows how to do this using core Tcl commands: set script { puts \\\"logging now\\\" lappend \\$myCurrentLogVar } set myCurrentLogVar log1 # Set up a switch of logging variable part way through! after 20000 set myCurrentLogVar log2 for {set i 0} {\\$i\\<10} {incr i} { # Introduce a random delay after [expr {int(5000 * rand())}] update ;# Check for the asynch log switch eval \\$script \\$i [clock clicks] } Note that in the most common case (where the script fragment is actually just a list of words forming a command prefix), it is better to use {*}\\$script when doing this sort of invocation pattern. It is less general than the eval command, and hence easier to make robust in practice. The following procedure acts in a way that is analogous to the lappend command, except it inserts the argument values at the start of the list in the variable: proc lprepend {varName args} { upvar 1 \\$varName var # Ensure that the variable exists and contains a list lappend var # Now we insert all the arguments in one go set var [ eval [list linsert \\$var 0] \\$args] } However, the last line would now normally be written without eval , like this: set var [linsert \\$var 0 {*}\\$args] SEE ALSO catch(n), concat(n), error(n), errorCode(n), errorInfo(n), interp(n), list(n), namespace(n), subst(n), uplevel(n) KEYWORDS concatenate, evaluate, script","title":"NAME"},{"location":"Eval/#name","text":"eval - Evaluate a Tcl script","title":"NAME"},{"location":"Eval/#synopsis","text":"eval arg ? arg ... ?","title":"SYNOPSIS"},{"location":"Eval/#description","text":"Eval takes one or more arguments, which together comprise a Tcl script containing one or more commands. Eval concatenates all its arguments in the same fashion as the concat command, passes the concatenated string to the Tcl interpreter recursively, and returns the result of that evaluation (or any error generated by it). Note that the list command quotes sequences of words in such a way that they are not further expanded by the eval command.","title":"DESCRIPTION"},{"location":"Eval/#examples","text":"Often, it is useful to store a fragment of a script in a variable and execute it later on with extra values appended. This technique is used in a number of places throughout the Tcl core (e.g. in fcopy , lsort and trace command callbacks). This example shows how to do this using core Tcl commands: set script { puts \\\"logging now\\\" lappend \\$myCurrentLogVar } set myCurrentLogVar log1 # Set up a switch of logging variable part way through! after 20000 set myCurrentLogVar log2 for {set i 0} {\\$i\\<10} {incr i} { # Introduce a random delay after [expr {int(5000 * rand())}] update ;# Check for the asynch log switch eval \\$script \\$i [clock clicks] } Note that in the most common case (where the script fragment is actually just a list of words forming a command prefix), it is better to use {*}\\$script when doing this sort of invocation pattern. It is less general than the eval command, and hence easier to make robust in practice. The following procedure acts in a way that is analogous to the lappend command, except it inserts the argument values at the start of the list in the variable: proc lprepend {varName args} { upvar 1 \\$varName var # Ensure that the variable exists and contains a list lappend var # Now we insert all the arguments in one go set var [ eval [list linsert \\$var 0] \\$args] } However, the last line would now normally be written without eval , like this: set var [linsert \\$var 0 {*}\\$args]","title":"EXAMPLES"},{"location":"Eval/#see-also","text":"catch(n), concat(n), error(n), errorCode(n), errorInfo(n), interp(n), list(n), namespace(n), subst(n), uplevel(n)","title":"SEE ALSO"},{"location":"Eval/#keywords","text":"concatenate, evaluate, script","title":"KEYWORDS"},{"location":"Exit/","text":"NAME exit - End the application SYNOPSIS exit ? returnCode ? DESCRIPTION Terminate the process, returning returnCode to the system as the exit status. If returnCode is not specified then it defaults to 0. EXAMPLE Since non-zero exit codes are usually interpreted as error cases by the calling process, the exit command is an important part of signaling that something fatal has gone wrong. This code fragment is useful in scripts to act as a general problem trap: proc main {} { # ... put the real main code in here ... } if {[catch {main} msg options]} { puts stderr \\\"unexpected script error: \\$msg\\\" if {[info exists env(DEBUG)]} { puts stderr \\\"---- BEGIN TRACE ----\\\" puts stderr [dict get \\$options -errorinfo] puts stderr \\\"---- END TRACE ----\\\" } # Reserve code 1 for \\\"expected\\\" error exits... exit 2 } SEE ALSO exec(n) KEYWORDS abort, exit, process","title":"NAME"},{"location":"Exit/#name","text":"exit - End the application","title":"NAME"},{"location":"Exit/#synopsis","text":"exit ? returnCode ?","title":"SYNOPSIS"},{"location":"Exit/#description","text":"Terminate the process, returning returnCode to the system as the exit status. If returnCode is not specified then it defaults to 0.","title":"DESCRIPTION"},{"location":"Exit/#example","text":"Since non-zero exit codes are usually interpreted as error cases by the calling process, the exit command is an important part of signaling that something fatal has gone wrong. This code fragment is useful in scripts to act as a general problem trap: proc main {} { # ... put the real main code in here ... } if {[catch {main} msg options]} { puts stderr \\\"unexpected script error: \\$msg\\\" if {[info exists env(DEBUG)]} { puts stderr \\\"---- BEGIN TRACE ----\\\" puts stderr [dict get \\$options -errorinfo] puts stderr \\\"---- END TRACE ----\\\" } # Reserve code 1 for \\\"expected\\\" error exits... exit 2 }","title":"EXAMPLE"},{"location":"Exit/#see-also","text":"exec(n)","title":"SEE ALSO"},{"location":"Exit/#keywords","text":"abort, exit, process","title":"KEYWORDS"},{"location":"ExprLong/","text":"NAME Tcl_ExprLong, Tcl_ExprDouble, Tcl_ExprBoolean, Tcl_ExprString - evaluate an expression SYNOPSIS #include <tcl.h> int Tcl_ExprLong(interp, expr, longPtr) int Tcl_ExprDouble(interp, expr, doublePtr) int Tcl_ExprBoolean(interp, expr, booleanPtr) int Tcl_ExprString(interp, expr) ARGUMENTS Interpreter in whose context to evaluate expr . Expression to be evaluated. Pointer to location in which to store the integer value of the expression. Pointer to location in which to store the floating-point value of the expression. Pointer to location in which to store the 0/1 boolean value of the expression. DESCRIPTION These four procedures all evaluate the expression given by the expr argument and return the result in one of four different forms. The expression can have any of the forms accepted by the expr command. Note that these procedures have been largely replaced by the value-based procedures Tcl_ExprLongObj , Tcl_ExprDoubleObj , Tcl_ExprBooleanObj , and Tcl_ExprObj . Those value-based procedures evaluate an expression held in a Tcl value instead of a string. The value argument can retain an internal representation that is more efficient to execute. The interp argument refers to an interpreter used to evaluate the expression (e.g. for variables and nested Tcl commands) and to return error information. For all of these procedures the return value is a standard Tcl result: TCL_OK means the expression was successfully evaluated, and TCL_ERROR means that an error occurred while evaluating the expression. If TCL_ERROR is returned then the interpreter\\'s result will hold a message describing the error. If an error occurs while executing a Tcl command embedded in the expression then that error will be returned. If the expression is successfully evaluated, then its value is returned in one of four forms, depending on which procedure is invoked. Tcl_ExprLong stores an integer value at *longPtr . If the expression\\'s actual value is a floating-point number, then it is truncated to an integer. If the expression\\'s actual value is a non-numeric string then an error is returned. Tcl_ExprDouble stores a floating-point value at *doublePtr . If the expression\\'s actual value is an integer, it is converted to floating-point. If the expression\\'s actual value is a non-numeric string then an error is returned. Tcl_ExprBoolean stores a 0/1 integer value at *booleanPtr . If the expression\\'s actual value is an integer or floating-point number, then they store 0 at *booleanPtr if the value was zero and 1 otherwise. If the expression\\'s actual value is a non-numeric string then it must be one of the values accepted by Tcl_GetBoolean such as or or else an error occurs. Tcl_ExprString returns the value of the expression as a string stored in the interpreter\\'s result. SEE ALSO Tcl_ExprLongObj, Tcl_ExprDoubleObj, Tcl_ExprBooleanObj, Tcl_ExprObj KEYWORDS boolean, double, evaluate, expression, integer, value, string","title":"NAME"},{"location":"ExprLong/#name","text":"Tcl_ExprLong, Tcl_ExprDouble, Tcl_ExprBoolean, Tcl_ExprString - evaluate an expression","title":"NAME"},{"location":"ExprLong/#synopsis","text":"#include <tcl.h> int Tcl_ExprLong(interp, expr, longPtr) int Tcl_ExprDouble(interp, expr, doublePtr) int Tcl_ExprBoolean(interp, expr, booleanPtr) int Tcl_ExprString(interp, expr)","title":"SYNOPSIS"},{"location":"ExprLong/#arguments","text":"Interpreter in whose context to evaluate expr . Expression to be evaluated. Pointer to location in which to store the integer value of the expression. Pointer to location in which to store the floating-point value of the expression. Pointer to location in which to store the 0/1 boolean value of the expression.","title":"ARGUMENTS"},{"location":"ExprLong/#description","text":"These four procedures all evaluate the expression given by the expr argument and return the result in one of four different forms. The expression can have any of the forms accepted by the expr command. Note that these procedures have been largely replaced by the value-based procedures Tcl_ExprLongObj , Tcl_ExprDoubleObj , Tcl_ExprBooleanObj , and Tcl_ExprObj . Those value-based procedures evaluate an expression held in a Tcl value instead of a string. The value argument can retain an internal representation that is more efficient to execute. The interp argument refers to an interpreter used to evaluate the expression (e.g. for variables and nested Tcl commands) and to return error information. For all of these procedures the return value is a standard Tcl result: TCL_OK means the expression was successfully evaluated, and TCL_ERROR means that an error occurred while evaluating the expression. If TCL_ERROR is returned then the interpreter\\'s result will hold a message describing the error. If an error occurs while executing a Tcl command embedded in the expression then that error will be returned. If the expression is successfully evaluated, then its value is returned in one of four forms, depending on which procedure is invoked. Tcl_ExprLong stores an integer value at *longPtr . If the expression\\'s actual value is a floating-point number, then it is truncated to an integer. If the expression\\'s actual value is a non-numeric string then an error is returned. Tcl_ExprDouble stores a floating-point value at *doublePtr . If the expression\\'s actual value is an integer, it is converted to floating-point. If the expression\\'s actual value is a non-numeric string then an error is returned. Tcl_ExprBoolean stores a 0/1 integer value at *booleanPtr . If the expression\\'s actual value is an integer or floating-point number, then they store 0 at *booleanPtr if the value was zero and 1 otherwise. If the expression\\'s actual value is a non-numeric string then it must be one of the values accepted by Tcl_GetBoolean such as or or else an error occurs. Tcl_ExprString returns the value of the expression as a string stored in the interpreter\\'s result.","title":"DESCRIPTION"},{"location":"ExprLong/#see-also","text":"Tcl_ExprLongObj, Tcl_ExprDoubleObj, Tcl_ExprBooleanObj, Tcl_ExprObj","title":"SEE ALSO"},{"location":"ExprLong/#keywords","text":"boolean, double, evaluate, expression, integer, value, string","title":"KEYWORDS"},{"location":"ExprLongObj/","text":"NAME Tcl_ExprLongObj, Tcl_ExprDoubleObj, Tcl_ExprBooleanObj, Tcl_ExprObj - evaluate an expression SYNOPSIS #include <tcl.h> int Tcl_ExprLongObj(interp, objPtr, longPtr) int Tcl_ExprDoubleObj(interp, objPtr, doublePtr) int Tcl_ExprBooleanObj(interp, objPtr, booleanPtr) int Tcl_ExprObj(interp, objPtr, resultPtrPtr) ARGUMENTS Interpreter in whose context to evaluate objPtr . Pointer to a value containing the expression to evaluate. Pointer to location in which to store the integer value of the expression. Pointer to location in which to store the floating-point value of the expression. Pointer to location in which to store the 0/1 boolean value of the expression. Pointer to location in which to store a pointer to the value that is the result of the expression. DESCRIPTION These four procedures all evaluate an expression, returning the result in one of four different forms. The expression is given by the objPtr argument, and it can have any of the forms accepted by the expr command. The interp argument refers to an interpreter used to evaluate the expression (e.g. for variables and nested Tcl commands) and to return error information. For all of these procedures the return value is a standard Tcl result: TCL_OK means the expression was successfully evaluated, and TCL_ERROR means that an error occurred while evaluating the expression. If TCL_ERROR is returned, then a message describing the error can be retrieved using Tcl_GetObjResult . If an error occurs while executing a Tcl command embedded in the expression then that error will be returned. If the expression is successfully evaluated, then its value is returned in one of four forms, depending on which procedure is invoked. Tcl_ExprLongObj stores an integer value at *longPtr . If the expression\\'s actual value is a floating-point number, then it is truncated to an integer. If the expression\\'s actual value is a non-numeric string then an error is returned. Tcl_ExprDoubleObj stores a floating-point value at *doublePtr . If the expression\\'s actual value is an integer, it is converted to floating-point. If the expression\\'s actual value is a non-numeric string then an error is returned. Tcl_ExprBooleanObj stores a 0/1 integer value at *booleanPtr . If the expression\\'s actual value is an integer or floating-point number, then they store 0 at *booleanPtr if the value was zero and 1 otherwise. If the expression\\'s actual value is a non-numeric string then it must be one of the values accepted by Tcl_GetBoolean such as or or else an error occurs. If Tcl_ExprObj successfully evaluates the expression, it stores a pointer to the Tcl value containing the expression\\'s value at *resultPtrPtr . In this case, the caller is responsible for calling Tcl_DecrRefCount to decrement the value\\'s reference count when it is finished with the value. REFERENCE COUNT MANAGEMENT Tcl_ExprLongObj , Tcl_ExprDoubleObj , Tcl_ExprBooleanObj , and Tcl_ExprObj all increment and decrement the reference count of their objPtr arguments; you must not pass them any value with a reference count of zero. They also manipulate the interpreter result; you must not count on the interpreter result to hold the reference count of any value over these calls. SEE ALSO Tcl_ExprLong, Tcl_ExprDouble, Tcl_ExprBoolean, Tcl_ExprString, Tcl_GetObjResult KEYWORDS boolean, double, evaluate, expression, integer, value, string","title":"NAME"},{"location":"ExprLongObj/#name","text":"Tcl_ExprLongObj, Tcl_ExprDoubleObj, Tcl_ExprBooleanObj, Tcl_ExprObj - evaluate an expression","title":"NAME"},{"location":"ExprLongObj/#synopsis","text":"#include <tcl.h> int Tcl_ExprLongObj(interp, objPtr, longPtr) int Tcl_ExprDoubleObj(interp, objPtr, doublePtr) int Tcl_ExprBooleanObj(interp, objPtr, booleanPtr) int Tcl_ExprObj(interp, objPtr, resultPtrPtr)","title":"SYNOPSIS"},{"location":"ExprLongObj/#arguments","text":"Interpreter in whose context to evaluate objPtr . Pointer to a value containing the expression to evaluate. Pointer to location in which to store the integer value of the expression. Pointer to location in which to store the floating-point value of the expression. Pointer to location in which to store the 0/1 boolean value of the expression. Pointer to location in which to store a pointer to the value that is the result of the expression.","title":"ARGUMENTS"},{"location":"ExprLongObj/#description","text":"These four procedures all evaluate an expression, returning the result in one of four different forms. The expression is given by the objPtr argument, and it can have any of the forms accepted by the expr command. The interp argument refers to an interpreter used to evaluate the expression (e.g. for variables and nested Tcl commands) and to return error information. For all of these procedures the return value is a standard Tcl result: TCL_OK means the expression was successfully evaluated, and TCL_ERROR means that an error occurred while evaluating the expression. If TCL_ERROR is returned, then a message describing the error can be retrieved using Tcl_GetObjResult . If an error occurs while executing a Tcl command embedded in the expression then that error will be returned. If the expression is successfully evaluated, then its value is returned in one of four forms, depending on which procedure is invoked. Tcl_ExprLongObj stores an integer value at *longPtr . If the expression\\'s actual value is a floating-point number, then it is truncated to an integer. If the expression\\'s actual value is a non-numeric string then an error is returned. Tcl_ExprDoubleObj stores a floating-point value at *doublePtr . If the expression\\'s actual value is an integer, it is converted to floating-point. If the expression\\'s actual value is a non-numeric string then an error is returned. Tcl_ExprBooleanObj stores a 0/1 integer value at *booleanPtr . If the expression\\'s actual value is an integer or floating-point number, then they store 0 at *booleanPtr if the value was zero and 1 otherwise. If the expression\\'s actual value is a non-numeric string then it must be one of the values accepted by Tcl_GetBoolean such as or or else an error occurs. If Tcl_ExprObj successfully evaluates the expression, it stores a pointer to the Tcl value containing the expression\\'s value at *resultPtrPtr . In this case, the caller is responsible for calling Tcl_DecrRefCount to decrement the value\\'s reference count when it is finished with the value.","title":"DESCRIPTION"},{"location":"ExprLongObj/#reference-count-management","text":"Tcl_ExprLongObj , Tcl_ExprDoubleObj , Tcl_ExprBooleanObj , and Tcl_ExprObj all increment and decrement the reference count of their objPtr arguments; you must not pass them any value with a reference count of zero. They also manipulate the interpreter result; you must not count on the interpreter result to hold the reference count of any value over these calls.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"ExprLongObj/#see-also","text":"Tcl_ExprLong, Tcl_ExprDouble, Tcl_ExprBoolean, Tcl_ExprString, Tcl_GetObjResult","title":"SEE ALSO"},{"location":"ExprLongObj/#keywords","text":"boolean, double, evaluate, expression, integer, value, string","title":"KEYWORDS"},{"location":"FileSystem/","text":"NAME Tcl_FSRegister, Tcl_FSUnregister, Tcl_FSData, Tcl_FSMountsChanged, Tcl_FSGetFileSystemForPath, Tcl_FSGetPathType, Tcl_FSCopyFile, Tcl_FSCopyDirectory, Tcl_FSCreateDirectory, Tcl_FSDeleteFile, Tcl_FSRemoveDirectory, Tcl_FSRenameFile, Tcl_FSListVolumes, Tcl_FSEvalFile, Tcl_FSEvalFileEx, Tcl_FSLoadFile, Tcl_FSUnloadFile, Tcl_FSMatchInDirectory, Tcl_FSLink, Tcl_FSLstat, Tcl_FSUtime, Tcl_FSFileAttrsGet, Tcl_FSFileAttrsSet, Tcl_FSFileAttrStrings, Tcl_FSStat, Tcl_FSAccess, Tcl_FSOpenFileChannel, Tcl_FSGetCwd, Tcl_FSChdir, Tcl_FSPathSeparator, Tcl_FSJoinPath, Tcl_FSSplitPath, Tcl_FSEqualPaths, Tcl_FSGetNormalizedPath, Tcl_FSJoinToPath, Tcl_FSConvertToPathType, Tcl_FSGetInternalRep, Tcl_FSGetTranslatedPath, Tcl_FSGetTranslatedStringPath, Tcl_FSNewNativePath, Tcl_FSGetNativePath, Tcl_FSFileSystemInfo, Tcl_GetAccessTimeFromStat, Tcl_GetBlockSizeFromStat, Tcl_GetBlocksFromStat, Tcl_GetChangeTimeFromStat, Tcl_GetDeviceTypeFromStat, Tcl_GetFSDeviceFromStat, Tcl_GetFSInodeFromStat, Tcl_GetGroupIdFromStat, Tcl_GetLinkCountFromStat, Tcl_GetModeFromStat, Tcl_GetModificationTimeFromStat, Tcl_GetSizeFromStat, Tcl_GetUserIdFromStat, Tcl_AllocStatBuf - procedures to interact with any filesystem SYNOPSIS #include <tcl.h> int Tcl_FSRegister(clientData, fsPtr) int Tcl_FSUnregister(fsPtr) void * Tcl_FSData(fsPtr) void Tcl_FSMountsChanged(fsPtr) const Tcl_Filesystem * Tcl_FSGetFileSystemForPath(pathPtr) Tcl_PathType Tcl_FSGetPathType(pathPtr) int Tcl_FSCopyFile(srcPathPtr, destPathPtr) int Tcl_FSCopyDirectory(srcPathPtr, destPathPtr, errorPtr) int Tcl_FSCreateDirectory(pathPtr) int Tcl_FSDeleteFile(pathPtr) int Tcl_FSRemoveDirectory(pathPtr, recursive, errorPtr) int Tcl_FSRenameFile(srcPathPtr, destPathPtr) Tcl_Obj * Tcl_FSListVolumes(void) int Tcl_FSEvalFileEx(interp, pathPtr, encodingName) int Tcl_FSEvalFile(interp, pathPtr) int Tcl_FSLoadFile(interp, pathPtr, sym1, sym2, proc1Ptr, proc2Ptr, loadHandlePtr, unloadProcPtr) int Tcl_FSUnloadFile(interp, loadHandle) int Tcl_FSMatchInDirectory(interp, resultPtr, pathPtr, pattern, types) Tcl_Obj * Tcl_FSLink(linkNamePtr, toPtr, linkAction) int Tcl_FSLstat(pathPtr, statPtr) int Tcl_FSUtime(pathPtr, tval) int Tcl_FSFileAttrsGet(interp, index, pathPtr, objPtrRef) int Tcl_FSFileAttrsSet(interp, index, pathPtr, objPtr) const char *const * Tcl_FSFileAttrStrings(pathPtr, objPtrRef) int Tcl_FSStat(pathPtr, statPtr) int Tcl_FSAccess(pathPtr, mode) Tcl_Channel Tcl_FSOpenFileChannel(interp, pathPtr, modeString, permissions) Tcl_Obj * Tcl_FSGetCwd(interp) int Tcl_FSChdir(pathPtr) Tcl_Obj * Tcl_FSPathSeparator(pathPtr) Tcl_Obj * Tcl_FSJoinPath(listObj, elements) Tcl_Obj * Tcl_FSSplitPath(pathPtr, lenPtr) int Tcl_FSEqualPaths(firstPtr, secondPtr) Tcl_Obj * Tcl_FSGetNormalizedPath(interp, pathPtr) Tcl_Obj * Tcl_FSJoinToPath(basePtr, objc, objv) int Tcl_FSConvertToPathType(interp, pathPtr) void * Tcl_FSGetInternalRep(pathPtr, fsPtr) Tcl_Obj * Tcl_FSGetTranslatedPath(interp, pathPtr) const char * Tcl_FSGetTranslatedStringPath(interp, pathPtr) Tcl_Obj * Tcl_FSNewNativePath(fsPtr, clientData) const void * Tcl_FSGetNativePath(pathPtr) Tcl_Obj * Tcl_FSFileSystemInfo(pathPtr) Tcl_StatBuf * Tcl_AllocStatBuf() long long Tcl_GetAccessTimeFromStat(statPtr) unsigned Tcl_GetBlockSizeFromStat(statPtr) unsigned long long Tcl_GetBlocksFromStat(statPtr) long long Tcl_GetChangeTimeFromStat(statPtr) int Tcl_GetDeviceTypeFromStat(statPtr) unsigned Tcl_GetFSDeviceFromStat(statPtr) unsigned Tcl_GetFSInodeFromStat(statPtr) int Tcl_GetGroupIdFromStat(statPtr) int Tcl_GetLinkCountFromStat(statPtr) unsigned Tcl_GetModeFromStat(statPtr) long long Tcl_GetModificationTimeFromStat(statPtr) unsigned long long Tcl_GetSizeFromStat(statPtr) int Tcl_GetUserIdFromStat(statPtr) ARGUMENTS Points to a structure containing the addresses of procedures that can be called to perform the various filesystem operations. The path represented by this value is used for the operation in question. If the value does not already have an internal path representation, it will be converted to have one. As for pathPtr , but used for the source file for a copy or rename operation. As for pathPtr , but used for the destination filename for a copy or rename operation. Whether to remove subdirectories and their contents as well. The encoding of the data stored in the file identified by pathPtr and to be evaluated. Only files or directories matching this pattern will be returned. Only files or directories matching the type descriptions contained in this structure will be returned. This parameter may be NULL. Interpreter to use either for results, evaluation, or reporting error messages. The native description of the path value to create. The first of two path values to compare. The value may be converted to path type. The second of two path values to compare. The value may be converted to path type. The list of path elements to operate on with a join operation. The number of elements in the listObj which should be joined together. If negative, then all elements are joined. In the case of an error, filled with a value containing the name of the file which caused an error in the various copy/rename operations. The index of the attribute in question. The value to set in the operation. Filled with a value containing the result of the operation. Preallocated value in which to store (using Tcl_ListObjAppendElement ) the list of files or directories which are successfully matched. Mask consisting of one or more of R_OK, W_OK, X_OK and F_OK. R_OK, W_OK and X_OK request checking whether the file exists and has read, write and execute permissions, respectively. F_OK just requests checking for the existence of the file. The structure that contains the result of a stat or lstat operation. Name of a procedure to look up in the file\\'s symbol table Name of a procedure to look up in the file\\'s symbol table Filled with the init function for this code. Filled with the safe-init function for this code. Filled with the clientData value to pass to this code\\'s unload function when it is called. Filled with an abstract token representing the loaded file. Filled with the function to use to unload this piece of code. Handle to the loaded library to be unloaded. The access and modification times in this structure are read and used to set those values for a given file. Specifies how the file is to be accessed. May have any of the values allowed for the mode argument to the Tcl open command. POSIX-style permission flags such as 0644. If a new file is created, these permissions will be set on the created file. If non-NULL, filled with the number of elements in the split path. The base path on to which to join the given elements. May be NULL. The number of elements in objv . The elements to join to the given base path. The name of the link to be created or read. What the link called linkNamePtr should be linked to, or NULL if the symbolic link specified by linkNamePtr is to be read. OR-ed combination of flags indicating what kind of link should be created (will be ignored if toPtr is NULL). Valid bits to set are TCL_CREATE_SYMBOLIC_LINK and TCL_CREATE_HARD_LINK . When both flags are set and the underlying filesystem can do either, symbolic links are preferred. DESCRIPTION There are several reasons for calling the Tcl_FS API functions (e.g. Tcl_FSAccess and Tcl_FSStat ) rather than calling system level functions like access and stat directly. First, they will work cross-platform, so an extension which calls them should work unmodified on Unix and Windows. Second, the Windows implementation of some of these functions fixes some bugs in the system level calls. Third, these function calls deal with any path conversions which may be required (and may cache the results of such conversions for greater efficiency on subsequent calls). Fourth, and perhaps most importantly, all of these functions are Any virtual filesystem (VFS for short) which has been registered (through Tcl_FSRegister ) may reroute file access to alternative media or access methods. This means that all of these functions (and therefore the corresponding file , glob , pwd , cd , open , etc. Tcl commands) may be operate on which are not native files in the native filesystem. This also means that any Tcl extension which accesses the filesystem (FS for short) through this API is automatically Of course, if an extension accesses the native filesystem directly (through platform-specific APIs, for example), then Tcl cannot intercept such calls. If appropriate VFSes have been registered, the may, to give two examples, be remote (e.g. situated on a remote ftp server) or archived (e.g. lying inside a .zip archive). Such registered filesystems provide a lookup table of functions to implement all or some of the functionality listed here. Finally, the Tcl_FSStat and Tcl_FSLstat calls abstract away from what the buffer is actually declared to be, allowing the same code to be used both on systems with and systems without support for files larger than 2GB in size. The Tcl_FS API is Tcl_Obj -ified and may cache internal representations and other path-related strings (e.g. the current working directory). One side-effect of this is that one must not pass in values with a reference count of zero to any of these functions. If such calls were handled, they might result in memory leaks (under some circumstances, the filesystem code may wish to retain a reference to the passed in value, and so one must not assume that after any of these calls return, the value still has a reference count of zero - it may have been incremented) or in a direct segmentation fault (or other memory access error) due to the value being freed part way through the complex value manipulation required to ensure that the path is fully normalized and absolute for filesystem determination. The practical lesson to learn from this is that Tcl_Obj *path = Tcl_NewStringObj(...); Tcl_FS Whatever (path); Tcl_DecrRefCount(path); is wrong, and may cause memory errors. The path must have its reference count incremented before passing it in, or decrementing it. For this reason, values with a reference count of zero are considered not to be valid filesystem paths and calling any Tcl_FS API function with such a value will result in no action being taken. FS API FUNCTIONS Tcl_FSCopyFile attempts to copy the file given by srcPathPtr to the path name given by destPathPtr . If the two paths given lie in the same filesystem (according to Tcl_FSGetFileSystemForPath ) then that filesystem\\'s function is called (if it is non-NULL). Otherwise the function returns -1 and sets the errno global C variable to the POSIX error code (which signifies a Tcl_FSCopyDirectory attempts to copy the directory given by srcPathPtr to the path name given by destPathPtr . If the two paths given lie in the same filesystem (according to Tcl_FSGetFileSystemForPath ) then that filesystem\\'s function is called (if it is non-NULL). Otherwise the function returns -1 and sets the errno global C variable to the POSIX error code (which signifies a Tcl_FSCreateDirectory attempts to create the directory given by pathPtr by calling the owning filesystem\\'s function. Tcl_FSDeleteFile attempts to delete the file given by pathPtr by calling the owning filesystem\\'s function. Tcl_FSRemoveDirectory attempts to remove the directory given by pathPtr by calling the owning filesystem\\'s function. Tcl_FSRenameFile attempts to rename the file or directory given by srcPathPtr to the path name given by destPathPtr . If the two paths given lie in the same filesystem (according to Tcl_FSGetFileSystemForPath ) then that filesystem\\'s function is called (if it is non-NULL). Otherwise the function returns -1 and sets the errno global C variable to the POSIX error code (which signifies a Tcl_FSListVolumes calls each filesystem which has a non-NULL function and asks them to return their list of root volumes. It accumulates the return values in a list which is returned to the caller (with a reference count of 0). Tcl_FSEvalFileEx reads the file given by pathPtr using the encoding identified by encodingName and evaluates its contents as a Tcl script. It returns the same information as Tcl_EvalObjEx . If encodingName is NULL, the utf-8 encoding is used for reading the file contents. If the file could not be read then a Tcl error is returned to describe why the file could not be read. The eofchar for files is (\\^Z) for all platforms. If you require a in code for string comparison, you can use which will be safely substituted by the Tcl interpreter into Tcl_FSEvalFile is a simpler version of Tcl_FSEvalFileEx that always uses the utf-8 encoding when reading the file. Tcl_FSLoadFile dynamically loads a binary code file into memory and returns the addresses of two procedures within that file, if they are defined. The appropriate function for the filesystem to which pathPtr belongs will be called. If that filesystem does not implement this function (most virtual filesystems will not, because of OS limitations in dynamically loading binary code), Tcl will attempt to copy the file to a temporary directory and load that temporary file. Tcl_FSUnloadFile reverses the operation, asking for the library indicated by the loadHandle to be removed from the process. Note that, unlike with the unload command, this does not give the library any opportunity to clean up. Both the above functions return a standard Tcl completion code. If an error occurs, an error message is left in the interp \\'s result. The token provided via the variable indicated by loadHandlePtr may be used with Tcl_FindSymbol . Tcl_FSMatchInDirectory is used by the globbing code to search a directory for all files which match a given pattern. The appropriate function for the filesystem to which pathPtr belongs will be called. The return value is a standard Tcl result indicating whether an error occurred in globbing. Error messages are placed in interp (unless interp is NULL, which is allowed), but good results are placed in the resultPtr given. Note that the glob code implements recursive patterns internally, so this function will only ever be passed simple patterns, which can be matched using the logic of string match . To handle recursion, Tcl will call this function frequently asking only for directories to be returned. A special case of being called with a NULL pattern indicates that the path needs to be checked only for the correct type. Tcl_FSLink replaces the library version of readlink , and extends it to support the creation of links. The appropriate function for the filesystem to which linkNamePtr belongs will be called. If the toPtr is NULL, a action is performed. The result is a Tcl_Obj specifying the contents of the symbolic link given by linkNamePtr , or NULL if the link could not be read. The result is owned by the caller, which should call Tcl_DecrRefCount when the result is no longer needed. If the toPtr is not NULL, Tcl should create a link of one of the types passed in in the linkAction flag. This flag is an OR\\'ed combination of TCL_CREATE_SYMBOLIC_LINK and TCL_CREATE_HARD_LINK . Where a choice exists (i.e. more than one flag is passed in), the Tcl convention is to prefer symbolic links. When a link is successfully created, the return value should be toPtr (which is therefore already owned by the caller). If unsuccessful, NULL is returned. Tcl_FSLstat fills the Tcl_StatBuf structure statPtr with information about the specified file. You do not need any access rights to the file to get this information but you need search rights to all directories named in the path leading to the file. The Tcl_StatBuf structure includes info regarding device, inode (always 0 on Windows), privilege mode, nlink (always 1 on Windows), user id (always 0 on Windows), group id (always 0 on Windows), rdev (same as device on Windows), size, last access time, last modification time, and last metadata change time. See PORTABLE STAT RESULT API for a description of how to write portable code to allocate and access the Tcl_StatBuf structure. If path exists, Tcl_FSLstat returns 0 and the stat structure is filled with data. Otherwise, -1 is returned, and no stat info is given. Tcl_FSUtime replaces the library version of utime. This returns 0 on success and -1 on error (as per the utime documentation). If successful, the function will update the and values of the file given. Tcl_FSFileAttrsGet implements read access for the hookable file attributes subcommand. The appropriate function for the filesystem to which pathPtr belongs will be called. If the result is TCL_OK , then a value was placed in objPtrRef , which will only be temporarily valid (unless Tcl_IncrRefCount is called). Tcl_FSFileAttrsSet implements write access for the hookable file attributes subcommand. The appropriate function for the filesystem to which pathPtr belongs will be called. Tcl_FSFileAttrStrings implements part of the hookable file attributes subcommand. The appropriate function for the filesystem to which pathPtr belongs will be called. The called procedure may either return an array of strings, or may instead return NULL and place a Tcl list into the given objPtrRef . Tcl will take that list and first increment its reference count before using it. On completion of that use, Tcl will decrement its reference count. Hence if the list should be disposed of by Tcl when done, it should have a reference count of zero, and if the list should not be disposed of, the filesystem should ensure it retains a reference count to the value. Tcl_FSAccess checks whether the process would be allowed to read, write or test for existence of the file (or other filesystem object) whose name is pathname . If pathname is a symbolic link on Unix, then permissions of the file referred by this symbolic link are tested. On success (all requested permissions granted), zero is returned. On error (at least one bit in mode asked for a permission that is denied, or some other error occurred), -1 is returned. Tcl_FSStat fills the Tcl_StatBuf structure statPtr with information about the specified file. You do not need any access rights to the file to get this information but you need search rights to all directories named in the path leading to the file. The Tcl_StatBuf structure includes info regarding device, inode (always 0 on Windows), privilege mode, nlink (always 1 on Windows), user id (always 0 on Windows), group id (always 0 on Windows), rdev (same as device on Windows), size, last access time, last modification time, and last metadata change time. See PORTABLE STAT RESULT API for a description of how to write portable code to allocate and access the Tcl_StatBuf structure. If path exists, Tcl_FSStat returns 0 and the stat structure is filled with data. Otherwise, -1 is returned, and no stat info is given. Tcl_FSOpenFileChannel opens a file specified by pathPtr and returns a channel handle that can be used to perform input and output on the file. This API is modeled after the fopen procedure of the Unix standard I/O library. The syntax and meaning of all arguments is similar to those given in the Tcl open command when opening a file. If an error occurs while opening the channel, Tcl_FSOpenFileChannel returns NULL and records a POSIX error code that can be retrieved with Tcl_GetErrno . In addition, if interp is non-NULL, Tcl_FSOpenFileChannel leaves an error message in interp \\'s result after any error. The newly created channel is not registered in the supplied interpreter; to register it, use Tcl_RegisterChannel . If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel. Tcl_FSGetCwd replaces the library version of getcwd . It returns the Tcl library\\'s current working directory. This may be different to the native platform\\'s working directory, which happens when the current working directory is not in the native filesystem. The result is a pointer to a Tcl_Obj specifying the current directory, or NULL if the current directory could not be determined. If NULL is returned, an error message is left in the interp \\'s result. The result already has its reference count incremented for the caller. When it is no longer needed, that reference count should be decremented. This is needed for thread-safety purposes, to allow multiple threads to access this and related functions, while ensuring the results are always valid. Tcl_FSChdir replaces the library version of chdir . The path is normalized and then passed to the filesystem which claims it. If that filesystem does not implement this function, Tcl will fallback to a combination of stat and access to check whether the directory exists and has appropriate permissions. For results, see chdir documentation. If successful, we keep a record of the successful path in cwdPathPtr for subsequent calls to Tcl_FSGetCwd . Tcl_FSPathSeparator returns the separator character to be used for most specific element of the path specified by pathPtr (i.e. the last part of the path). The separator is returned as a Tcl_Obj containing a string of length 1. If the path is invalid, NULL is returned. Tcl_FSJoinPath takes the given Tcl_Obj, which must be a valid list (which is allowed to have a reference count of zero), and returns the path value given by considering the first elements elements as valid path segments (each path segment may be a complete path, a partial path or just a single possible directory or file name). If any path segment is actually an absolute path, then all prior path segments are discarded. If elements is less than 0, we use the entire list. It is possible that the returned value is actually an element of the given list, so the caller should be careful to increment the reference count of the result before freeing the list. The returned value, typically with a reference count of zero (but it could be shared under some conditions), contains the joined path. The caller must add a reference count to the value before using it. In particular, the returned value could be an element of the given list, so freeing the list might free the value prematurely if no reference count has been taken. If the number of elements is zero, then the returned value will be an empty-string Tcl_Obj. Tcl_FSSplitPath takes the given Tcl_Obj, which should be a valid path, and returns a Tcl list value containing each segment of that path as an element. It returns a list value with a reference count of zero. If the passed in lenPtr is non-NULL, the variable it points to will be updated to contain the number of elements in the returned list. Tcl_FSEqualPaths tests whether the two paths given represent the same filesystem object. It returns 1 if the paths are equal, and 0 if they are different. If either path is NULL, 0 is always returned. Tcl_FSGetNormalizedPath this important function attempts to extract from the given Tcl_Obj a unique normalized path representation, whose string value can be used as a unique identifier for the file. It returns the normalized path value, owned by Tcl, or NULL if the path was invalid or could otherwise not be successfully converted. Extraction of absolute, normalized paths is very efficient (because the filesystem operates on these representations internally), although the result when the filesystem contains numerous symbolic links may not be the most user-friendly version of a path. The return value is owned by Tcl and has a lifetime equivalent to that of the pathPtr passed in (unless that is a relative path, in which case the normalized path value may be freed any time the cwd changes) - the caller can of course increment the reference count if it wishes to maintain a copy for longer. Tcl_FSJoinToPath takes the given value, which should usually be a valid path or NULL, and joins onto it the array of paths segments given. Returns a value, typically with reference count of zero (but it could be shared under some conditions), containing the joined path. The caller must add a reference count to the value before using it. If any of the values passed into this function ( pathPtr or path elements) have a reference count of zero, they will be freed when this function returns. Tcl_FSConvertToPathType tries to convert the given Tcl_Obj to a valid Tcl path type, taking account of the fact that the cwd may have changed even if this value is already supposedly of the correct type. If the conversion succeeds (i.e. the value is a valid path in one of the current filesystems), then TCL_OK is returned. Otherwise TCL_ERROR is returned, and an error message may be left in the interpreter. Tcl_FSGetInternalRep extracts the internal representation of a given path value, in the given filesystem. If the path value belongs to a different filesystem, we return NULL. If the internal representation is currently NULL, we attempt to generate it, by calling the filesystem\\'s Tcl_FSCreateInternalRepProc . Returns NULL or a valid internal path representation. This internal representation is cached, so that repeated calls to this function will not require additional conversions. Tcl_FSGetTranslatedPath attempts to extract the translated path from the given Tcl_Obj. If the translation succeeds (i.e. the value is a valid path), then it is returned. Otherwise NULL will be returned, and an error message may be left in the interpreter. The value returned is owned by the caller, which must store it or call Tcl_DecrRefCount to ensure memory is freed. This function is of little practical use, and Tcl_FSGetNormalizedPath or Tcl_FSGetNativePath are usually better functions to use for most purposes. Tcl_FSGetTranslatedStringPath does the same as Tcl_FSGetTranslatedPath , but returns a character string or NULL. The string returned is dynamically allocated and owned by the caller, which must store it or call Tcl_Free to ensure it is freed. Again, Tcl_FSGetNormalizedPath or Tcl_FSGetNativePath are usually better functions to use for most purposes. Tcl_FSNewNativePath performs something like the reverse of the usual obj->path->nativerep conversions. If some code retrieves a path in native form (from, e.g. readlink or a native dialog), and that path is to be used at the Tcl level, then calling this function is an efficient way of creating the appropriate path value type. The resulting value is a pure value, which will only receive a UTF-8 string representation if that is required by some Tcl code. Tcl_FSGetNativePath is for use by the Win/Unix native filesystems, so that they can easily retrieve the native (char* or TCHAR*) representation of a path. This function is a convenience wrapper around Tcl_FSGetInternalRep . It may be desirable in the future to have non-string-based native representations (for example, on MacOSX, a representation using a fileSpec of FSRef structure would probably be more efficient). On Windows a full Unicode representation would allow for paths of unlimited length. Currently the representation is simply a character string which may contain either the relative path or a complete, absolute normalized path in the native encoding (complex conditions dictate which of these will be provided, so neither can be relied upon, unless the path is known to be absolute). If you need a native path which must be absolute, then you should ask for the native version of a normalized path. If for some reason a non-absolute, non-normalized version of the path is needed, that must be constructed separately (e.g. using Tcl_FSGetTranslatedPath ). The native representation is cached so that repeated calls to this function will not require additional conversions. The return value is owned by Tcl and has a lifetime equivalent to that of the pathPtr passed in (unless that is a relative path, in which case the native representation may be freed any time the cwd changes). Tcl_FSFileSystemInfo returns a list of two elements. The first element is the name of the filesystem (e.g. or perhaps), and the second is the particular type of the given path within that filesystem (which is filesystem dependent). The second element may be empty if the filesystem does not provide a further categorization of files. A valid list value is returned, unless the path value is not recognized, when NULL will be returned. Tcl_FSGetFileSystemForPath returns a pointer to the Tcl_Filesystem which accepts this path as valid. If no filesystem will accept the path, NULL is returned. Tcl_FSGetPathType determines whether the given path is relative to the current directory, relative to the current volume, or absolute. It returns one of TCL_PATH_ABSOLUTE , TCL_PATH_RELATIVE , or TCL_PATH_VOLUME_RELATIVE PORTABLE STAT RESULT API Tcl_AllocStatBuf allocates a Tcl_StatBuf on the system heap (which may be deallocated by being passed to Tcl_Free ). This allows extensions to invoke Tcl_FSStat and Tcl_FSLstat without being dependent on the size of the buffer. That in turn depends on the flags used to build Tcl. The portable fields of a Tcl_StatBuf may be read using the following functions, each of which returns the value of the corresponding field listed in the table below. Note that on some platforms there may be other fields in the Tcl_StatBuf as it is an alias for a suitable system structure, but only the portable ones are made available here. See your system documentation for a full description of these fields. Access Function Field Tcl_GetFSDeviceFromStat st_dev Tcl_GetFSInodeFromStat st_ino Tcl_GetModeFromStat st_mode Tcl_GetLinkCountFromStat st_nlink Tcl_GetUserIdFromStat st_uid Tcl_GetGroupIdFromStat st_gid Tcl_GetDeviceTypeFromStat st_rdev Tcl_GetAccessTimeFromStat st_atime Tcl_GetModificationTimeFromStat st_mtime Tcl_GetChangeTimeFromStat st_ctime Tcl_GetSizeFromStat st_size Tcl_GetBlocksFromStat st_blocks Tcl_GetBlockSizeFromStat st_blksize THE VIRTUAL FILESYSTEM API A filesystem provides a Tcl_Filesystem structure that contains pointers to functions that implement the various operations on a filesystem; these operations are invoked as needed by the generic layer, which generally occurs through the functions listed above. The Tcl_Filesystem structures are manipulated using the following methods. Tcl_FSRegister takes a pointer to a filesystem structure and an optional piece of data to associated with that filesystem. On calling this function, Tcl will attach the filesystem to the list of known filesystems, and it will become fully functional immediately. Tcl does not check if the same filesystem is registered multiple times (and in general that is not a good thing to do). TCL_OK will be returned. Tcl_FSUnregister removes the given filesystem structure from the list of known filesystems, if it is known, and returns TCL_OK . If the filesystem is not currently registered, TCL_ERROR is returned. Tcl_FSData will return the clientData associated with the given filesystem, if that filesystem is registered. Otherwise it will return NULL. Tcl_FSMountsChanged is used to inform the Tcl\\'s core that the set of mount points for the given (already registered) filesystem have changed, and that cached file representations may therefore no longer be correct. THE TCL_FILESYSTEM STRUCTURE The Tcl_Filesystem structure contains the following fields: typedef struct Tcl_Filesystem { const char * typeName ; Tcl_Size structureLength ; Tcl_FSVersion version ; Tcl_FSPathInFilesystemProc * pathInFilesystemProc ; Tcl_FSDupInternalRepProc * dupInternalRepProc ; Tcl_FSFreeInternalRepProc * freeInternalRepProc ; Tcl_FSInternalToNormalizedProc * internalToNormalizedProc ; Tcl_FSCreateInternalRepProc * createInternalRepProc ; Tcl_FSNormalizePathProc * normalizePathProc ; Tcl_FSFilesystemPathTypeProc * filesystemPathTypeProc ; Tcl_FSFilesystemSeparatorProc * filesystemSeparatorProc ; Tcl_FSStatProc * statProc ; Tcl_FSAccessProc * accessProc ; Tcl_FSOpenFileChannelProc * openFileChannelProc ; Tcl_FSMatchInDirectoryProc * matchInDirectoryProc ; Tcl_FSUtimeProc * utimeProc ; Tcl_FSLinkProc * linkProc ; Tcl_FSListVolumesProc * listVolumesProc ; Tcl_FSFileAttrStringsProc * fileAttrStringsProc ; Tcl_FSFileAttrsGetProc * fileAttrsGetProc ; Tcl_FSFileAttrsSetProc * fileAttrsSetProc ; Tcl_FSCreateDirectoryProc * createDirectoryProc ; Tcl_FSRemoveDirectoryProc * removeDirectoryProc ; Tcl_FSDeleteFileProc * deleteFileProc ; Tcl_FSCopyFileProc * copyFileProc ; Tcl_FSRenameFileProc * renameFileProc ; Tcl_FSCopyDirectoryProc * copyDirectoryProc ; Tcl_FSLstatProc * lstatProc ; Tcl_FSLoadFileProc * loadFileProc ; Tcl_FSGetCwdProc * getCwdProc ; Tcl_FSChdirProc * chdirProc ; } Tcl_Filesystem ; Except for the first three fields in this structure which contain simple data elements, all entries contain addresses of functions called by the generic filesystem layer to perform the complete range of filesystem related actions. The many functions in this structure are broken down into three categories: infrastructure functions (almost all of which must be implemented), operational functions (which must be implemented if a complete filesystem is provided), and efficiency functions (which need only be implemented if they can be done so efficiently, or if they have side-effects which are required by the filesystem; Tcl has less efficient emulations it can fall back on). It is important to note that, in the current version of Tcl, most of these fallbacks are only used to handle commands initiated in Tcl, not in C. What this means is, that if a file rename command is issued in Tcl, and the relevant filesystem(s) do not implement their Tcl_FSRenameFileProc , Tcl\\'s core will instead fallback on a combination of other filesystem functions (it will use Tcl_FSCopyFileProc followed by Tcl_FSDeleteFileProc , and if Tcl_FSCopyFileProc is not implemented there is a further fallback). However, if a Tcl_FSRenameFileProc command is issued at the C level, no such fallbacks occur. This is true except for the last four entries in the filesystem table ( lstat , load , getcwd and chdir ) for which fallbacks do in fact occur at the C level. Any functions which take path names in Tcl_Obj form take those names in UTF-8 form. The filesystem infrastructure API is designed to support efficient, cached conversion of these UTF-8 paths to other native representations. EXAMPLE FILESYSTEM DEFINITION Here is the filesystem lookup table used by the extension which allows filesystem actions to be implemented in Tcl. static Tcl_Filesystem vfsFilesystem = { \\\"tclvfs\\\", sizeof(Tcl_Filesystem), TCL_FILESYSTEM_VERSION_1, &VfsPathInFilesystem, &VfsDupInternalRep, &VfsFreeInternalRep, /* No internal to normalized, since we don\\'t create * any pure \\'internal\\' Tcl_Obj path representations */ NULL, /* No create native rep function, since we don\\'t use * it and don\\'t choose to support uses of * Tcl_FSNewNativePath */ NULL, /* Normalize path isn\\'t needed - we assume paths only * have one representation */ NULL, &VfsFilesystemPathType, &VfsFilesystemSeparator, &VfsStat, &VfsAccess, &VfsOpenFileChannel, &VfsMatchInDirectory, &VfsUtime, /* We choose not to support symbolic links inside our * VFS\\'s */ NULL, &VfsListVolumes, &VfsFileAttrStrings, &VfsFileAttrsGet, &VfsFileAttrsSet, &VfsCreateDirectory, &VfsRemoveDirectory, &VfsDeleteFile, /* No copy file; use the core fallback mechanism */ NULL, /* No rename file; use the core fallback mechanism */ NULL, /* No copy directory; use the core fallback mechanism */ NULL, /* Core will use stat for lstat */ NULL, /* No load; use the core fallback mechanism */ NULL, /* We don\\'t need a getcwd or chdir; the core\\'s own * internal value is suitable */ NULL, NULL }; FILESYSTEM INFRASTRUCTURE These fields contain basic information about the filesystem structure and addresses of functions which are used to associate a particular filesystem with a file path, and deal with the internal handling of path representations, for example copying and freeing such representations. TYPENAME The typeName field contains a null-terminated string that identifies the type of the filesystem implemented, e.g. or STRUCTURE LENGTH The structureLength field is generally implemented as sizeof(Tcl_Filesystem) , and is there to allow easier binary backwards compatibility if the size of the structure changes in a future Tcl release. VERSION The version field should be set to TCL_FILESYSTEM_VERSION_1 . PATHINFILESYSTEMPROC The pathInFilesystemProc field contains the address of a function which is called to determine whether a given path value belongs to this filesystem or not. Tcl will only call the rest of the filesystem functions with a path for which this function has returned TCL_OK . If the path does not belong, -1 should be returned (the behavior of Tcl for any other return value is not defined). If TCL_OK is returned, then the optional clientDataPtr output parameter can be used to return an internal (filesystem specific) representation of the path, which will be cached inside the path value, and may be retrieved efficiently by the other filesystem functions. Tcl will simultaneously cache the fact that this path belongs to this filesystem. Such caches are invalidated when filesystem structures are added or removed from Tcl\\'s internal list of known filesystems. typedef int Tcl_FSPathInFilesystemProc ( Tcl_Obj * pathPtr , void ** clientDataPtr ); DUPINTERNALREPPROC This function makes a copy of a path\\'s internal representation, and is called when Tcl needs to duplicate a path value. If NULL, Tcl will simply not copy the internal representation, which may then need to be regenerated later. typedef void * Tcl_FSDupInternalRepProc ( void * clientData ); FREEINTERNALREPPROC Free the internal representation. This must be implemented if internal representations need freeing (i.e. if some memory is allocated when an internal representation is generated), but may otherwise be NULL. typedef void Tcl_FSFreeInternalRepProc ( void * clientData ); INTERNALTONORMALIZEDPROC Function to convert internal representation to a normalized path. Only required if the filesystem creates pure path values with no string/path representation. The return value is a Tcl value whose string representation is the normalized path. typedef Tcl_Obj * Tcl_FSInternalToNormalizedProc ( void * clientData ); CREATEINTERNALREPPROC Function to take a path value, and calculate an internal representation for it, and store that native representation in the value. May be NULL if paths have no internal representation, or if the Tcl_FSPathInFilesystemProc for this filesystem always immediately creates an internal representation for paths it accepts. typedef void * Tcl_FSCreateInternalRepProc ( Tcl_Obj * pathPtr ); NORMALIZEPATHPROC Function to normalize a path. Should be implemented for all filesystems which can have multiple string representations for the same path value. In Tcl, every must have a single unique string representation. Depending on the filesystem, there may be more than one unnormalized string representation which refers to that path (e.g. a relative path, a path with different character case if the filesystem is case insensitive, a path containing symbolic links, etc). If the very last component in the path is a symbolic link, it should not be converted into the value it points to (but its case or other aspects should be made unique). All other path components should be converted from symbolic links. This one exception is required to agree with Tcl\\'s semantics with file delete, file rename , file copy operating on symbolic links. This function may be called with nextCheckpoint either at the beginning of the path (i.e. zero), at the end of the path, or at any intermediate file separator in the path. It will never point to any other arbitrary position in the path. In the last of the three valid cases, the implementation can assume that the path up to and including the file separator is known and normalized. typedef int Tcl_FSNormalizePathProc ( Tcl_Interp * interp , Tcl_Obj * pathPtr , int nextCheckpoint ); FILESYSTEM OPERATIONS The fields in this section of the structure contain addresses of functions which are called to carry out the basic filesystem operations. A filesystem which expects to be used with the complete standard Tcl command set must implement all of these. If some of them are not implemented, then certain Tcl commands may fail when operating on paths within that filesystem. However, in some instances this may be desirable (for example, a read-only filesystem should not implement the last four functions, and a filesystem which does not support symbolic links need not implement the readlink function, etc. The Tcl core expects filesystems to behave in this way). FILESYSTEMPATHTYPEPROC Function to determine the type of a path in this filesystem. May be NULL, in which case no type information will be available to users of the filesystem. The is used only for informational purposes, and should be returned as the string representation of the Tcl_Obj which is returned. A typical return value might be or The Tcl_Obj result is owned by the filesystem and so Tcl will increment the reference count of that value if it wishes to retain a reference to it. typedef Tcl_Obj * Tcl_FSFilesystemPathTypeProc ( Tcl_Obj * pathPtr ); FILESYSTEMSEPARATORPROC Function to return the separator character(s) for this filesystem. This need only be implemented if the filesystem wishes to use a different separator than the standard string Amongst other uses, it is returned by the file separator command. The return value should be a value with reference count of zero. typedef Tcl_Obj * Tcl_FSFilesystemSeparatorProc ( Tcl_Obj * pathPtr ); STATPROC Function to process a Tcl_FSStat call. Must be implemented for any reasonable filesystem, since many Tcl level commands depend crucially upon it (e.g. file atime , file isdirectory , file size , glob ). typedef int Tcl_FSStatProc ( Tcl_Obj * pathPtr , Tcl_StatBuf * statPtr ); The Tcl_FSStatProc fills the stat structure statPtr with information about the specified file. You do not need any access rights to the file to get this information but you need search rights to all directories named in the path leading to the file. The stat structure includes info regarding device, inode (always 0 on Windows), privilege mode, nlink (always 1 on Windows), user id (always 0 on Windows), group id (always 0 on Windows), rdev (same as device on Windows), size, last access time, last modification time, and last metadata change time. If the file represented by pathPtr exists, the Tcl_FSStatProc returns 0 and the stat structure is filled with data. Otherwise, -1 is returned, and no stat info is given. ACCESSPROC Function to process a Tcl_FSAccess call. Must be implemented for any reasonable filesystem, since many Tcl level commands depend crucially upon it (e.g. file exists , file readable ). typedef int Tcl_FSAccessProc ( Tcl_Obj * pathPtr , int mode ); The Tcl_FSAccessProc checks whether the process would be allowed to read, write or test for existence of the file (or other filesystem object) whose name is in pathPtr . If the pathname refers to a symbolic link, then the permissions of the file referred by this symbolic link should be tested. On success (all requested permissions granted), zero is returned. On error (at least one bit in mode asked for a permission that is denied, or some other error occurred), -1 is returned. OPENFILECHANNELPROC Function to process a Tcl_FSOpenFileChannel call. Must be implemented for any reasonable filesystem, since any operations which require open or accessing a file\\'s contents will use it (e.g. open , encoding , and many Tk commands). typedef Tcl_Channel Tcl_FSOpenFileChannelProc ( Tcl_Interp * interp , Tcl_Obj * pathPtr , int mode , int permissions ); The Tcl_FSOpenFileChannelProc opens a file specified by pathPtr and returns a channel handle that can be used to perform input and output on the file. This API is modeled after the fopen procedure of the Unix standard I/O library. The syntax and meaning of all arguments is similar to those given in the Tcl open command when opening a file, where the mode argument is a combination of the POSIX flags O_RDONLY, O_WRONLY, etc. If an error occurs while opening the channel, the Tcl_FSOpenFileChannelProc returns NULL and records a POSIX error code that can be retrieved with Tcl_GetErrno . In addition, if interp is non-NULL, the Tcl_FSOpenFileChannelProc leaves an error message in interp \\'s result after any error. The newly created channel must not be registered in the supplied interpreter by a Tcl_FSOpenFileChannelProc ; that task is up to the caller of Tcl_FSOpenFileChannel (if necessary). If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel. MATCHINDIRECTORYPROC Function to process a Tcl_FSMatchInDirectory call. If not implemented, then glob and recursive copy functionality will be lacking in the filesystem (and this may impact commands like encoding names which use glob functionality internally). typedef int Tcl_FSMatchInDirectoryProc ( Tcl_Interp * interp , Tcl_Obj * resultPtr , Tcl_Obj * pathPtr , const char * pattern , Tcl_GlobTypeData * types ); The function should return all files or directories (or other filesystem objects) which match the given pattern and accord with the types specification given. There are two ways in which this function may be called. If pattern is NULL, then pathPtr is a full path specification of a single file or directory which should be checked for existence and correct type. Otherwise, pathPtr is a directory, the contents of which the function should search for files or directories which have the correct type. In either case, pathPtr can be assumed to be both non-NULL and non-empty. It is not currently documented whether pathPtr will have a file separator at its end of not, so code should be flexible to both possibilities. The return value is a standard Tcl result indicating whether an error occurred in the matching process. Error messages are placed in interp , unless interp in NULL in which case no error message need be generated; on a TCL_OK result, results should be added to the resultPtr value given (which can be assumed to be a valid unshared Tcl list). The matches added to resultPtr should include any path prefix given in pathPtr (this usually means they will be absolute path specifications). Note that if no matches are found, that simply leads to an empty result; errors are only signaled for actual file or filesystem problems which may occur during the matching process. The Tcl_GlobTypeData structure passed in the types parameter contains the following fields: typedef struct Tcl_GlobTypeData { /* Corresponds to bcdpfls as in \\'find -t\\' */ int type ; /* Corresponds to file permissions */ int perm ; /* Acceptable mac type */ Tcl_Obj * macType ; /* Acceptable mac creator */ Tcl_Obj * macCreator ; } Tcl_GlobTypeData ; There are two specific cases which it is important to handle correctly, both when types is non-NULL. The two cases are when types->types & TCL_GLOB_TYPE_DIR or types->types & TCL_GLOB_TYPE_MOUNT are true (and in particular when the other flags are false). In the first of these cases, the function must list the contained directories. Tcl uses this to implement recursive globbing, so it is critical that filesystems implement directory matching correctly. In the second of these cases, with TCL_GLOB_TYPE_MOUNT , the filesystem must list the mount points which lie within the given pathPtr (and in this case, pathPtr need not lie within the same filesystem - different to all other cases in which this function is called). Support for this is critical if Tcl is to have seamless transitions between from one filesystem to another. UTIMEPROC Function to process a Tcl_FSUtime call. Required to allow setting (not reading) of times with file mtime , file atime and the open-r/open-w/fcopy implementation of file copy . typedef int Tcl_FSUtimeProc ( Tcl_Obj * pathPtr , struct utimbuf * tval ); The access and modification times of the file specified by pathPtr should be changed to the values given in the tval structure. The return value should be 0 on success and -1 on an error, as with the system utime . LINKPROC Function to process a Tcl_FSLink call. Should be implemented only if the filesystem supports links, and may otherwise be NULL. typedef Tcl_Obj * Tcl_FSLinkProc ( Tcl_Obj * linkNamePtr , Tcl_Obj * toPtr , int linkAction ); If toPtr is NULL, the function is being asked to read the contents of a link. The result is a Tcl_Obj specifying the contents of the link given by linkNamePtr , or NULL if the link could not be read. The result is owned by the caller (and should therefore have its ref count incremented before being returned). Any callers should call Tcl_DecrRefCount on this result when it is no longer needed. If toPtr is not NULL, the function should attempt to create a link. The result in this case should be toPtr if the link was successful and NULL otherwise. In this case the result is not owned by the caller (i.e. no reference count manipulations on either end are needed). See the documentation for Tcl_FSLink for the correct interpretation of the linkAction flags. LISTVOLUMESPROC Function to list any filesystem volumes added by this filesystem. Should be implemented only if the filesystem adds volumes at the head of the filesystem, so that they can be returned by file volumes . typedef Tcl_Obj * Tcl_FSListVolumesProc (void); The result should be a list of volumes added by this filesystem, or NULL (or an empty list) if no volumes are provided. The result value is considered to be owned by the filesystem (not by Tcl\\'s core), but should be given a reference count for Tcl. Tcl will use the contents of the list and then decrement that reference count. This allows filesystems to choose whether they actually want to retain a of volumes or not (if not, they generate the list on the fly and pass it to Tcl with a reference count of 1 and then forget about the list, if yes, then they simply increment the reference count of their global list and pass it to Tcl which will copy the contents and then decrement the count back to where it was). Therefore, Tcl considers return values from this proc to be read-only. FILEATTRSTRINGSPROC Function to list all attribute strings which are valid for this filesystem. If not implemented the filesystem will not support the file attributes command. This allows arbitrary additional information to be attached to files in the filesystem. If it is not implemented, there is no need to implement the get and set methods. typedef const char *const * Tcl_FSFileAttrStringsProc ( Tcl_Obj * pathPtr , Tcl_Obj ** objPtrRef ); The called function may either return an array of strings, or may instead return NULL and place a Tcl list into the given objPtrRef . Tcl will take that list and first increment its reference count before using it. On completion of that use, Tcl will decrement its reference count. Hence if the list should be disposed of by Tcl when done, it should have a reference count of zero, and if the list should not be disposed of, the filesystem should ensure it returns a value with a reference count of at least one. FILEATTRSGETPROC Function to process a Tcl_FSFileAttrsGet call, used by file attributes. typedef int Tcl_FSFileAttrsGetProc ( Tcl_Interp * interp , int index , Tcl_Obj * pathPtr , Tcl_Obj ** objPtrRef ); Returns a standard Tcl return code. The attribute value retrieved, which corresponds to the index \\'th element in the list returned by the Tcl_FSFileAttrStringsProc , is a Tcl_Obj placed in objPtrRef (if TCL_OK was returned) and is likely to have a reference count of zero. Either way we must either store it somewhere (e.g. the Tcl result), or Incr/Decr its reference count to ensure it is properly freed. FILEATTRSSETPROC Function to process a Tcl_FSFileAttrsSet call, used by file attributes. If the filesystem is read-only, there is no need to implement this. typedef int Tcl_FSFileAttrsSetProc ( Tcl_Interp * interp , int index , Tcl_Obj * pathPtr , Tcl_Obj * objPtr ); The attribute value of the index \\'th element in the list returned by the Tcl_FSFileAttrStringsProc should be set to the objPtr given. CREATEDIRECTORYPROC Function to process a Tcl_FSCreateDirectory call. Should be implemented unless the FS is read-only. typedef int Tcl_FSCreateDirectoryProc ( Tcl_Obj * pathPtr ); The return value is a standard Tcl result indicating whether an error occurred in the process. If successful, a new directory should have been added to the filesystem in the location specified by pathPtr . REMOVEDIRECTORYPROC Function to process a Tcl_FSRemoveDirectory call. Should be implemented unless the FS is read-only. typedef int Tcl_FSRemoveDirectoryProc ( Tcl_Obj * pathPtr , int recursive , Tcl_Obj ** errorPtr ); The return value is a standard Tcl result indicating whether an error occurred in the process. If successful, the directory specified by pathPtr should have been removed from the filesystem. If the recursive flag is given, then a non-empty directory should be deleted without error. If this flag is not given, then and the directory is non-empty a POSIX error should be signaled. If an error does occur, the name of the file or directory which caused the error should be placed in errorPtr . DELETEFILEPROC Function to process a Tcl_FSDeleteFile call. Should be implemented unless the FS is read-only. typedef int Tcl_FSDeleteFileProc ( Tcl_Obj * pathPtr ); The return value is a standard Tcl result indicating whether an error occurred in the process. If successful, the file specified by pathPtr should have been removed from the filesystem. Note that, if the filesystem supports symbolic links, Tcl will always call this function and not Tcl_FSRemoveDirectoryProc when needed to delete them (even if they are symbolic links to directories). FILESYSTEM EFFICIENCY These functions need not be implemented for a particular filesystem because the core has a fallback implementation available. See each individual description for the consequences of leaving the field NULL. LSTATPROC Function to process a Tcl_FSLstat call. If not implemented, Tcl will attempt to use the statProc defined above instead. Therefore it need only be implemented if a filesystem can differentiate between stat and lstat calls. typedef int Tcl_FSLstatProc ( Tcl_Obj * pathPtr , Tcl_StatBuf * statPtr ); The behavior of this function is very similar to that of the Tcl_FSStatProc defined above, except that if it is applied to a symbolic link, it returns information about the link, not about the target file. COPYFILEPROC Function to process a Tcl_FSCopyFile call. If not implemented Tcl will fall back on open -r, open -w and fcopy as a copying mechanism. Therefore it need only be implemented if the filesystem can perform that action more efficiently. typedef int Tcl_FSCopyFileProc ( Tcl_Obj * srcPathPtr , Tcl_Obj * destPathPtr ); The return value is a standard Tcl result indicating whether an error occurred in the copying process. Note that, destPathPtr is the name of the file which should become the copy of srcPathPtr . It is never the name of a directory into which srcPathPtr could be copied (i.e. the function is much simpler than the Tcl level file copy subcommand). Note that, if the filesystem supports symbolic links, Tcl will always call this function and not copyDirectoryProc when needed to copy them (even if they are symbolic links to directories). Finally, if the filesystem determines it cannot support the file copy action, calling Tcl_SetErrno(EXDEV) and returning a non- TCL_OK result will tell Tcl to use its standard fallback mechanisms. RENAMEFILEPROC Function to process a Tcl_FSRenameFile call. If not implemented, Tcl will fall back on a copy and delete mechanism. Therefore it need only be implemented if the filesystem can perform that action more efficiently. typedef int Tcl_FSRenameFileProc ( Tcl_Obj * srcPathPtr , Tcl_Obj * destPathPtr ); The return value is a standard Tcl result indicating whether an error occurred in the renaming process. If the filesystem determines it cannot support the file rename action, calling Tcl_SetErrno(EXDEV) and returning a non- TCL_OK result will tell Tcl to use its standard fallback mechanisms. COPYDIRECTORYPROC Function to process a Tcl_FSCopyDirectory call. If not implemented, Tcl will fall back on a recursive file mkdir , file copy mechanism. Therefore it need only be implemented if the filesystem can perform that action more efficiently. typedef int Tcl_FSCopyDirectoryProc ( Tcl_Obj * srcPathPtr , Tcl_Obj * destPathPtr , Tcl_Obj ** errorPtr ); The return value is a standard Tcl result indicating whether an error occurred in the copying process. If an error does occur, the name of the file or directory which caused the error should be placed in errorPtr . Note that, destPathPtr is the name of the directory-name which should become the mirror-image of srcPathPtr . It is not the name of a directory into which srcPathPtr should be copied (i.e. the function is much simpler than the Tcl level file copy subcommand). Finally, if the filesystem determines it cannot support the directory copy action, calling Tcl_SetErrno(EXDEV) and returning a non- TCL_OK result will tell Tcl to use its standard fallback mechanisms. LOADFILEPROC Function to process a Tcl_FSLoadFile call. If not implemented, Tcl will fall back on a copy to native-temp followed by a Tcl_FSLoadFile on that temporary copy. Therefore it need only be implemented if the filesystem can load code directly, or it can be implemented simply to return TCL_ERROR to disable load functionality in this filesystem entirely. typedef int Tcl_FSLoadFileProc ( Tcl_Interp * interp , Tcl_Obj * pathPtr , Tcl_LoadHandle * handlePtr , Tcl_FSUnloadFileProc * unloadProcPtr ); Returns a standard Tcl completion code. If an error occurs, an error message is left in the interp \\'s result. The function dynamically loads a binary code file into memory. On a successful load, the handlePtr should be filled with a token for the dynamically loaded file, and the unloadProcPtr should be filled in with the address of a procedure. The unload procedure will be called with the given Tcl_LoadHandle as its only parameter when Tcl needs to unload the file. For example, for the native filesystem, the Tcl_LoadHandle returned is currently a token which can be used in the private TclpFindSymbol to access functions in the new code. Each filesystem is free to define the Tcl_LoadHandle as it requires. Finally, if the filesystem determines it cannot support the file load action, calling Tcl_SetErrno(EXDEV) and returning a non- TCL_OK result will tell Tcl to use its standard fallback mechanisms. UNLOADFILEPROC Function to unload a previously successfully loaded file. If load was implemented, then this should also be implemented, if there is any cleanup action required. typedef void Tcl_FSUnloadFileProc ( Tcl_LoadHandle loadHandle ); GETCWDPROC Function to process a Tcl_FSGetCwd call. Most filesystems need not implement this. It will usually only be called once, if getcwd is called before chdir . May be NULL. typedef Tcl_Obj * Tcl_FSGetCwdProc ( Tcl_Interp * interp ); If the filesystem supports a native notion of a current working directory (which might perhaps change independent of Tcl), this function should return that cwd as the result, or NULL if the current directory could not be determined (e.g. the user does not have appropriate permissions on the cwd directory). If NULL is returned, an error message is left in the interp \\'s result. CHDIRPROC Function to process a Tcl_FSChdir call. If filesystems do not implement this, it will be emulated by a series of directory access checks. Otherwise, virtual filesystems which do implement it need only respond with a positive return result if the pathPtr is a valid, accessible directory in their filesystem. They need not remember the result, since that will be automatically remembered for use by Tcl_FSGetCwd . Real filesystems should carry out the correct action (i.e. call the correct system chdir API). typedef int Tcl_FSChdirProc ( Tcl_Obj * pathPtr ); The Tcl_FSChdirProc changes the applications current working directory to the value specified in pathPtr . The function returns -1 on error or 0 on success. REFERENCE COUNT MANAGEMENT PUBLIC API CALLS For all of these functions, pathPtr (including the srcPathPtr and destPathPtr arguments to Tcl_FSCopyFile , Tcl_FSCopyDirectory , and Tcl_FSRenameFile , the firstPtr and secondPtr arguments to Tcl_FSEqualPaths , and the linkNamePtr and toPtr arguments to Tcl_FSLink ) must not be a zero reference count value; references may be retained in internal caches even for theoretically read-only operations. These functions may also manipulate the interpreter result (if they take and are given a non-NULL interp argument); you must not count on the interpreter result to hold the reference count of any argument value over these calls and should manage your own references there. However, references held by the arguments to a Tcl command are suitable for reference count management purposes for the duration of the implementation of that command. The errorPtr argument to Tcl_FSCopyDirectory and Tcl_FSRemoveDirectory is, when an object is set into it at all, set to an object with a non-zero reference count that should be passed to Tcl_DecrRefCount when no longer needed. Tcl_FSListVolumes always returns a zero-reference object, much like Tcl_NewObj . Tcl_FSLink always returns a non-zero-reference object when it is asked to read; you must call Tcl_DecrRefCount on the object once you no longer need it. Tcl_FSGetCwd always returns a non-zero-reference object; you must call Tcl_DecrRefCount on the object once you no longer need it. Tcl_FSPathSeparator always returns a zero-reference object, much like Tcl_NewObj . Tcl_FSJoinPath always returns a zero-reference object, much like Tcl_NewObj . Its listObj argument can have any reference count; it is only read by this function. Tcl_FSSplitPath always returns a zero-reference object, much like Tcl_NewObj . Tcl_FSGetNormalizedPath returns an object with a non-zero reference count where Tcl is the owner. You should increment its reference count if you want to retain it, but do not need to if you are just using the value immediately. Tcl_FSJoinToPath always returns a zero-reference object, much like Tcl_NewObj . Its basePtr argument follows the rules above for pathPtr , as do the values in the objv argument. Tcl_FSGetTranslatedPath returns a non-zero-reference object (or NULL in the error case); you must call Tcl_DecrRefCount on the object once you no longer need it. Tcl_FSNewNativePath always returns a zero-reference object (or NULL), much like Tcl_NewObj . Tcl_FSFileSystemInfo always returns a zero-reference object (or NULL), much like Tcl_NewObj . The objPtr and objPtrRef arguments to Tcl_FSFileAttrsGet , Tcl_FSFileAttrsSet and Tcl_FSFileAttrStrings are conventional Tcl values; the objPtr argument will be read but not retained, and the objPtrRef argument will have (on success) a zero-reference value written into it (as with Tcl_NewObj ). Tcl_FSFileAttrsGet and Tcl_FSFileAttrsSet may also manipulate the interpreter result. The resultPtr argument to Tcl_FSMatchInDirectory will not have its reference count manipulated, but it should have a reference count of no more than 1, and should not be the current interpreter result (as the function may overwrite that on error). VIRTUAL FILESYSTEM INTERFACE For all virtual filesystem implementation functions, any pathPtr arguments should not have their reference counts manipulated. If they take an interp argument, they may set an error message in that, but must not manipulate the pathPtr afterwards. Aside from that: internalToNormalizedProc : This should return a zero-reference count value, as if allocated with Tcl_NewObj . normalizePathProc : Unlike with other API implementation functions, the pathPtr argument here is guaranteed to be an unshared object that should be updated. Its reference count should not be modified. filesystemPathTypeProc : The return value (if non-NULL) either has a reference count of zero or needs to be maintained (on a per-thread basis) by the filesystem. Tcl will increment the reference count of the value if it wishes to retain it. filesystemSeparatorProc : The return value should be a value with reference count of zero. matchInDirectoryProc : The resultPtr argument should be assumed to hold a list that can be appended to (i.e., that has a reference count no greater than 1). No reference to it should be retained. linkProc : If toPtr is NULL, this should return a value with reference count 1 that has just been allocated and passed to Tcl_IncrRefCount . If toPtr is not NULL, it should be returned on success. listVolumesProc : The result value should be a list (if non-NULL); it will have its reference count decremented once (with Tcl_DecrRefCount ) by Tcl once done. fileAttrStringsProc : If the result is NULL, the objPtrRef should have a list value written to it; that list will have its reference count both incremented (with Tcl_IncrRefCount ) and decremented (with Tcl_DecrRefCount ). fileAttrsGetProc : The objPtrRef argument should have (on non-error return) a zero reference count value written to it (allocated as if with Tcl_NewObj ). fileAttrsSetProc : The objPtr argument should either just be read or its reference count incremented to retain it. removeDirectoryProc : If an error is being reported, the problem filename reported via errorPtr should be newly allocated (as if with Tcl_NewObj ) and have a reference count of 1 (i.e., have been passed to Tcl_IncrRefCount ). copyDirectoryProc : If an error is being reported, the problem filename reported via errorPtr should be newly allocated (as if with Tcl_NewObj ) and have a reference count of 1 (i.e., have been passed to Tcl_IncrRefCount ). getCwdProc : The result will be passed to Tcl_DecrRefCount by the implementation of Tcl_FSGetCwd after it has been normalized. SEE ALSO cd(n), file(n), filename(n), load(n), open(n), pwd(n), source(n), unload(n) KEYWORDS stat, access, filesystem, vfs, virtual filesystem","title":"NAME"},{"location":"FileSystem/#name","text":"Tcl_FSRegister, Tcl_FSUnregister, Tcl_FSData, Tcl_FSMountsChanged, Tcl_FSGetFileSystemForPath, Tcl_FSGetPathType, Tcl_FSCopyFile, Tcl_FSCopyDirectory, Tcl_FSCreateDirectory, Tcl_FSDeleteFile, Tcl_FSRemoveDirectory, Tcl_FSRenameFile, Tcl_FSListVolumes, Tcl_FSEvalFile, Tcl_FSEvalFileEx, Tcl_FSLoadFile, Tcl_FSUnloadFile, Tcl_FSMatchInDirectory, Tcl_FSLink, Tcl_FSLstat, Tcl_FSUtime, Tcl_FSFileAttrsGet, Tcl_FSFileAttrsSet, Tcl_FSFileAttrStrings, Tcl_FSStat, Tcl_FSAccess, Tcl_FSOpenFileChannel, Tcl_FSGetCwd, Tcl_FSChdir, Tcl_FSPathSeparator, Tcl_FSJoinPath, Tcl_FSSplitPath, Tcl_FSEqualPaths, Tcl_FSGetNormalizedPath, Tcl_FSJoinToPath, Tcl_FSConvertToPathType, Tcl_FSGetInternalRep, Tcl_FSGetTranslatedPath, Tcl_FSGetTranslatedStringPath, Tcl_FSNewNativePath, Tcl_FSGetNativePath, Tcl_FSFileSystemInfo, Tcl_GetAccessTimeFromStat, Tcl_GetBlockSizeFromStat, Tcl_GetBlocksFromStat, Tcl_GetChangeTimeFromStat, Tcl_GetDeviceTypeFromStat, Tcl_GetFSDeviceFromStat, Tcl_GetFSInodeFromStat, Tcl_GetGroupIdFromStat, Tcl_GetLinkCountFromStat, Tcl_GetModeFromStat, Tcl_GetModificationTimeFromStat, Tcl_GetSizeFromStat, Tcl_GetUserIdFromStat, Tcl_AllocStatBuf - procedures to interact with any filesystem","title":"NAME"},{"location":"FileSystem/#synopsis","text":"#include <tcl.h> int Tcl_FSRegister(clientData, fsPtr) int Tcl_FSUnregister(fsPtr) void * Tcl_FSData(fsPtr) void Tcl_FSMountsChanged(fsPtr) const Tcl_Filesystem * Tcl_FSGetFileSystemForPath(pathPtr) Tcl_PathType Tcl_FSGetPathType(pathPtr) int Tcl_FSCopyFile(srcPathPtr, destPathPtr) int Tcl_FSCopyDirectory(srcPathPtr, destPathPtr, errorPtr) int Tcl_FSCreateDirectory(pathPtr) int Tcl_FSDeleteFile(pathPtr) int Tcl_FSRemoveDirectory(pathPtr, recursive, errorPtr) int Tcl_FSRenameFile(srcPathPtr, destPathPtr) Tcl_Obj * Tcl_FSListVolumes(void) int Tcl_FSEvalFileEx(interp, pathPtr, encodingName) int Tcl_FSEvalFile(interp, pathPtr) int Tcl_FSLoadFile(interp, pathPtr, sym1, sym2, proc1Ptr, proc2Ptr, loadHandlePtr, unloadProcPtr) int Tcl_FSUnloadFile(interp, loadHandle) int Tcl_FSMatchInDirectory(interp, resultPtr, pathPtr, pattern, types) Tcl_Obj * Tcl_FSLink(linkNamePtr, toPtr, linkAction) int Tcl_FSLstat(pathPtr, statPtr) int Tcl_FSUtime(pathPtr, tval) int Tcl_FSFileAttrsGet(interp, index, pathPtr, objPtrRef) int Tcl_FSFileAttrsSet(interp, index, pathPtr, objPtr) const char *const * Tcl_FSFileAttrStrings(pathPtr, objPtrRef) int Tcl_FSStat(pathPtr, statPtr) int Tcl_FSAccess(pathPtr, mode) Tcl_Channel Tcl_FSOpenFileChannel(interp, pathPtr, modeString, permissions) Tcl_Obj * Tcl_FSGetCwd(interp) int Tcl_FSChdir(pathPtr) Tcl_Obj * Tcl_FSPathSeparator(pathPtr) Tcl_Obj * Tcl_FSJoinPath(listObj, elements) Tcl_Obj * Tcl_FSSplitPath(pathPtr, lenPtr) int Tcl_FSEqualPaths(firstPtr, secondPtr) Tcl_Obj * Tcl_FSGetNormalizedPath(interp, pathPtr) Tcl_Obj * Tcl_FSJoinToPath(basePtr, objc, objv) int Tcl_FSConvertToPathType(interp, pathPtr) void * Tcl_FSGetInternalRep(pathPtr, fsPtr) Tcl_Obj * Tcl_FSGetTranslatedPath(interp, pathPtr) const char * Tcl_FSGetTranslatedStringPath(interp, pathPtr) Tcl_Obj * Tcl_FSNewNativePath(fsPtr, clientData) const void * Tcl_FSGetNativePath(pathPtr) Tcl_Obj * Tcl_FSFileSystemInfo(pathPtr) Tcl_StatBuf * Tcl_AllocStatBuf() long long Tcl_GetAccessTimeFromStat(statPtr) unsigned Tcl_GetBlockSizeFromStat(statPtr) unsigned long long Tcl_GetBlocksFromStat(statPtr) long long Tcl_GetChangeTimeFromStat(statPtr) int Tcl_GetDeviceTypeFromStat(statPtr) unsigned Tcl_GetFSDeviceFromStat(statPtr) unsigned Tcl_GetFSInodeFromStat(statPtr) int Tcl_GetGroupIdFromStat(statPtr) int Tcl_GetLinkCountFromStat(statPtr) unsigned Tcl_GetModeFromStat(statPtr) long long Tcl_GetModificationTimeFromStat(statPtr) unsigned long long Tcl_GetSizeFromStat(statPtr) int Tcl_GetUserIdFromStat(statPtr)","title":"SYNOPSIS"},{"location":"FileSystem/#arguments","text":"Points to a structure containing the addresses of procedures that can be called to perform the various filesystem operations. The path represented by this value is used for the operation in question. If the value does not already have an internal path representation, it will be converted to have one. As for pathPtr , but used for the source file for a copy or rename operation. As for pathPtr , but used for the destination filename for a copy or rename operation. Whether to remove subdirectories and their contents as well. The encoding of the data stored in the file identified by pathPtr and to be evaluated. Only files or directories matching this pattern will be returned. Only files or directories matching the type descriptions contained in this structure will be returned. This parameter may be NULL. Interpreter to use either for results, evaluation, or reporting error messages. The native description of the path value to create. The first of two path values to compare. The value may be converted to path type. The second of two path values to compare. The value may be converted to path type. The list of path elements to operate on with a join operation. The number of elements in the listObj which should be joined together. If negative, then all elements are joined. In the case of an error, filled with a value containing the name of the file which caused an error in the various copy/rename operations. The index of the attribute in question. The value to set in the operation. Filled with a value containing the result of the operation. Preallocated value in which to store (using Tcl_ListObjAppendElement ) the list of files or directories which are successfully matched. Mask consisting of one or more of R_OK, W_OK, X_OK and F_OK. R_OK, W_OK and X_OK request checking whether the file exists and has read, write and execute permissions, respectively. F_OK just requests checking for the existence of the file. The structure that contains the result of a stat or lstat operation. Name of a procedure to look up in the file\\'s symbol table Name of a procedure to look up in the file\\'s symbol table Filled with the init function for this code. Filled with the safe-init function for this code. Filled with the clientData value to pass to this code\\'s unload function when it is called. Filled with an abstract token representing the loaded file. Filled with the function to use to unload this piece of code. Handle to the loaded library to be unloaded. The access and modification times in this structure are read and used to set those values for a given file. Specifies how the file is to be accessed. May have any of the values allowed for the mode argument to the Tcl open command. POSIX-style permission flags such as 0644. If a new file is created, these permissions will be set on the created file. If non-NULL, filled with the number of elements in the split path. The base path on to which to join the given elements. May be NULL. The number of elements in objv . The elements to join to the given base path. The name of the link to be created or read. What the link called linkNamePtr should be linked to, or NULL if the symbolic link specified by linkNamePtr is to be read. OR-ed combination of flags indicating what kind of link should be created (will be ignored if toPtr is NULL). Valid bits to set are TCL_CREATE_SYMBOLIC_LINK and TCL_CREATE_HARD_LINK . When both flags are set and the underlying filesystem can do either, symbolic links are preferred.","title":"ARGUMENTS"},{"location":"FileSystem/#description","text":"There are several reasons for calling the Tcl_FS API functions (e.g. Tcl_FSAccess and Tcl_FSStat ) rather than calling system level functions like access and stat directly. First, they will work cross-platform, so an extension which calls them should work unmodified on Unix and Windows. Second, the Windows implementation of some of these functions fixes some bugs in the system level calls. Third, these function calls deal with any path conversions which may be required (and may cache the results of such conversions for greater efficiency on subsequent calls). Fourth, and perhaps most importantly, all of these functions are Any virtual filesystem (VFS for short) which has been registered (through Tcl_FSRegister ) may reroute file access to alternative media or access methods. This means that all of these functions (and therefore the corresponding file , glob , pwd , cd , open , etc. Tcl commands) may be operate on which are not native files in the native filesystem. This also means that any Tcl extension which accesses the filesystem (FS for short) through this API is automatically Of course, if an extension accesses the native filesystem directly (through platform-specific APIs, for example), then Tcl cannot intercept such calls. If appropriate VFSes have been registered, the may, to give two examples, be remote (e.g. situated on a remote ftp server) or archived (e.g. lying inside a .zip archive). Such registered filesystems provide a lookup table of functions to implement all or some of the functionality listed here. Finally, the Tcl_FSStat and Tcl_FSLstat calls abstract away from what the buffer is actually declared to be, allowing the same code to be used both on systems with and systems without support for files larger than 2GB in size. The Tcl_FS API is Tcl_Obj -ified and may cache internal representations and other path-related strings (e.g. the current working directory). One side-effect of this is that one must not pass in values with a reference count of zero to any of these functions. If such calls were handled, they might result in memory leaks (under some circumstances, the filesystem code may wish to retain a reference to the passed in value, and so one must not assume that after any of these calls return, the value still has a reference count of zero - it may have been incremented) or in a direct segmentation fault (or other memory access error) due to the value being freed part way through the complex value manipulation required to ensure that the path is fully normalized and absolute for filesystem determination. The practical lesson to learn from this is that Tcl_Obj *path = Tcl_NewStringObj(...); Tcl_FS Whatever (path); Tcl_DecrRefCount(path); is wrong, and may cause memory errors. The path must have its reference count incremented before passing it in, or decrementing it. For this reason, values with a reference count of zero are considered not to be valid filesystem paths and calling any Tcl_FS API function with such a value will result in no action being taken.","title":"DESCRIPTION"},{"location":"FileSystem/#fs-api-functions","text":"Tcl_FSCopyFile attempts to copy the file given by srcPathPtr to the path name given by destPathPtr . If the two paths given lie in the same filesystem (according to Tcl_FSGetFileSystemForPath ) then that filesystem\\'s function is called (if it is non-NULL). Otherwise the function returns -1 and sets the errno global C variable to the POSIX error code (which signifies a Tcl_FSCopyDirectory attempts to copy the directory given by srcPathPtr to the path name given by destPathPtr . If the two paths given lie in the same filesystem (according to Tcl_FSGetFileSystemForPath ) then that filesystem\\'s function is called (if it is non-NULL). Otherwise the function returns -1 and sets the errno global C variable to the POSIX error code (which signifies a Tcl_FSCreateDirectory attempts to create the directory given by pathPtr by calling the owning filesystem\\'s function. Tcl_FSDeleteFile attempts to delete the file given by pathPtr by calling the owning filesystem\\'s function. Tcl_FSRemoveDirectory attempts to remove the directory given by pathPtr by calling the owning filesystem\\'s function. Tcl_FSRenameFile attempts to rename the file or directory given by srcPathPtr to the path name given by destPathPtr . If the two paths given lie in the same filesystem (according to Tcl_FSGetFileSystemForPath ) then that filesystem\\'s function is called (if it is non-NULL). Otherwise the function returns -1 and sets the errno global C variable to the POSIX error code (which signifies a Tcl_FSListVolumes calls each filesystem which has a non-NULL function and asks them to return their list of root volumes. It accumulates the return values in a list which is returned to the caller (with a reference count of 0). Tcl_FSEvalFileEx reads the file given by pathPtr using the encoding identified by encodingName and evaluates its contents as a Tcl script. It returns the same information as Tcl_EvalObjEx . If encodingName is NULL, the utf-8 encoding is used for reading the file contents. If the file could not be read then a Tcl error is returned to describe why the file could not be read. The eofchar for files is (\\^Z) for all platforms. If you require a in code for string comparison, you can use which will be safely substituted by the Tcl interpreter into Tcl_FSEvalFile is a simpler version of Tcl_FSEvalFileEx that always uses the utf-8 encoding when reading the file. Tcl_FSLoadFile dynamically loads a binary code file into memory and returns the addresses of two procedures within that file, if they are defined. The appropriate function for the filesystem to which pathPtr belongs will be called. If that filesystem does not implement this function (most virtual filesystems will not, because of OS limitations in dynamically loading binary code), Tcl will attempt to copy the file to a temporary directory and load that temporary file. Tcl_FSUnloadFile reverses the operation, asking for the library indicated by the loadHandle to be removed from the process. Note that, unlike with the unload command, this does not give the library any opportunity to clean up. Both the above functions return a standard Tcl completion code. If an error occurs, an error message is left in the interp \\'s result. The token provided via the variable indicated by loadHandlePtr may be used with Tcl_FindSymbol . Tcl_FSMatchInDirectory is used by the globbing code to search a directory for all files which match a given pattern. The appropriate function for the filesystem to which pathPtr belongs will be called. The return value is a standard Tcl result indicating whether an error occurred in globbing. Error messages are placed in interp (unless interp is NULL, which is allowed), but good results are placed in the resultPtr given. Note that the glob code implements recursive patterns internally, so this function will only ever be passed simple patterns, which can be matched using the logic of string match . To handle recursion, Tcl will call this function frequently asking only for directories to be returned. A special case of being called with a NULL pattern indicates that the path needs to be checked only for the correct type. Tcl_FSLink replaces the library version of readlink , and extends it to support the creation of links. The appropriate function for the filesystem to which linkNamePtr belongs will be called. If the toPtr is NULL, a action is performed. The result is a Tcl_Obj specifying the contents of the symbolic link given by linkNamePtr , or NULL if the link could not be read. The result is owned by the caller, which should call Tcl_DecrRefCount when the result is no longer needed. If the toPtr is not NULL, Tcl should create a link of one of the types passed in in the linkAction flag. This flag is an OR\\'ed combination of TCL_CREATE_SYMBOLIC_LINK and TCL_CREATE_HARD_LINK . Where a choice exists (i.e. more than one flag is passed in), the Tcl convention is to prefer symbolic links. When a link is successfully created, the return value should be toPtr (which is therefore already owned by the caller). If unsuccessful, NULL is returned. Tcl_FSLstat fills the Tcl_StatBuf structure statPtr with information about the specified file. You do not need any access rights to the file to get this information but you need search rights to all directories named in the path leading to the file. The Tcl_StatBuf structure includes info regarding device, inode (always 0 on Windows), privilege mode, nlink (always 1 on Windows), user id (always 0 on Windows), group id (always 0 on Windows), rdev (same as device on Windows), size, last access time, last modification time, and last metadata change time. See PORTABLE STAT RESULT API for a description of how to write portable code to allocate and access the Tcl_StatBuf structure. If path exists, Tcl_FSLstat returns 0 and the stat structure is filled with data. Otherwise, -1 is returned, and no stat info is given. Tcl_FSUtime replaces the library version of utime. This returns 0 on success and -1 on error (as per the utime documentation). If successful, the function will update the and values of the file given. Tcl_FSFileAttrsGet implements read access for the hookable file attributes subcommand. The appropriate function for the filesystem to which pathPtr belongs will be called. If the result is TCL_OK , then a value was placed in objPtrRef , which will only be temporarily valid (unless Tcl_IncrRefCount is called). Tcl_FSFileAttrsSet implements write access for the hookable file attributes subcommand. The appropriate function for the filesystem to which pathPtr belongs will be called. Tcl_FSFileAttrStrings implements part of the hookable file attributes subcommand. The appropriate function for the filesystem to which pathPtr belongs will be called. The called procedure may either return an array of strings, or may instead return NULL and place a Tcl list into the given objPtrRef . Tcl will take that list and first increment its reference count before using it. On completion of that use, Tcl will decrement its reference count. Hence if the list should be disposed of by Tcl when done, it should have a reference count of zero, and if the list should not be disposed of, the filesystem should ensure it retains a reference count to the value. Tcl_FSAccess checks whether the process would be allowed to read, write or test for existence of the file (or other filesystem object) whose name is pathname . If pathname is a symbolic link on Unix, then permissions of the file referred by this symbolic link are tested. On success (all requested permissions granted), zero is returned. On error (at least one bit in mode asked for a permission that is denied, or some other error occurred), -1 is returned. Tcl_FSStat fills the Tcl_StatBuf structure statPtr with information about the specified file. You do not need any access rights to the file to get this information but you need search rights to all directories named in the path leading to the file. The Tcl_StatBuf structure includes info regarding device, inode (always 0 on Windows), privilege mode, nlink (always 1 on Windows), user id (always 0 on Windows), group id (always 0 on Windows), rdev (same as device on Windows), size, last access time, last modification time, and last metadata change time. See PORTABLE STAT RESULT API for a description of how to write portable code to allocate and access the Tcl_StatBuf structure. If path exists, Tcl_FSStat returns 0 and the stat structure is filled with data. Otherwise, -1 is returned, and no stat info is given. Tcl_FSOpenFileChannel opens a file specified by pathPtr and returns a channel handle that can be used to perform input and output on the file. This API is modeled after the fopen procedure of the Unix standard I/O library. The syntax and meaning of all arguments is similar to those given in the Tcl open command when opening a file. If an error occurs while opening the channel, Tcl_FSOpenFileChannel returns NULL and records a POSIX error code that can be retrieved with Tcl_GetErrno . In addition, if interp is non-NULL, Tcl_FSOpenFileChannel leaves an error message in interp \\'s result after any error. The newly created channel is not registered in the supplied interpreter; to register it, use Tcl_RegisterChannel . If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel. Tcl_FSGetCwd replaces the library version of getcwd . It returns the Tcl library\\'s current working directory. This may be different to the native platform\\'s working directory, which happens when the current working directory is not in the native filesystem. The result is a pointer to a Tcl_Obj specifying the current directory, or NULL if the current directory could not be determined. If NULL is returned, an error message is left in the interp \\'s result. The result already has its reference count incremented for the caller. When it is no longer needed, that reference count should be decremented. This is needed for thread-safety purposes, to allow multiple threads to access this and related functions, while ensuring the results are always valid. Tcl_FSChdir replaces the library version of chdir . The path is normalized and then passed to the filesystem which claims it. If that filesystem does not implement this function, Tcl will fallback to a combination of stat and access to check whether the directory exists and has appropriate permissions. For results, see chdir documentation. If successful, we keep a record of the successful path in cwdPathPtr for subsequent calls to Tcl_FSGetCwd . Tcl_FSPathSeparator returns the separator character to be used for most specific element of the path specified by pathPtr (i.e. the last part of the path). The separator is returned as a Tcl_Obj containing a string of length 1. If the path is invalid, NULL is returned. Tcl_FSJoinPath takes the given Tcl_Obj, which must be a valid list (which is allowed to have a reference count of zero), and returns the path value given by considering the first elements elements as valid path segments (each path segment may be a complete path, a partial path or just a single possible directory or file name). If any path segment is actually an absolute path, then all prior path segments are discarded. If elements is less than 0, we use the entire list. It is possible that the returned value is actually an element of the given list, so the caller should be careful to increment the reference count of the result before freeing the list. The returned value, typically with a reference count of zero (but it could be shared under some conditions), contains the joined path. The caller must add a reference count to the value before using it. In particular, the returned value could be an element of the given list, so freeing the list might free the value prematurely if no reference count has been taken. If the number of elements is zero, then the returned value will be an empty-string Tcl_Obj. Tcl_FSSplitPath takes the given Tcl_Obj, which should be a valid path, and returns a Tcl list value containing each segment of that path as an element. It returns a list value with a reference count of zero. If the passed in lenPtr is non-NULL, the variable it points to will be updated to contain the number of elements in the returned list. Tcl_FSEqualPaths tests whether the two paths given represent the same filesystem object. It returns 1 if the paths are equal, and 0 if they are different. If either path is NULL, 0 is always returned. Tcl_FSGetNormalizedPath this important function attempts to extract from the given Tcl_Obj a unique normalized path representation, whose string value can be used as a unique identifier for the file. It returns the normalized path value, owned by Tcl, or NULL if the path was invalid or could otherwise not be successfully converted. Extraction of absolute, normalized paths is very efficient (because the filesystem operates on these representations internally), although the result when the filesystem contains numerous symbolic links may not be the most user-friendly version of a path. The return value is owned by Tcl and has a lifetime equivalent to that of the pathPtr passed in (unless that is a relative path, in which case the normalized path value may be freed any time the cwd changes) - the caller can of course increment the reference count if it wishes to maintain a copy for longer. Tcl_FSJoinToPath takes the given value, which should usually be a valid path or NULL, and joins onto it the array of paths segments given. Returns a value, typically with reference count of zero (but it could be shared under some conditions), containing the joined path. The caller must add a reference count to the value before using it. If any of the values passed into this function ( pathPtr or path elements) have a reference count of zero, they will be freed when this function returns. Tcl_FSConvertToPathType tries to convert the given Tcl_Obj to a valid Tcl path type, taking account of the fact that the cwd may have changed even if this value is already supposedly of the correct type. If the conversion succeeds (i.e. the value is a valid path in one of the current filesystems), then TCL_OK is returned. Otherwise TCL_ERROR is returned, and an error message may be left in the interpreter. Tcl_FSGetInternalRep extracts the internal representation of a given path value, in the given filesystem. If the path value belongs to a different filesystem, we return NULL. If the internal representation is currently NULL, we attempt to generate it, by calling the filesystem\\'s Tcl_FSCreateInternalRepProc . Returns NULL or a valid internal path representation. This internal representation is cached, so that repeated calls to this function will not require additional conversions. Tcl_FSGetTranslatedPath attempts to extract the translated path from the given Tcl_Obj. If the translation succeeds (i.e. the value is a valid path), then it is returned. Otherwise NULL will be returned, and an error message may be left in the interpreter. The value returned is owned by the caller, which must store it or call Tcl_DecrRefCount to ensure memory is freed. This function is of little practical use, and Tcl_FSGetNormalizedPath or Tcl_FSGetNativePath are usually better functions to use for most purposes. Tcl_FSGetTranslatedStringPath does the same as Tcl_FSGetTranslatedPath , but returns a character string or NULL. The string returned is dynamically allocated and owned by the caller, which must store it or call Tcl_Free to ensure it is freed. Again, Tcl_FSGetNormalizedPath or Tcl_FSGetNativePath are usually better functions to use for most purposes. Tcl_FSNewNativePath performs something like the reverse of the usual obj->path->nativerep conversions. If some code retrieves a path in native form (from, e.g. readlink or a native dialog), and that path is to be used at the Tcl level, then calling this function is an efficient way of creating the appropriate path value type. The resulting value is a pure value, which will only receive a UTF-8 string representation if that is required by some Tcl code. Tcl_FSGetNativePath is for use by the Win/Unix native filesystems, so that they can easily retrieve the native (char* or TCHAR*) representation of a path. This function is a convenience wrapper around Tcl_FSGetInternalRep . It may be desirable in the future to have non-string-based native representations (for example, on MacOSX, a representation using a fileSpec of FSRef structure would probably be more efficient). On Windows a full Unicode representation would allow for paths of unlimited length. Currently the representation is simply a character string which may contain either the relative path or a complete, absolute normalized path in the native encoding (complex conditions dictate which of these will be provided, so neither can be relied upon, unless the path is known to be absolute). If you need a native path which must be absolute, then you should ask for the native version of a normalized path. If for some reason a non-absolute, non-normalized version of the path is needed, that must be constructed separately (e.g. using Tcl_FSGetTranslatedPath ). The native representation is cached so that repeated calls to this function will not require additional conversions. The return value is owned by Tcl and has a lifetime equivalent to that of the pathPtr passed in (unless that is a relative path, in which case the native representation may be freed any time the cwd changes). Tcl_FSFileSystemInfo returns a list of two elements. The first element is the name of the filesystem (e.g. or perhaps), and the second is the particular type of the given path within that filesystem (which is filesystem dependent). The second element may be empty if the filesystem does not provide a further categorization of files. A valid list value is returned, unless the path value is not recognized, when NULL will be returned. Tcl_FSGetFileSystemForPath returns a pointer to the Tcl_Filesystem which accepts this path as valid. If no filesystem will accept the path, NULL is returned. Tcl_FSGetPathType determines whether the given path is relative to the current directory, relative to the current volume, or absolute. It returns one of TCL_PATH_ABSOLUTE , TCL_PATH_RELATIVE , or TCL_PATH_VOLUME_RELATIVE","title":"FS API FUNCTIONS"},{"location":"FileSystem/#portable-stat-result-api","text":"Tcl_AllocStatBuf allocates a Tcl_StatBuf on the system heap (which may be deallocated by being passed to Tcl_Free ). This allows extensions to invoke Tcl_FSStat and Tcl_FSLstat without being dependent on the size of the buffer. That in turn depends on the flags used to build Tcl. The portable fields of a Tcl_StatBuf may be read using the following functions, each of which returns the value of the corresponding field listed in the table below. Note that on some platforms there may be other fields in the Tcl_StatBuf as it is an alias for a suitable system structure, but only the portable ones are made available here. See your system documentation for a full description of these fields. Access Function Field Tcl_GetFSDeviceFromStat st_dev Tcl_GetFSInodeFromStat st_ino Tcl_GetModeFromStat st_mode Tcl_GetLinkCountFromStat st_nlink Tcl_GetUserIdFromStat st_uid Tcl_GetGroupIdFromStat st_gid Tcl_GetDeviceTypeFromStat st_rdev Tcl_GetAccessTimeFromStat st_atime Tcl_GetModificationTimeFromStat st_mtime Tcl_GetChangeTimeFromStat st_ctime Tcl_GetSizeFromStat st_size Tcl_GetBlocksFromStat st_blocks Tcl_GetBlockSizeFromStat st_blksize","title":"PORTABLE STAT RESULT API"},{"location":"FileSystem/#the-virtual-filesystem-api","text":"A filesystem provides a Tcl_Filesystem structure that contains pointers to functions that implement the various operations on a filesystem; these operations are invoked as needed by the generic layer, which generally occurs through the functions listed above. The Tcl_Filesystem structures are manipulated using the following methods. Tcl_FSRegister takes a pointer to a filesystem structure and an optional piece of data to associated with that filesystem. On calling this function, Tcl will attach the filesystem to the list of known filesystems, and it will become fully functional immediately. Tcl does not check if the same filesystem is registered multiple times (and in general that is not a good thing to do). TCL_OK will be returned. Tcl_FSUnregister removes the given filesystem structure from the list of known filesystems, if it is known, and returns TCL_OK . If the filesystem is not currently registered, TCL_ERROR is returned. Tcl_FSData will return the clientData associated with the given filesystem, if that filesystem is registered. Otherwise it will return NULL. Tcl_FSMountsChanged is used to inform the Tcl\\'s core that the set of mount points for the given (already registered) filesystem have changed, and that cached file representations may therefore no longer be correct.","title":"THE VIRTUAL FILESYSTEM API"},{"location":"FileSystem/#the-tcl_filesystem-structure","text":"The Tcl_Filesystem structure contains the following fields: typedef struct Tcl_Filesystem { const char * typeName ; Tcl_Size structureLength ; Tcl_FSVersion version ; Tcl_FSPathInFilesystemProc * pathInFilesystemProc ; Tcl_FSDupInternalRepProc * dupInternalRepProc ; Tcl_FSFreeInternalRepProc * freeInternalRepProc ; Tcl_FSInternalToNormalizedProc * internalToNormalizedProc ; Tcl_FSCreateInternalRepProc * createInternalRepProc ; Tcl_FSNormalizePathProc * normalizePathProc ; Tcl_FSFilesystemPathTypeProc * filesystemPathTypeProc ; Tcl_FSFilesystemSeparatorProc * filesystemSeparatorProc ; Tcl_FSStatProc * statProc ; Tcl_FSAccessProc * accessProc ; Tcl_FSOpenFileChannelProc * openFileChannelProc ; Tcl_FSMatchInDirectoryProc * matchInDirectoryProc ; Tcl_FSUtimeProc * utimeProc ; Tcl_FSLinkProc * linkProc ; Tcl_FSListVolumesProc * listVolumesProc ; Tcl_FSFileAttrStringsProc * fileAttrStringsProc ; Tcl_FSFileAttrsGetProc * fileAttrsGetProc ; Tcl_FSFileAttrsSetProc * fileAttrsSetProc ; Tcl_FSCreateDirectoryProc * createDirectoryProc ; Tcl_FSRemoveDirectoryProc * removeDirectoryProc ; Tcl_FSDeleteFileProc * deleteFileProc ; Tcl_FSCopyFileProc * copyFileProc ; Tcl_FSRenameFileProc * renameFileProc ; Tcl_FSCopyDirectoryProc * copyDirectoryProc ; Tcl_FSLstatProc * lstatProc ; Tcl_FSLoadFileProc * loadFileProc ; Tcl_FSGetCwdProc * getCwdProc ; Tcl_FSChdirProc * chdirProc ; } Tcl_Filesystem ; Except for the first three fields in this structure which contain simple data elements, all entries contain addresses of functions called by the generic filesystem layer to perform the complete range of filesystem related actions. The many functions in this structure are broken down into three categories: infrastructure functions (almost all of which must be implemented), operational functions (which must be implemented if a complete filesystem is provided), and efficiency functions (which need only be implemented if they can be done so efficiently, or if they have side-effects which are required by the filesystem; Tcl has less efficient emulations it can fall back on). It is important to note that, in the current version of Tcl, most of these fallbacks are only used to handle commands initiated in Tcl, not in C. What this means is, that if a file rename command is issued in Tcl, and the relevant filesystem(s) do not implement their Tcl_FSRenameFileProc , Tcl\\'s core will instead fallback on a combination of other filesystem functions (it will use Tcl_FSCopyFileProc followed by Tcl_FSDeleteFileProc , and if Tcl_FSCopyFileProc is not implemented there is a further fallback). However, if a Tcl_FSRenameFileProc command is issued at the C level, no such fallbacks occur. This is true except for the last four entries in the filesystem table ( lstat , load , getcwd and chdir ) for which fallbacks do in fact occur at the C level. Any functions which take path names in Tcl_Obj form take those names in UTF-8 form. The filesystem infrastructure API is designed to support efficient, cached conversion of these UTF-8 paths to other native representations.","title":"THE TCL_FILESYSTEM STRUCTURE"},{"location":"FileSystem/#example-filesystem-definition","text":"Here is the filesystem lookup table used by the extension which allows filesystem actions to be implemented in Tcl. static Tcl_Filesystem vfsFilesystem = { \\\"tclvfs\\\", sizeof(Tcl_Filesystem), TCL_FILESYSTEM_VERSION_1, &VfsPathInFilesystem, &VfsDupInternalRep, &VfsFreeInternalRep, /* No internal to normalized, since we don\\'t create * any pure \\'internal\\' Tcl_Obj path representations */ NULL, /* No create native rep function, since we don\\'t use * it and don\\'t choose to support uses of * Tcl_FSNewNativePath */ NULL, /* Normalize path isn\\'t needed - we assume paths only * have one representation */ NULL, &VfsFilesystemPathType, &VfsFilesystemSeparator, &VfsStat, &VfsAccess, &VfsOpenFileChannel, &VfsMatchInDirectory, &VfsUtime, /* We choose not to support symbolic links inside our * VFS\\'s */ NULL, &VfsListVolumes, &VfsFileAttrStrings, &VfsFileAttrsGet, &VfsFileAttrsSet, &VfsCreateDirectory, &VfsRemoveDirectory, &VfsDeleteFile, /* No copy file; use the core fallback mechanism */ NULL, /* No rename file; use the core fallback mechanism */ NULL, /* No copy directory; use the core fallback mechanism */ NULL, /* Core will use stat for lstat */ NULL, /* No load; use the core fallback mechanism */ NULL, /* We don\\'t need a getcwd or chdir; the core\\'s own * internal value is suitable */ NULL, NULL };","title":"EXAMPLE FILESYSTEM DEFINITION"},{"location":"FileSystem/#filesystem-infrastructure","text":"These fields contain basic information about the filesystem structure and addresses of functions which are used to associate a particular filesystem with a file path, and deal with the internal handling of path representations, for example copying and freeing such representations.","title":"FILESYSTEM INFRASTRUCTURE"},{"location":"FileSystem/#typename","text":"The typeName field contains a null-terminated string that identifies the type of the filesystem implemented, e.g. or","title":"TYPENAME"},{"location":"FileSystem/#structure-length","text":"The structureLength field is generally implemented as sizeof(Tcl_Filesystem) , and is there to allow easier binary backwards compatibility if the size of the structure changes in a future Tcl release.","title":"STRUCTURE LENGTH"},{"location":"FileSystem/#version","text":"The version field should be set to TCL_FILESYSTEM_VERSION_1 .","title":"VERSION"},{"location":"FileSystem/#pathinfilesystemproc","text":"The pathInFilesystemProc field contains the address of a function which is called to determine whether a given path value belongs to this filesystem or not. Tcl will only call the rest of the filesystem functions with a path for which this function has returned TCL_OK . If the path does not belong, -1 should be returned (the behavior of Tcl for any other return value is not defined). If TCL_OK is returned, then the optional clientDataPtr output parameter can be used to return an internal (filesystem specific) representation of the path, which will be cached inside the path value, and may be retrieved efficiently by the other filesystem functions. Tcl will simultaneously cache the fact that this path belongs to this filesystem. Such caches are invalidated when filesystem structures are added or removed from Tcl\\'s internal list of known filesystems. typedef int Tcl_FSPathInFilesystemProc ( Tcl_Obj * pathPtr , void ** clientDataPtr );","title":"PATHINFILESYSTEMPROC"},{"location":"FileSystem/#dupinternalrepproc","text":"This function makes a copy of a path\\'s internal representation, and is called when Tcl needs to duplicate a path value. If NULL, Tcl will simply not copy the internal representation, which may then need to be regenerated later. typedef void * Tcl_FSDupInternalRepProc ( void * clientData );","title":"DUPINTERNALREPPROC"},{"location":"FileSystem/#freeinternalrepproc","text":"Free the internal representation. This must be implemented if internal representations need freeing (i.e. if some memory is allocated when an internal representation is generated), but may otherwise be NULL. typedef void Tcl_FSFreeInternalRepProc ( void * clientData );","title":"FREEINTERNALREPPROC"},{"location":"FileSystem/#internaltonormalizedproc","text":"Function to convert internal representation to a normalized path. Only required if the filesystem creates pure path values with no string/path representation. The return value is a Tcl value whose string representation is the normalized path. typedef Tcl_Obj * Tcl_FSInternalToNormalizedProc ( void * clientData );","title":"INTERNALTONORMALIZEDPROC"},{"location":"FileSystem/#createinternalrepproc","text":"Function to take a path value, and calculate an internal representation for it, and store that native representation in the value. May be NULL if paths have no internal representation, or if the Tcl_FSPathInFilesystemProc for this filesystem always immediately creates an internal representation for paths it accepts. typedef void * Tcl_FSCreateInternalRepProc ( Tcl_Obj * pathPtr );","title":"CREATEINTERNALREPPROC"},{"location":"FileSystem/#normalizepathproc","text":"Function to normalize a path. Should be implemented for all filesystems which can have multiple string representations for the same path value. In Tcl, every must have a single unique string representation. Depending on the filesystem, there may be more than one unnormalized string representation which refers to that path (e.g. a relative path, a path with different character case if the filesystem is case insensitive, a path containing symbolic links, etc). If the very last component in the path is a symbolic link, it should not be converted into the value it points to (but its case or other aspects should be made unique). All other path components should be converted from symbolic links. This one exception is required to agree with Tcl\\'s semantics with file delete, file rename , file copy operating on symbolic links. This function may be called with nextCheckpoint either at the beginning of the path (i.e. zero), at the end of the path, or at any intermediate file separator in the path. It will never point to any other arbitrary position in the path. In the last of the three valid cases, the implementation can assume that the path up to and including the file separator is known and normalized. typedef int Tcl_FSNormalizePathProc ( Tcl_Interp * interp , Tcl_Obj * pathPtr , int nextCheckpoint );","title":"NORMALIZEPATHPROC"},{"location":"FileSystem/#filesystem-operations","text":"The fields in this section of the structure contain addresses of functions which are called to carry out the basic filesystem operations. A filesystem which expects to be used with the complete standard Tcl command set must implement all of these. If some of them are not implemented, then certain Tcl commands may fail when operating on paths within that filesystem. However, in some instances this may be desirable (for example, a read-only filesystem should not implement the last four functions, and a filesystem which does not support symbolic links need not implement the readlink function, etc. The Tcl core expects filesystems to behave in this way).","title":"FILESYSTEM OPERATIONS"},{"location":"FileSystem/#filesystempathtypeproc","text":"Function to determine the type of a path in this filesystem. May be NULL, in which case no type information will be available to users of the filesystem. The is used only for informational purposes, and should be returned as the string representation of the Tcl_Obj which is returned. A typical return value might be or The Tcl_Obj result is owned by the filesystem and so Tcl will increment the reference count of that value if it wishes to retain a reference to it. typedef Tcl_Obj * Tcl_FSFilesystemPathTypeProc ( Tcl_Obj * pathPtr );","title":"FILESYSTEMPATHTYPEPROC"},{"location":"FileSystem/#filesystemseparatorproc","text":"Function to return the separator character(s) for this filesystem. This need only be implemented if the filesystem wishes to use a different separator than the standard string Amongst other uses, it is returned by the file separator command. The return value should be a value with reference count of zero. typedef Tcl_Obj * Tcl_FSFilesystemSeparatorProc ( Tcl_Obj * pathPtr );","title":"FILESYSTEMSEPARATORPROC"},{"location":"FileSystem/#statproc","text":"Function to process a Tcl_FSStat call. Must be implemented for any reasonable filesystem, since many Tcl level commands depend crucially upon it (e.g. file atime , file isdirectory , file size , glob ). typedef int Tcl_FSStatProc ( Tcl_Obj * pathPtr , Tcl_StatBuf * statPtr ); The Tcl_FSStatProc fills the stat structure statPtr with information about the specified file. You do not need any access rights to the file to get this information but you need search rights to all directories named in the path leading to the file. The stat structure includes info regarding device, inode (always 0 on Windows), privilege mode, nlink (always 1 on Windows), user id (always 0 on Windows), group id (always 0 on Windows), rdev (same as device on Windows), size, last access time, last modification time, and last metadata change time. If the file represented by pathPtr exists, the Tcl_FSStatProc returns 0 and the stat structure is filled with data. Otherwise, -1 is returned, and no stat info is given.","title":"STATPROC"},{"location":"FileSystem/#accessproc","text":"Function to process a Tcl_FSAccess call. Must be implemented for any reasonable filesystem, since many Tcl level commands depend crucially upon it (e.g. file exists , file readable ). typedef int Tcl_FSAccessProc ( Tcl_Obj * pathPtr , int mode ); The Tcl_FSAccessProc checks whether the process would be allowed to read, write or test for existence of the file (or other filesystem object) whose name is in pathPtr . If the pathname refers to a symbolic link, then the permissions of the file referred by this symbolic link should be tested. On success (all requested permissions granted), zero is returned. On error (at least one bit in mode asked for a permission that is denied, or some other error occurred), -1 is returned.","title":"ACCESSPROC"},{"location":"FileSystem/#openfilechannelproc","text":"Function to process a Tcl_FSOpenFileChannel call. Must be implemented for any reasonable filesystem, since any operations which require open or accessing a file\\'s contents will use it (e.g. open , encoding , and many Tk commands). typedef Tcl_Channel Tcl_FSOpenFileChannelProc ( Tcl_Interp * interp , Tcl_Obj * pathPtr , int mode , int permissions ); The Tcl_FSOpenFileChannelProc opens a file specified by pathPtr and returns a channel handle that can be used to perform input and output on the file. This API is modeled after the fopen procedure of the Unix standard I/O library. The syntax and meaning of all arguments is similar to those given in the Tcl open command when opening a file, where the mode argument is a combination of the POSIX flags O_RDONLY, O_WRONLY, etc. If an error occurs while opening the channel, the Tcl_FSOpenFileChannelProc returns NULL and records a POSIX error code that can be retrieved with Tcl_GetErrno . In addition, if interp is non-NULL, the Tcl_FSOpenFileChannelProc leaves an error message in interp \\'s result after any error. The newly created channel must not be registered in the supplied interpreter by a Tcl_FSOpenFileChannelProc ; that task is up to the caller of Tcl_FSOpenFileChannel (if necessary). If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel.","title":"OPENFILECHANNELPROC"},{"location":"FileSystem/#matchindirectoryproc","text":"Function to process a Tcl_FSMatchInDirectory call. If not implemented, then glob and recursive copy functionality will be lacking in the filesystem (and this may impact commands like encoding names which use glob functionality internally). typedef int Tcl_FSMatchInDirectoryProc ( Tcl_Interp * interp , Tcl_Obj * resultPtr , Tcl_Obj * pathPtr , const char * pattern , Tcl_GlobTypeData * types ); The function should return all files or directories (or other filesystem objects) which match the given pattern and accord with the types specification given. There are two ways in which this function may be called. If pattern is NULL, then pathPtr is a full path specification of a single file or directory which should be checked for existence and correct type. Otherwise, pathPtr is a directory, the contents of which the function should search for files or directories which have the correct type. In either case, pathPtr can be assumed to be both non-NULL and non-empty. It is not currently documented whether pathPtr will have a file separator at its end of not, so code should be flexible to both possibilities. The return value is a standard Tcl result indicating whether an error occurred in the matching process. Error messages are placed in interp , unless interp in NULL in which case no error message need be generated; on a TCL_OK result, results should be added to the resultPtr value given (which can be assumed to be a valid unshared Tcl list). The matches added to resultPtr should include any path prefix given in pathPtr (this usually means they will be absolute path specifications). Note that if no matches are found, that simply leads to an empty result; errors are only signaled for actual file or filesystem problems which may occur during the matching process. The Tcl_GlobTypeData structure passed in the types parameter contains the following fields: typedef struct Tcl_GlobTypeData { /* Corresponds to bcdpfls as in \\'find -t\\' */ int type ; /* Corresponds to file permissions */ int perm ; /* Acceptable mac type */ Tcl_Obj * macType ; /* Acceptable mac creator */ Tcl_Obj * macCreator ; } Tcl_GlobTypeData ; There are two specific cases which it is important to handle correctly, both when types is non-NULL. The two cases are when types->types & TCL_GLOB_TYPE_DIR or types->types & TCL_GLOB_TYPE_MOUNT are true (and in particular when the other flags are false). In the first of these cases, the function must list the contained directories. Tcl uses this to implement recursive globbing, so it is critical that filesystems implement directory matching correctly. In the second of these cases, with TCL_GLOB_TYPE_MOUNT , the filesystem must list the mount points which lie within the given pathPtr (and in this case, pathPtr need not lie within the same filesystem - different to all other cases in which this function is called). Support for this is critical if Tcl is to have seamless transitions between from one filesystem to another.","title":"MATCHINDIRECTORYPROC"},{"location":"FileSystem/#utimeproc","text":"Function to process a Tcl_FSUtime call. Required to allow setting (not reading) of times with file mtime , file atime and the open-r/open-w/fcopy implementation of file copy . typedef int Tcl_FSUtimeProc ( Tcl_Obj * pathPtr , struct utimbuf * tval ); The access and modification times of the file specified by pathPtr should be changed to the values given in the tval structure. The return value should be 0 on success and -1 on an error, as with the system utime .","title":"UTIMEPROC"},{"location":"FileSystem/#linkproc","text":"Function to process a Tcl_FSLink call. Should be implemented only if the filesystem supports links, and may otherwise be NULL. typedef Tcl_Obj * Tcl_FSLinkProc ( Tcl_Obj * linkNamePtr , Tcl_Obj * toPtr , int linkAction ); If toPtr is NULL, the function is being asked to read the contents of a link. The result is a Tcl_Obj specifying the contents of the link given by linkNamePtr , or NULL if the link could not be read. The result is owned by the caller (and should therefore have its ref count incremented before being returned). Any callers should call Tcl_DecrRefCount on this result when it is no longer needed. If toPtr is not NULL, the function should attempt to create a link. The result in this case should be toPtr if the link was successful and NULL otherwise. In this case the result is not owned by the caller (i.e. no reference count manipulations on either end are needed). See the documentation for Tcl_FSLink for the correct interpretation of the linkAction flags.","title":"LINKPROC"},{"location":"FileSystem/#listvolumesproc","text":"Function to list any filesystem volumes added by this filesystem. Should be implemented only if the filesystem adds volumes at the head of the filesystem, so that they can be returned by file volumes . typedef Tcl_Obj * Tcl_FSListVolumesProc (void); The result should be a list of volumes added by this filesystem, or NULL (or an empty list) if no volumes are provided. The result value is considered to be owned by the filesystem (not by Tcl\\'s core), but should be given a reference count for Tcl. Tcl will use the contents of the list and then decrement that reference count. This allows filesystems to choose whether they actually want to retain a of volumes or not (if not, they generate the list on the fly and pass it to Tcl with a reference count of 1 and then forget about the list, if yes, then they simply increment the reference count of their global list and pass it to Tcl which will copy the contents and then decrement the count back to where it was). Therefore, Tcl considers return values from this proc to be read-only.","title":"LISTVOLUMESPROC"},{"location":"FileSystem/#fileattrstringsproc","text":"Function to list all attribute strings which are valid for this filesystem. If not implemented the filesystem will not support the file attributes command. This allows arbitrary additional information to be attached to files in the filesystem. If it is not implemented, there is no need to implement the get and set methods. typedef const char *const * Tcl_FSFileAttrStringsProc ( Tcl_Obj * pathPtr , Tcl_Obj ** objPtrRef ); The called function may either return an array of strings, or may instead return NULL and place a Tcl list into the given objPtrRef . Tcl will take that list and first increment its reference count before using it. On completion of that use, Tcl will decrement its reference count. Hence if the list should be disposed of by Tcl when done, it should have a reference count of zero, and if the list should not be disposed of, the filesystem should ensure it returns a value with a reference count of at least one.","title":"FILEATTRSTRINGSPROC"},{"location":"FileSystem/#fileattrsgetproc","text":"Function to process a Tcl_FSFileAttrsGet call, used by file attributes. typedef int Tcl_FSFileAttrsGetProc ( Tcl_Interp * interp , int index , Tcl_Obj * pathPtr , Tcl_Obj ** objPtrRef ); Returns a standard Tcl return code. The attribute value retrieved, which corresponds to the index \\'th element in the list returned by the Tcl_FSFileAttrStringsProc , is a Tcl_Obj placed in objPtrRef (if TCL_OK was returned) and is likely to have a reference count of zero. Either way we must either store it somewhere (e.g. the Tcl result), or Incr/Decr its reference count to ensure it is properly freed.","title":"FILEATTRSGETPROC"},{"location":"FileSystem/#fileattrssetproc","text":"Function to process a Tcl_FSFileAttrsSet call, used by file attributes. If the filesystem is read-only, there is no need to implement this. typedef int Tcl_FSFileAttrsSetProc ( Tcl_Interp * interp , int index , Tcl_Obj * pathPtr , Tcl_Obj * objPtr ); The attribute value of the index \\'th element in the list returned by the Tcl_FSFileAttrStringsProc should be set to the objPtr given.","title":"FILEATTRSSETPROC"},{"location":"FileSystem/#createdirectoryproc","text":"Function to process a Tcl_FSCreateDirectory call. Should be implemented unless the FS is read-only. typedef int Tcl_FSCreateDirectoryProc ( Tcl_Obj * pathPtr ); The return value is a standard Tcl result indicating whether an error occurred in the process. If successful, a new directory should have been added to the filesystem in the location specified by pathPtr .","title":"CREATEDIRECTORYPROC"},{"location":"FileSystem/#removedirectoryproc","text":"Function to process a Tcl_FSRemoveDirectory call. Should be implemented unless the FS is read-only. typedef int Tcl_FSRemoveDirectoryProc ( Tcl_Obj * pathPtr , int recursive , Tcl_Obj ** errorPtr ); The return value is a standard Tcl result indicating whether an error occurred in the process. If successful, the directory specified by pathPtr should have been removed from the filesystem. If the recursive flag is given, then a non-empty directory should be deleted without error. If this flag is not given, then and the directory is non-empty a POSIX error should be signaled. If an error does occur, the name of the file or directory which caused the error should be placed in errorPtr .","title":"REMOVEDIRECTORYPROC"},{"location":"FileSystem/#deletefileproc","text":"Function to process a Tcl_FSDeleteFile call. Should be implemented unless the FS is read-only. typedef int Tcl_FSDeleteFileProc ( Tcl_Obj * pathPtr ); The return value is a standard Tcl result indicating whether an error occurred in the process. If successful, the file specified by pathPtr should have been removed from the filesystem. Note that, if the filesystem supports symbolic links, Tcl will always call this function and not Tcl_FSRemoveDirectoryProc when needed to delete them (even if they are symbolic links to directories).","title":"DELETEFILEPROC"},{"location":"FileSystem/#filesystem-efficiency","text":"These functions need not be implemented for a particular filesystem because the core has a fallback implementation available. See each individual description for the consequences of leaving the field NULL.","title":"FILESYSTEM EFFICIENCY"},{"location":"FileSystem/#lstatproc","text":"Function to process a Tcl_FSLstat call. If not implemented, Tcl will attempt to use the statProc defined above instead. Therefore it need only be implemented if a filesystem can differentiate between stat and lstat calls. typedef int Tcl_FSLstatProc ( Tcl_Obj * pathPtr , Tcl_StatBuf * statPtr ); The behavior of this function is very similar to that of the Tcl_FSStatProc defined above, except that if it is applied to a symbolic link, it returns information about the link, not about the target file.","title":"LSTATPROC"},{"location":"FileSystem/#copyfileproc","text":"Function to process a Tcl_FSCopyFile call. If not implemented Tcl will fall back on open -r, open -w and fcopy as a copying mechanism. Therefore it need only be implemented if the filesystem can perform that action more efficiently. typedef int Tcl_FSCopyFileProc ( Tcl_Obj * srcPathPtr , Tcl_Obj * destPathPtr ); The return value is a standard Tcl result indicating whether an error occurred in the copying process. Note that, destPathPtr is the name of the file which should become the copy of srcPathPtr . It is never the name of a directory into which srcPathPtr could be copied (i.e. the function is much simpler than the Tcl level file copy subcommand). Note that, if the filesystem supports symbolic links, Tcl will always call this function and not copyDirectoryProc when needed to copy them (even if they are symbolic links to directories). Finally, if the filesystem determines it cannot support the file copy action, calling Tcl_SetErrno(EXDEV) and returning a non- TCL_OK result will tell Tcl to use its standard fallback mechanisms.","title":"COPYFILEPROC"},{"location":"FileSystem/#renamefileproc","text":"Function to process a Tcl_FSRenameFile call. If not implemented, Tcl will fall back on a copy and delete mechanism. Therefore it need only be implemented if the filesystem can perform that action more efficiently. typedef int Tcl_FSRenameFileProc ( Tcl_Obj * srcPathPtr , Tcl_Obj * destPathPtr ); The return value is a standard Tcl result indicating whether an error occurred in the renaming process. If the filesystem determines it cannot support the file rename action, calling Tcl_SetErrno(EXDEV) and returning a non- TCL_OK result will tell Tcl to use its standard fallback mechanisms.","title":"RENAMEFILEPROC"},{"location":"FileSystem/#copydirectoryproc","text":"Function to process a Tcl_FSCopyDirectory call. If not implemented, Tcl will fall back on a recursive file mkdir , file copy mechanism. Therefore it need only be implemented if the filesystem can perform that action more efficiently. typedef int Tcl_FSCopyDirectoryProc ( Tcl_Obj * srcPathPtr , Tcl_Obj * destPathPtr , Tcl_Obj ** errorPtr ); The return value is a standard Tcl result indicating whether an error occurred in the copying process. If an error does occur, the name of the file or directory which caused the error should be placed in errorPtr . Note that, destPathPtr is the name of the directory-name which should become the mirror-image of srcPathPtr . It is not the name of a directory into which srcPathPtr should be copied (i.e. the function is much simpler than the Tcl level file copy subcommand). Finally, if the filesystem determines it cannot support the directory copy action, calling Tcl_SetErrno(EXDEV) and returning a non- TCL_OK result will tell Tcl to use its standard fallback mechanisms.","title":"COPYDIRECTORYPROC"},{"location":"FileSystem/#loadfileproc","text":"Function to process a Tcl_FSLoadFile call. If not implemented, Tcl will fall back on a copy to native-temp followed by a Tcl_FSLoadFile on that temporary copy. Therefore it need only be implemented if the filesystem can load code directly, or it can be implemented simply to return TCL_ERROR to disable load functionality in this filesystem entirely. typedef int Tcl_FSLoadFileProc ( Tcl_Interp * interp , Tcl_Obj * pathPtr , Tcl_LoadHandle * handlePtr , Tcl_FSUnloadFileProc * unloadProcPtr ); Returns a standard Tcl completion code. If an error occurs, an error message is left in the interp \\'s result. The function dynamically loads a binary code file into memory. On a successful load, the handlePtr should be filled with a token for the dynamically loaded file, and the unloadProcPtr should be filled in with the address of a procedure. The unload procedure will be called with the given Tcl_LoadHandle as its only parameter when Tcl needs to unload the file. For example, for the native filesystem, the Tcl_LoadHandle returned is currently a token which can be used in the private TclpFindSymbol to access functions in the new code. Each filesystem is free to define the Tcl_LoadHandle as it requires. Finally, if the filesystem determines it cannot support the file load action, calling Tcl_SetErrno(EXDEV) and returning a non- TCL_OK result will tell Tcl to use its standard fallback mechanisms.","title":"LOADFILEPROC"},{"location":"FileSystem/#unloadfileproc","text":"Function to unload a previously successfully loaded file. If load was implemented, then this should also be implemented, if there is any cleanup action required. typedef void Tcl_FSUnloadFileProc ( Tcl_LoadHandle loadHandle );","title":"UNLOADFILEPROC"},{"location":"FileSystem/#getcwdproc","text":"Function to process a Tcl_FSGetCwd call. Most filesystems need not implement this. It will usually only be called once, if getcwd is called before chdir . May be NULL. typedef Tcl_Obj * Tcl_FSGetCwdProc ( Tcl_Interp * interp ); If the filesystem supports a native notion of a current working directory (which might perhaps change independent of Tcl), this function should return that cwd as the result, or NULL if the current directory could not be determined (e.g. the user does not have appropriate permissions on the cwd directory). If NULL is returned, an error message is left in the interp \\'s result.","title":"GETCWDPROC"},{"location":"FileSystem/#chdirproc","text":"Function to process a Tcl_FSChdir call. If filesystems do not implement this, it will be emulated by a series of directory access checks. Otherwise, virtual filesystems which do implement it need only respond with a positive return result if the pathPtr is a valid, accessible directory in their filesystem. They need not remember the result, since that will be automatically remembered for use by Tcl_FSGetCwd . Real filesystems should carry out the correct action (i.e. call the correct system chdir API). typedef int Tcl_FSChdirProc ( Tcl_Obj * pathPtr ); The Tcl_FSChdirProc changes the applications current working directory to the value specified in pathPtr . The function returns -1 on error or 0 on success.","title":"CHDIRPROC"},{"location":"FileSystem/#reference-count-management","text":"","title":"REFERENCE COUNT MANAGEMENT"},{"location":"FileSystem/#public-api-calls","text":"For all of these functions, pathPtr (including the srcPathPtr and destPathPtr arguments to Tcl_FSCopyFile , Tcl_FSCopyDirectory , and Tcl_FSRenameFile , the firstPtr and secondPtr arguments to Tcl_FSEqualPaths , and the linkNamePtr and toPtr arguments to Tcl_FSLink ) must not be a zero reference count value; references may be retained in internal caches even for theoretically read-only operations. These functions may also manipulate the interpreter result (if they take and are given a non-NULL interp argument); you must not count on the interpreter result to hold the reference count of any argument value over these calls and should manage your own references there. However, references held by the arguments to a Tcl command are suitable for reference count management purposes for the duration of the implementation of that command. The errorPtr argument to Tcl_FSCopyDirectory and Tcl_FSRemoveDirectory is, when an object is set into it at all, set to an object with a non-zero reference count that should be passed to Tcl_DecrRefCount when no longer needed. Tcl_FSListVolumes always returns a zero-reference object, much like Tcl_NewObj . Tcl_FSLink always returns a non-zero-reference object when it is asked to read; you must call Tcl_DecrRefCount on the object once you no longer need it. Tcl_FSGetCwd always returns a non-zero-reference object; you must call Tcl_DecrRefCount on the object once you no longer need it. Tcl_FSPathSeparator always returns a zero-reference object, much like Tcl_NewObj . Tcl_FSJoinPath always returns a zero-reference object, much like Tcl_NewObj . Its listObj argument can have any reference count; it is only read by this function. Tcl_FSSplitPath always returns a zero-reference object, much like Tcl_NewObj . Tcl_FSGetNormalizedPath returns an object with a non-zero reference count where Tcl is the owner. You should increment its reference count if you want to retain it, but do not need to if you are just using the value immediately. Tcl_FSJoinToPath always returns a zero-reference object, much like Tcl_NewObj . Its basePtr argument follows the rules above for pathPtr , as do the values in the objv argument. Tcl_FSGetTranslatedPath returns a non-zero-reference object (or NULL in the error case); you must call Tcl_DecrRefCount on the object once you no longer need it. Tcl_FSNewNativePath always returns a zero-reference object (or NULL), much like Tcl_NewObj . Tcl_FSFileSystemInfo always returns a zero-reference object (or NULL), much like Tcl_NewObj . The objPtr and objPtrRef arguments to Tcl_FSFileAttrsGet , Tcl_FSFileAttrsSet and Tcl_FSFileAttrStrings are conventional Tcl values; the objPtr argument will be read but not retained, and the objPtrRef argument will have (on success) a zero-reference value written into it (as with Tcl_NewObj ). Tcl_FSFileAttrsGet and Tcl_FSFileAttrsSet may also manipulate the interpreter result. The resultPtr argument to Tcl_FSMatchInDirectory will not have its reference count manipulated, but it should have a reference count of no more than 1, and should not be the current interpreter result (as the function may overwrite that on error).","title":"PUBLIC API CALLS"},{"location":"FileSystem/#virtual-filesystem-interface","text":"For all virtual filesystem implementation functions, any pathPtr arguments should not have their reference counts manipulated. If they take an interp argument, they may set an error message in that, but must not manipulate the pathPtr afterwards. Aside from that: internalToNormalizedProc : This should return a zero-reference count value, as if allocated with Tcl_NewObj . normalizePathProc : Unlike with other API implementation functions, the pathPtr argument here is guaranteed to be an unshared object that should be updated. Its reference count should not be modified. filesystemPathTypeProc : The return value (if non-NULL) either has a reference count of zero or needs to be maintained (on a per-thread basis) by the filesystem. Tcl will increment the reference count of the value if it wishes to retain it. filesystemSeparatorProc : The return value should be a value with reference count of zero. matchInDirectoryProc : The resultPtr argument should be assumed to hold a list that can be appended to (i.e., that has a reference count no greater than 1). No reference to it should be retained. linkProc : If toPtr is NULL, this should return a value with reference count 1 that has just been allocated and passed to Tcl_IncrRefCount . If toPtr is not NULL, it should be returned on success. listVolumesProc : The result value should be a list (if non-NULL); it will have its reference count decremented once (with Tcl_DecrRefCount ) by Tcl once done. fileAttrStringsProc : If the result is NULL, the objPtrRef should have a list value written to it; that list will have its reference count both incremented (with Tcl_IncrRefCount ) and decremented (with Tcl_DecrRefCount ). fileAttrsGetProc : The objPtrRef argument should have (on non-error return) a zero reference count value written to it (allocated as if with Tcl_NewObj ). fileAttrsSetProc : The objPtr argument should either just be read or its reference count incremented to retain it. removeDirectoryProc : If an error is being reported, the problem filename reported via errorPtr should be newly allocated (as if with Tcl_NewObj ) and have a reference count of 1 (i.e., have been passed to Tcl_IncrRefCount ). copyDirectoryProc : If an error is being reported, the problem filename reported via errorPtr should be newly allocated (as if with Tcl_NewObj ) and have a reference count of 1 (i.e., have been passed to Tcl_IncrRefCount ). getCwdProc : The result will be passed to Tcl_DecrRefCount by the implementation of Tcl_FSGetCwd after it has been normalized.","title":"VIRTUAL FILESYSTEM INTERFACE"},{"location":"FileSystem/#see-also","text":"cd(n), file(n), filename(n), load(n), open(n), pwd(n), source(n), unload(n)","title":"SEE ALSO"},{"location":"FileSystem/#keywords","text":"stat, access, filesystem, vfs, virtual filesystem","title":"KEYWORDS"},{"location":"FindExec/","text":"NAME Tcl_FindExecutable, Tcl_GetNameOfExecutable - identify or return the name of the binary file containing the application SYNOPSIS #include <tcl.h> const char * Tcl_FindExecutable(argv0) const char * Tcl_GetNameOfExecutable() ARGUMENTS The first command-line argument to the program, which gives the application\\'s name. DESCRIPTION The Tcl_FindExecutable procedure computes the full path name of the executable file from which the application was invoked and saves it for Tcl\\'s internal use. The executable\\'s path name is needed for several purposes in Tcl. For example, it is needed on some platforms in the implementation of the load command. It is also returned by the info nameofexecutable command. The result of Tcl_FindExecutable is the full Tcl version with build information (e.g., 9.0.0+abcdef...abcdef.gcc-1002 ). On UNIX platforms this procedure is typically invoked as the very first thing in the application\\'s main program; it must be passed argv[0] as its argument. It is important not to change the working directory before the invocation. Tcl_FindExecutable uses argv0 along with the PATH environment variable to find the application\\'s executable, if possible. If it fails to find the binary, then future calls to info nameofexecutable will return an empty string. On Windows platforms this procedure is typically invoked as the very first thing in the application\\'s main program as well; Its argv[0] argument is only used to indicate whether the executable has a stderr channel (any non-null value) or not (the value null). If Tcl_SetPanicProc is never called and no debugger is running, this determines whether the panic message is sent to stderr or to a standard system dialog. Tcl_GetNameOfExecutable simply returns a pointer to the internal full path name of the executable file as computed by Tcl_FindExecutable . This procedure call is the C API equivalent to the info nameofexecutable command. NULL is returned if the internal full path name has not been computed or unknown. Tcl_FindExecutable can not be used in stub-enabled extensions. KEYWORDS binary, executable file","title":"NAME"},{"location":"FindExec/#name","text":"Tcl_FindExecutable, Tcl_GetNameOfExecutable - identify or return the name of the binary file containing the application","title":"NAME"},{"location":"FindExec/#synopsis","text":"#include <tcl.h> const char * Tcl_FindExecutable(argv0) const char * Tcl_GetNameOfExecutable()","title":"SYNOPSIS"},{"location":"FindExec/#arguments","text":"The first command-line argument to the program, which gives the application\\'s name.","title":"ARGUMENTS"},{"location":"FindExec/#description","text":"The Tcl_FindExecutable procedure computes the full path name of the executable file from which the application was invoked and saves it for Tcl\\'s internal use. The executable\\'s path name is needed for several purposes in Tcl. For example, it is needed on some platforms in the implementation of the load command. It is also returned by the info nameofexecutable command. The result of Tcl_FindExecutable is the full Tcl version with build information (e.g., 9.0.0+abcdef...abcdef.gcc-1002 ). On UNIX platforms this procedure is typically invoked as the very first thing in the application\\'s main program; it must be passed argv[0] as its argument. It is important not to change the working directory before the invocation. Tcl_FindExecutable uses argv0 along with the PATH environment variable to find the application\\'s executable, if possible. If it fails to find the binary, then future calls to info nameofexecutable will return an empty string. On Windows platforms this procedure is typically invoked as the very first thing in the application\\'s main program as well; Its argv[0] argument is only used to indicate whether the executable has a stderr channel (any non-null value) or not (the value null). If Tcl_SetPanicProc is never called and no debugger is running, this determines whether the panic message is sent to stderr or to a standard system dialog. Tcl_GetNameOfExecutable simply returns a pointer to the internal full path name of the executable file as computed by Tcl_FindExecutable . This procedure call is the C API equivalent to the info nameofexecutable command. NULL is returned if the internal full path name has not been computed or unknown. Tcl_FindExecutable can not be used in stub-enabled extensions.","title":"DESCRIPTION"},{"location":"FindExec/#keywords","text":"binary, executable file","title":"KEYWORDS"},{"location":"GetCwd/","text":"NAME Tcl_GetCwd, Tcl_Chdir - manipulate the current working directory SYNOPSIS #include <tcl.h> char * Tcl_GetCwd(interp, bufferPtr) int Tcl_Chdir(dirName) ARGUMENTS Interpreter in which to report an error, if any. This dynamic string is used to store the current working directory. At the time of the call it should be uninitialized or free. The caller must eventually call Tcl_DStringFree to free up anything stored here. File path in UTF-8 format. DESCRIPTION These procedures may be used to manipulate the current working directory for the application. They provide C-level access to the same functionality as the Tcl pwd command. Tcl_GetCwd returns a pointer to a string specifying the current directory, or NULL if the current directory could not be determined. If NULL is returned, an error message is left in the interp \\'s result. Storage for the result string is allocated in bufferPtr; the caller must call Tcl_DStringFree() when the result is no longer needed. The format of the path is UTF-8. Tcl_Chdir changes the applications current working directory to the value specified in dirName . The format of the passed in string must be UTF-8. The function returns -1 on error or 0 on success. KEYWORDS pwd","title":"NAME"},{"location":"GetCwd/#name","text":"Tcl_GetCwd, Tcl_Chdir - manipulate the current working directory","title":"NAME"},{"location":"GetCwd/#synopsis","text":"#include <tcl.h> char * Tcl_GetCwd(interp, bufferPtr) int Tcl_Chdir(dirName)","title":"SYNOPSIS"},{"location":"GetCwd/#arguments","text":"Interpreter in which to report an error, if any. This dynamic string is used to store the current working directory. At the time of the call it should be uninitialized or free. The caller must eventually call Tcl_DStringFree to free up anything stored here. File path in UTF-8 format.","title":"ARGUMENTS"},{"location":"GetCwd/#description","text":"These procedures may be used to manipulate the current working directory for the application. They provide C-level access to the same functionality as the Tcl pwd command. Tcl_GetCwd returns a pointer to a string specifying the current directory, or NULL if the current directory could not be determined. If NULL is returned, an error message is left in the interp \\'s result. Storage for the result string is allocated in bufferPtr; the caller must call Tcl_DStringFree() when the result is no longer needed. The format of the path is UTF-8. Tcl_Chdir changes the applications current working directory to the value specified in dirName . The format of the passed in string must be UTF-8. The function returns -1 on error or 0 on success.","title":"DESCRIPTION"},{"location":"GetCwd/#keywords","text":"pwd","title":"KEYWORDS"},{"location":"GetHostName/","text":"NAME Tcl_GetHostName - get the name of the local host SYNOPSIS #include <tcl.h> const char * Tcl_GetHostName() DESCRIPTION Tcl_GetHostName is a utility procedure used by some of the Tcl commands. It returns a pointer to a string containing the name for the current machine, or an empty string if the name cannot be determined. The string is statically allocated, and the caller must not modify of free it. KEYWORDS hostname","title":"NAME"},{"location":"GetHostName/#name","text":"Tcl_GetHostName - get the name of the local host","title":"NAME"},{"location":"GetHostName/#synopsis","text":"#include <tcl.h> const char * Tcl_GetHostName()","title":"SYNOPSIS"},{"location":"GetHostName/#description","text":"Tcl_GetHostName is a utility procedure used by some of the Tcl commands. It returns a pointer to a string containing the name for the current machine, or an empty string if the name cannot be determined. The string is statically allocated, and the caller must not modify of free it.","title":"DESCRIPTION"},{"location":"GetHostName/#keywords","text":"hostname","title":"KEYWORDS"},{"location":"GetIndex/","text":"NAME Tcl_GetIndexFromObj, Tcl_GetIndexFromObjStruct - lookup string in table of keywords SYNOPSIS #include <tcl.h> int Tcl_GetIndexFromObj(interp, objPtr, tablePtr, msg, flags, indexPtr) int Tcl_GetIndexFromObjStruct(interp, objPtr, structTablePtr, offset, msg, flags, indexPtr) ARGUMENTS Interpreter to use for error reporting; if NULL, then no message is provided on errors. The string value of this value is used to search through tablePtr . If the TCL_INDEX_TEMP_TABLE flag is not specified, the internal representation is modified to hold the index of the matching table entry. An array of null-terminated strings. The end of the array is marked by a NULL string pointer. Note that, unless the TCL_INDEX_TEMP_TABLE flag is specified, references to the tablePtr may be retained in the internal representation of objPtr , so this should represent the address of a statically-allocated array. An array of arbitrary type, typically some struct type. The first member of the structure must be a null-terminated string. The size of the structure is given by offset . Note that, unless the TCL_INDEX_TEMP_TABLE flag is specified, references to the structTablePtr may be retained in the internal representation of objPtr , so this should represent the address of a statically-allocated array of structures. The offset to add to structTablePtr to get to the next entry. The end of the array is marked by a NULL string pointer. Null-terminated string describing what is being looked up, such as option . This string is included in error messages. OR-ed combination of bits providing additional information for operation. The only bits that are currently defined are TCL_EXACT , TCL_INDEX_TEMP_TABLE , and TCL_NULL_OK . If not (int *)NULL, the index of the string in tablePtr that matches the value of objPtr is returned here. The variable can be any integer type, signed or unsigned, char, short, long or long long. It can also be an enum. DESCRIPTION These procedures provide an efficient way for looking up keywords, switch names, option names, and similar things where the literal value of a Tcl value must be chosen from a predefined set. Tcl_GetIndexFromObj compares objPtr against each of the strings in tablePtr to find a match. A match occurs if objPtr \\'s string value is identical to one of the strings in tablePtr , or if it is a non-empty unique abbreviation for exactly one of the strings in tablePtr and the TCL_EXACT flag was not specified; in either case TCL_OK is returned. If indexPtr is not NULL the index of the matching entry is stored at *indexPtr . If there is no matching entry, TCL_ERROR is returned and an error message is left in interp \\'s result if interp is not NULL. Msg is included in the error message to indicate what was being looked up. For example, if msg is option the error message will have a form like If the TCL_INDEX_TEMP_TABLE was not specified, when Tcl_GetIndexFromObj completes successfully it modifies the internal representation of objPtr to hold the address of the table and the index of the matching entry. If Tcl_GetIndexFromObj is invoked again with the same objPtr and tablePtr arguments (e.g. during a reinvocation of a Tcl command), it returns the matching index immediately without having to redo the lookup operation. Note: Tcl_GetIndexFromObj assumes that the entries in tablePtr are static: they must not change between invocations. This caching mechanism can be disallowed by specifying the TCL_INDEX_TEMP_TABLE flag. If the TCL_NULL_OK flag was specified, objPtr is allowed to be NULL or the empty string. The resulting index is -1. Otherwise, if the value of objPtr is the empty string, Tcl_GetIndexFromObj will treat it as a non-matching value and return TCL_ERROR . Tcl_GetIndexFromObjStruct works just like Tcl_GetIndexFromObj , except that instead of treating tablePtr as an array of string pointers, it treats it as a pointer to the first string in a series of strings that have offset bytes between them (i.e. that there is a pointer to the first array of characters at tablePtr , a pointer to the second array of characters at tablePtr + offset bytes, etc.) This is particularly useful when processing things like Tk_ConfigurationSpec , whose string keys are in the same place in each of several array elements. REFERENCE COUNT MANAGEMENT Tcl_GetIndexFromObj and Tcl_GetIndexFromObjStruct do not modify the reference count of their objPtr arguments; they only read. Note however that these functions may set the interpreter result; if that is the only place that is holding a reference to the object, it will be deleted. SEE ALSO prefix(n), Tcl_WrongNumArgs(3) KEYWORDS index, option, value, table lookup","title":"NAME"},{"location":"GetIndex/#name","text":"Tcl_GetIndexFromObj, Tcl_GetIndexFromObjStruct - lookup string in table of keywords","title":"NAME"},{"location":"GetIndex/#synopsis","text":"#include <tcl.h> int Tcl_GetIndexFromObj(interp, objPtr, tablePtr, msg, flags, indexPtr) int Tcl_GetIndexFromObjStruct(interp, objPtr, structTablePtr, offset, msg, flags, indexPtr)","title":"SYNOPSIS"},{"location":"GetIndex/#arguments","text":"Interpreter to use for error reporting; if NULL, then no message is provided on errors. The string value of this value is used to search through tablePtr . If the TCL_INDEX_TEMP_TABLE flag is not specified, the internal representation is modified to hold the index of the matching table entry. An array of null-terminated strings. The end of the array is marked by a NULL string pointer. Note that, unless the TCL_INDEX_TEMP_TABLE flag is specified, references to the tablePtr may be retained in the internal representation of objPtr , so this should represent the address of a statically-allocated array. An array of arbitrary type, typically some struct type. The first member of the structure must be a null-terminated string. The size of the structure is given by offset . Note that, unless the TCL_INDEX_TEMP_TABLE flag is specified, references to the structTablePtr may be retained in the internal representation of objPtr , so this should represent the address of a statically-allocated array of structures. The offset to add to structTablePtr to get to the next entry. The end of the array is marked by a NULL string pointer. Null-terminated string describing what is being looked up, such as option . This string is included in error messages. OR-ed combination of bits providing additional information for operation. The only bits that are currently defined are TCL_EXACT , TCL_INDEX_TEMP_TABLE , and TCL_NULL_OK . If not (int *)NULL, the index of the string in tablePtr that matches the value of objPtr is returned here. The variable can be any integer type, signed or unsigned, char, short, long or long long. It can also be an enum.","title":"ARGUMENTS"},{"location":"GetIndex/#description","text":"These procedures provide an efficient way for looking up keywords, switch names, option names, and similar things where the literal value of a Tcl value must be chosen from a predefined set. Tcl_GetIndexFromObj compares objPtr against each of the strings in tablePtr to find a match. A match occurs if objPtr \\'s string value is identical to one of the strings in tablePtr , or if it is a non-empty unique abbreviation for exactly one of the strings in tablePtr and the TCL_EXACT flag was not specified; in either case TCL_OK is returned. If indexPtr is not NULL the index of the matching entry is stored at *indexPtr . If there is no matching entry, TCL_ERROR is returned and an error message is left in interp \\'s result if interp is not NULL. Msg is included in the error message to indicate what was being looked up. For example, if msg is option the error message will have a form like If the TCL_INDEX_TEMP_TABLE was not specified, when Tcl_GetIndexFromObj completes successfully it modifies the internal representation of objPtr to hold the address of the table and the index of the matching entry. If Tcl_GetIndexFromObj is invoked again with the same objPtr and tablePtr arguments (e.g. during a reinvocation of a Tcl command), it returns the matching index immediately without having to redo the lookup operation. Note: Tcl_GetIndexFromObj assumes that the entries in tablePtr are static: they must not change between invocations. This caching mechanism can be disallowed by specifying the TCL_INDEX_TEMP_TABLE flag. If the TCL_NULL_OK flag was specified, objPtr is allowed to be NULL or the empty string. The resulting index is -1. Otherwise, if the value of objPtr is the empty string, Tcl_GetIndexFromObj will treat it as a non-matching value and return TCL_ERROR . Tcl_GetIndexFromObjStruct works just like Tcl_GetIndexFromObj , except that instead of treating tablePtr as an array of string pointers, it treats it as a pointer to the first string in a series of strings that have offset bytes between them (i.e. that there is a pointer to the first array of characters at tablePtr , a pointer to the second array of characters at tablePtr + offset bytes, etc.) This is particularly useful when processing things like Tk_ConfigurationSpec , whose string keys are in the same place in each of several array elements.","title":"DESCRIPTION"},{"location":"GetIndex/#reference-count-management","text":"Tcl_GetIndexFromObj and Tcl_GetIndexFromObjStruct do not modify the reference count of their objPtr arguments; they only read. Note however that these functions may set the interpreter result; if that is the only place that is holding a reference to the object, it will be deleted.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"GetIndex/#see-also","text":"prefix(n), Tcl_WrongNumArgs(3)","title":"SEE ALSO"},{"location":"GetIndex/#keywords","text":"index, option, value, table lookup","title":"KEYWORDS"},{"location":"GetInt/","text":"NAME Tcl_GetInt, Tcl_GetDouble, Tcl_GetBoolean - convert from string to integer, double, or boolean SYNOPSIS #include <tcl.h> int Tcl_GetInt(interp, src, intPtr) int Tcl_GetDouble(interp, src, doublePtr) int Tcl_GetBoolean(interp, src, intPtr) int Tcl_GetBool(interp, src, flags, charPtr) ARGUMENTS Interpreter to use for error reporting. Textual value to be converted. Points to place to store integer value converted from src . Points to place to store double-precision floating-point value converted from src . Points to place to store boolean value (0 or 1) value converted from src . 0 or TCL_NULL_OK. If TCL_NULL_OK is used, then the empty string or NULL will result in Tcl_GetBool return TCL_OK, the *charPtr filled with the value \\'\\xFF\\' ; DESCRIPTION These procedures convert from strings to integers or double-precision floating-point values or booleans (represented as 0- or 1-valued integers). Each of the procedures takes a src argument, converts it to an internal form of a particular type, and stores the converted value at the location indicated by the procedure\\'s third argument. If all goes well, each of the procedures returns TCL_OK . If src does not have the proper syntax for the desired type then TCL_ERROR is returned, an error message is left in the interpreter\\'s result, and nothing is stored at * intPtr or * doublePtr . Tcl_GetInt expects src to consist of a collection of integer digits, optionally signed and optionally preceded and followed by white space. If the first two characters of src after the optional white space and sign are then src is expected to be in hexadecimal form; otherwise, if the first such characters are then src is expected to be in decimal form; otherwise, if the first such characters are then src is expected to be in octal form; otherwise, if the first such characters are then src is expected to be in binary form; otherwise, src is expected to be in decimal form. Tcl_GetDouble expects src to consist of a floating-point number, which is: white space; a sign; a sequence of digits; a decimal point a sequence of digits; the letter a signed decimal exponent; and more white space. Any of the fields may be omitted, except that the digits either before or after the decimal point must be present and if the is present then it must be followed by the exponent number. If there are no fields apart from the sign and initial sequence of digits (i.e., no decimal point or exponent indicator), that initial sequence of digits should take one of the forms that Tcl_GetInt supports, described above. The use of as a decimal point is not supported nor should any other sort of inter-digit separator be present. Tcl_GetBoolean expects src to specify a boolean value. If src is any of 0 , false , no , or off , then Tcl_GetBoolean stores a zero value at *intPtr . If src is any of 1 , true , yes , or on , then 1 is stored at *intPtr . Any of these values may be abbreviated, and upper-case spellings are also acceptable. Tcl_GetBool functions almost the same as Tcl_GetBoolean , but it has an additional parameter flags , which can be used to specify whether the empty string or NULL is accepted as valid. KEYWORDS boolean, conversion, double, floating-point, integer","title":"NAME"},{"location":"GetInt/#name","text":"Tcl_GetInt, Tcl_GetDouble, Tcl_GetBoolean - convert from string to integer, double, or boolean","title":"NAME"},{"location":"GetInt/#synopsis","text":"#include <tcl.h> int Tcl_GetInt(interp, src, intPtr) int Tcl_GetDouble(interp, src, doublePtr) int Tcl_GetBoolean(interp, src, intPtr) int Tcl_GetBool(interp, src, flags, charPtr)","title":"SYNOPSIS"},{"location":"GetInt/#arguments","text":"Interpreter to use for error reporting. Textual value to be converted. Points to place to store integer value converted from src . Points to place to store double-precision floating-point value converted from src . Points to place to store boolean value (0 or 1) value converted from src . 0 or TCL_NULL_OK. If TCL_NULL_OK is used, then the empty string or NULL will result in Tcl_GetBool return TCL_OK, the *charPtr filled with the value \\'\\xFF\\' ;","title":"ARGUMENTS"},{"location":"GetInt/#description","text":"These procedures convert from strings to integers or double-precision floating-point values or booleans (represented as 0- or 1-valued integers). Each of the procedures takes a src argument, converts it to an internal form of a particular type, and stores the converted value at the location indicated by the procedure\\'s third argument. If all goes well, each of the procedures returns TCL_OK . If src does not have the proper syntax for the desired type then TCL_ERROR is returned, an error message is left in the interpreter\\'s result, and nothing is stored at * intPtr or * doublePtr . Tcl_GetInt expects src to consist of a collection of integer digits, optionally signed and optionally preceded and followed by white space. If the first two characters of src after the optional white space and sign are then src is expected to be in hexadecimal form; otherwise, if the first such characters are then src is expected to be in decimal form; otherwise, if the first such characters are then src is expected to be in octal form; otherwise, if the first such characters are then src is expected to be in binary form; otherwise, src is expected to be in decimal form. Tcl_GetDouble expects src to consist of a floating-point number, which is: white space; a sign; a sequence of digits; a decimal point a sequence of digits; the letter a signed decimal exponent; and more white space. Any of the fields may be omitted, except that the digits either before or after the decimal point must be present and if the is present then it must be followed by the exponent number. If there are no fields apart from the sign and initial sequence of digits (i.e., no decimal point or exponent indicator), that initial sequence of digits should take one of the forms that Tcl_GetInt supports, described above. The use of as a decimal point is not supported nor should any other sort of inter-digit separator be present. Tcl_GetBoolean expects src to specify a boolean value. If src is any of 0 , false , no , or off , then Tcl_GetBoolean stores a zero value at *intPtr . If src is any of 1 , true , yes , or on , then 1 is stored at *intPtr . Any of these values may be abbreviated, and upper-case spellings are also acceptable. Tcl_GetBool functions almost the same as Tcl_GetBoolean , but it has an additional parameter flags , which can be used to specify whether the empty string or NULL is accepted as valid.","title":"DESCRIPTION"},{"location":"GetInt/#keywords","text":"boolean, conversion, double, floating-point, integer","title":"KEYWORDS"},{"location":"GetOpnFl/","text":"NAME Tcl_GetOpenFile - Return a FILE* for a channel registered in the given interpreter (Unix only) SYNOPSIS #include <tcl.h> int Tcl_GetOpenFile(interp, chanID, write, checkUsage, filePtr) ARGUMENTS Tcl interpreter from which file handle is to be obtained. String identifying channel, such as stdin or file4 . Non-zero means the file will be used for writing, zero means it will be used for reading. If non-zero, then an error will be generated if the file was not opened for the access indicated by write . Points to word in which to store pointer to FILE structure for the file given by chanID . DESCRIPTION Tcl_GetOpenFile takes as argument a file identifier of the form returned by the open command and returns at *filePtr a pointer to the FILE structure for the file. The write argument indicates whether the FILE pointer will be used for reading or writing. In some cases, such as a channel that connects to a pipeline of subprocesses, different FILE pointers will be returned for reading and writing. Tcl_GetOpenFile normally returns TCL_OK . If an error occurs in Tcl_GetOpenFile (e.g. chanID did not make any sense or checkUsage was set and the file was not opened for the access specified by write ) then TCL_ERROR is returned and the interpreter\\'s result will contain an error message. In the current implementation checkUsage is ignored and consistency checks are always performed. Note that this interface is only supported on the Unix platform. KEYWORDS channel, file handle, permissions, pipeline, read, write","title":"NAME"},{"location":"GetOpnFl/#name","text":"Tcl_GetOpenFile - Return a FILE* for a channel registered in the given interpreter (Unix only)","title":"NAME"},{"location":"GetOpnFl/#synopsis","text":"#include <tcl.h> int Tcl_GetOpenFile(interp, chanID, write, checkUsage, filePtr)","title":"SYNOPSIS"},{"location":"GetOpnFl/#arguments","text":"Tcl interpreter from which file handle is to be obtained. String identifying channel, such as stdin or file4 . Non-zero means the file will be used for writing, zero means it will be used for reading. If non-zero, then an error will be generated if the file was not opened for the access indicated by write . Points to word in which to store pointer to FILE structure for the file given by chanID .","title":"ARGUMENTS"},{"location":"GetOpnFl/#description","text":"Tcl_GetOpenFile takes as argument a file identifier of the form returned by the open command and returns at *filePtr a pointer to the FILE structure for the file. The write argument indicates whether the FILE pointer will be used for reading or writing. In some cases, such as a channel that connects to a pipeline of subprocesses, different FILE pointers will be returned for reading and writing. Tcl_GetOpenFile normally returns TCL_OK . If an error occurs in Tcl_GetOpenFile (e.g. chanID did not make any sense or checkUsage was set and the file was not opened for the access specified by write ) then TCL_ERROR is returned and the interpreter\\'s result will contain an error message. In the current implementation checkUsage is ignored and consistency checks are always performed. Note that this interface is only supported on the Unix platform.","title":"DESCRIPTION"},{"location":"GetOpnFl/#keywords","text":"channel, file handle, permissions, pipeline, read, write","title":"KEYWORDS"},{"location":"GetStdChan/","text":"NAME Tcl_GetStdChannel, Tcl_SetStdChannel - procedures for retrieving and replacing the standard channels SYNOPSIS #include <tcl.h> Tcl_Channel Tcl_GetStdChannel(type) Tcl_SetStdChannel(channel, type) ARGUMENTS The identifier for the standard channel to retrieve or modify. Must be one of TCL_STDIN , TCL_STDOUT , or TCL_STDERR . The channel to use as the new value for the specified standard channel. DESCRIPTION Tcl defines three special channels that are used by various I/O related commands if no other channels are specified. The standard input channel has a channel name of stdin and is used by read and gets . The standard output channel is named stdout and is used by puts . The standard error channel is named stderr and is used for reporting errors. In addition, the standard channels are inherited by any child processes created using exec or open in the absence of any other redirections. The standard channels are actually aliases for other normal channels. The current channel associated with a standard channel can be retrieved by calling Tcl_GetStdChannel with one of TCL_STDIN , TCL_STDOUT , or TCL_STDERR as the type . The return value will be a valid channel, or NULL. A new channel can be set for the standard channel specified by type by calling Tcl_SetStdChannel with a new channel or NULL in the channel argument. If the specified channel is closed by a later call to Tcl_Close , then the corresponding standard channel will automatically be set to NULL. If a non-NULL value for channel is passed to Tcl_SetStdChannel , then that same value should be passed to Tcl_RegisterChannel , like so: Tcl_RegisterChannel(NULL, channel); This is a workaround for a misfeature in Tcl_SetStdChannel that it fails to do some reference counting housekeeping. This misfeature cannot be corrected without contradicting the assumptions of some existing code that calls Tcl_SetStdChannel . If Tcl_GetStdChannel is called before Tcl_SetStdChannel , Tcl will construct a new channel to wrap the appropriate platform-specific standard file handle. If Tcl_SetStdChannel is called before Tcl_GetStdChannel , then the default channel will not be created. If one of the standard channels is set to NULL, either by calling Tcl_SetStdChannel with a NULL channel argument, or by calling Tcl_Close on the channel, then the next call to Tcl_CreateChannel will automatically set the standard channel with the newly created channel. If more than one standard channel is NULL, then the standard channels will be assigned starting with standard input, followed by standard output, with standard error being last. See Tcl_StandardChannels for a general treatise about standard channels and the behavior of the Tcl library with regard to them. SEE ALSO Tcl_Close(3), Tcl_CreateChannel(3), Tcl_Main(3), tclsh(1) KEYWORDS standard channel, standard input, standard output, standard error","title":"NAME"},{"location":"GetStdChan/#name","text":"Tcl_GetStdChannel, Tcl_SetStdChannel - procedures for retrieving and replacing the standard channels","title":"NAME"},{"location":"GetStdChan/#synopsis","text":"#include <tcl.h> Tcl_Channel Tcl_GetStdChannel(type) Tcl_SetStdChannel(channel, type)","title":"SYNOPSIS"},{"location":"GetStdChan/#arguments","text":"The identifier for the standard channel to retrieve or modify. Must be one of TCL_STDIN , TCL_STDOUT , or TCL_STDERR . The channel to use as the new value for the specified standard channel.","title":"ARGUMENTS"},{"location":"GetStdChan/#description","text":"Tcl defines three special channels that are used by various I/O related commands if no other channels are specified. The standard input channel has a channel name of stdin and is used by read and gets . The standard output channel is named stdout and is used by puts . The standard error channel is named stderr and is used for reporting errors. In addition, the standard channels are inherited by any child processes created using exec or open in the absence of any other redirections. The standard channels are actually aliases for other normal channels. The current channel associated with a standard channel can be retrieved by calling Tcl_GetStdChannel with one of TCL_STDIN , TCL_STDOUT , or TCL_STDERR as the type . The return value will be a valid channel, or NULL. A new channel can be set for the standard channel specified by type by calling Tcl_SetStdChannel with a new channel or NULL in the channel argument. If the specified channel is closed by a later call to Tcl_Close , then the corresponding standard channel will automatically be set to NULL. If a non-NULL value for channel is passed to Tcl_SetStdChannel , then that same value should be passed to Tcl_RegisterChannel , like so: Tcl_RegisterChannel(NULL, channel); This is a workaround for a misfeature in Tcl_SetStdChannel that it fails to do some reference counting housekeeping. This misfeature cannot be corrected without contradicting the assumptions of some existing code that calls Tcl_SetStdChannel . If Tcl_GetStdChannel is called before Tcl_SetStdChannel , Tcl will construct a new channel to wrap the appropriate platform-specific standard file handle. If Tcl_SetStdChannel is called before Tcl_GetStdChannel , then the default channel will not be created. If one of the standard channels is set to NULL, either by calling Tcl_SetStdChannel with a NULL channel argument, or by calling Tcl_Close on the channel, then the next call to Tcl_CreateChannel will automatically set the standard channel with the newly created channel. If more than one standard channel is NULL, then the standard channels will be assigned starting with standard input, followed by standard output, with standard error being last. See Tcl_StandardChannels for a general treatise about standard channels and the behavior of the Tcl library with regard to them.","title":"DESCRIPTION"},{"location":"GetStdChan/#see-also","text":"Tcl_Close(3), Tcl_CreateChannel(3), Tcl_Main(3), tclsh(1)","title":"SEE ALSO"},{"location":"GetStdChan/#keywords","text":"standard channel, standard input, standard output, standard error","title":"KEYWORDS"},{"location":"GetTime/","text":"NAME Tcl_GetTime, Tcl_SetTimeProc, Tcl_QueryTimeProc - get date and time SYNOPSIS #include <tcl.h> Tcl_GetTime(timePtr) Tcl_SetTimeProc(getProc, scaleProc, clientData) Tcl_QueryTimeProc(getProcPtr, scaleProcPtr, clientDataPtr) ARGUMENTS Points to memory in which to store the date and time information. Pointer to handler function replacing Tcl_GetTime \\'s access to the OS. Pointer to handler function for the conversion of time delays in the virtual domain to real-time. Value passed through to the two handler functions. Pointer to place the currently registered get handler function into. Pointer to place the currently registered scale handler function into. Pointer to place the currently registered pass-through value into. DESCRIPTION The Tcl_GetTime function retrieves the current time as a Tcl_Time structure in memory the caller provides. This structure has the following definition: typedef struct Tcl_Time { long sec ; long usec ; } Tcl_Time ; On return, the sec member of the structure is filled in with the number of seconds that have elapsed since the epoch: the epoch is the point in time of 00:00 UTC, 1 January 1970. This number does not count leap seconds - an interval of one day advances it by 86400 seconds regardless of whether a leap second has been inserted. The usec member of the structure is filled in with the number of microseconds that have elapsed since the start of the second designated by sec . The Tcl library makes every effort to keep this number as precise as possible, subject to the limitations of the computer system. On multiprocessor variants of Windows, this number may be limited to the 10- or 20-ms granularity of the system clock. (On single-processor Windows systems, the usec field is derived from a performance counter and is highly precise.) VIRTUALIZED TIME The Tcl_SetTimeProc function registers two related handler functions with the core. The first handler function is a replacement for Tcl_GetTime , or rather the OS access made by Tcl_GetTime . The other handler function is used by the Tcl notifier to convert wait/block times from the virtual domain into real time. The Tcl_QueryTimeProc function returns the currently registered handler functions. If no external handlers were set then this will return the standard handlers accessing and processing the native time of the OS. The arguments to the function are allowed to be NULL; and any argument which is NULL is ignored and not set. The signatures of the handler functions are as follows: typedef void Tcl_GetTimeProc ( Tcl_Time * timebuf , void * clientData ); typedef void Tcl_ScaleTimeProc ( Tcl_Time * timebuf , void * clientData ); The timebuf fields contain the time to manipulate, and the clientData fields contain a pointer supplied at the time the handler functions were registered. Any handler pair specified has to return data which is consistent between them. In other words, setting one handler of the pair to something assuming a 10-times slowdown, and the other handler of the pair to something assuming a two-times slowdown is wrong and not allowed. The set handler functions are allowed to run the delivered time backwards, however this should be avoided. We have to allow it as the native time can run backwards as the user can fiddle with the system time one way or other. Note that the insertion of the hooks will not change the behavior of the Tcl core with regard to this situation, i.e. the existing behavior is retained. SEE ALSO clock(n) KEYWORDS date, time","title":"NAME"},{"location":"GetTime/#name","text":"Tcl_GetTime, Tcl_SetTimeProc, Tcl_QueryTimeProc - get date and time","title":"NAME"},{"location":"GetTime/#synopsis","text":"#include <tcl.h> Tcl_GetTime(timePtr) Tcl_SetTimeProc(getProc, scaleProc, clientData) Tcl_QueryTimeProc(getProcPtr, scaleProcPtr, clientDataPtr)","title":"SYNOPSIS"},{"location":"GetTime/#arguments","text":"Points to memory in which to store the date and time information. Pointer to handler function replacing Tcl_GetTime \\'s access to the OS. Pointer to handler function for the conversion of time delays in the virtual domain to real-time. Value passed through to the two handler functions. Pointer to place the currently registered get handler function into. Pointer to place the currently registered scale handler function into. Pointer to place the currently registered pass-through value into.","title":"ARGUMENTS"},{"location":"GetTime/#description","text":"The Tcl_GetTime function retrieves the current time as a Tcl_Time structure in memory the caller provides. This structure has the following definition: typedef struct Tcl_Time { long sec ; long usec ; } Tcl_Time ; On return, the sec member of the structure is filled in with the number of seconds that have elapsed since the epoch: the epoch is the point in time of 00:00 UTC, 1 January 1970. This number does not count leap seconds - an interval of one day advances it by 86400 seconds regardless of whether a leap second has been inserted. The usec member of the structure is filled in with the number of microseconds that have elapsed since the start of the second designated by sec . The Tcl library makes every effort to keep this number as precise as possible, subject to the limitations of the computer system. On multiprocessor variants of Windows, this number may be limited to the 10- or 20-ms granularity of the system clock. (On single-processor Windows systems, the usec field is derived from a performance counter and is highly precise.)","title":"DESCRIPTION"},{"location":"GetTime/#virtualized-time","text":"The Tcl_SetTimeProc function registers two related handler functions with the core. The first handler function is a replacement for Tcl_GetTime , or rather the OS access made by Tcl_GetTime . The other handler function is used by the Tcl notifier to convert wait/block times from the virtual domain into real time. The Tcl_QueryTimeProc function returns the currently registered handler functions. If no external handlers were set then this will return the standard handlers accessing and processing the native time of the OS. The arguments to the function are allowed to be NULL; and any argument which is NULL is ignored and not set. The signatures of the handler functions are as follows: typedef void Tcl_GetTimeProc ( Tcl_Time * timebuf , void * clientData ); typedef void Tcl_ScaleTimeProc ( Tcl_Time * timebuf , void * clientData ); The timebuf fields contain the time to manipulate, and the clientData fields contain a pointer supplied at the time the handler functions were registered. Any handler pair specified has to return data which is consistent between them. In other words, setting one handler of the pair to something assuming a 10-times slowdown, and the other handler of the pair to something assuming a two-times slowdown is wrong and not allowed. The set handler functions are allowed to run the delivered time backwards, however this should be avoided. We have to allow it as the native time can run backwards as the user can fiddle with the system time one way or other. Note that the insertion of the hooks will not change the behavior of the Tcl core with regard to this situation, i.e. the existing behavior is retained.","title":"VIRTUALIZED TIME"},{"location":"GetTime/#see-also","text":"clock(n)","title":"SEE ALSO"},{"location":"GetTime/#keywords","text":"date, time","title":"KEYWORDS"},{"location":"GetVersion/","text":"NAME Tcl_GetVersion - get the version of the library at runtime SYNOPSIS #include <tcl.h> Tcl_GetVersion(major, minor, patchLevel, type) ARGUMENTS Major version number of the Tcl library. Minor version number of the Tcl library. The patch level of the Tcl library (or alpha or beta number). The type of release, also indicates the type of patch level. Can be one of TCL_ALPHA_RELEASE , TCL_BETA_RELEASE , or TCL_FINAL_RELEASE . DESCRIPTION Tcl_GetVersion should be used to query the version number of the Tcl library at runtime. This is useful when using a dynamically loaded Tcl library or when writing a stubs-aware extension. For instance, if you write an extension that is linked against the Tcl stubs library, it could be loaded into a program linked to an older version of Tcl than you expected. Use Tcl_GetVersion to verify that fact, and possibly to change the behavior of your extension. Tcl_GetVersion accepts NULL for any of the arguments. For instance if you do not care about the patchLevel of the library, pass a NULL for the patchLevel argument. KEYWORDS version, patchlevel, major, minor, alpha, beta, release","title":"NAME"},{"location":"GetVersion/#name","text":"Tcl_GetVersion - get the version of the library at runtime","title":"NAME"},{"location":"GetVersion/#synopsis","text":"#include <tcl.h> Tcl_GetVersion(major, minor, patchLevel, type)","title":"SYNOPSIS"},{"location":"GetVersion/#arguments","text":"Major version number of the Tcl library. Minor version number of the Tcl library. The patch level of the Tcl library (or alpha or beta number). The type of release, also indicates the type of patch level. Can be one of TCL_ALPHA_RELEASE , TCL_BETA_RELEASE , or TCL_FINAL_RELEASE .","title":"ARGUMENTS"},{"location":"GetVersion/#description","text":"Tcl_GetVersion should be used to query the version number of the Tcl library at runtime. This is useful when using a dynamically loaded Tcl library or when writing a stubs-aware extension. For instance, if you write an extension that is linked against the Tcl stubs library, it could be loaded into a program linked to an older version of Tcl than you expected. Use Tcl_GetVersion to verify that fact, and possibly to change the behavior of your extension. Tcl_GetVersion accepts NULL for any of the arguments. For instance if you do not care about the patchLevel of the library, pass a NULL for the patchLevel argument.","title":"DESCRIPTION"},{"location":"GetVersion/#keywords","text":"version, patchlevel, major, minor, alpha, beta, release","title":"KEYWORDS"},{"location":"Hash/","text":"NAME Tcl_InitHashTable, Tcl_InitCustomHashTable, Tcl_InitObjHashTable, Tcl_DeleteHashTable, Tcl_CreateHashEntry, Tcl_DeleteHashEntry, Tcl_FindHashEntry, Tcl_GetHashValue, Tcl_SetHashValue, Tcl_GetHashKey, Tcl_FirstHashEntry, Tcl_NextHashEntry, Tcl_HashStats - procedures to manage hash tables SYNOPSIS #include <tcl.h> Tcl_InitHashTable(tablePtr, keyType) Tcl_InitCustomHashTable(tablePtr, keyType, typePtr) Tcl_InitObjHashTable(tablePtr) Tcl_DeleteHashTable(tablePtr) Tcl_HashEntry * Tcl_CreateHashEntry(tablePtr, key, newPtr) Tcl_DeleteHashEntry(entryPtr) Tcl_HashEntry * Tcl_FindHashEntry(tablePtr, key) void * Tcl_GetHashValue(entryPtr) Tcl_SetHashValue(entryPtr, value) void * Tcl_GetHashKey(tablePtr, entryPtr) Tcl_HashEntry * Tcl_FirstHashEntry(tablePtr, searchPtr) Tcl_HashEntry * Tcl_NextHashEntry(searchPtr) char * Tcl_HashStats(tablePtr) ARGUMENTS Address of hash table structure (for all procedures but Tcl_InitHashTable , this must have been initialized by previous call to Tcl_InitHashTable ). Kind of keys to use for new hash table. Must be either TCL_STRING_KEYS , TCL_ONE_WORD_KEYS , TCL_CUSTOM_TYPE_KEYS , TCL_CUSTOM_PTR_KEYS , or an integer value greater than 1. Address of structure which defines the behavior of the hash table. Key to use for probe into table. Exact form depends on keyType used to create table. The word at *newPtr is set to 1 if a new entry was created and 0 if there was already an entry for key . Pointer to hash table entry. New value to assign to hash table entry. Pointer to record to use to keep track of progress in enumerating all the entries in a hash table. DESCRIPTION A hash table consists of zero or more entries, each consisting of a key and a value. Given the key for an entry, the hashing routines can very quickly locate the entry, and hence its value. There may be at most one entry in a hash table with a particular key, but many entries may have the same value. Keys can take one of four forms: strings, one-word values, integer arrays, or custom keys defined by a Tcl_HashKeyType structure (See section THE TCL_HASHKEYTYPE STRUCTURE below). All of the keys in a given table have the same form, which is specified when the table is initialized. The value of a hash table entry can be anything that fits in the same space as a pointer. Values for hash table entries are managed entirely by clients, not by the hash module itself. Typically each entry\\'s value is a pointer to a data structure managed by client code. Hash tables grow gracefully as the number of entries increases, so that there are always less than three entries per hash bucket, on average. This allows for fast lookups regardless of the number of entries in a table. The core provides three functions for the initialization of hash tables, Tcl_InitHashTable, Tcl_InitObjHashTable and Tcl_InitCustomHashTable. Tcl_InitHashTable initializes a structure that describes a new hash table. The space for the structure is provided by the caller, not by the hash module. The value of keyType indicates what kinds of keys will be used for all entries in the table. All of the key types described later are allowed, with the exception of TCL_CUSTOM_TYPE_KEYS and TCL_CUSTOM_PTR_KEYS . Tcl_InitObjHashTable is a wrapper around Tcl_InitCustomHashTable and initializes a hash table whose keys are Tcl_Obj *. Tcl_InitCustomHashTable initializes a structure that describes a new hash table. The space for the structure is provided by the caller, not by the hash module. The value of keyType indicates what kinds of keys will be used for all entries in the table. KeyType must have one of the following values: TCL_STRING_KEYS : Keys are null-terminated strings. They are passed to hashing routines using the address of the first character of the string. TCL_ONE_WORD_KEYS : Keys are single-word values; they are passed to hashing routines and stored in hash table entries as values. The pointer value is the key; it need not (and usually does not) actually point to a string. TCL_CUSTOM_TYPE_KEYS : Keys are of arbitrary type, and are stored in the entry. Hashing and comparison is determined by typePtr . The Tcl_HashKeyType structure is described in the section THE TCL_HASHKEYTYPE STRUCTURE below. TCL_CUSTOM_PTR_KEYS : Keys are pointers to an arbitrary type, and are stored in the entry. Hashing and comparison is determined by typePtr . The Tcl_HashKeyType structure is described in the section THE TCL_HASHKEYTYPE STRUCTURE below. other : If keyType is not one of the above, then it must be an integer value greater than 1. In this case the keys will be arrays of values, where keyType gives the number of ints in each key. This allows structures to be used as keys. All keys must have the same size. Array keys are passed into hashing functions using the address of the first int in the array. Tcl_DeleteHashTable deletes all of the entries in a hash table and frees up the memory associated with the table\\'s bucket array and entries. It does not free the actual table structure (pointed to by tablePtr ), since that memory is assumed to be managed by the client. Tcl_DeleteHashTable also does not free or otherwise manipulate the values of the hash table entries. If the entry values point to dynamically-allocated memory, then it is the client\\'s responsibility to free these structures before deleting the table. Tcl_CreateHashEntry locates the entry corresponding to a particular key, creating a new entry in the table if there was not already one with the given key. If an entry already existed with the given key then *newPtr is set to zero. If a new entry was created, then *newPtr is set to a non-zero value and the value of the new entry will be set to zero. The return value from Tcl_CreateHashEntry is a pointer to the entry, which may be used to retrieve and modify the entry\\'s value or to delete the entry from the table. Tcl_DeleteHashEntry will remove an existing entry from a table. The memory associated with the entry itself will be freed, but the client is responsible for any cleanup associated with the entry\\'s value, such as freeing a structure that it points to. Tcl_FindHashEntry is similar to Tcl_CreateHashEntry except that it does not create a new entry if the key doesn\\'t exist; instead, it returns NULL as result. Tcl_GetHashValue and Tcl_SetHashValue are used to read and write an entry\\'s value, respectively. Tcl_GetHashKey returns the key for a given hash table entry, either as a pointer to a string, a one-word key, or as a pointer to the first word of an array of integers, depending on the keyType used to create a hash table. In all cases Tcl_GetHashKey returns a result with type When the key is a string or array, the result of Tcl_GetHashKey points to information in the table entry; this information will remain valid until the entry is deleted or its table is deleted. Tcl_FirstHashEntry and Tcl_NextHashEntry may be used to scan all of the entries in a hash table. A structure of type provided by the client, is used to keep track of progress through the table. Tcl_FirstHashEntry initializes the search record and returns the first entry in the table (or NULL if the table is empty). Each subsequent call to Tcl_NextHashEntry returns the next entry in the table or NULL if the end of the table has been reached. A call to Tcl_FirstHashEntry followed by calls to Tcl_NextHashEntry will return each of the entries in the table exactly once, in an arbitrary order. It is inadvisable to modify the structure of the table, e.g. by creating or deleting entries, while the search is in progress, with the exception of deleting the entry returned by Tcl_FirstHashEntry or Tcl_NextHashEntry . Tcl_HashStats returns a dynamically-allocated string with overall information about a hash table, such as the number of entries it contains, the number of buckets in its hash array, and the utilization of the buckets. It is the caller\\'s responsibility to free the result string by passing it to Tcl_Free . The header file tcl.h defines the actual data structures used to implement hash tables. This is necessary so that clients can allocate Tcl_HashTable structures and so that macros can be used to read and write the values of entries. However, users of the hashing routines should never refer directly to any of the fields of any of the hash-related data structures; use the procedures and macros defined here. THE TCL_HASHKEYTYPE STRUCTURE Extension writers can define new hash key types by defining four procedures, initializing a Tcl_HashKeyType structure to describe the type, and calling Tcl_InitCustomHashTable . The Tcl_HashKeyType structure is defined as follows: typedef struct Tcl_HashKeyType { int version ; int flags ; Tcl_HashKeyProc * hashKeyProc ; Tcl_CompareHashKeysProc * compareKeysProc ; Tcl_AllocHashEntryProc * allocEntryProc ; Tcl_FreeHashEntryProc * freeEntryProc ; } Tcl_HashKeyType ; The version member is the version of the table. If this structure is extended in future then the version can be used to distinguish between different structures. It should be set to TCL_HASH_KEY_TYPE_VERSION . The flags member is 0 or one or more of the following values OR\\'ed together: TCL_HASH_KEY_RANDOMIZE_HASH : There are some things, pointers for example which do not hash well because they do not use the lower bits. If this flag is set then the hash table will attempt to rectify this by randomizing the bits and then using the upper N bits as the index into the table. TCL_HASH_KEY_SYSTEM_HASH : This flag forces Tcl to use the memory allocation procedures provided by the operating system when allocating and freeing memory used to store the hash table data structures, and not any of Tcl\\'s own customized memory allocation routines. This is important if the hash table is to be used in the implementation of a custom set of allocation routines, or something that a custom set of allocation routines might depend on, in order to avoid any circular dependency. The hashKeyProc member contains the address of a function called to calculate a hash value for the key. typedef TCL_HASH_TYPE Tcl_HashKeyProc ( Tcl_HashTable * tablePtr , void * keyPtr ); If this is NULL then keyPtr is used and TCL_HASH_KEY_RANDOMIZE_HASH is assumed. The compareKeysProc member contains the address of a function called to compare two keys. typedef int Tcl_CompareHashKeysProc ( void * keyPtr , Tcl_HashEntry * hPtr ); If this is NULL then the keyPtr pointers are compared. If the keys do not match then the function returns 0, otherwise it returns 1. The allocEntryProc member contains the address of a function called to allocate space for an entry and initialize the key and clientData. typedef Tcl_HashEntry * Tcl_AllocHashEntryProc ( Tcl_HashTable * tablePtr , void * keyPtr ); If this is NULL then Tcl_Alloc is used to allocate enough space for a Tcl_HashEntry, the key pointer is assigned to key.oneWordValue and the clientData is set to NULL. String keys and array keys use this function to allocate enough space for the entry and the key in one block, rather than doing it in two blocks. This saves space for a pointer to the key from the entry and another memory allocation. Tcl_Obj* keys use this function to allocate enough space for an entry and increment the reference count on the value. The freeEntryProc member contains the address of a function called to free space for an entry. typedef void Tcl_FreeHashEntryProc ( Tcl_HashEntry * hPtr ); If this is NULL then Tcl_Free is used to free the space for the entry. Tcl_Obj* keys use this function to decrement the reference count on the value. REFERENCE COUNT MANAGEMENT When a hash table is created with Tcl_InitCustomHashTable , the Tcl_CreateHashEntry function will increment the reference count of its key argument when it creates a key (but not if there is an existing matching key). The reference count of the key will be decremented when the corresponding hash entry is deleted, whether with Tcl_DeleteHashEntry or with Tcl_DeleteHashTable . The Tcl_GetHashKey function will return the key without further modifying its reference count. Custom hash tables that use a Tcl_Obj* as key will generally need to do something similar in their allocEntryProc . SEE ALSO Dict(3) KEYWORDS hash table, key, lookup, search, value","title":"NAME"},{"location":"Hash/#name","text":"Tcl_InitHashTable, Tcl_InitCustomHashTable, Tcl_InitObjHashTable, Tcl_DeleteHashTable, Tcl_CreateHashEntry, Tcl_DeleteHashEntry, Tcl_FindHashEntry, Tcl_GetHashValue, Tcl_SetHashValue, Tcl_GetHashKey, Tcl_FirstHashEntry, Tcl_NextHashEntry, Tcl_HashStats - procedures to manage hash tables","title":"NAME"},{"location":"Hash/#synopsis","text":"#include <tcl.h> Tcl_InitHashTable(tablePtr, keyType) Tcl_InitCustomHashTable(tablePtr, keyType, typePtr) Tcl_InitObjHashTable(tablePtr) Tcl_DeleteHashTable(tablePtr) Tcl_HashEntry * Tcl_CreateHashEntry(tablePtr, key, newPtr) Tcl_DeleteHashEntry(entryPtr) Tcl_HashEntry * Tcl_FindHashEntry(tablePtr, key) void * Tcl_GetHashValue(entryPtr) Tcl_SetHashValue(entryPtr, value) void * Tcl_GetHashKey(tablePtr, entryPtr) Tcl_HashEntry * Tcl_FirstHashEntry(tablePtr, searchPtr) Tcl_HashEntry * Tcl_NextHashEntry(searchPtr) char * Tcl_HashStats(tablePtr)","title":"SYNOPSIS"},{"location":"Hash/#arguments","text":"Address of hash table structure (for all procedures but Tcl_InitHashTable , this must have been initialized by previous call to Tcl_InitHashTable ). Kind of keys to use for new hash table. Must be either TCL_STRING_KEYS , TCL_ONE_WORD_KEYS , TCL_CUSTOM_TYPE_KEYS , TCL_CUSTOM_PTR_KEYS , or an integer value greater than 1. Address of structure which defines the behavior of the hash table. Key to use for probe into table. Exact form depends on keyType used to create table. The word at *newPtr is set to 1 if a new entry was created and 0 if there was already an entry for key . Pointer to hash table entry. New value to assign to hash table entry. Pointer to record to use to keep track of progress in enumerating all the entries in a hash table.","title":"ARGUMENTS"},{"location":"Hash/#description","text":"A hash table consists of zero or more entries, each consisting of a key and a value. Given the key for an entry, the hashing routines can very quickly locate the entry, and hence its value. There may be at most one entry in a hash table with a particular key, but many entries may have the same value. Keys can take one of four forms: strings, one-word values, integer arrays, or custom keys defined by a Tcl_HashKeyType structure (See section THE TCL_HASHKEYTYPE STRUCTURE below). All of the keys in a given table have the same form, which is specified when the table is initialized. The value of a hash table entry can be anything that fits in the same space as a pointer. Values for hash table entries are managed entirely by clients, not by the hash module itself. Typically each entry\\'s value is a pointer to a data structure managed by client code. Hash tables grow gracefully as the number of entries increases, so that there are always less than three entries per hash bucket, on average. This allows for fast lookups regardless of the number of entries in a table. The core provides three functions for the initialization of hash tables, Tcl_InitHashTable, Tcl_InitObjHashTable and Tcl_InitCustomHashTable. Tcl_InitHashTable initializes a structure that describes a new hash table. The space for the structure is provided by the caller, not by the hash module. The value of keyType indicates what kinds of keys will be used for all entries in the table. All of the key types described later are allowed, with the exception of TCL_CUSTOM_TYPE_KEYS and TCL_CUSTOM_PTR_KEYS . Tcl_InitObjHashTable is a wrapper around Tcl_InitCustomHashTable and initializes a hash table whose keys are Tcl_Obj *. Tcl_InitCustomHashTable initializes a structure that describes a new hash table. The space for the structure is provided by the caller, not by the hash module. The value of keyType indicates what kinds of keys will be used for all entries in the table. KeyType must have one of the following values: TCL_STRING_KEYS : Keys are null-terminated strings. They are passed to hashing routines using the address of the first character of the string. TCL_ONE_WORD_KEYS : Keys are single-word values; they are passed to hashing routines and stored in hash table entries as values. The pointer value is the key; it need not (and usually does not) actually point to a string. TCL_CUSTOM_TYPE_KEYS : Keys are of arbitrary type, and are stored in the entry. Hashing and comparison is determined by typePtr . The Tcl_HashKeyType structure is described in the section THE TCL_HASHKEYTYPE STRUCTURE below. TCL_CUSTOM_PTR_KEYS : Keys are pointers to an arbitrary type, and are stored in the entry. Hashing and comparison is determined by typePtr . The Tcl_HashKeyType structure is described in the section THE TCL_HASHKEYTYPE STRUCTURE below. other : If keyType is not one of the above, then it must be an integer value greater than 1. In this case the keys will be arrays of values, where keyType gives the number of ints in each key. This allows structures to be used as keys. All keys must have the same size. Array keys are passed into hashing functions using the address of the first int in the array. Tcl_DeleteHashTable deletes all of the entries in a hash table and frees up the memory associated with the table\\'s bucket array and entries. It does not free the actual table structure (pointed to by tablePtr ), since that memory is assumed to be managed by the client. Tcl_DeleteHashTable also does not free or otherwise manipulate the values of the hash table entries. If the entry values point to dynamically-allocated memory, then it is the client\\'s responsibility to free these structures before deleting the table. Tcl_CreateHashEntry locates the entry corresponding to a particular key, creating a new entry in the table if there was not already one with the given key. If an entry already existed with the given key then *newPtr is set to zero. If a new entry was created, then *newPtr is set to a non-zero value and the value of the new entry will be set to zero. The return value from Tcl_CreateHashEntry is a pointer to the entry, which may be used to retrieve and modify the entry\\'s value or to delete the entry from the table. Tcl_DeleteHashEntry will remove an existing entry from a table. The memory associated with the entry itself will be freed, but the client is responsible for any cleanup associated with the entry\\'s value, such as freeing a structure that it points to. Tcl_FindHashEntry is similar to Tcl_CreateHashEntry except that it does not create a new entry if the key doesn\\'t exist; instead, it returns NULL as result. Tcl_GetHashValue and Tcl_SetHashValue are used to read and write an entry\\'s value, respectively. Tcl_GetHashKey returns the key for a given hash table entry, either as a pointer to a string, a one-word key, or as a pointer to the first word of an array of integers, depending on the keyType used to create a hash table. In all cases Tcl_GetHashKey returns a result with type When the key is a string or array, the result of Tcl_GetHashKey points to information in the table entry; this information will remain valid until the entry is deleted or its table is deleted. Tcl_FirstHashEntry and Tcl_NextHashEntry may be used to scan all of the entries in a hash table. A structure of type provided by the client, is used to keep track of progress through the table. Tcl_FirstHashEntry initializes the search record and returns the first entry in the table (or NULL if the table is empty). Each subsequent call to Tcl_NextHashEntry returns the next entry in the table or NULL if the end of the table has been reached. A call to Tcl_FirstHashEntry followed by calls to Tcl_NextHashEntry will return each of the entries in the table exactly once, in an arbitrary order. It is inadvisable to modify the structure of the table, e.g. by creating or deleting entries, while the search is in progress, with the exception of deleting the entry returned by Tcl_FirstHashEntry or Tcl_NextHashEntry . Tcl_HashStats returns a dynamically-allocated string with overall information about a hash table, such as the number of entries it contains, the number of buckets in its hash array, and the utilization of the buckets. It is the caller\\'s responsibility to free the result string by passing it to Tcl_Free . The header file tcl.h defines the actual data structures used to implement hash tables. This is necessary so that clients can allocate Tcl_HashTable structures and so that macros can be used to read and write the values of entries. However, users of the hashing routines should never refer directly to any of the fields of any of the hash-related data structures; use the procedures and macros defined here.","title":"DESCRIPTION"},{"location":"Hash/#the-tcl_hashkeytype-structure","text":"Extension writers can define new hash key types by defining four procedures, initializing a Tcl_HashKeyType structure to describe the type, and calling Tcl_InitCustomHashTable . The Tcl_HashKeyType structure is defined as follows: typedef struct Tcl_HashKeyType { int version ; int flags ; Tcl_HashKeyProc * hashKeyProc ; Tcl_CompareHashKeysProc * compareKeysProc ; Tcl_AllocHashEntryProc * allocEntryProc ; Tcl_FreeHashEntryProc * freeEntryProc ; } Tcl_HashKeyType ; The version member is the version of the table. If this structure is extended in future then the version can be used to distinguish between different structures. It should be set to TCL_HASH_KEY_TYPE_VERSION . The flags member is 0 or one or more of the following values OR\\'ed together: TCL_HASH_KEY_RANDOMIZE_HASH : There are some things, pointers for example which do not hash well because they do not use the lower bits. If this flag is set then the hash table will attempt to rectify this by randomizing the bits and then using the upper N bits as the index into the table. TCL_HASH_KEY_SYSTEM_HASH : This flag forces Tcl to use the memory allocation procedures provided by the operating system when allocating and freeing memory used to store the hash table data structures, and not any of Tcl\\'s own customized memory allocation routines. This is important if the hash table is to be used in the implementation of a custom set of allocation routines, or something that a custom set of allocation routines might depend on, in order to avoid any circular dependency. The hashKeyProc member contains the address of a function called to calculate a hash value for the key. typedef TCL_HASH_TYPE Tcl_HashKeyProc ( Tcl_HashTable * tablePtr , void * keyPtr ); If this is NULL then keyPtr is used and TCL_HASH_KEY_RANDOMIZE_HASH is assumed. The compareKeysProc member contains the address of a function called to compare two keys. typedef int Tcl_CompareHashKeysProc ( void * keyPtr , Tcl_HashEntry * hPtr ); If this is NULL then the keyPtr pointers are compared. If the keys do not match then the function returns 0, otherwise it returns 1. The allocEntryProc member contains the address of a function called to allocate space for an entry and initialize the key and clientData. typedef Tcl_HashEntry * Tcl_AllocHashEntryProc ( Tcl_HashTable * tablePtr , void * keyPtr ); If this is NULL then Tcl_Alloc is used to allocate enough space for a Tcl_HashEntry, the key pointer is assigned to key.oneWordValue and the clientData is set to NULL. String keys and array keys use this function to allocate enough space for the entry and the key in one block, rather than doing it in two blocks. This saves space for a pointer to the key from the entry and another memory allocation. Tcl_Obj* keys use this function to allocate enough space for an entry and increment the reference count on the value. The freeEntryProc member contains the address of a function called to free space for an entry. typedef void Tcl_FreeHashEntryProc ( Tcl_HashEntry * hPtr ); If this is NULL then Tcl_Free is used to free the space for the entry. Tcl_Obj* keys use this function to decrement the reference count on the value.","title":"THE TCL_HASHKEYTYPE STRUCTURE"},{"location":"Hash/#reference-count-management","text":"When a hash table is created with Tcl_InitCustomHashTable , the Tcl_CreateHashEntry function will increment the reference count of its key argument when it creates a key (but not if there is an existing matching key). The reference count of the key will be decremented when the corresponding hash entry is deleted, whether with Tcl_DeleteHashEntry or with Tcl_DeleteHashTable . The Tcl_GetHashKey function will return the key without further modifying its reference count. Custom hash tables that use a Tcl_Obj* as key will generally need to do something similar in their allocEntryProc .","title":"REFERENCE COUNT MANAGEMENT"},{"location":"Hash/#see-also","text":"Dict(3)","title":"SEE ALSO"},{"location":"Hash/#keywords","text":"hash table, key, lookup, search, value","title":"KEYWORDS"},{"location":"Init/","text":"NAME Tcl_Init - find and source initialization script SYNOPSIS #include <tcl.h> int Tcl_Init(interp) const char * Tcl_SetPreInitScript(scriptPtr) ARGUMENTS Interpreter to initialize. Address of the initialization script. DESCRIPTION Tcl_Init is a helper procedure that finds and source s the init.tcl script, which should exist somewhere on the Tcl library path. Tcl_Init is typically called from Tcl_AppInit procedures. Tcl_SetPreInitScript registers the pre-initialization script and returns the former (now replaced) script pointer. A value of NULL may be passed to not register any script. The pre-initialization script is executed by Tcl_Init before accessing the file system. The purpose is to typically prepare a custom file system (like an embedded zip-file) to be activated before the search. When used in stub-enabled embedders, the stubs table must be first initialized using one of Tcl_InitSubsystems , Tcl_SetPanicProc , Tcl_FindExecutable or TclZipfs_AppHook before Tcl_SetPreInitScript may be called. SEE ALSO Tcl_AppInit, Tcl_Main KEYWORDS application, initialization, interpreter","title":"NAME"},{"location":"Init/#name","text":"Tcl_Init - find and source initialization script","title":"NAME"},{"location":"Init/#synopsis","text":"#include <tcl.h> int Tcl_Init(interp) const char * Tcl_SetPreInitScript(scriptPtr)","title":"SYNOPSIS"},{"location":"Init/#arguments","text":"Interpreter to initialize. Address of the initialization script.","title":"ARGUMENTS"},{"location":"Init/#description","text":"Tcl_Init is a helper procedure that finds and source s the init.tcl script, which should exist somewhere on the Tcl library path. Tcl_Init is typically called from Tcl_AppInit procedures. Tcl_SetPreInitScript registers the pre-initialization script and returns the former (now replaced) script pointer. A value of NULL may be passed to not register any script. The pre-initialization script is executed by Tcl_Init before accessing the file system. The purpose is to typically prepare a custom file system (like an embedded zip-file) to be activated before the search. When used in stub-enabled embedders, the stubs table must be first initialized using one of Tcl_InitSubsystems , Tcl_SetPanicProc , Tcl_FindExecutable or TclZipfs_AppHook before Tcl_SetPreInitScript may be called.","title":"DESCRIPTION"},{"location":"Init/#see-also","text":"Tcl_AppInit, Tcl_Main","title":"SEE ALSO"},{"location":"Init/#keywords","text":"application, initialization, interpreter","title":"KEYWORDS"},{"location":"InitStubs/","text":"NAME Tcl_InitStubs - initialize the Tcl stubs mechanism SYNOPSIS #include <tcl.h> const char * Tcl_InitStubs(interp, version, exact) ARGUMENTS Tcl interpreter handle. A version string consisting of one or more decimal numbers separated by dots. 1 means that only the particular version specified by version is acceptable. 0 means that versions newer than version are also acceptable as long as they have the same major version number as version . Other bits have no effect. INTRODUCTION The Tcl stubs mechanism defines a way to dynamically bind extensions to a particular Tcl implementation at run time. This provides two significant benefits to Tcl users: 1) Extensions that use the stubs mechanism can be loaded into multiple versions of Tcl without being recompiled or relinked. 2) Extensions that use the stubs mechanism can be dynamically loaded into statically-linked Tcl applications. The stubs mechanism accomplishes this by exporting function tables that define an interface to the Tcl API. The extension then accesses the Tcl API through offsets into the function table, so there are no direct references to any of the Tcl library\\'s symbols. This redirection is transparent to the extension, so an extension writer can continue to use all public Tcl functions as documented. The stubs mechanism requires no changes to applications incorporating Tcl interpreters. Only developers creating C-based Tcl extensions need to take steps to use the stubs mechanism with their extensions. Enabling the stubs mechanism for an extension requires the following steps: 1) Call Tcl_InitStubs in the extension before calling any other Tcl functions. 2) Define the USE_TCL_STUBS symbol. Typically, you would include the -DUSE_TCL_STUBS flag when compiling the extension. 3) Link the extension with the Tcl stubs library instead of the standard Tcl library. For example, to use the Tcl 9.0 ABI on Unix platforms, the library name is libtclstub9.0.a ; on Windows platforms, the library name is tclstub90.lib . If the extension also requires the Tk API, it must also call Tk_InitStubs to initialize the Tk stubs interface and link with the Tk stubs libraries. See the Tk_InitStubs page for more information. DESCRIPTION Tcl_InitStubs attempts to initialize the stub table pointers and ensure that the correct version of Tcl is loaded. In addition to an interpreter handle, it accepts as arguments a version number and a Boolean flag indicating whether the extension requires an exact version match or not. If exact is 0, then the extension is indicating that newer versions of Tcl are acceptable as long as they have the same major version number as version ; non-zero means that only the specified version is acceptable. Tcl_InitStubs returns a string containing the actual version of Tcl satisfying the request, or NULL if the Tcl version is not acceptable, does not support stubs, or any other error condition occurred. SEE ALSO Tk_InitStubs KEYWORDS stubs","title":"NAME"},{"location":"InitStubs/#name","text":"Tcl_InitStubs - initialize the Tcl stubs mechanism","title":"NAME"},{"location":"InitStubs/#synopsis","text":"#include <tcl.h> const char * Tcl_InitStubs(interp, version, exact)","title":"SYNOPSIS"},{"location":"InitStubs/#arguments","text":"Tcl interpreter handle. A version string consisting of one or more decimal numbers separated by dots. 1 means that only the particular version specified by version is acceptable. 0 means that versions newer than version are also acceptable as long as they have the same major version number as version . Other bits have no effect.","title":"ARGUMENTS"},{"location":"InitStubs/#introduction","text":"The Tcl stubs mechanism defines a way to dynamically bind extensions to a particular Tcl implementation at run time. This provides two significant benefits to Tcl users: 1) Extensions that use the stubs mechanism can be loaded into multiple versions of Tcl without being recompiled or relinked. 2) Extensions that use the stubs mechanism can be dynamically loaded into statically-linked Tcl applications. The stubs mechanism accomplishes this by exporting function tables that define an interface to the Tcl API. The extension then accesses the Tcl API through offsets into the function table, so there are no direct references to any of the Tcl library\\'s symbols. This redirection is transparent to the extension, so an extension writer can continue to use all public Tcl functions as documented. The stubs mechanism requires no changes to applications incorporating Tcl interpreters. Only developers creating C-based Tcl extensions need to take steps to use the stubs mechanism with their extensions. Enabling the stubs mechanism for an extension requires the following steps: 1) Call Tcl_InitStubs in the extension before calling any other Tcl functions. 2) Define the USE_TCL_STUBS symbol. Typically, you would include the -DUSE_TCL_STUBS flag when compiling the extension. 3) Link the extension with the Tcl stubs library instead of the standard Tcl library. For example, to use the Tcl 9.0 ABI on Unix platforms, the library name is libtclstub9.0.a ; on Windows platforms, the library name is tclstub90.lib . If the extension also requires the Tk API, it must also call Tk_InitStubs to initialize the Tk stubs interface and link with the Tk stubs libraries. See the Tk_InitStubs page for more information.","title":"INTRODUCTION"},{"location":"InitStubs/#description","text":"Tcl_InitStubs attempts to initialize the stub table pointers and ensure that the correct version of Tcl is loaded. In addition to an interpreter handle, it accepts as arguments a version number and a Boolean flag indicating whether the extension requires an exact version match or not. If exact is 0, then the extension is indicating that newer versions of Tcl are acceptable as long as they have the same major version number as version ; non-zero means that only the specified version is acceptable. Tcl_InitStubs returns a string containing the actual version of Tcl satisfying the request, or NULL if the Tcl version is not acceptable, does not support stubs, or any other error condition occurred.","title":"DESCRIPTION"},{"location":"InitStubs/#see-also","text":"Tk_InitStubs","title":"SEE ALSO"},{"location":"InitStubs/#keywords","text":"stubs","title":"KEYWORDS"},{"location":"InitSubSyst/","text":"NAME Tcl_InitSubsystems - initialize the Tcl library. SYNOPSIS #include <tcl.h> const char * Tcl_InitSubsystems(void) DESCRIPTION The Tcl_InitSubsystems procedure initializes the Tcl library. This procedure is typically invoked as the very first thing in the application\\'s main program. The result of Tcl_InitSubsystems is the full Tcl version with build information (e.g., 9.0.0+abcdef...abcdef.gcc-1002 ). Tcl_InitSubsystems is very similar in use to Tcl_FindExecutable . It can be used when Tcl is used as utility library, no other encodings than utf-8, iso8859-1 or utf-16 are used, and no interest exists in the value of info nameofexecutable . The system encoding will not be extracted from the environment, but falls back to utf-8. KEYWORDS binary, executable file","title":"NAME"},{"location":"InitSubSyst/#name","text":"Tcl_InitSubsystems - initialize the Tcl library.","title":"NAME"},{"location":"InitSubSyst/#synopsis","text":"#include <tcl.h> const char * Tcl_InitSubsystems(void)","title":"SYNOPSIS"},{"location":"InitSubSyst/#description","text":"The Tcl_InitSubsystems procedure initializes the Tcl library. This procedure is typically invoked as the very first thing in the application\\'s main program. The result of Tcl_InitSubsystems is the full Tcl version with build information (e.g., 9.0.0+abcdef...abcdef.gcc-1002 ). Tcl_InitSubsystems is very similar in use to Tcl_FindExecutable . It can be used when Tcl is used as utility library, no other encodings than utf-8, iso8859-1 or utf-16 are used, and no interest exists in the value of info nameofexecutable . The system encoding will not be extracted from the environment, but falls back to utf-8.","title":"DESCRIPTION"},{"location":"InitSubSyst/#keywords","text":"binary, executable file","title":"KEYWORDS"},{"location":"IntObj/","text":"NAME Tcl_NewIntObj, Tcl_NewLongObj, Tcl_NewWideIntObj, Tcl_SetIntObj, Tcl_SetLongObj, Tcl_SetWideIntObj, Tcl_GetIntFromObj, Tcl_GetIntForIndex, Tcl_GetLongFromObj, Tcl_GetWideIntFromObj, Tcl_GetWideUIntFromObj, Tcl_NewBignumObj, Tcl_SetBignumObj, Tcl_GetBignumFromObj, Tcl_TakeBignumFromObj - manipulate Tcl values as integers SYNOPSIS #include <tcl.h> Tcl_Obj * Tcl_NewIntObj(intValue) Tcl_Obj * Tcl_NewLongObj(longValue) Tcl_Obj * Tcl_NewWideIntObj(wideValue) Tcl_SetIntObj(objPtr, intValue) Tcl_SetLongObj(objPtr, longValue) Tcl_SetWideIntObj(objPtr, wideValue) int Tcl_GetIntFromObj(interp, objPtr, intPtr) int Tcl_GetIntForIndex(interp, objPtr, endValue, indexPtr) int Tcl_GetLongFromObj(interp, objPtr, longPtr) int Tcl_GetWideIntFromObj(interp, objPtr, widePtr) int Tcl_GetWideUIntFromObj(interp, objPtr, uwidePtr) int Tcl_GetSizeIntFromObj(interp, objPtr, sizePtr) #include <tclTomMath.h> Tcl_Obj * Tcl_NewBignumObj(bigValue) Tcl_SetBignumObj(objPtr, bigValue) int Tcl_GetBignumFromObj(interp, objPtr, bigValue) int Tcl_TakeBignumFromObj(interp, objPtr, bigValue) int Tcl_InitBignumFromDouble(interp, doubleValue, bigValue) ARGUMENTS Tcl_GetIntForIndex will return this when the input value is \\\"end\\\". Integer value used to initialize or set a Tcl value. Long integer value used to initialize or set a Tcl value. Wide integer value used to initialize or set a Tcl value. For Tcl_SetIntObj , Tcl_SetLongObj , Tcl_SetWideIntObj , and Tcl_SetBignumObj , this points to the value in which to store an integral value. For Tcl_GetIntFromObj , Tcl_GetLongFromObj , Tcl_GetWideIntFromObj , Tcl_GetBignumFromObj , and Tcl_TakeBignumFromObj , this refers to the value from which to retrieve an integral value. When non-NULL, an error message is left here when integral value retrieval fails. Points to place to store the integer value retrieved from objPtr . Points to place to store the long integer value retrieved from objPtr . Points to place to store the Tcl_Size value retrieved from objPtr . Points to place to store the wide integer value retrieved from objPtr . Points to place to store the unsigned wide integer value retrieved from objPtr . Points to place to store the Tcl_Size integer value retrieved from objPtr . Points to a multi-precision integer structure declared by the LibTomMath library. Double value from which the integer part is determined and used to initialize a multi-precision integer value. DESCRIPTION These procedures are used to create, modify, and read Tcl values that hold integral values. The different routines exist to accommodate different integral types in C with which values might be exchanged. The C integral types for which Tcl provides value exchange routines are int , long int , Tcl_WideInt , and mp_int . The int and long int types are provided by the C language standard. The Tcl_WideInt type is a typedef defined to be whatever signed integral type covers at least the 64-bit integer range (-9223372036854775808 to 9223372036854775807). Depending on the platform and the C compiler, the actual type might be long long int , or something else. The mp_int type is a multiple-precision integer type defined by the LibTomMath multiple-precision integer library. The Tcl_NewIntObj , Tcl_NewLongObj , Tcl_NewWideIntObj , and Tcl_NewBignumObj routines each create and return a new Tcl value initialized to the integral value of the argument. The returned Tcl value is unshared. The Tcl_SetIntObj , Tcl_SetLongObj , Tcl_SetWideIntObj , and Tcl_SetBignumObj routines each set the value of an existing Tcl value pointed to by objPtr to the integral value provided by the other argument. The objPtr argument must point to an unshared Tcl value. Any attempt to set the value of a shared Tcl value violates Tcl\\'s copy-on-write policy. Any existing string representation or internal representation in the unshared Tcl value will be freed as a consequence of setting the new value. The Tcl_GetIntForIndex routine attempts to retrieve an index value from the Tcl value objPtr . If the attempt succeeds, then TCL_OK is returned, and the value is written to the storage provided by the caller. The attempt might fail if objPtr does not hold an index value. If the attempt fails, then TCL_ERROR is returned, and if interp is non-NULL, an error message is left in interp . The Tcl_ObjType of objPtr may be changed to make subsequent calls to the same routine more efficient. The Tcl_GetIntFromObj , Tcl_GetLongFromObj , Tcl_GetWideIntFromObj , Tcl_GetSizeIntFromObj , Tcl_GetBignumFromObj , and Tcl_TakeBignumFromObj routines attempt to retrieve an integral value of the appropriate type from the Tcl value objPtr . If the attempt succeeds, then TCL_OK is returned, and the value is written to the storage provided by the caller. The attempt might fail if objPtr does not hold an integral value, or if the value exceeds the range of the target type. If the attempt fails, then TCL_ERROR is returned, and if interp is non-NULL, an error message is left in interp . The Tcl_ObjType of objPtr may be changed to make subsequent calls to the same routine more efficient. Unlike the other functions, Tcl_TakeBignumFromObj may set the content of the Tcl value objPtr to an empty string in the process of retrieving the multiple-precision integer value. The choice between Tcl_GetBignumFromObj and Tcl_TakeBignumFromObj is governed by how the caller will continue to use objPtr . If after the mp_int value is retrieved from objPtr , the caller will make no more use of objPtr , then using Tcl_TakeBignumFromObj permits Tcl to detect when an unshared objPtr permits the value to be moved instead of copied, which should be more efficient. If anything later in the caller requires objPtr to continue to hold the same value, then Tcl_GetBignumFromObj must be chosen. The Tcl_InitBignumFromDouble routine is a utility procedure that extracts the integer part of doubleValue and stores that integer value in the mp_int value bigValue . REFERENCE COUNT MANAGEMENT Tcl_NewIntObj , Tcl_NewLongObj , Tcl_NewWideIntObj , and Tcl_NewBignumObj always return a zero-reference object, much like Tcl_NewObj . Tcl_SetIntObj , Tcl_SetLongObj , Tcl_SetWideIntObj , and Tcl_SetBignumObj do not modify the reference count of their objPtr arguments, but do require that the object be unshared. Tcl_GetIntFromObj , Tcl_GetIntForIndex , Tcl_GetLongFromObj , Tcl_GetWideIntFromObj , Tcl_GetBignumFromObj , and Tcl_TakeBignumFromObj do not modify the reference count of their objPtr arguments; they only read. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to the object, it will be deleted. Also note that if Tcl_TakeBignumFromObj is given an unshared value, the value of that object may be modified; it is intended to be used when the value is by the operation at this point. SEE ALSO Tcl_NewObj, Tcl_DecrRefCount, Tcl_IncrRefCount, Tcl_GetObjResult KEYWORDS integer, integer value, integer type, internal representation, value, value type, string representation","title":"NAME"},{"location":"IntObj/#name","text":"Tcl_NewIntObj, Tcl_NewLongObj, Tcl_NewWideIntObj, Tcl_SetIntObj, Tcl_SetLongObj, Tcl_SetWideIntObj, Tcl_GetIntFromObj, Tcl_GetIntForIndex, Tcl_GetLongFromObj, Tcl_GetWideIntFromObj, Tcl_GetWideUIntFromObj, Tcl_NewBignumObj, Tcl_SetBignumObj, Tcl_GetBignumFromObj, Tcl_TakeBignumFromObj - manipulate Tcl values as integers","title":"NAME"},{"location":"IntObj/#synopsis","text":"#include <tcl.h> Tcl_Obj * Tcl_NewIntObj(intValue) Tcl_Obj * Tcl_NewLongObj(longValue) Tcl_Obj * Tcl_NewWideIntObj(wideValue) Tcl_SetIntObj(objPtr, intValue) Tcl_SetLongObj(objPtr, longValue) Tcl_SetWideIntObj(objPtr, wideValue) int Tcl_GetIntFromObj(interp, objPtr, intPtr) int Tcl_GetIntForIndex(interp, objPtr, endValue, indexPtr) int Tcl_GetLongFromObj(interp, objPtr, longPtr) int Tcl_GetWideIntFromObj(interp, objPtr, widePtr) int Tcl_GetWideUIntFromObj(interp, objPtr, uwidePtr) int Tcl_GetSizeIntFromObj(interp, objPtr, sizePtr) #include <tclTomMath.h> Tcl_Obj * Tcl_NewBignumObj(bigValue) Tcl_SetBignumObj(objPtr, bigValue) int Tcl_GetBignumFromObj(interp, objPtr, bigValue) int Tcl_TakeBignumFromObj(interp, objPtr, bigValue) int Tcl_InitBignumFromDouble(interp, doubleValue, bigValue)","title":"SYNOPSIS"},{"location":"IntObj/#arguments","text":"Tcl_GetIntForIndex will return this when the input value is \\\"end\\\". Integer value used to initialize or set a Tcl value. Long integer value used to initialize or set a Tcl value. Wide integer value used to initialize or set a Tcl value. For Tcl_SetIntObj , Tcl_SetLongObj , Tcl_SetWideIntObj , and Tcl_SetBignumObj , this points to the value in which to store an integral value. For Tcl_GetIntFromObj , Tcl_GetLongFromObj , Tcl_GetWideIntFromObj , Tcl_GetBignumFromObj , and Tcl_TakeBignumFromObj , this refers to the value from which to retrieve an integral value. When non-NULL, an error message is left here when integral value retrieval fails. Points to place to store the integer value retrieved from objPtr . Points to place to store the long integer value retrieved from objPtr . Points to place to store the Tcl_Size value retrieved from objPtr . Points to place to store the wide integer value retrieved from objPtr . Points to place to store the unsigned wide integer value retrieved from objPtr . Points to place to store the Tcl_Size integer value retrieved from objPtr . Points to a multi-precision integer structure declared by the LibTomMath library. Double value from which the integer part is determined and used to initialize a multi-precision integer value.","title":"ARGUMENTS"},{"location":"IntObj/#description","text":"These procedures are used to create, modify, and read Tcl values that hold integral values. The different routines exist to accommodate different integral types in C with which values might be exchanged. The C integral types for which Tcl provides value exchange routines are int , long int , Tcl_WideInt , and mp_int . The int and long int types are provided by the C language standard. The Tcl_WideInt type is a typedef defined to be whatever signed integral type covers at least the 64-bit integer range (-9223372036854775808 to 9223372036854775807). Depending on the platform and the C compiler, the actual type might be long long int , or something else. The mp_int type is a multiple-precision integer type defined by the LibTomMath multiple-precision integer library. The Tcl_NewIntObj , Tcl_NewLongObj , Tcl_NewWideIntObj , and Tcl_NewBignumObj routines each create and return a new Tcl value initialized to the integral value of the argument. The returned Tcl value is unshared. The Tcl_SetIntObj , Tcl_SetLongObj , Tcl_SetWideIntObj , and Tcl_SetBignumObj routines each set the value of an existing Tcl value pointed to by objPtr to the integral value provided by the other argument. The objPtr argument must point to an unshared Tcl value. Any attempt to set the value of a shared Tcl value violates Tcl\\'s copy-on-write policy. Any existing string representation or internal representation in the unshared Tcl value will be freed as a consequence of setting the new value. The Tcl_GetIntForIndex routine attempts to retrieve an index value from the Tcl value objPtr . If the attempt succeeds, then TCL_OK is returned, and the value is written to the storage provided by the caller. The attempt might fail if objPtr does not hold an index value. If the attempt fails, then TCL_ERROR is returned, and if interp is non-NULL, an error message is left in interp . The Tcl_ObjType of objPtr may be changed to make subsequent calls to the same routine more efficient. The Tcl_GetIntFromObj , Tcl_GetLongFromObj , Tcl_GetWideIntFromObj , Tcl_GetSizeIntFromObj , Tcl_GetBignumFromObj , and Tcl_TakeBignumFromObj routines attempt to retrieve an integral value of the appropriate type from the Tcl value objPtr . If the attempt succeeds, then TCL_OK is returned, and the value is written to the storage provided by the caller. The attempt might fail if objPtr does not hold an integral value, or if the value exceeds the range of the target type. If the attempt fails, then TCL_ERROR is returned, and if interp is non-NULL, an error message is left in interp . The Tcl_ObjType of objPtr may be changed to make subsequent calls to the same routine more efficient. Unlike the other functions, Tcl_TakeBignumFromObj may set the content of the Tcl value objPtr to an empty string in the process of retrieving the multiple-precision integer value. The choice between Tcl_GetBignumFromObj and Tcl_TakeBignumFromObj is governed by how the caller will continue to use objPtr . If after the mp_int value is retrieved from objPtr , the caller will make no more use of objPtr , then using Tcl_TakeBignumFromObj permits Tcl to detect when an unshared objPtr permits the value to be moved instead of copied, which should be more efficient. If anything later in the caller requires objPtr to continue to hold the same value, then Tcl_GetBignumFromObj must be chosen. The Tcl_InitBignumFromDouble routine is a utility procedure that extracts the integer part of doubleValue and stores that integer value in the mp_int value bigValue .","title":"DESCRIPTION"},{"location":"IntObj/#reference-count-management","text":"Tcl_NewIntObj , Tcl_NewLongObj , Tcl_NewWideIntObj , and Tcl_NewBignumObj always return a zero-reference object, much like Tcl_NewObj . Tcl_SetIntObj , Tcl_SetLongObj , Tcl_SetWideIntObj , and Tcl_SetBignumObj do not modify the reference count of their objPtr arguments, but do require that the object be unshared. Tcl_GetIntFromObj , Tcl_GetIntForIndex , Tcl_GetLongFromObj , Tcl_GetWideIntFromObj , Tcl_GetBignumFromObj , and Tcl_TakeBignumFromObj do not modify the reference count of their objPtr arguments; they only read. Note however that this function may set the interpreter result; if that is the only place that is holding a reference to the object, it will be deleted. Also note that if Tcl_TakeBignumFromObj is given an unshared value, the value of that object may be modified; it is intended to be used when the value is by the operation at this point.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"IntObj/#see-also","text":"Tcl_NewObj, Tcl_DecrRefCount, Tcl_IncrRefCount, Tcl_GetObjResult","title":"SEE ALSO"},{"location":"IntObj/#keywords","text":"integer, integer value, integer type, internal representation, value, value type, string representation","title":"KEYWORDS"},{"location":"Limit/","text":"NAME Tcl_LimitAddHandler, Tcl_LimitCheck, Tcl_LimitExceeded, Tcl_LimitGetCommands, Tcl_LimitGetGranularity, Tcl_LimitGetTime, Tcl_LimitReady, Tcl_LimitRemoveHandler, Tcl_LimitSetCommands, Tcl_LimitSetGranularity, Tcl_LimitSetTime, Tcl_LimitTypeEnabled, Tcl_LimitTypeExceeded, Tcl_LimitTypeReset, Tcl_LimitTypeSet - manage and check resource limits on interpreters SYNOPSIS #include <tcl.h> int Tcl_LimitCheck(interp) int Tcl_LimitReady(interp) int Tcl_LimitExceeded(interp) int Tcl_LimitTypeExceeded(interp, type) int Tcl_LimitTypeEnabled(interp, type) void Tcl_LimitTypeSet(interp, type) void Tcl_LimitTypeReset(interp, type) int Tcl_LimitGetCommands(interp) void Tcl_LimitSetCommands(interp, commandLimit) void Tcl_LimitGetTime(interp, timeLimitPtr) void Tcl_LimitSetTime(interp, timeLimitPtr) int Tcl_LimitGetGranularity(interp, type) void Tcl_LimitSetGranularity(interp, type, granularity) void Tcl_LimitAddHandler(interp, type, handlerProc, clientData, deleteProc) void Tcl_LimitRemoveHandler(interp, type, handlerProc, clientData) ARGUMENTS Interpreter that the limit being managed applies to or that will have its limits checked. The type of limit that the operation refers to. This must be either TCL_LIMIT_COMMANDS or TCL_LIMIT_TIME . The maximum number of commands (as reported by info cmdcount ) that may be executed in the interpreter. A pointer to a structure that will either have the new time limit read from ( Tcl_LimitSetTime ) or the current time limit written to ( Tcl_LimitGetTime ). Divisor that indicates how often a particular limit should really be checked. Must be at least 1. Function to call when a particular limit is exceeded. If the handlerProc removes or raises the limit during its processing, the limited interpreter will be permitted to continue to process after the handler returns. Many handlers may be attached to the same interpreter limit; their order of execution is not defined, and they must be identified by handlerProc and clientData when they are deleted. Arbitrary pointer-sized word used to pass some context to the handlerProc function. Function to call whenever a handler is deleted. May be NULL if the clientData requires no deletion. DESCRIPTION Tcl\\'s interpreter resource limit subsystem allows for close control over how much computation time a script may use, and is useful for cases where a program is divided into multiple pieces where some parts are more trusted than others (e.g. web application servers). Every interpreter may have a limit on the wall-time for execution, and a limit on the number of commands that the interpreter may execute. Since checking of these limits is potentially expensive (especially the time limit), each limit also has a checking granularity, which is a divisor for an internal count of the number of points in the core where a check may be performed (which is immediately before executing a command and at an unspecified frequency between running commands, which can happen in empty-bodied while loops). The final component of the limit engine is a callback scheme which allows for notifications of when a limit has been exceeded. These callbacks can just provide logging, or may allocate more resources to the interpreter to permit it to continue processing longer. When a limit is exceeded (and the callbacks have run; the order of execution of the callbacks is unspecified) execution in the limited interpreter is stopped by raising an error and setting a flag that prevents the catch command in that interpreter from trapping that error. It is up to the context that started execution in that interpreter (typically the main interpreter) to handle the error. LIMIT CHECKING API To check the resource limits for an interpreter, call Tcl_LimitCheck , which returns TCL_OK if the limit was not exceeded (after processing callbacks) and TCL_ERROR if the limit was exceeded (in which case an error message is also placed in the interpreter result). That function should only be called when Tcl_LimitReady returns non-zero so that granularity policy is enforced. This API is designed to be similar in usage to Tcl_AsyncReady and Tcl_AsyncInvoke . When writing code that may behave like catch in respect of errors, you should only trap an error if Tcl_LimitExceeded returns zero. If it returns non-zero, the interpreter is in a limit-exceeded state and errors should be allowed to propagate to the calling context. You can also check whether a particular type of limit has been exceeded using Tcl_LimitTypeExceeded . LIMIT CONFIGURATION To check whether a limit has been set (but not whether it has actually been exceeded) on an interpreter, call Tcl_LimitTypeEnabled with the type of limit you want to check. To enable a particular limit call Tcl_LimitTypeSet , and to disable a limit call Tcl_LimitTypeReset . The level of a command limit may be set using Tcl_LimitSetCommands , and retrieved using Tcl_LimitGetCommands . Similarly for a time limit with Tcl_LimitSetTime and Tcl_LimitGetTime respectively, but with that API the time limit is copied from and to the Tcl_Time structure that the timeLimitPtr argument points to. The checking granularity for a particular limit may be set using Tcl_LimitSetGranularity and retrieved using Tcl_LimitGetGranularity . Note that granularities must always be positive. LIMIT CALLBACKS To add a handler callback to be invoked when a limit is exceeded, call Tcl_LimitAddHandler . The handlerProc argument describes the function that will actually be called; it should have the following prototype: typedef void Tcl_LimitHandlerProc ( void * clientData , Tcl_Interp * interp ); The clientData argument to the handler will be whatever is passed to the clientData argument to Tcl_LimitAddHandler , and the interp is the interpreter that had its limit exceeded. The deleteProc argument to Tcl_LimitAddHandler is a function to call to delete the clientData value. It may be TCL_STATIC or NULL if no deletion action is necessary, or TCL_DYNAMIC if all that is necessary is to free the structure with Tcl_Free . Otherwise, it should refer to a function with the following prototype: typedef void Tcl_LimitHandlerDeleteProc ( void * clientData ); A limit handler may be deleted using Tcl_LimitRemoveHandler ; the handler removed will be the first one found (out of the handlers added with Tcl_LimitAddHandler ) with exactly matching type , handlerProc and clientData arguments. This function always invokes the deleteProc on the clientData (unless the deleteProc was NULL or TCL_STATIC ). KEYWORDS interpreter, resource, limit, commands, time, callback","title":"NAME"},{"location":"Limit/#name","text":"Tcl_LimitAddHandler, Tcl_LimitCheck, Tcl_LimitExceeded, Tcl_LimitGetCommands, Tcl_LimitGetGranularity, Tcl_LimitGetTime, Tcl_LimitReady, Tcl_LimitRemoveHandler, Tcl_LimitSetCommands, Tcl_LimitSetGranularity, Tcl_LimitSetTime, Tcl_LimitTypeEnabled, Tcl_LimitTypeExceeded, Tcl_LimitTypeReset, Tcl_LimitTypeSet - manage and check resource limits on interpreters","title":"NAME"},{"location":"Limit/#synopsis","text":"#include <tcl.h> int Tcl_LimitCheck(interp) int Tcl_LimitReady(interp) int Tcl_LimitExceeded(interp) int Tcl_LimitTypeExceeded(interp, type) int Tcl_LimitTypeEnabled(interp, type) void Tcl_LimitTypeSet(interp, type) void Tcl_LimitTypeReset(interp, type) int Tcl_LimitGetCommands(interp) void Tcl_LimitSetCommands(interp, commandLimit) void Tcl_LimitGetTime(interp, timeLimitPtr) void Tcl_LimitSetTime(interp, timeLimitPtr) int Tcl_LimitGetGranularity(interp, type) void Tcl_LimitSetGranularity(interp, type, granularity) void Tcl_LimitAddHandler(interp, type, handlerProc, clientData, deleteProc) void Tcl_LimitRemoveHandler(interp, type, handlerProc, clientData)","title":"SYNOPSIS"},{"location":"Limit/#arguments","text":"Interpreter that the limit being managed applies to or that will have its limits checked. The type of limit that the operation refers to. This must be either TCL_LIMIT_COMMANDS or TCL_LIMIT_TIME . The maximum number of commands (as reported by info cmdcount ) that may be executed in the interpreter. A pointer to a structure that will either have the new time limit read from ( Tcl_LimitSetTime ) or the current time limit written to ( Tcl_LimitGetTime ). Divisor that indicates how often a particular limit should really be checked. Must be at least 1. Function to call when a particular limit is exceeded. If the handlerProc removes or raises the limit during its processing, the limited interpreter will be permitted to continue to process after the handler returns. Many handlers may be attached to the same interpreter limit; their order of execution is not defined, and they must be identified by handlerProc and clientData when they are deleted. Arbitrary pointer-sized word used to pass some context to the handlerProc function. Function to call whenever a handler is deleted. May be NULL if the clientData requires no deletion.","title":"ARGUMENTS"},{"location":"Limit/#description","text":"Tcl\\'s interpreter resource limit subsystem allows for close control over how much computation time a script may use, and is useful for cases where a program is divided into multiple pieces where some parts are more trusted than others (e.g. web application servers). Every interpreter may have a limit on the wall-time for execution, and a limit on the number of commands that the interpreter may execute. Since checking of these limits is potentially expensive (especially the time limit), each limit also has a checking granularity, which is a divisor for an internal count of the number of points in the core where a check may be performed (which is immediately before executing a command and at an unspecified frequency between running commands, which can happen in empty-bodied while loops). The final component of the limit engine is a callback scheme which allows for notifications of when a limit has been exceeded. These callbacks can just provide logging, or may allocate more resources to the interpreter to permit it to continue processing longer. When a limit is exceeded (and the callbacks have run; the order of execution of the callbacks is unspecified) execution in the limited interpreter is stopped by raising an error and setting a flag that prevents the catch command in that interpreter from trapping that error. It is up to the context that started execution in that interpreter (typically the main interpreter) to handle the error.","title":"DESCRIPTION"},{"location":"Limit/#limit-checking-api","text":"To check the resource limits for an interpreter, call Tcl_LimitCheck , which returns TCL_OK if the limit was not exceeded (after processing callbacks) and TCL_ERROR if the limit was exceeded (in which case an error message is also placed in the interpreter result). That function should only be called when Tcl_LimitReady returns non-zero so that granularity policy is enforced. This API is designed to be similar in usage to Tcl_AsyncReady and Tcl_AsyncInvoke . When writing code that may behave like catch in respect of errors, you should only trap an error if Tcl_LimitExceeded returns zero. If it returns non-zero, the interpreter is in a limit-exceeded state and errors should be allowed to propagate to the calling context. You can also check whether a particular type of limit has been exceeded using Tcl_LimitTypeExceeded .","title":"LIMIT CHECKING API"},{"location":"Limit/#limit-configuration","text":"To check whether a limit has been set (but not whether it has actually been exceeded) on an interpreter, call Tcl_LimitTypeEnabled with the type of limit you want to check. To enable a particular limit call Tcl_LimitTypeSet , and to disable a limit call Tcl_LimitTypeReset . The level of a command limit may be set using Tcl_LimitSetCommands , and retrieved using Tcl_LimitGetCommands . Similarly for a time limit with Tcl_LimitSetTime and Tcl_LimitGetTime respectively, but with that API the time limit is copied from and to the Tcl_Time structure that the timeLimitPtr argument points to. The checking granularity for a particular limit may be set using Tcl_LimitSetGranularity and retrieved using Tcl_LimitGetGranularity . Note that granularities must always be positive.","title":"LIMIT CONFIGURATION"},{"location":"Limit/#limit-callbacks","text":"To add a handler callback to be invoked when a limit is exceeded, call Tcl_LimitAddHandler . The handlerProc argument describes the function that will actually be called; it should have the following prototype: typedef void Tcl_LimitHandlerProc ( void * clientData , Tcl_Interp * interp ); The clientData argument to the handler will be whatever is passed to the clientData argument to Tcl_LimitAddHandler , and the interp is the interpreter that had its limit exceeded. The deleteProc argument to Tcl_LimitAddHandler is a function to call to delete the clientData value. It may be TCL_STATIC or NULL if no deletion action is necessary, or TCL_DYNAMIC if all that is necessary is to free the structure with Tcl_Free . Otherwise, it should refer to a function with the following prototype: typedef void Tcl_LimitHandlerDeleteProc ( void * clientData ); A limit handler may be deleted using Tcl_LimitRemoveHandler ; the handler removed will be the first one found (out of the handlers added with Tcl_LimitAddHandler ) with exactly matching type , handlerProc and clientData arguments. This function always invokes the deleteProc on the clientData (unless the deleteProc was NULL or TCL_STATIC ).","title":"LIMIT CALLBACKS"},{"location":"Limit/#keywords","text":"interpreter, resource, limit, commands, time, callback","title":"KEYWORDS"},{"location":"LinkVar/","text":"NAME Tcl_LinkArray, Tcl_LinkVar, Tcl_UnlinkVar, Tcl_UpdateLinkedVar - link Tcl variable to C variable SYNOPSIS #include <tcl.h> int Tcl_LinkVar(interp, varName, addr, type) int Tcl_LinkArray(interp, varName, addr, type, size) Tcl_UnlinkVar(interp, varName) Tcl_UpdateLinkedVar(interp, varName) ARGUMENTS Interpreter that contains varName . Also used by Tcl_LinkVar to return error messages. Name of global variable. Address of C variable that is to be linked to varName . In Tcl_LinkArray , may be NULL to tell Tcl to create the storage for the array in the variable. Type of C variable for Tcl_LinkVar or type of array element for Tcl_LinkArray . Must be one of TCL_LINK_INT , TCL_LINK_UINT , TCL_LINK_CHAR , TCL_LINK_UCHAR , TCL_LINK_SHORT , TCL_LINK_USHORT , TCL_LINK_LONG , TCL_LINK_ULONG , TCL_LINK_WIDE_INT , TCL_LINK_WIDE_UINT , TCL_LINK_FLOAT , TCL_LINK_DOUBLE , TCL_LINK_BOOLEAN , or one of the extra ones listed below. In Tcl_LinkVar , the additional linked type TCL_LINK_STRING may be used. In Tcl_LinkArray , the additional linked types TCL_LINK_CHARS and TCL_LINK_BINARY may be used. All the above for both functions may be optionally OR\\'ed with TCL_LINK_READ_ONLY to make the Tcl variable read-only. The number of elements in the C array. Must be greater than zero. DESCRIPTION Tcl_LinkVar uses variable traces to keep the Tcl variable named by varName in sync with the C variable at the address given by addr . Whenever the Tcl variable is read the value of the C variable will be returned, and whenever the Tcl variable is written the C variable will be updated to have the same value. Tcl_LinkVar normally returns TCL_OK ; if an error occurs while setting up the link (e.g. because varName is the name of array) then TCL_ERROR is returned and the interpreter\\'s result contains an error message. Tcl_LinkArray is similar, but for arrays of fixed size (given by the size argument). When asked to allocate the backing C array storage (via the addr argument being NULL), it writes the address that it allocated to the Tcl interpreter result. The type argument specifies the type of the C variable, or the type of the elements of the C array, and must have one of the following values, optionally OR\\'ed with TCL_LINK_READ_ONLY : TCL_LINK_INT : The C variable, or each element of the C array, is of type int . Any value written into the Tcl variable must have a proper integer form acceptable to Tcl_GetIntFromObj ; attempts to write non-integer values into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_UINT : The C variable, or each element of the C array, is of type unsigned int . Any value written into the Tcl variable must have a proper unsigned integer form acceptable to Tcl_GetWideIntFromObj and in the platform\\'s defined range for the unsigned int type; attempts to write non-integer values (or values outside the range) into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_CHAR : The C variable, or each element of the C array, is of type char . Any value written into the Tcl variable must have a proper integer form acceptable to Tcl_GetIntFromObj and be in the range of the char datatype; attempts to write non-integer or out-of-range values into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. If using an array of these, consider using **TCL_LINK_CHARS** instead. TCL_LINK_CHARS : The C array is of type char * and is mapped into Tcl as a string. Any value written into the Tcl variable must have the same length as the underlying storage. Only supported with Tcl_LinkArray . TCL_LINK_UCHAR : The C variable, or each element of the C array, is of type unsigned char . Any value written into the Tcl variable must have a proper unsigned integer form acceptable to Tcl_GetIntFromObj and in the platform\\'s defined range for the unsigned char type; attempts to write non-integer values (or values outside the range) into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. If using an array of these, consider using **TCL_LINK_BINARY** instead. TCL_LINK_BINARY : The C array is of type unsigned char * and is mapped into Tcl as a bytearray. Any value written into the Tcl variable must have the same length as the underlying storage. Only supported with Tcl_LinkArray . TCL_LINK_SHORT : The C variable, or each element of the C array, is of type short . Any value written into the Tcl variable must have a proper integer form acceptable to Tcl_GetIntFromObj and be in the range of the short datatype; attempts to write non-integer or out-of-range values into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_USHORT : The C variable, or each element of the C array, is of type unsigned short . Any value written into the Tcl variable must have a proper unsigned integer form acceptable to Tcl_GetIntFromObj and in the platform\\'s defined range for the unsigned short type; attempts to write non-integer values (or values outside the range) into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_LONG : The C variable, or each element of the C array, is of type long . Any value written into the Tcl variable must have a proper integer form acceptable to Tcl_GetLongFromObj ; attempts to write non-integer or out-of-range values into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_ULONG : The C variable, or each element of the C array, is of type unsigned long . Any value written into the Tcl variable must have a proper unsigned integer form acceptable to Tcl_GetWideIntFromObj and in the platform\\'s defined range for the unsigned long type; attempts to write non-integer values (or values outside the range) into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_DOUBLE : The C variable, or each element of the C array, is of type double . Any value written into the Tcl variable must have a proper real form acceptable to Tcl_GetDoubleFromObj ; attempts to write non-real values into varName will be rejected with Tcl errors. Incomplete integer or real representations (like the empty string, \\'.\\', \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_FLOAT : The C variable, or each element of the C array, is of type float . Any value written into the Tcl variable must have a proper real form acceptable to Tcl_GetDoubleFromObj and must be within the range acceptable for a float ; attempts to write non-real values (or values outside the range) into varName will be rejected with Tcl errors. Incomplete integer or real representations (like the empty string, \\'.\\', \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_WIDE_INT : The C variable, or each element of the C array, is of type Tcl_WideInt (which is an integer type at least 64-bits wide on all platforms that can support it.) Any value written into the Tcl variable must have a proper integer form acceptable to Tcl_GetWideIntFromObj ; attempts to write non-integer values into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_WIDE_UINT : The C variable, or each element of the C array, is of type Tcl_WideUInt (which is an unsigned integer type at least 64-bits wide on all platforms that can support it.) Any value written into the Tcl variable must have a proper unsigned wideinteger form acceptable to Tcl_GetWideUIntFromObj ; attempts to write non-integer values into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_BOOLEAN : The C variable, or each element of the C array, is of type int . If its value is zero then it will read from Tcl as otherwise it will read from Tcl as Whenever varName is modified, the C variable will be set to a 0 or 1 value. Any value written into the Tcl variable must have a proper boolean form acceptable to Tcl_GetBooleanFromObj ; attempts to write non-boolean values into varName will be rejected with Tcl errors. TCL_LINK_STRING : The C variable is of type char * . If its value is not NULL then it must be a pointer to a string allocated with Tcl_Alloc . Whenever the Tcl variable is modified the current C string will be freed and new memory will be allocated to hold a copy of the variable\\'s new value. If the C variable contains a NULL pointer then the Tcl variable will read as This is only supported by Tcl_LinkVar . If the TCL_LINK_READ_ONLY flag is present in type then the variable will be read-only from Tcl, so that its value can only be changed by modifying the C variable. Attempts to write the variable from Tcl will be rejected with errors. Tcl_UnlinkVar removes the link previously set up for the variable given by varName . If there does not exist a link for varName then the procedure has no effect. Tcl_UpdateLinkedVar may be invoked after the C variable has changed to force the Tcl variable to be updated immediately. In many cases this procedure is not needed, since any attempt to read the Tcl variable will return the latest value of the C variable. However, if a trace has been set on the Tcl variable (such as a Tk widget that wishes to display the value of the variable), the trace will not trigger when the C variable has changed. Tcl_UpdateLinkedVar ensures that any traces on the Tcl variable are invoked. Note that, as with any call to a Tcl interpreter, Tcl_UpdateLinkedVar must be called from the same thread that created the interpreter. The safest mechanism is to ensure that the C variable is only ever updated from the same thread that created the interpreter (possibly in response to an event posted with Tcl_ThreadQueueEvent ), but when it is necessary to update the variable in a separate thread, it is advised that Tcl_AsyncMark be used to indicate to the thread hosting the interpreter that it is ready to run Tcl_UpdateLinkedVar . SEE ALSO Tcl_TraceVar(3) KEYWORDS boolean, integer, link, read-only, real, string, trace, variable","title":"NAME"},{"location":"LinkVar/#name","text":"Tcl_LinkArray, Tcl_LinkVar, Tcl_UnlinkVar, Tcl_UpdateLinkedVar - link Tcl variable to C variable","title":"NAME"},{"location":"LinkVar/#synopsis","text":"#include <tcl.h> int Tcl_LinkVar(interp, varName, addr, type) int Tcl_LinkArray(interp, varName, addr, type, size) Tcl_UnlinkVar(interp, varName) Tcl_UpdateLinkedVar(interp, varName)","title":"SYNOPSIS"},{"location":"LinkVar/#arguments","text":"Interpreter that contains varName . Also used by Tcl_LinkVar to return error messages. Name of global variable. Address of C variable that is to be linked to varName . In Tcl_LinkArray , may be NULL to tell Tcl to create the storage for the array in the variable. Type of C variable for Tcl_LinkVar or type of array element for Tcl_LinkArray . Must be one of TCL_LINK_INT , TCL_LINK_UINT , TCL_LINK_CHAR , TCL_LINK_UCHAR , TCL_LINK_SHORT , TCL_LINK_USHORT , TCL_LINK_LONG , TCL_LINK_ULONG , TCL_LINK_WIDE_INT , TCL_LINK_WIDE_UINT , TCL_LINK_FLOAT , TCL_LINK_DOUBLE , TCL_LINK_BOOLEAN , or one of the extra ones listed below. In Tcl_LinkVar , the additional linked type TCL_LINK_STRING may be used. In Tcl_LinkArray , the additional linked types TCL_LINK_CHARS and TCL_LINK_BINARY may be used. All the above for both functions may be optionally OR\\'ed with TCL_LINK_READ_ONLY to make the Tcl variable read-only. The number of elements in the C array. Must be greater than zero.","title":"ARGUMENTS"},{"location":"LinkVar/#description","text":"Tcl_LinkVar uses variable traces to keep the Tcl variable named by varName in sync with the C variable at the address given by addr . Whenever the Tcl variable is read the value of the C variable will be returned, and whenever the Tcl variable is written the C variable will be updated to have the same value. Tcl_LinkVar normally returns TCL_OK ; if an error occurs while setting up the link (e.g. because varName is the name of array) then TCL_ERROR is returned and the interpreter\\'s result contains an error message. Tcl_LinkArray is similar, but for arrays of fixed size (given by the size argument). When asked to allocate the backing C array storage (via the addr argument being NULL), it writes the address that it allocated to the Tcl interpreter result. The type argument specifies the type of the C variable, or the type of the elements of the C array, and must have one of the following values, optionally OR\\'ed with TCL_LINK_READ_ONLY : TCL_LINK_INT : The C variable, or each element of the C array, is of type int . Any value written into the Tcl variable must have a proper integer form acceptable to Tcl_GetIntFromObj ; attempts to write non-integer values into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_UINT : The C variable, or each element of the C array, is of type unsigned int . Any value written into the Tcl variable must have a proper unsigned integer form acceptable to Tcl_GetWideIntFromObj and in the platform\\'s defined range for the unsigned int type; attempts to write non-integer values (or values outside the range) into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_CHAR : The C variable, or each element of the C array, is of type char . Any value written into the Tcl variable must have a proper integer form acceptable to Tcl_GetIntFromObj and be in the range of the char datatype; attempts to write non-integer or out-of-range values into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. If using an array of these, consider using **TCL_LINK_CHARS** instead. TCL_LINK_CHARS : The C array is of type char * and is mapped into Tcl as a string. Any value written into the Tcl variable must have the same length as the underlying storage. Only supported with Tcl_LinkArray . TCL_LINK_UCHAR : The C variable, or each element of the C array, is of type unsigned char . Any value written into the Tcl variable must have a proper unsigned integer form acceptable to Tcl_GetIntFromObj and in the platform\\'s defined range for the unsigned char type; attempts to write non-integer values (or values outside the range) into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. If using an array of these, consider using **TCL_LINK_BINARY** instead. TCL_LINK_BINARY : The C array is of type unsigned char * and is mapped into Tcl as a bytearray. Any value written into the Tcl variable must have the same length as the underlying storage. Only supported with Tcl_LinkArray . TCL_LINK_SHORT : The C variable, or each element of the C array, is of type short . Any value written into the Tcl variable must have a proper integer form acceptable to Tcl_GetIntFromObj and be in the range of the short datatype; attempts to write non-integer or out-of-range values into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_USHORT : The C variable, or each element of the C array, is of type unsigned short . Any value written into the Tcl variable must have a proper unsigned integer form acceptable to Tcl_GetIntFromObj and in the platform\\'s defined range for the unsigned short type; attempts to write non-integer values (or values outside the range) into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_LONG : The C variable, or each element of the C array, is of type long . Any value written into the Tcl variable must have a proper integer form acceptable to Tcl_GetLongFromObj ; attempts to write non-integer or out-of-range values into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_ULONG : The C variable, or each element of the C array, is of type unsigned long . Any value written into the Tcl variable must have a proper unsigned integer form acceptable to Tcl_GetWideIntFromObj and in the platform\\'s defined range for the unsigned long type; attempts to write non-integer values (or values outside the range) into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_DOUBLE : The C variable, or each element of the C array, is of type double . Any value written into the Tcl variable must have a proper real form acceptable to Tcl_GetDoubleFromObj ; attempts to write non-real values into varName will be rejected with Tcl errors. Incomplete integer or real representations (like the empty string, \\'.\\', \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_FLOAT : The C variable, or each element of the C array, is of type float . Any value written into the Tcl variable must have a proper real form acceptable to Tcl_GetDoubleFromObj and must be within the range acceptable for a float ; attempts to write non-real values (or values outside the range) into varName will be rejected with Tcl errors. Incomplete integer or real representations (like the empty string, \\'.\\', \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_WIDE_INT : The C variable, or each element of the C array, is of type Tcl_WideInt (which is an integer type at least 64-bits wide on all platforms that can support it.) Any value written into the Tcl variable must have a proper integer form acceptable to Tcl_GetWideIntFromObj ; attempts to write non-integer values into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_WIDE_UINT : The C variable, or each element of the C array, is of type Tcl_WideUInt (which is an unsigned integer type at least 64-bits wide on all platforms that can support it.) Any value written into the Tcl variable must have a proper unsigned wideinteger form acceptable to Tcl_GetWideUIntFromObj ; attempts to write non-integer values into varName will be rejected with Tcl errors. Incomplete integer representations (like the empty string, \\'+\\', \\'-\\' or the hex/octal/decimal/binary prefix) are accepted as if they are valid too. TCL_LINK_BOOLEAN : The C variable, or each element of the C array, is of type int . If its value is zero then it will read from Tcl as otherwise it will read from Tcl as Whenever varName is modified, the C variable will be set to a 0 or 1 value. Any value written into the Tcl variable must have a proper boolean form acceptable to Tcl_GetBooleanFromObj ; attempts to write non-boolean values into varName will be rejected with Tcl errors. TCL_LINK_STRING : The C variable is of type char * . If its value is not NULL then it must be a pointer to a string allocated with Tcl_Alloc . Whenever the Tcl variable is modified the current C string will be freed and new memory will be allocated to hold a copy of the variable\\'s new value. If the C variable contains a NULL pointer then the Tcl variable will read as This is only supported by Tcl_LinkVar . If the TCL_LINK_READ_ONLY flag is present in type then the variable will be read-only from Tcl, so that its value can only be changed by modifying the C variable. Attempts to write the variable from Tcl will be rejected with errors. Tcl_UnlinkVar removes the link previously set up for the variable given by varName . If there does not exist a link for varName then the procedure has no effect. Tcl_UpdateLinkedVar may be invoked after the C variable has changed to force the Tcl variable to be updated immediately. In many cases this procedure is not needed, since any attempt to read the Tcl variable will return the latest value of the C variable. However, if a trace has been set on the Tcl variable (such as a Tk widget that wishes to display the value of the variable), the trace will not trigger when the C variable has changed. Tcl_UpdateLinkedVar ensures that any traces on the Tcl variable are invoked. Note that, as with any call to a Tcl interpreter, Tcl_UpdateLinkedVar must be called from the same thread that created the interpreter. The safest mechanism is to ensure that the C variable is only ever updated from the same thread that created the interpreter (possibly in response to an event posted with Tcl_ThreadQueueEvent ), but when it is necessary to update the variable in a separate thread, it is advised that Tcl_AsyncMark be used to indicate to the thread hosting the interpreter that it is ready to run Tcl_UpdateLinkedVar .","title":"DESCRIPTION"},{"location":"LinkVar/#see-also","text":"Tcl_TraceVar(3)","title":"SEE ALSO"},{"location":"LinkVar/#keywords","text":"boolean, integer, link, read-only, real, string, trace, variable","title":"KEYWORDS"},{"location":"ListObj/","text":"NAME Tcl_ListObjAppendList, Tcl_ListObjAppendElement, Tcl_NewListObj, Tcl_SetListObj, Tcl_ListObjGetElements, Tcl_ListObjLength, Tcl_ListObjIndex, Tcl_ListObjReplace - manipulate Tcl values as lists SYNOPSIS #include <tcl.h> int Tcl_ListObjAppendList(interp, listPtr, elemListPtr) int Tcl_ListObjAppendElement(interp, listPtr, objPtr) Tcl_Obj * Tcl_NewListObj(objc, objv) Tcl_SetListObj(objPtr, objc, objv) int Tcl_ListObjGetElements(interp, listPtr, objcPtr, objvPtr) int Tcl_ListObjLength(interp, listPtr, lengthPtr) int Tcl_ListObjIndex(interp, listPtr, index, objPtrPtr) int Tcl_ListObjReplace(interp, listPtr, first, count, objc, objv) ARGUMENTS If an error occurs while converting a value to be a list value, an error message is left in the interpreter\\'s result value unless interp is NULL. Points to the list value to be manipulated. If listPtr does not already point to a list value, an attempt will be made to convert it to one. For Tcl_ListObjAppendList , this points to a list value containing elements to be appended onto listPtr . Each element of * elemListPtr will become a new element of listPtr . If * elemListPtr is not NULL and does not already point to a list value, an attempt will be made to convert it to one. For Tcl_ListObjAppendElement , points to the Tcl value that will be appended to listPtr . For Tcl_SetListObj , this points to the Tcl value that will be converted to a list value containing the objc elements of the array referenced by objv . Points to location where Tcl_ListObjGetElements stores the number of element values in listPtr . A location where Tcl_ListObjGetElements stores a pointer to an array of pointers to the element values of listPtr . The number of Tcl values that Tcl_NewListObj will insert into a new list value, and Tcl_ListObjReplace will insert into listPtr . For Tcl_SetListObj , the number of Tcl values to insert into objPtr . An array of pointers to values. Tcl_NewListObj will insert these values into a new list value and Tcl_ListObjReplace will insert them into an existing listPtr . Each value will become a separate list element. Points to location where Tcl_ListObjLength stores the length of the list. Index of the list element that Tcl_ListObjIndex is to return. The first element has index 0. Points to place where Tcl_ListObjIndex is to store a pointer to the resulting list element value. Index of the starting list element that Tcl_ListObjReplace is to replace. The list\\'s first element has index 0. The number of elements that Tcl_ListObjReplace is to replace. DESCRIPTION Tcl list values have an internal representation that supports the efficient indexing and appending. The procedures described in this man page are used to create, modify, index, and append to Tcl list values from C code. Tcl_ListObjAppendList and Tcl_ListObjAppendElement both add one or more values to the end of the list value referenced by listPtr . Tcl_ListObjAppendList appends each element of the list value referenced by elemListPtr while Tcl_ListObjAppendElement appends the single value referenced by objPtr . Both procedures will convert the value referenced by listPtr to a list value if necessary. If an error occurs during conversion, both procedures return TCL_ERROR and leave an error message in the interpreter\\'s result value if interp is not NULL. Similarly, if elemListPtr does not already refer to a list value, Tcl_ListObjAppendList will attempt to convert it to one and if an error occurs during conversion, will return TCL_ERROR and leave an error message in the interpreter\\'s result value if interp is not NULL. Both procedures invalidate any old string representation of listPtr and, if it was converted to a list value, free any old internal representation. Similarly, Tcl_ListObjAppendList frees any old internal representation of elemListPtr if it converts it to a list value. After appending each element in elemListPtr , Tcl_ListObjAppendList increments the element\\'s reference count since listPtr now also refers to it. For the same reason, Tcl_ListObjAppendElement increments objPtr \\'s reference count. If no error occurs, the two procedures return TCL_OK after appending the values. Tcl_NewListObj and Tcl_SetListObj create a new value or modify an existing value to hold the objc elements of the array referenced by objv where each element is a pointer to a Tcl value. If objc is less than or equal to zero, they return an empty value. If objv is NULL, the resulting list contains 0 elements, with reserved space in an internal representation for objc more elements (to avoid its reallocation later). The new value\\'s string representation is left invalid. The two procedures increment the reference counts of the elements in objc since the list value now refers to them. The new list value returned by Tcl_NewListObj has reference count zero. Tcl_ListObjGetElements returns a count and a pointer to an array of the elements in a list value. It returns the count by storing it in the address objcPtr . Similarly, it returns the array pointer by storing it in the address objvPtr . The memory pointed to is managed by Tcl and should not be freed or written to by the caller. If the list is empty, 0 is stored at objcPtr and NULL at objvPtr . If objcPtr points to a variable of type int and the list contains more than 2**31 elements, the function returns TCL_ERROR . If listPtr is not already a list value, Tcl_ListObjGetElements will attempt to convert it to one; if the conversion fails, it returns TCL_ERROR and leaves an error message in the interpreter\\'s result value if interp is not NULL. Otherwise it returns TCL_OK after storing the count and array pointer. Tcl_ListObjLength returns the number of elements in the list value referenced by listPtr . It returns this count by storing a value in the address lengthPtr . If lengthPtr points to a variable of type int and the list contains more than 2**31 elements, the function returns TCL_ERROR . If the value is not already a list value, Tcl_ListObjLength will attempt to convert it to one; if the conversion fails, it returns TCL_ERROR and leaves an error message in the interpreter\\'s result value if interp is not NULL. Otherwise it returns TCL_OK after storing the list\\'s length. The procedure Tcl_ListObjIndex returns a pointer to the value at element index in the list referenced by listPtr . It returns this value by storing a pointer to it in the address objPtrPtr . If listPtr does not already refer to a list value, Tcl_ListObjIndex will attempt to convert it to one; if the conversion fails, it returns TCL_ERROR and leaves an error message in the interpreter\\'s result value if interp is not NULL. If the index is out of range, that is, index is negative or greater than or equal to the number of elements in the list, Tcl_ListObjIndex stores a NULL in objPtrPtr and returns TCL_OK . Otherwise it returns TCL_OK after storing the element\\'s value pointer. The reference count for the list element is not incremented; the caller must do that if it needs to retain a pointer to the element. Tcl_ListObjReplace replaces zero or more elements of the list referenced by listPtr with the objc values in the array referenced by objv . If listPtr does not point to a list value, Tcl_ListObjReplace will attempt to convert it to one; if the conversion fails, it returns TCL_ERROR and leaves an error message in the interpreter\\'s result value if interp is not NULL. Otherwise, it returns TCL_OK after replacing the values. If objv is NULL, no new elements are added. If the argument first is zero or negative, it refers to the first element. If first is greater than or equal to the number of elements in the list, then no elements are deleted; the new elements are appended to the list. count gives the number of elements to replace. If count is zero or negative then no elements are deleted; the new elements are simply inserted before the one designated by first . Tcl_ListObjReplace invalidates listPtr \\'s old string representation. The reference counts of any elements inserted from objv are incremented since the resulting list now refers to them. Similarly, the reference counts for any replaced values are decremented. Because Tcl_ListObjReplace combines both element insertion and deletion, it can be used to implement a number of list operations. For example, the following code inserts the objc values referenced by the array of value pointers objv just before the element index of the list referenced by listPtr : result = Tcl_ListObjReplace (interp, listPtr, index, 0, objc, objv); Similarly, the following code appends the objc values referenced by the array objv to the end of the list listPtr : result = Tcl_ListObjLength (interp, listPtr, &length); if (result == TCL_OK) { result = Tcl_ListObjReplace (interp, listPtr, length, 0, objc, objv); } The count list elements starting at first can be deleted by simply calling Tcl_ListObjReplace with a NULL objvPtr : result = Tcl_ListObjReplace (interp, listPtr, first, count, 0, NULL); REFERENCE COUNT MANAGEMENT Tcl_NewListObj always returns a zero-reference object, much like Tcl_NewObj . If a non-NULL objv argument is given, the reference counts of the first objc values in that array are incremented. Tcl_SetListObj does not modify the reference count of its objPtr argument, but does require that the object be unshared. The reference counts of the first objc values in the objv array are incremented. Tcl_ListObjGetElements , Tcl_ListObjIndex , and Tcl_ListObjLength do not modify the reference count of their listPtr arguments; they only read. Note however that these three functions may set the interpreter result; if that is the only place that is holding a reference to the object, it will be deleted. Tcl_ListObjAppendList , Tcl_ListObjAppendElement , and Tcl_ListObjReplace require an unshared listPtr argument. Tcl_ListObjAppendList only reads its elemListPtr argument. Tcl_ListObjAppendElement increments the reference count of its objPtr on success. Tcl_ListObjReplace increments the reference count of the first objc values in the objv array on success. Note however that all these three functions may set the interpreter result on failure; if that is the only place that is holding a reference to the object, it will be deleted. SEE ALSO Tcl_NewObj(3), Tcl_DecrRefCount(3), Tcl_IncrRefCount(3), Tcl_GetObjResult(3) KEYWORDS append, index, insert, internal representation, length, list, list value, list type, value, value type, replace, string representation","title":"NAME"},{"location":"ListObj/#name","text":"Tcl_ListObjAppendList, Tcl_ListObjAppendElement, Tcl_NewListObj, Tcl_SetListObj, Tcl_ListObjGetElements, Tcl_ListObjLength, Tcl_ListObjIndex, Tcl_ListObjReplace - manipulate Tcl values as lists","title":"NAME"},{"location":"ListObj/#synopsis","text":"#include <tcl.h> int Tcl_ListObjAppendList(interp, listPtr, elemListPtr) int Tcl_ListObjAppendElement(interp, listPtr, objPtr) Tcl_Obj * Tcl_NewListObj(objc, objv) Tcl_SetListObj(objPtr, objc, objv) int Tcl_ListObjGetElements(interp, listPtr, objcPtr, objvPtr) int Tcl_ListObjLength(interp, listPtr, lengthPtr) int Tcl_ListObjIndex(interp, listPtr, index, objPtrPtr) int Tcl_ListObjReplace(interp, listPtr, first, count, objc, objv)","title":"SYNOPSIS"},{"location":"ListObj/#arguments","text":"If an error occurs while converting a value to be a list value, an error message is left in the interpreter\\'s result value unless interp is NULL. Points to the list value to be manipulated. If listPtr does not already point to a list value, an attempt will be made to convert it to one. For Tcl_ListObjAppendList , this points to a list value containing elements to be appended onto listPtr . Each element of * elemListPtr will become a new element of listPtr . If * elemListPtr is not NULL and does not already point to a list value, an attempt will be made to convert it to one. For Tcl_ListObjAppendElement , points to the Tcl value that will be appended to listPtr . For Tcl_SetListObj , this points to the Tcl value that will be converted to a list value containing the objc elements of the array referenced by objv . Points to location where Tcl_ListObjGetElements stores the number of element values in listPtr . A location where Tcl_ListObjGetElements stores a pointer to an array of pointers to the element values of listPtr . The number of Tcl values that Tcl_NewListObj will insert into a new list value, and Tcl_ListObjReplace will insert into listPtr . For Tcl_SetListObj , the number of Tcl values to insert into objPtr . An array of pointers to values. Tcl_NewListObj will insert these values into a new list value and Tcl_ListObjReplace will insert them into an existing listPtr . Each value will become a separate list element. Points to location where Tcl_ListObjLength stores the length of the list. Index of the list element that Tcl_ListObjIndex is to return. The first element has index 0. Points to place where Tcl_ListObjIndex is to store a pointer to the resulting list element value. Index of the starting list element that Tcl_ListObjReplace is to replace. The list\\'s first element has index 0. The number of elements that Tcl_ListObjReplace is to replace.","title":"ARGUMENTS"},{"location":"ListObj/#description","text":"Tcl list values have an internal representation that supports the efficient indexing and appending. The procedures described in this man page are used to create, modify, index, and append to Tcl list values from C code. Tcl_ListObjAppendList and Tcl_ListObjAppendElement both add one or more values to the end of the list value referenced by listPtr . Tcl_ListObjAppendList appends each element of the list value referenced by elemListPtr while Tcl_ListObjAppendElement appends the single value referenced by objPtr . Both procedures will convert the value referenced by listPtr to a list value if necessary. If an error occurs during conversion, both procedures return TCL_ERROR and leave an error message in the interpreter\\'s result value if interp is not NULL. Similarly, if elemListPtr does not already refer to a list value, Tcl_ListObjAppendList will attempt to convert it to one and if an error occurs during conversion, will return TCL_ERROR and leave an error message in the interpreter\\'s result value if interp is not NULL. Both procedures invalidate any old string representation of listPtr and, if it was converted to a list value, free any old internal representation. Similarly, Tcl_ListObjAppendList frees any old internal representation of elemListPtr if it converts it to a list value. After appending each element in elemListPtr , Tcl_ListObjAppendList increments the element\\'s reference count since listPtr now also refers to it. For the same reason, Tcl_ListObjAppendElement increments objPtr \\'s reference count. If no error occurs, the two procedures return TCL_OK after appending the values. Tcl_NewListObj and Tcl_SetListObj create a new value or modify an existing value to hold the objc elements of the array referenced by objv where each element is a pointer to a Tcl value. If objc is less than or equal to zero, they return an empty value. If objv is NULL, the resulting list contains 0 elements, with reserved space in an internal representation for objc more elements (to avoid its reallocation later). The new value\\'s string representation is left invalid. The two procedures increment the reference counts of the elements in objc since the list value now refers to them. The new list value returned by Tcl_NewListObj has reference count zero. Tcl_ListObjGetElements returns a count and a pointer to an array of the elements in a list value. It returns the count by storing it in the address objcPtr . Similarly, it returns the array pointer by storing it in the address objvPtr . The memory pointed to is managed by Tcl and should not be freed or written to by the caller. If the list is empty, 0 is stored at objcPtr and NULL at objvPtr . If objcPtr points to a variable of type int and the list contains more than 2**31 elements, the function returns TCL_ERROR . If listPtr is not already a list value, Tcl_ListObjGetElements will attempt to convert it to one; if the conversion fails, it returns TCL_ERROR and leaves an error message in the interpreter\\'s result value if interp is not NULL. Otherwise it returns TCL_OK after storing the count and array pointer. Tcl_ListObjLength returns the number of elements in the list value referenced by listPtr . It returns this count by storing a value in the address lengthPtr . If lengthPtr points to a variable of type int and the list contains more than 2**31 elements, the function returns TCL_ERROR . If the value is not already a list value, Tcl_ListObjLength will attempt to convert it to one; if the conversion fails, it returns TCL_ERROR and leaves an error message in the interpreter\\'s result value if interp is not NULL. Otherwise it returns TCL_OK after storing the list\\'s length. The procedure Tcl_ListObjIndex returns a pointer to the value at element index in the list referenced by listPtr . It returns this value by storing a pointer to it in the address objPtrPtr . If listPtr does not already refer to a list value, Tcl_ListObjIndex will attempt to convert it to one; if the conversion fails, it returns TCL_ERROR and leaves an error message in the interpreter\\'s result value if interp is not NULL. If the index is out of range, that is, index is negative or greater than or equal to the number of elements in the list, Tcl_ListObjIndex stores a NULL in objPtrPtr and returns TCL_OK . Otherwise it returns TCL_OK after storing the element\\'s value pointer. The reference count for the list element is not incremented; the caller must do that if it needs to retain a pointer to the element. Tcl_ListObjReplace replaces zero or more elements of the list referenced by listPtr with the objc values in the array referenced by objv . If listPtr does not point to a list value, Tcl_ListObjReplace will attempt to convert it to one; if the conversion fails, it returns TCL_ERROR and leaves an error message in the interpreter\\'s result value if interp is not NULL. Otherwise, it returns TCL_OK after replacing the values. If objv is NULL, no new elements are added. If the argument first is zero or negative, it refers to the first element. If first is greater than or equal to the number of elements in the list, then no elements are deleted; the new elements are appended to the list. count gives the number of elements to replace. If count is zero or negative then no elements are deleted; the new elements are simply inserted before the one designated by first . Tcl_ListObjReplace invalidates listPtr \\'s old string representation. The reference counts of any elements inserted from objv are incremented since the resulting list now refers to them. Similarly, the reference counts for any replaced values are decremented. Because Tcl_ListObjReplace combines both element insertion and deletion, it can be used to implement a number of list operations. For example, the following code inserts the objc values referenced by the array of value pointers objv just before the element index of the list referenced by listPtr : result = Tcl_ListObjReplace (interp, listPtr, index, 0, objc, objv); Similarly, the following code appends the objc values referenced by the array objv to the end of the list listPtr : result = Tcl_ListObjLength (interp, listPtr, &length); if (result == TCL_OK) { result = Tcl_ListObjReplace (interp, listPtr, length, 0, objc, objv); } The count list elements starting at first can be deleted by simply calling Tcl_ListObjReplace with a NULL objvPtr : result = Tcl_ListObjReplace (interp, listPtr, first, count, 0, NULL);","title":"DESCRIPTION"},{"location":"ListObj/#reference-count-management","text":"Tcl_NewListObj always returns a zero-reference object, much like Tcl_NewObj . If a non-NULL objv argument is given, the reference counts of the first objc values in that array are incremented. Tcl_SetListObj does not modify the reference count of its objPtr argument, but does require that the object be unshared. The reference counts of the first objc values in the objv array are incremented. Tcl_ListObjGetElements , Tcl_ListObjIndex , and Tcl_ListObjLength do not modify the reference count of their listPtr arguments; they only read. Note however that these three functions may set the interpreter result; if that is the only place that is holding a reference to the object, it will be deleted. Tcl_ListObjAppendList , Tcl_ListObjAppendElement , and Tcl_ListObjReplace require an unshared listPtr argument. Tcl_ListObjAppendList only reads its elemListPtr argument. Tcl_ListObjAppendElement increments the reference count of its objPtr on success. Tcl_ListObjReplace increments the reference count of the first objc values in the objv array on success. Note however that all these three functions may set the interpreter result on failure; if that is the only place that is holding a reference to the object, it will be deleted.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"ListObj/#see-also","text":"Tcl_NewObj(3), Tcl_DecrRefCount(3), Tcl_IncrRefCount(3), Tcl_GetObjResult(3)","title":"SEE ALSO"},{"location":"ListObj/#keywords","text":"append, index, insert, internal representation, length, list, list value, list type, value, value type, replace, string representation","title":"KEYWORDS"},{"location":"Load/","text":"NAME load - Load machine code and initialize new commands SYNOPSIS load ? -global ? ? -lazy ? ? -- ? fileName \\ load ? -global ? ? -lazy ? ? -- ? fileName prefix \\ load ? -global ? ? -lazy ? ? -- ? fileName prefix interp DESCRIPTION This command loads binary code from a file into the application\\'s address space and calls an initialization procedure in the library to incorporate it into an interpreter. fileName is the name of the file containing the code; its exact form varies from system to system but on most systems it is a shared library, such as a .so file under Solaris or a DLL under Windows. prefix is used to compute the name of an initialization procedure. interp is the path name of the interpreter into which to load the library (see the interp manual entry for details); if interp is omitted, it defaults to the interpreter in which the load command was invoked. Once the file has been loaded into the application\\'s address space, one of two initialization procedures will be invoked in the new code. Typically the initialization procedure will add new commands to a Tcl interpreter. The name of the initialization procedure is determined by prefix and whether or not the target interpreter is a safe one. For normal interpreters the name of the initialization procedure will have the form prefix _Init . For example, if prefix is Foo , the initialization procedure\\'s name will be Foo_Init . If the target interpreter is a safe interpreter, then the name of the initialization procedure will be prefix _SafeInit instead of prefix _Init . The prefix _SafeInit function should be written carefully, so that it initializes the safe interpreter only with partial functionality provided by the library that is safe for use by untrusted code. For more information on Safe-Tcl, see the safe manual entry. The initialization procedure must match the following prototype: typedef int Tcl_LibraryInitProc ( Tcl_Interp * interp ); The interp argument identifies the interpreter in which the library is to be loaded. The initialization procedure must return TCL_OK or TCL_ERROR to indicate whether or not it completed successfully; in the event of an error it should set the interpreter\\'s result to point to an error message. The result of the load command will be the result returned by the initialization procedure. The actual loading of a file will only be done once for each fileName in an application. If a given fileName is loaded into multiple interpreters, then the first load will load the code and call the initialization procedure; subsequent load s will call the initialization procedure without loading the code again. For Tcl versions lower than 8.5, it is not possible to unload or reload a library. From version 8.5 however, the unload command allows the unloading of libraries loaded with load , for libraries that are aware of the Tcl\\'s unloading mechanism. The load command also supports libraries that are statically linked with the application, if those libraries have been registered by calling the Tcl_StaticLibrary procedure. If fileName is an empty string, then prefix must be specified. If prefix is omitted or specified as an empty string, Tcl tries to guess the prefix by taking the last element of fileName , strip off the first three characters if they are lib , then strip off the next three characters if they are tcl9 , and use any following wordchars but not digits, converted to titlecase as the prefix. For example, the command load libxyz4.2.so uses the prefix Xyz and the command load bin/last.so {} uses the prefix Last . If fileName is an empty string, then prefix must be specified. The load command first searches for a statically loaded library (one that has been registered by calling the Tcl_StaticLibrary procedure) by that name; if one is found, it is used. Otherwise, the load command searches for a dynamically loaded library by that name, and uses it if it is found. If several different files have been load ed with different versions of the library, Tcl picks the file that was loaded first. If -global is specified preceding the filename, all symbols found in the shared library are exported for global use by other libraries. The option -lazy delays the actual loading of symbols until their first actual use. The options may be abbreviated. The option -- indicates the end of the options, and should be used if you wish to use a filename which starts with - and you provide a prefix to the load command. On platforms which do not support the -global or -lazy options, the options still exist but have no effect. Note that use of the -global or -lazy option may lead to crashes in your application later (in case of symbol conflicts resp. missing symbols), which cannot be detected during the load . So, only use this when you know what you are doing, you will not get a nice error message when something is wrong with the loaded library. PORTABILITY ISSUES Windows \u2007\u2007\u2007\u2007\u2007 : When a load fails with error, it is also possible that a dependent library was not found. To see the dependent libraries, type in a DOS console to see what the library must import. When loading a DLL in the current directory, Windows will ignore as a path specifier and use a search heuristic to find the DLL instead. To avoid this, load the DLL with: load [file join [pwd] mylib.DLL] BUGS If the same file is load ed by different fileName s, it will be loaded into the process\\'s address space multiple times. The behavior of this varies from system to system (some systems may detect the redundant loads, others may not). EXAMPLE The following is a minimal extension: include \\<tcl.h> #include \\<stdio.h> static int fooCmd(void *clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) { printf(\\\"called with %d arguments\\n\\\", objc); return TCL_OK; } int Foo_Init(Tcl_Interp *interp) { if (Tcl_InitStubs(interp, \\\"8.1\\\", 0) == NULL) { return TCL_ERROR; } printf(\\\"creating foo command\\\"); Tcl_CreateObjCommand(interp, \\\"foo\\\", fooCmd, NULL, NULL); return TCL_OK; } When built into a shared/dynamic library with a suitable name (e.g. foo.dll on Windows, libfoo.so on Solaris and Linux) it can then be loaded into Tcl with the following: # Load the extension switch \\$tcl_platform(platform) { windows { load [file join [pwd] foo.dll] } unix { load [file join [pwd] libfoo[info sharedlibextension]] } } # Now execute the command defined by the extension foo SEE ALSO info sharedlibextension, package(n), Tcl_StaticLibrary(3), safe(n) KEYWORDS binary code, dynamic library, load, safe interpreter, shared library","title":"NAME"},{"location":"Load/#name","text":"load - Load machine code and initialize new commands","title":"NAME"},{"location":"Load/#synopsis","text":"load ? -global ? ? -lazy ? ? -- ? fileName \\ load ? -global ? ? -lazy ? ? -- ? fileName prefix \\ load ? -global ? ? -lazy ? ? -- ? fileName prefix interp","title":"SYNOPSIS"},{"location":"Load/#description","text":"This command loads binary code from a file into the application\\'s address space and calls an initialization procedure in the library to incorporate it into an interpreter. fileName is the name of the file containing the code; its exact form varies from system to system but on most systems it is a shared library, such as a .so file under Solaris or a DLL under Windows. prefix is used to compute the name of an initialization procedure. interp is the path name of the interpreter into which to load the library (see the interp manual entry for details); if interp is omitted, it defaults to the interpreter in which the load command was invoked. Once the file has been loaded into the application\\'s address space, one of two initialization procedures will be invoked in the new code. Typically the initialization procedure will add new commands to a Tcl interpreter. The name of the initialization procedure is determined by prefix and whether or not the target interpreter is a safe one. For normal interpreters the name of the initialization procedure will have the form prefix _Init . For example, if prefix is Foo , the initialization procedure\\'s name will be Foo_Init . If the target interpreter is a safe interpreter, then the name of the initialization procedure will be prefix _SafeInit instead of prefix _Init . The prefix _SafeInit function should be written carefully, so that it initializes the safe interpreter only with partial functionality provided by the library that is safe for use by untrusted code. For more information on Safe-Tcl, see the safe manual entry. The initialization procedure must match the following prototype: typedef int Tcl_LibraryInitProc ( Tcl_Interp * interp ); The interp argument identifies the interpreter in which the library is to be loaded. The initialization procedure must return TCL_OK or TCL_ERROR to indicate whether or not it completed successfully; in the event of an error it should set the interpreter\\'s result to point to an error message. The result of the load command will be the result returned by the initialization procedure. The actual loading of a file will only be done once for each fileName in an application. If a given fileName is loaded into multiple interpreters, then the first load will load the code and call the initialization procedure; subsequent load s will call the initialization procedure without loading the code again. For Tcl versions lower than 8.5, it is not possible to unload or reload a library. From version 8.5 however, the unload command allows the unloading of libraries loaded with load , for libraries that are aware of the Tcl\\'s unloading mechanism. The load command also supports libraries that are statically linked with the application, if those libraries have been registered by calling the Tcl_StaticLibrary procedure. If fileName is an empty string, then prefix must be specified. If prefix is omitted or specified as an empty string, Tcl tries to guess the prefix by taking the last element of fileName , strip off the first three characters if they are lib , then strip off the next three characters if they are tcl9 , and use any following wordchars but not digits, converted to titlecase as the prefix. For example, the command load libxyz4.2.so uses the prefix Xyz and the command load bin/last.so {} uses the prefix Last . If fileName is an empty string, then prefix must be specified. The load command first searches for a statically loaded library (one that has been registered by calling the Tcl_StaticLibrary procedure) by that name; if one is found, it is used. Otherwise, the load command searches for a dynamically loaded library by that name, and uses it if it is found. If several different files have been load ed with different versions of the library, Tcl picks the file that was loaded first. If -global is specified preceding the filename, all symbols found in the shared library are exported for global use by other libraries. The option -lazy delays the actual loading of symbols until their first actual use. The options may be abbreviated. The option -- indicates the end of the options, and should be used if you wish to use a filename which starts with - and you provide a prefix to the load command. On platforms which do not support the -global or -lazy options, the options still exist but have no effect. Note that use of the -global or -lazy option may lead to crashes in your application later (in case of symbol conflicts resp. missing symbols), which cannot be detected during the load . So, only use this when you know what you are doing, you will not get a nice error message when something is wrong with the loaded library.","title":"DESCRIPTION"},{"location":"Load/#portability-issues","text":"Windows \u2007\u2007\u2007\u2007\u2007 : When a load fails with error, it is also possible that a dependent library was not found. To see the dependent libraries, type in a DOS console to see what the library must import. When loading a DLL in the current directory, Windows will ignore as a path specifier and use a search heuristic to find the DLL instead. To avoid this, load the DLL with: load [file join [pwd] mylib.DLL]","title":"PORTABILITY ISSUES"},{"location":"Load/#bugs","text":"If the same file is load ed by different fileName s, it will be loaded into the process\\'s address space multiple times. The behavior of this varies from system to system (some systems may detect the redundant loads, others may not).","title":"BUGS"},{"location":"Load/#example","text":"The following is a minimal extension:","title":"EXAMPLE"},{"location":"Load/#include-tclh-include-stdioh-static-int-foocmdvoid","text":"*clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) { printf(\\\"called with %d arguments\\n\\\", objc); return TCL_OK; } int Foo_Init(Tcl_Interp *interp) { if (Tcl_InitStubs(interp, \\\"8.1\\\", 0) == NULL) { return TCL_ERROR; } printf(\\\"creating foo command\\\"); Tcl_CreateObjCommand(interp, \\\"foo\\\", fooCmd, NULL, NULL); return TCL_OK; } When built into a shared/dynamic library with a suitable name (e.g. foo.dll on Windows, libfoo.so on Solaris and Linux) it can then be loaded into Tcl with the following: # Load the extension switch \\$tcl_platform(platform) { windows { load [file join [pwd] foo.dll] } unix { load [file join [pwd] libfoo[info sharedlibextension]] } } # Now execute the command defined by the extension foo","title":"include \\&lt;tcl.h> #include \\&lt;stdio.h> static int fooCmd(void"},{"location":"Load/#see-also","text":"info sharedlibextension, package(n), Tcl_StaticLibrary(3), safe(n)","title":"SEE ALSO"},{"location":"Load/#keywords","text":"binary code, dynamic library, load, safe interpreter, shared library","title":"KEYWORDS"},{"location":"Method/","text":"NAME Tcl_ClassSetConstructor, Tcl_ClassSetDestructor, Tcl_MethodDeclarerClass, Tcl_MethodDeclarerObject, Tcl_MethodIsPublic, Tcl_MethodIsPrivate, Tcl_MethodIsType, Tcl_MethodName, Tcl_NewInstanceMethod, Tcl_NewMethod, Tcl_ObjectContextInvokeNext, Tcl_ObjectContextIsFiltering, Tcl_ObjectContextMethod, Tcl_ObjectContextObject, Tcl_ObjectContextSkippedArgs - manipulate methods and method-call contexts SYNOPSIS #include <tclOO.h> Tcl_Method Tcl_NewMethod(interp, class, nameObj, flags, methodTypePtr, clientData) Tcl_Method Tcl_NewInstanceMethod(interp, object, nameObj, flags, methodTypePtr, clientData) Tcl_ClassSetConstructor(interp, class, method) Tcl_ClassSetDestructor(interp, class, method) Tcl_Class Tcl_MethodDeclarerClass(method) Tcl_Object Tcl_MethodDeclarerObject(method) Tcl_Obj * Tcl_MethodName(method) int Tcl_MethodIsPublic(method) int Tcl_MethodIsPrivate(method) int Tcl_MethodIsType(method, methodTypePtr, clientDataPtr) int Tcl_ObjectContextInvokeNext(interp, context, objc, objv, skip) int Tcl_ObjectContextIsFiltering(context) Tcl_Method Tcl_ObjectContextMethod(context) Tcl_Object Tcl_ObjectContextObject(context) Tcl_Size Tcl_ObjectContextSkippedArgs(context) ARGUMENTS The interpreter holding the object or class to create or update a method in. The object to create the method in. The class to create the method in. The name of the method to create. Should not be NULL unless creating constructors or destructors. A flag saying (currently) what the visibility of the method is. The supported public values of this flag are TCL_OO_METHOD_PUBLIC (which is fixed at 1 for backward compatibility) for an exported method, TCL_OO_METHOD_UNEXPORTED (which is fixed at 0 for backward compatibility) for a non-exported method, and TCL_OO_METHOD_PRIVATE for a private method. A description of the type of the method to create, or the type of method to compare against. A piece of data that is passed to the implementation of the method without interpretation. A pointer to a variable in which to write the clientData value supplied when the method was created. If NULL, the clientData value will not be retrieved. A reference to a method to query. A reference to a method-call context. Note that client code must not retain a reference to a context. The number of arguments to pass to the method implementation. An array of arguments to pass to the method implementation. The number of arguments passed to the method implementation that do not represent \\\"real\\\" arguments. DESCRIPTION A method is an operation carried out on an object that is associated with the object. Every method must be attached to either an object or a class; methods attached to a class are associated with all instances (direct and indirect) of that class. Given a method, the entity that declared it can be found using Tcl_MethodDeclarerClass which returns the class that the method is attached to (or NULL if the method is not attached to any class) and Tcl_MethodDeclarerObject which returns the object that the method is attached to (or NULL if the method is not attached to an object). The name of the method can be retrieved with Tcl_MethodName , whether the method is exported is retrieved with Tcl_MethodIsPublic , and whether the method is private is retrieved with Tcl_MethodIsPrivate . The type of the method can also be introspected upon to a limited degree; the function Tcl_MethodIsType returns whether a method is of a particular type, assigning the per-method clientData to the variable pointed to by clientDataPtr if (that is non-NULL) if the type is matched. METHOD CREATION Methods are created by Tcl_NewMethod and Tcl_NewInstanceMethod , which create a method attached to a class or an object respectively. In both cases, the nameObj argument gives the name of the method to create, the flags argument states whether the method should be exported initially or be marked as a private method, the methodTypePtr argument describes the implementation of the method (see the METHOD TYPES section below) and the clientData argument gives some implementation-specific data that is passed on to the implementation of the method when it is called. When the nameObj argument to Tcl_NewMethod is NULL, an unnamed method is created, which is used for constructors and destructors. Constructors should be installed into their class using the Tcl_ClassSetConstructor function, and destructors (which must not require any arguments) should be installed into their class using the Tcl_ClassSetDestructor function. Unnamed methods should not be used for any other purpose, and named methods should not be used as either constructors or destructors. Also note that a NULL methodTypePtr is used to provide internal signaling, and should not be used in client code. METHOD CALL CONTEXTS When a method is called, a method-call context reference is passed in as one of the arguments to the implementation function. This context can be inspected to provide information about the caller, but should not be retained beyond the moment when the method call terminates. The method that is being called can be retrieved from the context by using Tcl_ObjectContextMethod , and the object that caused the method to be invoked can be retrieved with Tcl_ObjectContextObject . The number of arguments that are to be skipped (e.g. the object name and method name in a normal method call) is read with Tcl_ObjectContextSkippedArgs , and the context can also report whether it is working as a filter for another method through Tcl_ObjectContextIsFiltering . During the execution of a method, the method implementation may choose to invoke the stages of the method call chain that come after the current method implementation. This (the core of the next command) is done using Tcl_ObjectContextInvokeNext . Note that this function does not manipulate the call-frame stack, unlike the next command; if the method implementation has pushed one or more extra frames on the stack as part of its implementation, it is also responsible for temporarily popping those frames from the stack while the Tcl_ObjectContextInvokeNext function is executing. Note also that the method-call context is never deleted during the execution of this function. METHOD TYPES The types of methods are described by a pointer to a Tcl_MethodType structure, which is defined as: typedef struct { int version ; const char * name ; Tcl_MethodCallProc * callProc ; Tcl_MethodDeleteProc * deleteProc ; Tcl_CloneProc * cloneProc ; } Tcl_MethodType ; The version field allows for future expansion of the structure, and should always be declared equal to TCL_OO_METHOD_VERSION_CURRENT. The name field provides a human-readable name for the type, and is the value that is exposed via the info class methodtype and info object methodtype Tcl commands. The callProc field gives a function that is called when the method is invoked; it must never be NULL. The deleteProc field gives a function that is used to delete a particular method, and is called when the method is replaced or removed; if the field is NULL, it is assumed that the method\\'s clientData needs no special action to delete. The cloneProc field is either a function that is used to copy a method\\'s clientData (as part of Tcl_CopyObjectInstance ) or NULL to indicate that the clientData can just be copied directly. TCL_METHODCALLPROC FUNCTION SIGNATURE Functions matching this signature are called when the method is invoked. typedef int Tcl_MethodCallProc ( void * clientData , Tcl_Interp * interp , Tcl_ObjectContext objectContext , int objc , Tcl_Obj *const * objv ); The clientData argument to a Tcl_MethodCallProc is the value that was given when the method was created, the interp is a place in which to execute scripts and access variables as well as being where to put the result of the method, and the objc and objv fields give the parameter objects to the method. The calling context of the method can be discovered through the objectContext argument, and the return value from a Tcl_MethodCallProc is any Tcl return code (e.g. TCL_OK, TCL_ERROR). TCL_METHODDELETEPROC FUNCTION SIGNATURE Functions matching this signature are used when a method is deleted, whether through a new method being created or because the object or class is deleted. typedef void Tcl_MethodDeleteProc ( void * clientData ); The clientData argument to a Tcl_MethodDeleteProc will be the same as the value passed to the clientData argument to Tcl_NewMethod or Tcl_NewInstanceMethod when the method was created. TCL_CLONEPROC FUNCTION SIGNATURE Functions matching this signature are used to copy a method when the object or class is copied using Tcl_CopyObjectInstance (or oo::copy ). typedef int Tcl_CloneProc ( Tcl_Interp * interp , void * oldClientData , void ** newClientDataPtr ); The interp argument gives a place to write an error message when the attempt to clone the object is to fail, in which case the clone procedure must also return TCL_ERROR; it should return TCL_OK otherwise. The oldClientData field to a Tcl_CloneProc gives the value from the method being copied from, and the newClientDataPtr field will point to a variable in which to write the value for the method being copied to. REFERENCE COUNT MANAGEMENT The nameObj argument to Tcl_NewMethod and Tcl_NewInstanceMethod (when non-NULL) will have its reference count incremented if there is no existing method with that name in that class/object. The result of Tcl_MethodName is a value with a reference count of at least one. It should not be modified without first duplicating it (with Tcl_DuplicateObj ). The values in the first objc values of the objv argument to Tcl_ObjectContextInvokeNext are assumed to have a reference count of at least 1; the containing array is assumed to endure until the next method implementation (see next ) returns. Be aware that methods may yield ; if any post-call actions are desired (e.g., decrementing the reference count of values passed in here), they must be scheduled with Tcl_NRAddCallback . The callProc of the Tcl_MethodType structure takes values of at least reference count 1 in its objv argument. It may add its own references, but must not decrement the reference count below that level; the caller of the method will decrement the reference count once the method returns properly (and the reference will be held if the method yield s). SEE ALSO Class(3), NRE(3), oo::class(n), oo::define(n), oo::object(n) KEYWORDS constructor, method, object","title":"NAME"},{"location":"Method/#name","text":"Tcl_ClassSetConstructor, Tcl_ClassSetDestructor, Tcl_MethodDeclarerClass, Tcl_MethodDeclarerObject, Tcl_MethodIsPublic, Tcl_MethodIsPrivate, Tcl_MethodIsType, Tcl_MethodName, Tcl_NewInstanceMethod, Tcl_NewMethod, Tcl_ObjectContextInvokeNext, Tcl_ObjectContextIsFiltering, Tcl_ObjectContextMethod, Tcl_ObjectContextObject, Tcl_ObjectContextSkippedArgs - manipulate methods and method-call contexts","title":"NAME"},{"location":"Method/#synopsis","text":"#include <tclOO.h> Tcl_Method Tcl_NewMethod(interp, class, nameObj, flags, methodTypePtr, clientData) Tcl_Method Tcl_NewInstanceMethod(interp, object, nameObj, flags, methodTypePtr, clientData) Tcl_ClassSetConstructor(interp, class, method) Tcl_ClassSetDestructor(interp, class, method) Tcl_Class Tcl_MethodDeclarerClass(method) Tcl_Object Tcl_MethodDeclarerObject(method) Tcl_Obj * Tcl_MethodName(method) int Tcl_MethodIsPublic(method) int Tcl_MethodIsPrivate(method) int Tcl_MethodIsType(method, methodTypePtr, clientDataPtr) int Tcl_ObjectContextInvokeNext(interp, context, objc, objv, skip) int Tcl_ObjectContextIsFiltering(context) Tcl_Method Tcl_ObjectContextMethod(context) Tcl_Object Tcl_ObjectContextObject(context) Tcl_Size Tcl_ObjectContextSkippedArgs(context)","title":"SYNOPSIS"},{"location":"Method/#arguments","text":"The interpreter holding the object or class to create or update a method in. The object to create the method in. The class to create the method in. The name of the method to create. Should not be NULL unless creating constructors or destructors. A flag saying (currently) what the visibility of the method is. The supported public values of this flag are TCL_OO_METHOD_PUBLIC (which is fixed at 1 for backward compatibility) for an exported method, TCL_OO_METHOD_UNEXPORTED (which is fixed at 0 for backward compatibility) for a non-exported method, and TCL_OO_METHOD_PRIVATE for a private method. A description of the type of the method to create, or the type of method to compare against. A piece of data that is passed to the implementation of the method without interpretation. A pointer to a variable in which to write the clientData value supplied when the method was created. If NULL, the clientData value will not be retrieved. A reference to a method to query. A reference to a method-call context. Note that client code must not retain a reference to a context. The number of arguments to pass to the method implementation. An array of arguments to pass to the method implementation. The number of arguments passed to the method implementation that do not represent \\\"real\\\" arguments.","title":"ARGUMENTS"},{"location":"Method/#description","text":"A method is an operation carried out on an object that is associated with the object. Every method must be attached to either an object or a class; methods attached to a class are associated with all instances (direct and indirect) of that class. Given a method, the entity that declared it can be found using Tcl_MethodDeclarerClass which returns the class that the method is attached to (or NULL if the method is not attached to any class) and Tcl_MethodDeclarerObject which returns the object that the method is attached to (or NULL if the method is not attached to an object). The name of the method can be retrieved with Tcl_MethodName , whether the method is exported is retrieved with Tcl_MethodIsPublic , and whether the method is private is retrieved with Tcl_MethodIsPrivate . The type of the method can also be introspected upon to a limited degree; the function Tcl_MethodIsType returns whether a method is of a particular type, assigning the per-method clientData to the variable pointed to by clientDataPtr if (that is non-NULL) if the type is matched.","title":"DESCRIPTION"},{"location":"Method/#method-creation","text":"Methods are created by Tcl_NewMethod and Tcl_NewInstanceMethod , which create a method attached to a class or an object respectively. In both cases, the nameObj argument gives the name of the method to create, the flags argument states whether the method should be exported initially or be marked as a private method, the methodTypePtr argument describes the implementation of the method (see the METHOD TYPES section below) and the clientData argument gives some implementation-specific data that is passed on to the implementation of the method when it is called. When the nameObj argument to Tcl_NewMethod is NULL, an unnamed method is created, which is used for constructors and destructors. Constructors should be installed into their class using the Tcl_ClassSetConstructor function, and destructors (which must not require any arguments) should be installed into their class using the Tcl_ClassSetDestructor function. Unnamed methods should not be used for any other purpose, and named methods should not be used as either constructors or destructors. Also note that a NULL methodTypePtr is used to provide internal signaling, and should not be used in client code.","title":"METHOD CREATION"},{"location":"Method/#method-call-contexts","text":"When a method is called, a method-call context reference is passed in as one of the arguments to the implementation function. This context can be inspected to provide information about the caller, but should not be retained beyond the moment when the method call terminates. The method that is being called can be retrieved from the context by using Tcl_ObjectContextMethod , and the object that caused the method to be invoked can be retrieved with Tcl_ObjectContextObject . The number of arguments that are to be skipped (e.g. the object name and method name in a normal method call) is read with Tcl_ObjectContextSkippedArgs , and the context can also report whether it is working as a filter for another method through Tcl_ObjectContextIsFiltering . During the execution of a method, the method implementation may choose to invoke the stages of the method call chain that come after the current method implementation. This (the core of the next command) is done using Tcl_ObjectContextInvokeNext . Note that this function does not manipulate the call-frame stack, unlike the next command; if the method implementation has pushed one or more extra frames on the stack as part of its implementation, it is also responsible for temporarily popping those frames from the stack while the Tcl_ObjectContextInvokeNext function is executing. Note also that the method-call context is never deleted during the execution of this function.","title":"METHOD CALL CONTEXTS"},{"location":"Method/#method-types","text":"The types of methods are described by a pointer to a Tcl_MethodType structure, which is defined as: typedef struct { int version ; const char * name ; Tcl_MethodCallProc * callProc ; Tcl_MethodDeleteProc * deleteProc ; Tcl_CloneProc * cloneProc ; } Tcl_MethodType ; The version field allows for future expansion of the structure, and should always be declared equal to TCL_OO_METHOD_VERSION_CURRENT. The name field provides a human-readable name for the type, and is the value that is exposed via the info class methodtype and info object methodtype Tcl commands. The callProc field gives a function that is called when the method is invoked; it must never be NULL. The deleteProc field gives a function that is used to delete a particular method, and is called when the method is replaced or removed; if the field is NULL, it is assumed that the method\\'s clientData needs no special action to delete. The cloneProc field is either a function that is used to copy a method\\'s clientData (as part of Tcl_CopyObjectInstance ) or NULL to indicate that the clientData can just be copied directly.","title":"METHOD TYPES"},{"location":"Method/#tcl_methodcallproc-function-signature","text":"Functions matching this signature are called when the method is invoked. typedef int Tcl_MethodCallProc ( void * clientData , Tcl_Interp * interp , Tcl_ObjectContext objectContext , int objc , Tcl_Obj *const * objv ); The clientData argument to a Tcl_MethodCallProc is the value that was given when the method was created, the interp is a place in which to execute scripts and access variables as well as being where to put the result of the method, and the objc and objv fields give the parameter objects to the method. The calling context of the method can be discovered through the objectContext argument, and the return value from a Tcl_MethodCallProc is any Tcl return code (e.g. TCL_OK, TCL_ERROR).","title":"TCL_METHODCALLPROC FUNCTION SIGNATURE"},{"location":"Method/#tcl_methoddeleteproc-function-signature","text":"Functions matching this signature are used when a method is deleted, whether through a new method being created or because the object or class is deleted. typedef void Tcl_MethodDeleteProc ( void * clientData ); The clientData argument to a Tcl_MethodDeleteProc will be the same as the value passed to the clientData argument to Tcl_NewMethod or Tcl_NewInstanceMethod when the method was created.","title":"TCL_METHODDELETEPROC FUNCTION SIGNATURE"},{"location":"Method/#tcl_cloneproc-function-signature","text":"Functions matching this signature are used to copy a method when the object or class is copied using Tcl_CopyObjectInstance (or oo::copy ). typedef int Tcl_CloneProc ( Tcl_Interp * interp , void * oldClientData , void ** newClientDataPtr ); The interp argument gives a place to write an error message when the attempt to clone the object is to fail, in which case the clone procedure must also return TCL_ERROR; it should return TCL_OK otherwise. The oldClientData field to a Tcl_CloneProc gives the value from the method being copied from, and the newClientDataPtr field will point to a variable in which to write the value for the method being copied to.","title":"TCL_CLONEPROC FUNCTION SIGNATURE"},{"location":"Method/#reference-count-management","text":"The nameObj argument to Tcl_NewMethod and Tcl_NewInstanceMethod (when non-NULL) will have its reference count incremented if there is no existing method with that name in that class/object. The result of Tcl_MethodName is a value with a reference count of at least one. It should not be modified without first duplicating it (with Tcl_DuplicateObj ). The values in the first objc values of the objv argument to Tcl_ObjectContextInvokeNext are assumed to have a reference count of at least 1; the containing array is assumed to endure until the next method implementation (see next ) returns. Be aware that methods may yield ; if any post-call actions are desired (e.g., decrementing the reference count of values passed in here), they must be scheduled with Tcl_NRAddCallback . The callProc of the Tcl_MethodType structure takes values of at least reference count 1 in its objv argument. It may add its own references, but must not decrement the reference count below that level; the caller of the method will decrement the reference count once the method returns properly (and the reference will be held if the method yield s).","title":"REFERENCE COUNT MANAGEMENT"},{"location":"Method/#see-also","text":"Class(3), NRE(3), oo::class(n), oo::define(n), oo::object(n)","title":"SEE ALSO"},{"location":"Method/#keywords","text":"constructor, method, object","title":"KEYWORDS"},{"location":"NRE/","text":"NAME Tcl_NRCreateCommand, Tcl_NRCreateCommand2, Tcl_NRCallObjProc, Tcl_NRCallObjProc2, Tcl_NREvalObj, Tcl_NREvalObjv, Tcl_NRCmdSwap, Tcl_NRExprObj, Tcl_NRAddCallback - Non-Recursive (stackless) evaluation of Tcl scripts. SYNOPSIS #include <tcl.h> Tcl_Command Tcl_NRCreateCommand(interp, cmdName, proc, nreProc, clientData, deleteProc) Tcl_Command Tcl_NRCreateCommand2(interp, cmdName, proc2, nreProc2, clientData, deleteProc) int Tcl_NRCallObjProc(interp, nreProc, clientData, objc, objv) int Tcl_NRCallObjProc2(interp, nreProc2, clientData, objc, objv) int Tcl_NREvalObj(interp, objPtr, flags) int Tcl_NREvalObjv(interp, objc, objv, flags) int Tcl_NRCmdSwap(interp, cmd, objc, objv, flags) int Tcl_NRExprObj(interp, objPtr, resultPtr) void Tcl_NRAddCallback(interp, postProcPtr, data0, data1, data2, data3) ARGUMENTS The relevant Interpreter. Name of the command to create. Called in order to evaluate a command. Is often just a small wrapper that uses Tcl_NRCallObjProc to call nreProc using a new trampoline. Behaves in the same way as the proc argument to Tcl_CreateObjCommand (3) ( q.v. ). Called in order to evaluate a command. Is often just a small wrapper that uses Tcl_NRCallObjProc2 to call nreProc2 using a new trampoline. Behaves in the same way as the proc2 argument to Tcl_CreateObjCommand2 (3) ( q.v. ). Called instead of proc when a trampoline is already in use. Called instead of proc2 when a trampoline is already in use. Arbitrary one-word value passed to proc , nreProc , deleteProc and objProc . Called before cmdName is deleted from the interpreter, allowing for command-specific cleanup. May be NULL. Number of items in objv . Words in the command. A script or expression to evaluate. As described for Tcl_EvalObjv . Token to use instead of one derived from the first word of objv in order to evaluate a command. Pointer to an unshared Tcl_Obj where the result of the evaluation is stored if the return code is TCL_OK. A function to push. data0 through data3 are four one-word values that will be passed to the function designated by postProcPtr when it is invoked. DESCRIPTION These functions provide an interface to the function stack that an interpreter iterates through to evaluate commands. The routine behind a command is implemented by an initial function and any additional functions that the routine pushes onto the stack as it progresses. The interpreter itself pushes functions onto the stack to react to the end of a routine and to exercise other forms of control such as switching between in-progress stacks and the evaluation of other scripts at additional levels without adding frames to the C stack. To execute a routine, the initial function for the routine is called and then a small bit of code called a trampoline iteratively takes functions off the stack and calls them, using the value of the last call as the value of the routine. Tcl_NRCallObjProc calls nreProc using a new trampoline. Tcl_NRCreateCommand , an alternative to Tcl_CreateObjCommand , resolves cmdName , which may contain namespace qualifiers, relative to the current namespace, creates a command by that name, and returns a token for the command which may be used in subsequent calls to Tcl_GetCommandName . Except for a few cases noted below any existing command by the same name is first deleted. If interp is in the process of being deleted Tcl_NRCreateCommand does not create any command, does not delete any command, and returns NULL. Tcl_NRCreateCommand2 , is an alternative to Tcl_NRCreateCommand in the same way as Tcl_CreateObjCommand2 . Tcl_NREvalObj pushes a function that is like Tcl_EvalObjEx but consumes no space on the C stack. Tcl_NREvalObjv pushes a function that is like Tcl_EvalObjv but consumes no space on the C stack. Tcl_NRCmdSwap is like Tcl_NREvalObjv , but uses cmd , a token previously returned by Tcl_CreateObjCommand or Tcl_GetCommandFromObj , instead of resolving the first word of objv . Tcl_NRExprObj pushes a function that evaluates objPtr as an expression in the same manner as Tcl_ExprObj but without consuming space on the C stack. All of the functions return TCL_OK if the evaluation of the script, command, or expression has been scheduled successfully. Otherwise (for example if the command name cannot be resolved), they return TCL_ERROR and store a message as the interpreter\\'s result. Tcl_NRAddCallback pushes postProcPtr . The signature for Tcl_NRPostProc is: typedef int Tcl_NRPostProc ( void * data [], Tcl_Interp * interp , int result ); data is a pointer to an array containing data0 through data3 . result is the value returned by the previous function implementing part the routine. EXAMPLE The following command uses Tcl_EvalObjEx , which consumes space on the C stack, to evalute a script: int TheCmdOldObjProc ( void *clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) { int result; Tcl_Obj *objPtr; ... preparation ... result = Tcl_EvalObjEx (interp, objPtr, 0); ... postprocessing ... return result; } Tcl_CreateObjCommand (interp, \\\"theCommand\\\", TheCmdOldObjProc , clientData, TheCmdDeleteProc); To avoid consuming space on the C stack, TheCmdOldObjProc is renamed to TheCmdNRObjProc and the postprocessing step is split into a separate function, TheCmdPostProc , which is pushed onto the function stack. Tcl_EvalObjEx is replaced with Tcl_NREvalObj , which uses a trampoline instead of consuming space on the C stack. A new version of TheCmdOldObjProc is just a a wrapper that uses Tcl_NRCallObjProc to call TheCmdNRObjProc : int TheCmdOldObjProc ( void *clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) { return Tcl_NRCallObjProc (interp, TheCmdNRObjProc , clientData, objc, objv); } int TheCmdNRObjProc void *clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) { Tcl_Obj *objPtr; ... preparation ... Tcl_NRAddCallback (interp, TheCmdPostProc , data0, data1, data2, data3); /* data0 .. data3 are up to four one-word items to * pass to the postprocessing procedure */ return Tcl_NREvalObj (interp, objPtr, 0); } int TheCmdNRPostProc ( void *data[], Tcl_Interp *interp, int result) { /* data[0] .. data[3] are the four words of data * passed to Tcl_NRAddCallback */ ... postprocessing ... return result; } Any function comprising a routine can push other functions, making it possible implement looping and sequencing constructs using the function stack. REFERENCE COUNT MANAGEMENT The first objc values in the objv array passed to the functions Tcl_NRCallObjProc , Tcl_NREvalObjv , and Tcl_NRCmdSwap should have a reference count of at least 1; they may have additional references taken during the execution. The objPtr argument to Tcl_NREvalObj and Tcl_NRExprObj should have a reference count of at least 1, and may have additional references taken to it during execution. The resultObj argument to Tcl_NRExprObj should be an unshared object. Use Tcl_NRAddCallback to schedule any required final decrementing of the reference counts of arguments to any of the other functions on this page, as with any other post-processing step in the non-recursive execution engine. The SEE ALSO Tcl_CreateCommand(3), Tcl_CreateObjCommand(3), Tcl_EvalObjEx(3), Tcl_GetCommandFromObj(3), Tcl_ExprObj(3) KEYWORDS stackless, nonrecursive, execute, command, global, value, result, script COPYRIGHT Copyright \u00a9 2008 Kevin B. Kenny. Copyright \u00a9 2018 Nathan Coulter.","title":"NAME"},{"location":"NRE/#name","text":"Tcl_NRCreateCommand, Tcl_NRCreateCommand2, Tcl_NRCallObjProc, Tcl_NRCallObjProc2, Tcl_NREvalObj, Tcl_NREvalObjv, Tcl_NRCmdSwap, Tcl_NRExprObj, Tcl_NRAddCallback - Non-Recursive (stackless) evaluation of Tcl scripts.","title":"NAME"},{"location":"NRE/#synopsis","text":"#include <tcl.h> Tcl_Command Tcl_NRCreateCommand(interp, cmdName, proc, nreProc, clientData, deleteProc) Tcl_Command Tcl_NRCreateCommand2(interp, cmdName, proc2, nreProc2, clientData, deleteProc) int Tcl_NRCallObjProc(interp, nreProc, clientData, objc, objv) int Tcl_NRCallObjProc2(interp, nreProc2, clientData, objc, objv) int Tcl_NREvalObj(interp, objPtr, flags) int Tcl_NREvalObjv(interp, objc, objv, flags) int Tcl_NRCmdSwap(interp, cmd, objc, objv, flags) int Tcl_NRExprObj(interp, objPtr, resultPtr) void Tcl_NRAddCallback(interp, postProcPtr, data0, data1, data2, data3)","title":"SYNOPSIS"},{"location":"NRE/#arguments","text":"The relevant Interpreter. Name of the command to create. Called in order to evaluate a command. Is often just a small wrapper that uses Tcl_NRCallObjProc to call nreProc using a new trampoline. Behaves in the same way as the proc argument to Tcl_CreateObjCommand (3) ( q.v. ). Called in order to evaluate a command. Is often just a small wrapper that uses Tcl_NRCallObjProc2 to call nreProc2 using a new trampoline. Behaves in the same way as the proc2 argument to Tcl_CreateObjCommand2 (3) ( q.v. ). Called instead of proc when a trampoline is already in use. Called instead of proc2 when a trampoline is already in use. Arbitrary one-word value passed to proc , nreProc , deleteProc and objProc . Called before cmdName is deleted from the interpreter, allowing for command-specific cleanup. May be NULL. Number of items in objv . Words in the command. A script or expression to evaluate. As described for Tcl_EvalObjv . Token to use instead of one derived from the first word of objv in order to evaluate a command. Pointer to an unshared Tcl_Obj where the result of the evaluation is stored if the return code is TCL_OK. A function to push. data0 through data3 are four one-word values that will be passed to the function designated by postProcPtr when it is invoked.","title":"ARGUMENTS"},{"location":"NRE/#description","text":"These functions provide an interface to the function stack that an interpreter iterates through to evaluate commands. The routine behind a command is implemented by an initial function and any additional functions that the routine pushes onto the stack as it progresses. The interpreter itself pushes functions onto the stack to react to the end of a routine and to exercise other forms of control such as switching between in-progress stacks and the evaluation of other scripts at additional levels without adding frames to the C stack. To execute a routine, the initial function for the routine is called and then a small bit of code called a trampoline iteratively takes functions off the stack and calls them, using the value of the last call as the value of the routine. Tcl_NRCallObjProc calls nreProc using a new trampoline. Tcl_NRCreateCommand , an alternative to Tcl_CreateObjCommand , resolves cmdName , which may contain namespace qualifiers, relative to the current namespace, creates a command by that name, and returns a token for the command which may be used in subsequent calls to Tcl_GetCommandName . Except for a few cases noted below any existing command by the same name is first deleted. If interp is in the process of being deleted Tcl_NRCreateCommand does not create any command, does not delete any command, and returns NULL. Tcl_NRCreateCommand2 , is an alternative to Tcl_NRCreateCommand in the same way as Tcl_CreateObjCommand2 . Tcl_NREvalObj pushes a function that is like Tcl_EvalObjEx but consumes no space on the C stack. Tcl_NREvalObjv pushes a function that is like Tcl_EvalObjv but consumes no space on the C stack. Tcl_NRCmdSwap is like Tcl_NREvalObjv , but uses cmd , a token previously returned by Tcl_CreateObjCommand or Tcl_GetCommandFromObj , instead of resolving the first word of objv . Tcl_NRExprObj pushes a function that evaluates objPtr as an expression in the same manner as Tcl_ExprObj but without consuming space on the C stack. All of the functions return TCL_OK if the evaluation of the script, command, or expression has been scheduled successfully. Otherwise (for example if the command name cannot be resolved), they return TCL_ERROR and store a message as the interpreter\\'s result. Tcl_NRAddCallback pushes postProcPtr . The signature for Tcl_NRPostProc is: typedef int Tcl_NRPostProc ( void * data [], Tcl_Interp * interp , int result ); data is a pointer to an array containing data0 through data3 . result is the value returned by the previous function implementing part the routine.","title":"DESCRIPTION"},{"location":"NRE/#example","text":"The following command uses Tcl_EvalObjEx , which consumes space on the C stack, to evalute a script: int TheCmdOldObjProc ( void *clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) { int result; Tcl_Obj *objPtr; ... preparation ... result = Tcl_EvalObjEx (interp, objPtr, 0); ... postprocessing ... return result; } Tcl_CreateObjCommand (interp, \\\"theCommand\\\", TheCmdOldObjProc , clientData, TheCmdDeleteProc); To avoid consuming space on the C stack, TheCmdOldObjProc is renamed to TheCmdNRObjProc and the postprocessing step is split into a separate function, TheCmdPostProc , which is pushed onto the function stack. Tcl_EvalObjEx is replaced with Tcl_NREvalObj , which uses a trampoline instead of consuming space on the C stack. A new version of TheCmdOldObjProc is just a a wrapper that uses Tcl_NRCallObjProc to call TheCmdNRObjProc : int TheCmdOldObjProc ( void *clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) { return Tcl_NRCallObjProc (interp, TheCmdNRObjProc , clientData, objc, objv); } int TheCmdNRObjProc void *clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) { Tcl_Obj *objPtr; ... preparation ... Tcl_NRAddCallback (interp, TheCmdPostProc , data0, data1, data2, data3); /* data0 .. data3 are up to four one-word items to * pass to the postprocessing procedure */ return Tcl_NREvalObj (interp, objPtr, 0); } int TheCmdNRPostProc ( void *data[], Tcl_Interp *interp, int result) { /* data[0] .. data[3] are the four words of data * passed to Tcl_NRAddCallback */ ... postprocessing ... return result; } Any function comprising a routine can push other functions, making it possible implement looping and sequencing constructs using the function stack.","title":"EXAMPLE"},{"location":"NRE/#reference-count-management","text":"The first objc values in the objv array passed to the functions Tcl_NRCallObjProc , Tcl_NREvalObjv , and Tcl_NRCmdSwap should have a reference count of at least 1; they may have additional references taken during the execution. The objPtr argument to Tcl_NREvalObj and Tcl_NRExprObj should have a reference count of at least 1, and may have additional references taken to it during execution. The resultObj argument to Tcl_NRExprObj should be an unshared object. Use Tcl_NRAddCallback to schedule any required final decrementing of the reference counts of arguments to any of the other functions on this page, as with any other post-processing step in the non-recursive execution engine. The","title":"REFERENCE COUNT MANAGEMENT"},{"location":"NRE/#see-also","text":"Tcl_CreateCommand(3), Tcl_CreateObjCommand(3), Tcl_EvalObjEx(3), Tcl_GetCommandFromObj(3), Tcl_ExprObj(3)","title":"SEE ALSO"},{"location":"NRE/#keywords","text":"stackless, nonrecursive, execute, command, global, value, result, script","title":"KEYWORDS"},{"location":"NRE/#copyright","text":"Copyright \u00a9 2008 Kevin B. Kenny. Copyright \u00a9 2018 Nathan Coulter.","title":"COPYRIGHT"},{"location":"Namespace/","text":"NAME namespace - create and manipulate contexts for commands and variables SYNOPSIS namespace ? subcommand ? ? arg ... ? DESCRIPTION The namespace command lets you create, access, and destroy separate contexts for commands and variables. See the section WHAT IS A NAMESPACE? below for a brief overview of namespaces. The legal values of subcommand are listed below. Note that you can abbreviate the subcommand s. namespace children ? namespace ? ? pattern ? : Returns a list of all child namespaces that belong to the namespace namespace . If namespace is not specified, then the children are returned for the current namespace. This command returns fully-qualified names, which start with a double colon ( :: ). If the optional pattern is given, then this command returns only the names that match the glob-style pattern. The actual pattern used is determined as follows: a pattern that starts with double colon ( :: ) is used directly, otherwise the namespace namespace (or the fully-qualified name of the current namespace) is prepended onto the pattern. namespace code script : Captures the current namespace context for later execution of the script script . It returns a new script in which script has been wrapped in a namespace inscope command. The new script has two important properties. First, it can be evaluated in any namespace and will cause script to be evaluated in the current namespace (the one where the namespace code command was invoked). Second, additional arguments can be appended to the resulting script and they will be passed to script as additional arguments. For example, suppose the command set script [namespace code {foo bar}] is invoked in namespace ::a::b . Then eval \\$script [list x y] can be executed in any namespace (assuming the value of script has been passed in properly) and will have the same effect as the command ::namespace eval ::a::b {foo bar x y} . This command is needed because extensions like Tk normally execute callback scripts in the global namespace. A scoped command captures a command together with its namespace context in a way that allows it to be executed properly later. See the section SCOPED SCRIPTS for some examples of how this is used to create callback scripts. namespace current : Returns the fully-qualified name for the current namespace. The actual name of the global namespace is (i.e., an empty string), but this command returns :: for the global namespace as a convenience to programmers. namespace delete ? namespace namespace ... ? : Each namespace namespace is deleted and all variables, procedures, and child namespaces contained in the namespace are deleted. If a procedure is currently executing inside the namespace, the namespace will be kept alive until the procedure returns; however, the namespace is marked to prevent other code from looking it up by name. If a namespace does not exist, this command returns an error. If no namespace names are given, this command does nothing. namespace ensemble subcommand ? arg ... ? : Creates and manipulates a command that is formed out of an ensemble of subcommands. See the section ENSEMBLES below for further details. namespace eval namespace arg ? arg ... ? : Activates a namespace called namespace and evaluates some code in that context. If the namespace does not already exist, it is created. If more than one arg argument is specified, the arguments are concatenated together with a space between each one in the same fashion as the eval command, and the result is evaluated. If *namespace* has leading namespace qualifiers and any leading namespaces do not exist, they are automatically created. namespace exists namespace : Returns 1 if namespace is a valid namespace in the current context, returns 0 otherwise. namespace export ? -clear ? ? pattern pattern ... ? : Specifies which commands are exported from a namespace. The exported commands are those that can be later imported into another namespace using a namespace import command. Both commands defined in a namespace and commands the namespace has previously imported can be exported by a namespace. The commands do not have to be defined at the time the namespace export command is executed. Each pattern may contain glob-style special characters, but it may not include any namespace qualifiers. That is, the pattern can only specify commands in the current (exporting) namespace. Each pattern is appended onto the namespace\\'s list of export patterns. If the -clear flag is given, the namespace\\'s export pattern list is reset to empty before any pattern arguments are appended. If no pattern s are given and the -clear flag is not given, this command returns the namespace\\'s current export list. namespace forget ? pattern pattern ... ? : Removes previously imported commands from a namespace. Each pattern is a simple or qualified name such as x , foo::x or a::b::p* . Qualified names contain double colons ( :: ) and qualify a name with the name of one or more namespaces. Each is qualified with the name of an exporting namespace and may have glob-style special characters in the command name at the end of the qualified name. Glob characters may not appear in a namespace name. For each this command deletes the matching commands of the current namespace that were imported from a different namespace. For this command first finds the matching exported commands. It then checks whether any of those commands were previously imported by the current namespace. If so, this command deletes the corresponding imported commands. In effect, this undoes the action of a namespace import command. namespace import ? -force ? ? pattern pattern ... ? : Imports commands into a namespace, or queries the set of imported commands in a namespace. When no arguments are present, namespace import returns the list of commands in the current namespace that have been imported from other namespaces. The commands in the returned list are in the format of simple names, with no namespace qualifiers at all. This format is suitable for composition with namespace forget (see EXAMPLES below). When *pattern* arguments are present, each *pattern* is a qualified name like **foo::x** or **a::p\\***. That is, it includes the name of an exporting namespace and may have glob-style special characters in the command name at the end of the qualified name. Glob characters may not appear in a namespace name. When the namespace name is not fully qualified (i.e., does not start with a namespace separator) it is resolved as a namespace name in the way described in the **NAME RESOLUTION** section; it is an error if no namespace with that name can be found. All the commands that match a *pattern* string and which are currently exported from their namespace are added to the current namespace. This is done by creating a new command in the current namespace that points to the exported command in its original namespace; when the new imported command is called, it invokes the exported command. This command normally returns an error if an imported command conflicts with an existing command. However, if the **-force** option is given, imported commands will silently replace existing commands. The **namespace import** command has snapshot semantics: that is, only requested commands that are currently defined in the exporting namespace are imported. In other words, you can import only the commands that are in a namespace at the time when the **namespace import** command is executed. If another command is defined and exported in this namespace later on, it will not be imported. namespace inscope namespace script ? arg ... ? : Executes a script in the context of the specified namespace . This command is not expected to be used directly by programmers; calls to it are generated implicitly when applications use namespace code commands to create callback scripts that the applications then register with, e.g., Tk widgets. The namespace inscope command is much like the namespace eval command except that the namespace must already exist, and namespace inscope appends additional arg s as proper list elements. **namespace inscope ::foo \\$script \\$x \\$y \\$z** is equivalent to **namespace eval ::foo \\[concat \\$script \\[list \\$x \\$y \\$z\\]\\]** thus additional arguments will not undergo a second round of substitution, as is the case with **namespace eval**. namespace origin command : Returns the fully-qualified name of the original command to which the imported command command refers. When a command is imported into a namespace, a new command is created in that namespace that points to the actual command in the exporting namespace. If a command is imported into a sequence of namespaces a, b,...,n where each successive namespace just imports the command from the previous namespace, this command returns the fully-qualified name of the original command in the first namespace, a . If command does not refer to an imported command, the command\\'s own fully-qualified name is returned. namespace parent ? namespace ? : Returns the fully-qualified name of the parent namespace for namespace namespace . If namespace is not specified, the fully-qualified name of the current namespace\\'s parent is returned. namespace path ? namespaceList ? : Returns the command resolution path of the current namespace. If namespaceList is specified as a list of named namespaces, the current namespace\\'s command resolution path is set to those namespaces and returns the empty list. The default command resolution path is always empty. See the section NAME RESOLUTION below for an explanation of the rules regarding name resolution. namespace qualifiers string : Returns any leading namespace qualifiers for string . Qualifiers are namespace names separated by double colons ( :: ). For the string ::foo::bar::x , this command returns ::foo::bar , and for :: it returns an empty string. This command is the complement of the namespace tail command. Note that it does not check whether the namespace names are, in fact, the names of currently defined namespaces. namespace tail string : Returns the simple name at the end of a qualified string. Qualifiers are namespace names separated by double colons ( :: ). For the string ::foo::bar::x , this command returns x , and for :: it returns an empty string. This command is the complement of the namespace qualifiers command. It does not check whether the namespace names are, in fact, the names of currently defined namespaces. namespace upvar namespace ? otherVar myVar ...? : This command arranges for zero or more local variables in the current procedure to refer to variables in namespace . The namespace name is resolved as described in section NAME RESOLUTION . The command namespace upvar \\$ns a b has the same behaviour as upvar 0 \\${ns}::a b , with the sole exception of the resolution rules used for qualified namespace or variable names. namespace upvar returns an empty string. namespace unknown ? script ? : Sets or returns the unknown command handler for the current namespace. The handler is invoked when a command called from within the namespace cannot be found in the current namespace, the namespace\\'s path nor in the global namespace. The script argument, if given, should be a well formed list representing a command name and optional arguments. When the handler is invoked, the full invocation line will be appended to the script and the result evaluated in the context of the namespace. The default handler for all namespaces is ::unknown . If no argument is given, it returns the handler for the current namespace. namespace which ? -command ? ? -variable ? name : Looks up name as either a command or variable and returns its fully-qualified name. For example, if name does not exist in the current namespace but does exist in the global namespace, this command returns a fully-qualified name in the global namespace. If the command or variable does not exist, this command returns an empty string. If the variable has been created but not defined, such as with the variable command or through a trace on the variable, this command will return the fully-qualified name of the variable. If no flag is given, name is treated as a command name. See the section NAME RESOLUTION below for an explanation of the rules regarding name resolution. WHAT IS A NAMESPACE? A namespace is a collection of commands and variables. It encapsulates the commands and variables to ensure that they will not interfere with the commands and variables of other namespaces. Tcl has always had one such collection, which we refer to as the global namespace . The global namespace holds all global variables and commands. The namespace eval command lets you create new namespaces. For example, namespace eval Counter { namespace export bump variable num 0 proc bump {} { variable num incr num } } creates a new namespace containing the variable num and the procedure bump . The commands and variables in this namespace are separate from other commands and variables in the same program. If there is a command named bump in the global namespace, for example, it will be different from the command bump in the Counter namespace. Namespace variables resemble global variables in Tcl. They exist outside of the procedures in a namespace but can be accessed in a procedure via the variable command, as shown in the example above. Namespaces are dynamic. You can add and delete commands and variables at any time, so you can build up the contents of a namespace over time using a series of namespace eval commands. For example, the following series of commands has the same effect as the namespace definition shown above: namespace eval Counter { variable num 0 proc bump {} { variable num return [incr num] } } namespace eval Counter { proc test {args} { return \\$args } } namespace eval Counter { rename test \\\"\\\" } Note that the test procedure is added to the Counter namespace, and later removed via the rename command. Namespaces can have other namespaces within them, so they nest hierarchically. A nested namespace is encapsulated inside its parent namespace and can not interfere with other namespaces. QUALIFIED NAMES Each namespace has a textual name such as history or ::safe::interp . Since namespaces may nest, qualified names are used to refer to commands, variables, and child namespaces contained inside namespaces. Qualified names are similar to the hierarchical path names for Unix files or Tk widgets, except that :: is used as the separator instead of / or . . The topmost or global namespace has the name (i.e., an empty string), although :: is a synonym. As an example, the name ::safe::interp::create refers to the command create in the namespace interp that is a child of namespace ::safe , which in turn is a child of the global namespace, :: . If you want to access commands and variables from another namespace, you must use some extra syntax. Names must be qualified by the namespace that contains them. From the global namespace, we might access the Counter procedures like this: Counter::bump 5 Counter::Reset We could access the current count like this: puts \\\"count = \\$Counter::num\\\" When one namespace contains another, you may need more than one qualifier to reach its elements. If we had a namespace Foo that contained the namespace Counter , you could invoke its bump procedure from the global namespace like this: Foo::Counter::bump 3 You can also use qualified names when you create and rename commands. For example, you could add a procedure to the Foo namespace like this: proc Foo::Test {args} {return \\$args} And you could move the same procedure to another namespace like this: rename Foo::Test Bar::Test There are a few remaining points about qualified names that we should cover. Namespaces have nonempty names except for the global namespace. :: is disallowed in simple command, variable, and namespace names except as a namespace separator. Extra colons in any separator part of a qualified name are ignored; i.e. two or more colons are treated as a namespace separator. A trailing :: in a qualified variable or command name refers to the variable or command named {}. However, a trailing :: in a qualified namespace name is ignored. NAME RESOLUTION In general, all Tcl commands that take variable and command names support qualified names. This means you can give qualified names to such commands as set , proc , rename , and interp alias . If you provide a fully-qualified name that starts with a :: , there is no question about what command, variable, or namespace you mean. However, if the name does not start with a :: (i.e., is relative ), Tcl follows basic rules for looking it up: Variable names are always resolved by looking first in the current namespace, and then in the global namespace. Command names are always resolved by looking in the current namespace first. If not found there, they are searched for in every namespace on the current namespace\\'s command path (which is empty by default). If not found there, command names are looked up in the global namespace (or, failing that, are processed by the appropriate namespace unknown handler.) Namespace names are always resolved by looking in only the current namespace. In the following example, set traceLevel 0 namespace eval Debug { printTrace \\$traceLevel } Tcl looks for traceLevel in the namespace Debug and then in the global namespace. It looks up the command printTrace in the same way. If a variable or command name is not found in either context, the name is undefined. To make this point absolutely clear, consider the following example: set traceLevel 0 namespace eval Foo { variable traceLevel 3 namespace eval Debug { printTrace \\$traceLevel } } Here Tcl looks for traceLevel first in the namespace Foo::Debug . Since it is not found there, Tcl then looks for it in the global namespace. The variable Foo::traceLevel is completely ignored during the name resolution process. You can use the namespace which command to clear up any question about name resolution. For example, the command: namespace eval Foo::Debug { namespace which -variable traceLevel} returns ::traceLevel . On the other hand, the command, namespace eval Foo { namespace which -variable traceLevel} returns ::Foo::traceLevel . As mentioned above, namespace names are looked up differently than the names of variables and commands. Namespace names are always resolved in the current namespace. This means, for example, that a namespace eval command that creates a new namespace always creates a child of the current namespace unless the new namespace name begins with :: . Tcl has no access control to limit what variables, commands, or namespaces you can reference. If you provide a qualified name that resolves to an element by the name resolution rule above, you can access the element. You can access a namespace variable from a procedure in the same namespace by using the variable command. Much like the global command, this creates a local link to the namespace variable. If necessary, it also creates the variable in the current namespace and initializes it. Note that the global command only creates links to variables in the global namespace. It is not necessary to use a variable command if you always refer to the namespace variable using an appropriate qualified name. IMPORTING COMMANDS Namespaces are often used to represent libraries. Some library commands are used so frequently that it is a nuisance to type their qualified names. For example, suppose that all of the commands in a package like BLT are contained in a namespace called Blt . Then you might access these commands like this: Blt::graph .g -background red Blt::table . .g 0,0 If you use the graph and table commands frequently, you may want to access them without the Blt:: prefix. You can do this by importing the commands into the current namespace, like this: namespace import Blt::* This adds all exported commands from the Blt namespace into the current namespace context, so you can write code like this: graph .g -background red table . .g 0,0 The namespace import command only imports commands from a namespace that that namespace exported with a namespace export command. Importing every command from a namespace is generally a bad idea since you do not know what you will get. It is better to import just the specific commands you need. For example, the command namespace import Blt::graph Blt::table imports only the graph and table commands into the current context. If you try to import a command that already exists, you will get an error. This prevents you from importing the same command from two different packages. But from time to time (perhaps when debugging), you may want to get around this restriction. You may want to reissue the namespace import command to pick up new commands that have appeared in a namespace. In that case, you can use the -force option, and existing commands will be silently overwritten: namespace import -force Blt::graph Blt::table If for some reason, you want to stop using the imported commands, you can remove them with a namespace forget command, like this: namespace forget Blt::* This searches the current namespace for any commands imported from Blt . If it finds any, it removes them. Otherwise, it does nothing. After this, the Blt commands must be accessed with the Blt:: prefix. When you delete a command from the exporting namespace like this: rename Blt::graph \\\"\\\" the command is automatically removed from all namespaces that import it. EXPORTING COMMANDS You can export commands from a namespace like this: namespace eval Counter { namespace export bump reset variable Num 0 variable Max 100 proc bump {{by 1}} { variable Num incr Num \\$by Check return \\$Num } proc reset {} { variable Num set Num 0 } proc Check {} { variable Num variable Max if {\\$Num > \\$Max} { error \\\"too high!\\\" } } } The procedures bump and reset are exported, so they are included when you import from the Counter namespace, like this: namespace import Counter::* However, the Check procedure is not exported, so it is ignored by the import operation. The namespace import command only imports commands that were declared as exported by their namespace. The namespace export command specifies what commands may be imported by other namespaces. If a namespace import command specifies a command that is not exported, the command is not imported. SCOPED SCRIPTS The namespace code command is the means by which a script may be packaged for evaluation in a namespace other than the one in which it was created. It is used most often to create event handlers, Tk bindings, and traces for evaluation in the global context. For instance, the following code indicates how to direct a variable trace callback into the current namespace: namespace eval a { variable b proc theTraceCallback { n1 n2 op } { upvar 1 \\$n1 var puts \\\"the value of \\$n1 has changed to \\$var\\\" return } trace add variable b write [ namespace code theTraceCallback] } set a::b c When executed, it prints the message: the value of a::b has changed to c ENSEMBLES The namespace ensemble is used to create and manipulate ensemble commands, which are commands formed by grouping subcommands together. The commands typically come from the current namespace when the ensemble was created, though this is configurable. Note that there may be any number of ensembles associated with any namespace (including none, which is true of all namespaces by default), though all the ensembles associated with a namespace are deleted when that namespace is deleted. The link between an ensemble command and its namespace is maintained however the ensemble is renamed. Three subcommands of the namespace ensemble command are defined: namespace ensemble create ? option value ... ? : Creates a new ensemble command linked to the current namespace, returning the fully qualified name of the command created. The arguments to namespace ensemble create allow the configuration of the command as if with the namespace ensemble configure command. If not overridden with the -command option, this command creates an ensemble with exactly the same name as the linked namespace. See the section ENSEMBLE OPTIONS below for a full list of options supported and their effects. namespace ensemble configure command ? option ? ? value ... ? : Retrieves the value of an option associated with the ensemble command named command , or updates some options associated with that ensemble command. See the section ENSEMBLE OPTIONS below for a full list of options supported and their effects. namespace ensemble exists command : Returns a boolean value that describes whether the command command exists and is an ensemble command. This command only ever returns an error if the number of arguments to the command is wrong. When called, an ensemble command takes its first argument and looks it up (according to the rules described below) to discover a list of words to replace the ensemble command and subcommand with. The resulting list of words is then evaluated (with no further substitutions) as if that was what was typed originally (i.e. by passing the list of words through Tcl_EvalObjv ) and returning the result of the command. Note that it is legal to make the target of an ensemble rewrite be another (or even the same) ensemble command. The ensemble command will not be visible through the use of the uplevel or info level commands. ENSEMBLE OPTIONS The following options, supported by the namespace ensemble create and namespace ensemble configure commands, control how an ensemble command behaves: -map : When non-empty, this option supplies a dictionary that provides a mapping from subcommand names to a list of prefix words to substitute in place of the ensemble command and subcommand words (in a manner similar to an alias created with interp alias ; the words are not reparsed after substitution); if the first word of any target is not fully qualified when set, it is assumed to be relative to the current namespace and changed to be exactly that (that is, it is always fully qualified when read). When this option is empty, the mapping will be from the local name of the subcommand to its fully-qualified name. Note that when this option is non-empty and the -subcommands option is empty, the ensemble subcommand names will be exactly those words that have mappings in the dictionary. -parameters : This option gives a list of named arguments (the names being used during generation of error messages) that are passed by the caller of the ensemble between the name of the ensemble and the subcommand argument. By default, it is the empty list. -prefixes : This option (which is enabled by default) controls whether the ensemble command recognizes unambiguous prefixes of its subcommands. When turned off, the ensemble command requires exact matching of subcommand names. -subcommands : When non-empty, this option lists exactly what subcommands are in the ensemble. The mapping for each of those commands will be either whatever is defined in the -map option, or to the command with the same name in the namespace linked to the ensemble. If this option is empty, the subcommands of the namespace will either be the keys of the dictionary listed in the -map option or the exported commands of the linked namespace at the time of the invocation of the ensemble command. -unknown : When non-empty, this option provides a partial command (to which all the words that are arguments to the ensemble command, including the fully-qualified name of the ensemble, are appended) to handle the case where an ensemble subcommand is not recognized and would otherwise generate an error. When empty (the default) an error (in the style of Tcl_GetIndexFromObj ) is generated whenever the ensemble is unable to determine how to implement a particular subcommand. See UNKNOWN HANDLER BEHAVIOUR for more details. The following extra option is allowed by namespace ensemble create: -command : This write-only option allows the name of the ensemble created by namespace ensemble create to be anything in any existing namespace. The default value for this option is the fully-qualified name of the namespace in which the namespace ensemble create command is invoked. The following extra option is allowed by namespace ensemble configure: -namespace : This read-only option allows the retrieval of the fully-qualified name of the namespace which the ensemble was created within. UNKNOWN HANDLER BEHAVIOUR If an unknown handler is specified for an ensemble, that handler is called when the ensemble command would otherwise return an error due to it being unable to decide which subcommand to invoke. The exact conditions under which that occurs are controlled by the -subcommands , -map and -prefixes options as described above. To execute the unknown handler, the ensemble mechanism takes the specified -unknown option and appends each argument of the attempted ensemble command invocation (including the ensemble command itself, expressed as a fully qualified name). It invokes the resulting command in the scope of the attempted call. If the execution of the unknown handler terminates normally, the ensemble engine reparses the subcommand (as described below) and tries to dispatch it again, which is ideal for when the ensemble\\'s configuration has been updated by the unknown subcommand handler. Any other kind of termination of the unknown handler is treated as an error. The result of the unknown handler is expected to be a list (it is an error if it is not). If the list is an empty list, the ensemble command attempts to look up the original subcommand again and, if it is not found this time, an error will be generated just as if the -unknown handler was not there (i.e. for any particular invocation of an ensemble, its unknown handler will be called at most once.) This makes it easy for the unknown handler to update the ensemble or its backing namespace so as to provide an implementation of the desired subcommand and reparse. When the result is a non-empty list, the words of that list are used to replace the ensemble command and subcommand, just as if they had been looked up in the -map . It is up to the unknown handler to supply all namespace qualifiers if the implementing subcommand is not in the namespace of the caller of the ensemble command. Also note that when ensemble commands are chained (e.g. if you make one of the commands that implement an ensemble subcommand into an ensemble, in a manner similar to the text widget\\'s tag and mark subcommands) then the rewrite happens in the context of the caller of the outermost ensemble. That is to say that ensembles do not in themselves place any namespace contexts on the Tcl call stack. Where an empty -unknown handler is given (the default), the ensemble command will generate an error message based on the list of commands that the ensemble has defined (formatted similarly to the error message from Tcl_GetIndexFromObj ). This is the error that will be thrown when the subcommand is still not recognized during reparsing. It is also an error for an -unknown handler to delete its namespace. EXAMPLES Create a namespace containing a variable and an exported command: namespace eval foo { variable bar 0 proc grill {} { variable bar puts \\\"called [incr bar] times\\\" } namespace export grill } Call the command defined in the previous example in various ways. # Direct call ::foo::grill # Use the command resolution path to find the name namespace eval boo { namespace path ::foo grill } # Import into current namespace, then call local alias namespace import foo::grill grill # Create two ensembles, one with the default name and one with a # specified name. Then call through the ensembles. namespace eval foo { namespace ensemble create namespace ensemble create -command ::foobar } foo grill foobar grill Look up where the command imported in the previous example came from: puts \\\"grill came from [ namespace origin grill]\\\" Remove all imported commands from the current namespace: namespace forget {*}[namespace import] Create an ensemble for simple working with numbers, using the -parameters option to allow the operator to be put between the first and second arguments. namespace eval do { namespace export * namespace ensemble create -parameters x proc plus {x y} {expr { \\$x + \\$y }} proc minus {x y} {expr { \\$x - \\$y }} } # In use, the ensemble works like this: puts [do 1 plus [do 9 minus 7]] SEE ALSO interp(n), upvar(n), variable(n) KEYWORDS command, ensemble, exported, internal, variable","title":"NAME"},{"location":"Namespace/#name","text":"namespace - create and manipulate contexts for commands and variables","title":"NAME"},{"location":"Namespace/#synopsis","text":"namespace ? subcommand ? ? arg ... ?","title":"SYNOPSIS"},{"location":"Namespace/#description","text":"The namespace command lets you create, access, and destroy separate contexts for commands and variables. See the section WHAT IS A NAMESPACE? below for a brief overview of namespaces. The legal values of subcommand are listed below. Note that you can abbreviate the subcommand s. namespace children ? namespace ? ? pattern ? : Returns a list of all child namespaces that belong to the namespace namespace . If namespace is not specified, then the children are returned for the current namespace. This command returns fully-qualified names, which start with a double colon ( :: ). If the optional pattern is given, then this command returns only the names that match the glob-style pattern. The actual pattern used is determined as follows: a pattern that starts with double colon ( :: ) is used directly, otherwise the namespace namespace (or the fully-qualified name of the current namespace) is prepended onto the pattern. namespace code script : Captures the current namespace context for later execution of the script script . It returns a new script in which script has been wrapped in a namespace inscope command. The new script has two important properties. First, it can be evaluated in any namespace and will cause script to be evaluated in the current namespace (the one where the namespace code command was invoked). Second, additional arguments can be appended to the resulting script and they will be passed to script as additional arguments. For example, suppose the command set script [namespace code {foo bar}] is invoked in namespace ::a::b . Then eval \\$script [list x y] can be executed in any namespace (assuming the value of script has been passed in properly) and will have the same effect as the command ::namespace eval ::a::b {foo bar x y} . This command is needed because extensions like Tk normally execute callback scripts in the global namespace. A scoped command captures a command together with its namespace context in a way that allows it to be executed properly later. See the section SCOPED SCRIPTS for some examples of how this is used to create callback scripts. namespace current : Returns the fully-qualified name for the current namespace. The actual name of the global namespace is (i.e., an empty string), but this command returns :: for the global namespace as a convenience to programmers. namespace delete ? namespace namespace ... ? : Each namespace namespace is deleted and all variables, procedures, and child namespaces contained in the namespace are deleted. If a procedure is currently executing inside the namespace, the namespace will be kept alive until the procedure returns; however, the namespace is marked to prevent other code from looking it up by name. If a namespace does not exist, this command returns an error. If no namespace names are given, this command does nothing. namespace ensemble subcommand ? arg ... ? : Creates and manipulates a command that is formed out of an ensemble of subcommands. See the section ENSEMBLES below for further details. namespace eval namespace arg ? arg ... ? : Activates a namespace called namespace and evaluates some code in that context. If the namespace does not already exist, it is created. If more than one arg argument is specified, the arguments are concatenated together with a space between each one in the same fashion as the eval command, and the result is evaluated. If *namespace* has leading namespace qualifiers and any leading namespaces do not exist, they are automatically created. namespace exists namespace : Returns 1 if namespace is a valid namespace in the current context, returns 0 otherwise. namespace export ? -clear ? ? pattern pattern ... ? : Specifies which commands are exported from a namespace. The exported commands are those that can be later imported into another namespace using a namespace import command. Both commands defined in a namespace and commands the namespace has previously imported can be exported by a namespace. The commands do not have to be defined at the time the namespace export command is executed. Each pattern may contain glob-style special characters, but it may not include any namespace qualifiers. That is, the pattern can only specify commands in the current (exporting) namespace. Each pattern is appended onto the namespace\\'s list of export patterns. If the -clear flag is given, the namespace\\'s export pattern list is reset to empty before any pattern arguments are appended. If no pattern s are given and the -clear flag is not given, this command returns the namespace\\'s current export list. namespace forget ? pattern pattern ... ? : Removes previously imported commands from a namespace. Each pattern is a simple or qualified name such as x , foo::x or a::b::p* . Qualified names contain double colons ( :: ) and qualify a name with the name of one or more namespaces. Each is qualified with the name of an exporting namespace and may have glob-style special characters in the command name at the end of the qualified name. Glob characters may not appear in a namespace name. For each this command deletes the matching commands of the current namespace that were imported from a different namespace. For this command first finds the matching exported commands. It then checks whether any of those commands were previously imported by the current namespace. If so, this command deletes the corresponding imported commands. In effect, this undoes the action of a namespace import command. namespace import ? -force ? ? pattern pattern ... ? : Imports commands into a namespace, or queries the set of imported commands in a namespace. When no arguments are present, namespace import returns the list of commands in the current namespace that have been imported from other namespaces. The commands in the returned list are in the format of simple names, with no namespace qualifiers at all. This format is suitable for composition with namespace forget (see EXAMPLES below). When *pattern* arguments are present, each *pattern* is a qualified name like **foo::x** or **a::p\\***. That is, it includes the name of an exporting namespace and may have glob-style special characters in the command name at the end of the qualified name. Glob characters may not appear in a namespace name. When the namespace name is not fully qualified (i.e., does not start with a namespace separator) it is resolved as a namespace name in the way described in the **NAME RESOLUTION** section; it is an error if no namespace with that name can be found. All the commands that match a *pattern* string and which are currently exported from their namespace are added to the current namespace. This is done by creating a new command in the current namespace that points to the exported command in its original namespace; when the new imported command is called, it invokes the exported command. This command normally returns an error if an imported command conflicts with an existing command. However, if the **-force** option is given, imported commands will silently replace existing commands. The **namespace import** command has snapshot semantics: that is, only requested commands that are currently defined in the exporting namespace are imported. In other words, you can import only the commands that are in a namespace at the time when the **namespace import** command is executed. If another command is defined and exported in this namespace later on, it will not be imported. namespace inscope namespace script ? arg ... ? : Executes a script in the context of the specified namespace . This command is not expected to be used directly by programmers; calls to it are generated implicitly when applications use namespace code commands to create callback scripts that the applications then register with, e.g., Tk widgets. The namespace inscope command is much like the namespace eval command except that the namespace must already exist, and namespace inscope appends additional arg s as proper list elements. **namespace inscope ::foo \\$script \\$x \\$y \\$z** is equivalent to **namespace eval ::foo \\[concat \\$script \\[list \\$x \\$y \\$z\\]\\]** thus additional arguments will not undergo a second round of substitution, as is the case with **namespace eval**. namespace origin command : Returns the fully-qualified name of the original command to which the imported command command refers. When a command is imported into a namespace, a new command is created in that namespace that points to the actual command in the exporting namespace. If a command is imported into a sequence of namespaces a, b,...,n where each successive namespace just imports the command from the previous namespace, this command returns the fully-qualified name of the original command in the first namespace, a . If command does not refer to an imported command, the command\\'s own fully-qualified name is returned. namespace parent ? namespace ? : Returns the fully-qualified name of the parent namespace for namespace namespace . If namespace is not specified, the fully-qualified name of the current namespace\\'s parent is returned. namespace path ? namespaceList ? : Returns the command resolution path of the current namespace. If namespaceList is specified as a list of named namespaces, the current namespace\\'s command resolution path is set to those namespaces and returns the empty list. The default command resolution path is always empty. See the section NAME RESOLUTION below for an explanation of the rules regarding name resolution. namespace qualifiers string : Returns any leading namespace qualifiers for string . Qualifiers are namespace names separated by double colons ( :: ). For the string ::foo::bar::x , this command returns ::foo::bar , and for :: it returns an empty string. This command is the complement of the namespace tail command. Note that it does not check whether the namespace names are, in fact, the names of currently defined namespaces. namespace tail string : Returns the simple name at the end of a qualified string. Qualifiers are namespace names separated by double colons ( :: ). For the string ::foo::bar::x , this command returns x , and for :: it returns an empty string. This command is the complement of the namespace qualifiers command. It does not check whether the namespace names are, in fact, the names of currently defined namespaces. namespace upvar namespace ? otherVar myVar ...? : This command arranges for zero or more local variables in the current procedure to refer to variables in namespace . The namespace name is resolved as described in section NAME RESOLUTION . The command namespace upvar \\$ns a b has the same behaviour as upvar 0 \\${ns}::a b , with the sole exception of the resolution rules used for qualified namespace or variable names. namespace upvar returns an empty string. namespace unknown ? script ? : Sets or returns the unknown command handler for the current namespace. The handler is invoked when a command called from within the namespace cannot be found in the current namespace, the namespace\\'s path nor in the global namespace. The script argument, if given, should be a well formed list representing a command name and optional arguments. When the handler is invoked, the full invocation line will be appended to the script and the result evaluated in the context of the namespace. The default handler for all namespaces is ::unknown . If no argument is given, it returns the handler for the current namespace. namespace which ? -command ? ? -variable ? name : Looks up name as either a command or variable and returns its fully-qualified name. For example, if name does not exist in the current namespace but does exist in the global namespace, this command returns a fully-qualified name in the global namespace. If the command or variable does not exist, this command returns an empty string. If the variable has been created but not defined, such as with the variable command or through a trace on the variable, this command will return the fully-qualified name of the variable. If no flag is given, name is treated as a command name. See the section NAME RESOLUTION below for an explanation of the rules regarding name resolution.","title":"DESCRIPTION"},{"location":"Namespace/#what-is-a-namespace","text":"A namespace is a collection of commands and variables. It encapsulates the commands and variables to ensure that they will not interfere with the commands and variables of other namespaces. Tcl has always had one such collection, which we refer to as the global namespace . The global namespace holds all global variables and commands. The namespace eval command lets you create new namespaces. For example, namespace eval Counter { namespace export bump variable num 0 proc bump {} { variable num incr num } } creates a new namespace containing the variable num and the procedure bump . The commands and variables in this namespace are separate from other commands and variables in the same program. If there is a command named bump in the global namespace, for example, it will be different from the command bump in the Counter namespace. Namespace variables resemble global variables in Tcl. They exist outside of the procedures in a namespace but can be accessed in a procedure via the variable command, as shown in the example above. Namespaces are dynamic. You can add and delete commands and variables at any time, so you can build up the contents of a namespace over time using a series of namespace eval commands. For example, the following series of commands has the same effect as the namespace definition shown above: namespace eval Counter { variable num 0 proc bump {} { variable num return [incr num] } } namespace eval Counter { proc test {args} { return \\$args } } namespace eval Counter { rename test \\\"\\\" } Note that the test procedure is added to the Counter namespace, and later removed via the rename command. Namespaces can have other namespaces within them, so they nest hierarchically. A nested namespace is encapsulated inside its parent namespace and can not interfere with other namespaces.","title":"WHAT IS A NAMESPACE?"},{"location":"Namespace/#qualified-names","text":"Each namespace has a textual name such as history or ::safe::interp . Since namespaces may nest, qualified names are used to refer to commands, variables, and child namespaces contained inside namespaces. Qualified names are similar to the hierarchical path names for Unix files or Tk widgets, except that :: is used as the separator instead of / or . . The topmost or global namespace has the name (i.e., an empty string), although :: is a synonym. As an example, the name ::safe::interp::create refers to the command create in the namespace interp that is a child of namespace ::safe , which in turn is a child of the global namespace, :: . If you want to access commands and variables from another namespace, you must use some extra syntax. Names must be qualified by the namespace that contains them. From the global namespace, we might access the Counter procedures like this: Counter::bump 5 Counter::Reset We could access the current count like this: puts \\\"count = \\$Counter::num\\\" When one namespace contains another, you may need more than one qualifier to reach its elements. If we had a namespace Foo that contained the namespace Counter , you could invoke its bump procedure from the global namespace like this: Foo::Counter::bump 3 You can also use qualified names when you create and rename commands. For example, you could add a procedure to the Foo namespace like this: proc Foo::Test {args} {return \\$args} And you could move the same procedure to another namespace like this: rename Foo::Test Bar::Test There are a few remaining points about qualified names that we should cover. Namespaces have nonempty names except for the global namespace. :: is disallowed in simple command, variable, and namespace names except as a namespace separator. Extra colons in any separator part of a qualified name are ignored; i.e. two or more colons are treated as a namespace separator. A trailing :: in a qualified variable or command name refers to the variable or command named {}. However, a trailing :: in a qualified namespace name is ignored.","title":"QUALIFIED NAMES"},{"location":"Namespace/#name-resolution","text":"In general, all Tcl commands that take variable and command names support qualified names. This means you can give qualified names to such commands as set , proc , rename , and interp alias . If you provide a fully-qualified name that starts with a :: , there is no question about what command, variable, or namespace you mean. However, if the name does not start with a :: (i.e., is relative ), Tcl follows basic rules for looking it up: Variable names are always resolved by looking first in the current namespace, and then in the global namespace. Command names are always resolved by looking in the current namespace first. If not found there, they are searched for in every namespace on the current namespace\\'s command path (which is empty by default). If not found there, command names are looked up in the global namespace (or, failing that, are processed by the appropriate namespace unknown handler.) Namespace names are always resolved by looking in only the current namespace. In the following example, set traceLevel 0 namespace eval Debug { printTrace \\$traceLevel } Tcl looks for traceLevel in the namespace Debug and then in the global namespace. It looks up the command printTrace in the same way. If a variable or command name is not found in either context, the name is undefined. To make this point absolutely clear, consider the following example: set traceLevel 0 namespace eval Foo { variable traceLevel 3 namespace eval Debug { printTrace \\$traceLevel } } Here Tcl looks for traceLevel first in the namespace Foo::Debug . Since it is not found there, Tcl then looks for it in the global namespace. The variable Foo::traceLevel is completely ignored during the name resolution process. You can use the namespace which command to clear up any question about name resolution. For example, the command: namespace eval Foo::Debug { namespace which -variable traceLevel} returns ::traceLevel . On the other hand, the command, namespace eval Foo { namespace which -variable traceLevel} returns ::Foo::traceLevel . As mentioned above, namespace names are looked up differently than the names of variables and commands. Namespace names are always resolved in the current namespace. This means, for example, that a namespace eval command that creates a new namespace always creates a child of the current namespace unless the new namespace name begins with :: . Tcl has no access control to limit what variables, commands, or namespaces you can reference. If you provide a qualified name that resolves to an element by the name resolution rule above, you can access the element. You can access a namespace variable from a procedure in the same namespace by using the variable command. Much like the global command, this creates a local link to the namespace variable. If necessary, it also creates the variable in the current namespace and initializes it. Note that the global command only creates links to variables in the global namespace. It is not necessary to use a variable command if you always refer to the namespace variable using an appropriate qualified name.","title":"NAME RESOLUTION"},{"location":"Namespace/#importing-commands","text":"Namespaces are often used to represent libraries. Some library commands are used so frequently that it is a nuisance to type their qualified names. For example, suppose that all of the commands in a package like BLT are contained in a namespace called Blt . Then you might access these commands like this: Blt::graph .g -background red Blt::table . .g 0,0 If you use the graph and table commands frequently, you may want to access them without the Blt:: prefix. You can do this by importing the commands into the current namespace, like this: namespace import Blt::* This adds all exported commands from the Blt namespace into the current namespace context, so you can write code like this: graph .g -background red table . .g 0,0 The namespace import command only imports commands from a namespace that that namespace exported with a namespace export command. Importing every command from a namespace is generally a bad idea since you do not know what you will get. It is better to import just the specific commands you need. For example, the command namespace import Blt::graph Blt::table imports only the graph and table commands into the current context. If you try to import a command that already exists, you will get an error. This prevents you from importing the same command from two different packages. But from time to time (perhaps when debugging), you may want to get around this restriction. You may want to reissue the namespace import command to pick up new commands that have appeared in a namespace. In that case, you can use the -force option, and existing commands will be silently overwritten: namespace import -force Blt::graph Blt::table If for some reason, you want to stop using the imported commands, you can remove them with a namespace forget command, like this: namespace forget Blt::* This searches the current namespace for any commands imported from Blt . If it finds any, it removes them. Otherwise, it does nothing. After this, the Blt commands must be accessed with the Blt:: prefix. When you delete a command from the exporting namespace like this: rename Blt::graph \\\"\\\" the command is automatically removed from all namespaces that import it.","title":"IMPORTING COMMANDS"},{"location":"Namespace/#exporting-commands","text":"You can export commands from a namespace like this: namespace eval Counter { namespace export bump reset variable Num 0 variable Max 100 proc bump {{by 1}} { variable Num incr Num \\$by Check return \\$Num } proc reset {} { variable Num set Num 0 } proc Check {} { variable Num variable Max if {\\$Num > \\$Max} { error \\\"too high!\\\" } } } The procedures bump and reset are exported, so they are included when you import from the Counter namespace, like this: namespace import Counter::* However, the Check procedure is not exported, so it is ignored by the import operation. The namespace import command only imports commands that were declared as exported by their namespace. The namespace export command specifies what commands may be imported by other namespaces. If a namespace import command specifies a command that is not exported, the command is not imported.","title":"EXPORTING COMMANDS"},{"location":"Namespace/#scoped-scripts","text":"The namespace code command is the means by which a script may be packaged for evaluation in a namespace other than the one in which it was created. It is used most often to create event handlers, Tk bindings, and traces for evaluation in the global context. For instance, the following code indicates how to direct a variable trace callback into the current namespace: namespace eval a { variable b proc theTraceCallback { n1 n2 op } { upvar 1 \\$n1 var puts \\\"the value of \\$n1 has changed to \\$var\\\" return } trace add variable b write [ namespace code theTraceCallback] } set a::b c When executed, it prints the message: the value of a::b has changed to c","title":"SCOPED SCRIPTS"},{"location":"Namespace/#ensembles","text":"The namespace ensemble is used to create and manipulate ensemble commands, which are commands formed by grouping subcommands together. The commands typically come from the current namespace when the ensemble was created, though this is configurable. Note that there may be any number of ensembles associated with any namespace (including none, which is true of all namespaces by default), though all the ensembles associated with a namespace are deleted when that namespace is deleted. The link between an ensemble command and its namespace is maintained however the ensemble is renamed. Three subcommands of the namespace ensemble command are defined: namespace ensemble create ? option value ... ? : Creates a new ensemble command linked to the current namespace, returning the fully qualified name of the command created. The arguments to namespace ensemble create allow the configuration of the command as if with the namespace ensemble configure command. If not overridden with the -command option, this command creates an ensemble with exactly the same name as the linked namespace. See the section ENSEMBLE OPTIONS below for a full list of options supported and their effects. namespace ensemble configure command ? option ? ? value ... ? : Retrieves the value of an option associated with the ensemble command named command , or updates some options associated with that ensemble command. See the section ENSEMBLE OPTIONS below for a full list of options supported and their effects. namespace ensemble exists command : Returns a boolean value that describes whether the command command exists and is an ensemble command. This command only ever returns an error if the number of arguments to the command is wrong. When called, an ensemble command takes its first argument and looks it up (according to the rules described below) to discover a list of words to replace the ensemble command and subcommand with. The resulting list of words is then evaluated (with no further substitutions) as if that was what was typed originally (i.e. by passing the list of words through Tcl_EvalObjv ) and returning the result of the command. Note that it is legal to make the target of an ensemble rewrite be another (or even the same) ensemble command. The ensemble command will not be visible through the use of the uplevel or info level commands.","title":"ENSEMBLES"},{"location":"Namespace/#ensemble-options","text":"The following options, supported by the namespace ensemble create and namespace ensemble configure commands, control how an ensemble command behaves: -map : When non-empty, this option supplies a dictionary that provides a mapping from subcommand names to a list of prefix words to substitute in place of the ensemble command and subcommand words (in a manner similar to an alias created with interp alias ; the words are not reparsed after substitution); if the first word of any target is not fully qualified when set, it is assumed to be relative to the current namespace and changed to be exactly that (that is, it is always fully qualified when read). When this option is empty, the mapping will be from the local name of the subcommand to its fully-qualified name. Note that when this option is non-empty and the -subcommands option is empty, the ensemble subcommand names will be exactly those words that have mappings in the dictionary. -parameters : This option gives a list of named arguments (the names being used during generation of error messages) that are passed by the caller of the ensemble between the name of the ensemble and the subcommand argument. By default, it is the empty list. -prefixes : This option (which is enabled by default) controls whether the ensemble command recognizes unambiguous prefixes of its subcommands. When turned off, the ensemble command requires exact matching of subcommand names. -subcommands : When non-empty, this option lists exactly what subcommands are in the ensemble. The mapping for each of those commands will be either whatever is defined in the -map option, or to the command with the same name in the namespace linked to the ensemble. If this option is empty, the subcommands of the namespace will either be the keys of the dictionary listed in the -map option or the exported commands of the linked namespace at the time of the invocation of the ensemble command. -unknown : When non-empty, this option provides a partial command (to which all the words that are arguments to the ensemble command, including the fully-qualified name of the ensemble, are appended) to handle the case where an ensemble subcommand is not recognized and would otherwise generate an error. When empty (the default) an error (in the style of Tcl_GetIndexFromObj ) is generated whenever the ensemble is unable to determine how to implement a particular subcommand. See UNKNOWN HANDLER BEHAVIOUR for more details. The following extra option is allowed by namespace ensemble create: -command : This write-only option allows the name of the ensemble created by namespace ensemble create to be anything in any existing namespace. The default value for this option is the fully-qualified name of the namespace in which the namespace ensemble create command is invoked. The following extra option is allowed by namespace ensemble configure: -namespace : This read-only option allows the retrieval of the fully-qualified name of the namespace which the ensemble was created within.","title":"ENSEMBLE OPTIONS"},{"location":"Namespace/#unknown-handler-behaviour","text":"If an unknown handler is specified for an ensemble, that handler is called when the ensemble command would otherwise return an error due to it being unable to decide which subcommand to invoke. The exact conditions under which that occurs are controlled by the -subcommands , -map and -prefixes options as described above. To execute the unknown handler, the ensemble mechanism takes the specified -unknown option and appends each argument of the attempted ensemble command invocation (including the ensemble command itself, expressed as a fully qualified name). It invokes the resulting command in the scope of the attempted call. If the execution of the unknown handler terminates normally, the ensemble engine reparses the subcommand (as described below) and tries to dispatch it again, which is ideal for when the ensemble\\'s configuration has been updated by the unknown subcommand handler. Any other kind of termination of the unknown handler is treated as an error. The result of the unknown handler is expected to be a list (it is an error if it is not). If the list is an empty list, the ensemble command attempts to look up the original subcommand again and, if it is not found this time, an error will be generated just as if the -unknown handler was not there (i.e. for any particular invocation of an ensemble, its unknown handler will be called at most once.) This makes it easy for the unknown handler to update the ensemble or its backing namespace so as to provide an implementation of the desired subcommand and reparse. When the result is a non-empty list, the words of that list are used to replace the ensemble command and subcommand, just as if they had been looked up in the -map . It is up to the unknown handler to supply all namespace qualifiers if the implementing subcommand is not in the namespace of the caller of the ensemble command. Also note that when ensemble commands are chained (e.g. if you make one of the commands that implement an ensemble subcommand into an ensemble, in a manner similar to the text widget\\'s tag and mark subcommands) then the rewrite happens in the context of the caller of the outermost ensemble. That is to say that ensembles do not in themselves place any namespace contexts on the Tcl call stack. Where an empty -unknown handler is given (the default), the ensemble command will generate an error message based on the list of commands that the ensemble has defined (formatted similarly to the error message from Tcl_GetIndexFromObj ). This is the error that will be thrown when the subcommand is still not recognized during reparsing. It is also an error for an -unknown handler to delete its namespace.","title":"UNKNOWN HANDLER BEHAVIOUR"},{"location":"Namespace/#examples","text":"Create a namespace containing a variable and an exported command: namespace eval foo { variable bar 0 proc grill {} { variable bar puts \\\"called [incr bar] times\\\" } namespace export grill } Call the command defined in the previous example in various ways. # Direct call ::foo::grill # Use the command resolution path to find the name namespace eval boo { namespace path ::foo grill } # Import into current namespace, then call local alias namespace import foo::grill grill # Create two ensembles, one with the default name and one with a # specified name. Then call through the ensembles. namespace eval foo { namespace ensemble create namespace ensemble create -command ::foobar } foo grill foobar grill Look up where the command imported in the previous example came from: puts \\\"grill came from [ namespace origin grill]\\\" Remove all imported commands from the current namespace: namespace forget {*}[namespace import] Create an ensemble for simple working with numbers, using the -parameters option to allow the operator to be put between the first and second arguments. namespace eval do { namespace export * namespace ensemble create -parameters x proc plus {x y} {expr { \\$x + \\$y }} proc minus {x y} {expr { \\$x - \\$y }} } # In use, the ensemble works like this: puts [do 1 plus [do 9 minus 7]]","title":"EXAMPLES"},{"location":"Namespace/#see-also","text":"interp(n), upvar(n), variable(n)","title":"SEE ALSO"},{"location":"Namespace/#keywords","text":"command, ensemble, exported, internal, variable","title":"KEYWORDS"},{"location":"Notifier/","text":"NAME Tcl_CreateEventSource, Tcl_DeleteEventSource, Tcl_SetMaxBlockTime, Tcl_QueueEvent, Tcl_ThreadQueueEvent, Tcl_ThreadAlert, Tcl_GetCurrentThread, Tcl_DeleteEvents, Tcl_InitNotifier, Tcl_FinalizeNotifier, Tcl_WaitForEvent, Tcl_AlertNotifier, Tcl_SetTimer, Tcl_ServiceAll, Tcl_ServiceEvent, Tcl_GetServiceMode, Tcl_SetServiceMode, Tcl_ServiceModeHook, Tcl_SetNotifier - the event queue and notifier interfaces SYNOPSIS #include <tcl.h> void Tcl_CreateEventSource(setupProc, checkProc, clientData) void Tcl_DeleteEventSource(setupProc, checkProc, clientData) void Tcl_SetMaxBlockTime(timePtr) void Tcl_QueueEvent(evPtr, position) void Tcl_ThreadQueueEvent(threadId, evPtr, position) void Tcl_ThreadAlert(threadId) Tcl_ThreadId Tcl_GetCurrentThread() void Tcl_DeleteEvents(deleteProc, clientData) void * Tcl_InitNotifier() void Tcl_FinalizeNotifier(clientData) int Tcl_WaitForEvent(timePtr) void Tcl_AlertNotifier(clientData) void Tcl_SetTimer(timePtr) int Tcl_ServiceAll() int Tcl_ServiceEvent(flags) int Tcl_GetServiceMode() int Tcl_SetServiceMode(mode) void Tcl_ServiceModeHook(mode) void Tcl_SetNotifier(notifierProcPtr) ARGUMENTS Procedure to invoke to prepare for event wait in Tcl_DoOneEvent . Procedure for Tcl_DoOneEvent to invoke after waiting for events. Checks to see if any events have occurred and, if so, queues them. Arbitrary one-word value to pass to setupProc , checkProc , or deleteProc . Indicates the maximum amount of time to wait for an event. This is specified as an interval (how long to wait), not an absolute time (when to wakeup). If the pointer passed to Tcl_WaitForEvent is NULL, it means there is no maximum wait time: wait forever if necessary. An event to add to the event queue. The storage for the event must have been allocated by the caller using Tcl_Alloc . Where to add the new event in the queue: TCL_QUEUE_TAIL , TCL_QUEUE_HEAD , TCL_QUEUE_MARK , and whether to do an alert if the queue is empty: TCL_QUEUE_ALERT_IF_EMPTY . A unique identifier for a thread. Procedure to invoke for each queued event in Tcl_DeleteEvents . What types of events to service. These flags are the same as those passed to Tcl_DoOneEvent . Indicates whether events should be serviced by Tcl_ServiceAll . Must be one of TCL_SERVICE_NONE or TCL_SERVICE_ALL . Structure of function pointers describing notifier procedures that are to replace the ones installed in the executable. See REPLACING THE NOTIFIER for details. INTRODUCTION The interfaces described here are used to customize the Tcl event loop. The two most common customizations are to add new sources of events and to merge Tcl\\'s event loop with some other event loop, such as one provided by an application in which Tcl is embedded. Each of these tasks is described in a separate section below. The procedures in this manual entry are the building blocks out of which the Tcl event notifier is constructed. The event notifier is the lowest layer in the Tcl event mechanism. It consists of three things: [1] : Event sources: these represent the ways in which events can be generated. For example, there is a timer event source that implements the Tcl_CreateTimerHandler procedure and the after command, and there is a file event source that implements the Tcl_CreateFileHandler procedure on Unix systems. An event source must work with the notifier to detect events at the right times, record them on the event queue, and eventually notify higher-level software that they have occurred. The procedures Tcl_CreateEventSource , Tcl_DeleteEventSource , and Tcl_SetMaxBlockTime , Tcl_QueueEvent , and Tcl_DeleteEvents are used primarily by event sources. [2] : The event queue: there is a single queue for each thread containing a Tcl interpreter, containing events that have been detected but not yet serviced. Event sources place events onto the queue so that they may be processed in order at appropriate times during the event loop. The event queue guarantees a fair discipline of event handling, so that no event source can starve the others. It also allows events to be saved for servicing at a future time. Tcl_QueueEvent is used (primarily by event sources) to add events to the current thread\\'s event queue and Tcl_DeleteEvents is used to remove events from the queue without processing them. [3] : The event loop: in order to detect and process events, the application enters a loop that waits for events to occur, places them on the event queue, and then processes them. Most applications will do this by calling the procedure Tcl_DoOneEvent , which is described in a separate manual entry. Most Tcl applications need not worry about any of the internals of the Tcl notifier. However, the notifier now has enough flexibility to be retargeted either for a new platform or to use an external event loop (such as the Motif event loop, when Tcl is embedded in a Motif application). The procedures Tcl_WaitForEvent and Tcl_SetTimer are normally implemented by Tcl, but may be replaced with new versions to retarget the notifier (the Tcl_InitNotifier , Tcl_AlertNotifier , Tcl_FinalizeNotifier , Tcl_Sleep , Tcl_CreateFileHandler , and Tcl_DeleteFileHandler must also be replaced; see CREATING A NEW NOTIFIER below for details). The procedures Tcl_ServiceAll , Tcl_ServiceEvent , Tcl_GetServiceMode , and Tcl_SetServiceMode are provided to help connect Tcl\\'s event loop to an external event loop such as Motif\\'s. NOTIFIER BASICS The easiest way to understand how the notifier works is to consider what happens when Tcl_DoOneEvent is called. Tcl_DoOneEvent is passed a flags argument that indicates what sort of events it is OK to process and also whether or not to block if no events are ready. Tcl_DoOneEvent does the following things: [1] : Check the event queue to see if it contains any events that can be serviced. If so, service the first possible event, remove it from the queue, and return. It does this by calling Tcl_ServiceEvent and passing in the flags argument. [2] : Prepare to block for an event. To do this, Tcl_DoOneEvent invokes a setup procedure in each event source. The event source will perform event-source specific initialization and possibly call Tcl_SetMaxBlockTime to limit how long Tcl_WaitForEvent will block if no new events occur. [3] : Call Tcl_WaitForEvent . This procedure is implemented differently on different platforms; it waits for an event to occur, based on the information provided by the event sources. It may cause the application to block if timePtr specifies an interval other than 0. Tcl_WaitForEvent returns when something has happened, such as a file becoming readable or the interval given by timePtr expiring. If there are no events for Tcl_WaitForEvent to wait for, so that it would block forever, then it returns immediately and Tcl_DoOneEvent returns 0. [4] : Call a check procedure in each event source. The check procedure determines whether any events of interest to this source occurred. If so, the events are added to the event queue. [5] : Check the event queue to see if it contains any events that can be serviced. If so, service the first possible event, remove it from the queue, and return. [6] : See if there are idle callbacks pending. If so, invoke all of them and return. [7] : Either return 0 to indicate that no events were ready, or go back to step [2] if blocking was requested by the caller. CREATING A NEW EVENT SOURCE An event source consists of three procedures invoked by the notifier, plus additional C procedures that are invoked by higher-level code to arrange for event-driven callbacks. The three procedures called by the notifier consist of the setup and check procedures described above, plus an additional procedure that is invoked when an event is removed from the event queue for servicing. The procedure Tcl_CreateEventSource creates a new event source. Its arguments specify the setup procedure and check procedure for the event source. SetupProc should match the following prototype: typedef void Tcl_EventSetupProc ( void * clientData , int flags ); The clientData argument will be the same as the clientData argument to Tcl_CreateEventSource ; it is typically used to point to private information managed by the event source. The flags argument will be the same as the flags argument passed to Tcl_DoOneEvent except that it will never be 0 ( Tcl_DoOneEvent replaces 0 with TCL_ALL_EVENTS ). Flags indicates what kinds of events should be considered; if the bit corresponding to this event source is not set, the event source should return immediately without doing anything. For example, the file event source checks for the TCL_FILE_EVENTS bit. SetupProc \\'s job is to make sure that the application wakes up when events of the desired type occur. This is typically done in a platform-dependent fashion. For example, under Unix an event source might call Tcl_CreateFileHandler ; under Windows it might request notification with a Windows event. For timer-driven event sources such as timer events or any polled event, the event source can call Tcl_SetMaxBlockTime to force the application to wake up after a specified time even if no events have occurred. If no event source calls Tcl_SetMaxBlockTime then Tcl_WaitForEvent will wait as long as necessary for an event to occur; otherwise, it will only wait as long as the shortest interval passed to Tcl_SetMaxBlockTime by one of the event sources. If an event source knows that it already has events ready to report, it can request a zero maximum block time. For example, the setup procedure for the X event source looks to see if there are events already queued. If there are, it calls Tcl_SetMaxBlockTime with a 0 block time so that Tcl_WaitForEvent does not block if there is no new data on the X connection. The timePtr argument to Tcl_WaitForEvent points to a structure that describes a time interval in seconds and microseconds: typedef struct Tcl_Time { long sec ; long usec ; } Tcl_Time ; The usec field should be less than 1000000. Information provided to Tcl_SetMaxBlockTime is only used for the next call to Tcl_WaitForEvent ; it is discarded after Tcl_WaitForEvent returns. The next time an event wait is done each of the event sources\\' setup procedures will be called again, and they can specify new information for that event wait. If the application uses an external event loop rather than Tcl_DoOneEvent , the event sources may need to call Tcl_SetMaxBlockTime at other times. For example, if a new event handler is registered that needs to poll for events, the event source may call Tcl_SetMaxBlockTime to set the block time to zero to force the external event loop to call Tcl. In this case, Tcl_SetMaxBlockTime invokes Tcl_SetTimer with the shortest interval seen since the last call to Tcl_DoOneEvent or Tcl_ServiceAll . In addition to the generic procedure Tcl_SetMaxBlockTime , other platform-specific procedures may also be available for setupProc , if there is additional information needed by Tcl_WaitForEvent on that platform. For example, on Unix systems the Tcl_CreateFileHandler interface can be used to wait for file events. The second procedure provided by each event source is its check procedure, indicated by the checkProc argument to Tcl_CreateEventSource . CheckProc must match the following prototype: typedef void Tcl_EventCheckProc ( void * clientData , int flags ); The arguments to this procedure are the same as those for setupProc . CheckProc is invoked by Tcl_DoOneEvent after it has waited for events. Presumably at least one event source is now prepared to queue an event. Tcl_DoOneEvent calls each of the event sources in turn, so they all have a chance to queue any events that are ready. The check procedure does two things. First, it must see if any events have triggered. Different event sources do this in different ways. If an event source\\'s check procedure detects an interesting event, it must add the event to Tcl\\'s event queue. To do this, the event source calls Tcl_QueueEvent . The evPtr argument is a pointer to a dynamically allocated structure containing the event (see below for more information on memory management issues). Each event source can define its own event structure with whatever information is relevant to that event source. However, the first element of the structure must be a structure of type Tcl_Event , and the address of this structure is used when communicating between the event source and the rest of the notifier. A Tcl_Event has the following definition: typedef struct { Tcl_EventProc * proc ; struct Tcl_Event * nextPtr ; } Tcl_Event ; The event source must fill in the proc field of the event before calling Tcl_QueueEvent . The nextPtr is used to link together the events in the queue and should not be modified by the event source. An event may be added to the queue at any of three positions, depending on the position argument to Tcl_QueueEvent : TCL_QUEUE_TAIL : Add the event at the back of the queue, so that all other pending events will be serviced first. This is almost always the right place for new events. TCL_QUEUE_HEAD : Add the event at the front of the queue, so that it will be serviced before all other queued events. TCL_QUEUE_MARK : Add the event at the front of the queue, unless there are other events at the front whose position is TCL_QUEUE_MARK ; if so, add the new event just after all other TCL_QUEUE_MARK events. This value of position is used to insert an ordered sequence of events at the front of the queue, such as a series of Enter and Leave events synthesized during a grab or ungrab operation in Tk. TCL_QUEUE_ALERT_IF_EMPTY : When used in Tcl_ThreadQueueEvent arranges for an automatic call of Tcl_ThreadAlert when the queue was empty. When it is time to handle an event from the queue (steps 1 and 4 above) Tcl_ServiceEvent will invoke the proc specified in the first queued Tcl_Event structure. Proc must match the following prototype: typedef int Tcl_EventProc ( Tcl_Event * evPtr , int flags ); The first argument to proc is a pointer to the event, which will be the same as the first argument to the Tcl_QueueEvent call that added the event to the queue. The second argument to proc is the flags argument for the current call to Tcl_ServiceEvent ; this is used by the event source to return immediately if its events are not relevant. It is up to proc to handle the event, typically by invoking one or more Tcl commands or C-level callbacks. Once the event source has finished handling the event it returns 1 to indicate that the event can be removed from the queue. If for some reason the event source decides that the event cannot be handled at this time, it may return 0 to indicate that the event should be deferred for processing later; in this case Tcl_ServiceEvent will go on to the next event in the queue and attempt to service it. There are several reasons why an event source might defer an event. One possibility is that events of this type are excluded by the flags argument. For example, the file event source will always return 0 if the TCL_FILE_EVENTS bit is not set in flags . Another example of deferring events happens in Tk if Tk_RestrictEvents has been invoked to defer certain kinds of window events. When proc returns 1, Tcl_ServiceEvent will remove the event from the event queue and free its storage. Note that the storage for an event must be allocated by the event source (using Tcl_Alloc ) before calling Tcl_QueueEvent , but it will be freed by Tcl_ServiceEvent , not by the event source. Calling Tcl_QueueEvent adds an event to the current thread\\'s queue. To add an event to another thread\\'s queue, use Tcl_ThreadQueueEvent . Tcl_ThreadQueueEvent accepts as an argument a Tcl_ThreadId argument, which uniquely identifies a thread in a Tcl application. To obtain the Tcl_ThreadId for the current thread, use the Tcl_GetCurrentThread procedure. (A thread would then need to pass this identifier to other threads for those threads to be able to add events to its queue.) After adding an event to another thread\\'s queue, you then typically need to call Tcl_ThreadAlert to that thread\\'s notifier to alert it to the new event. Tcl_DeleteEvents can be used to explicitly remove one or more events from the event queue. Tcl_DeleteEvents calls proc for each event in the queue, deleting those for with the procedure returns 1. Events for which the procedure returns 0 are left in the queue. Proc should match the following prototype: typedef int Tcl_EventDeleteProc ( Tcl_Event * evPtr , void * clientData ); The clientData argument will be the same as the clientData argument to Tcl_DeleteEvents ; it is typically used to point to private information managed by the event source. The evPtr will point to the next event in the queue. Tcl_DeleteEventSource deletes an event source. The setupProc , checkProc , and clientData arguments must exactly match those provided to the Tcl_CreateEventSource for the event source to be deleted. If no such source exists, Tcl_DeleteEventSource has no effect. CREATING A NEW NOTIFIER The notifier consists of all the procedures described in this manual entry, plus Tcl_DoOneEvent and Tcl_Sleep , which are available on all platforms, and Tcl_CreateFileHandler and Tcl_DeleteFileHandler , which are Unix-specific. Most of these procedures are generic, in that they are the same for all notifiers. However, none of the procedures are notifier-dependent: Tcl_InitNotifier , Tcl_AlertNotifier , Tcl_FinalizeNotifier , Tcl_SetTimer , Tcl_Sleep , Tcl_WaitForEvent , Tcl_CreateFileHandler , Tcl_DeleteFileHandler and Tcl_ServiceModeHook . To support a new platform or to integrate Tcl with an application-specific event loop, you must write new versions of these procedures. Tcl_InitNotifier initializes the notifier state and returns a handle to the notifier state. Tcl calls this procedure when initializing a Tcl interpreter. Similarly, Tcl_FinalizeNotifier shuts down the notifier, and is called by Tcl_Finalize when shutting down a Tcl interpreter. Tcl_WaitForEvent is the lowest-level procedure in the notifier; it is responsible for waiting for an event to occur or for a given time to elapse. Before Tcl_WaitForEvent is invoked, each of the event sources\\' setup procedure will have been invoked. The timePtr argument to Tcl_WaitForEvent gives the maximum time to block for an event, based on calls to Tcl_SetMaxBlockTime made by setup procedures and on other information (such as the TCL_DONT_WAIT bit in flags ). Ideally, Tcl_WaitForEvent should only wait for an event to occur; it should not actually process the event in any way. Later on, the event sources will process the raw events and create Tcl_Events on the event queue in their checkProc procedures. However, on some platforms (such as Windows) this is not possible; events may be processed in Tcl_WaitForEvent , including queuing Tcl_Events and more (for example, callbacks for native widgets may be invoked). The return value from Tcl_WaitForEvent must be either 0, 1, or -1. On platforms such as Windows where events get processed in Tcl_WaitForEvent , a return value of 1 means that there may be more events still pending that have not been processed. This is a sign to the caller that it must call Tcl_WaitForEvent again if it wants all pending events to be processed. A 0 return value means that calling Tcl_WaitForEvent again will not have any effect: either this is a platform where Tcl_WaitForEvent only waits without doing any event processing, or Tcl_WaitForEvent knows for sure that there are no additional events to process (e.g. it returned because the time elapsed). Finally, a return value of -1 means that the event loop is no longer operational and the application should probably unwind and terminate. Under Windows this happens when a WM_QUIT message is received; under Unix it happens when Tcl_WaitForEvent would have waited forever because there were no active event sources and the timeout was infinite. Tcl_AlertNotifier is used to allow any thread to the notifier to alert it to new events on its queue. Tcl_AlertNotifier requires as an argument the notifier handle returned by Tcl_InitNotifier . If the notifier will be used with an external event loop, then it must also support the Tcl_SetTimer interface. Tcl_SetTimer is invoked by Tcl_SetMaxBlockTime whenever the maximum blocking time has been reduced. Tcl_SetTimer should arrange for the external event loop to invoke Tcl_ServiceAll after the specified interval even if no events have occurred. This interface is needed because Tcl_WaitForEvent is not invoked when there is an external event loop. If the notifier will only be used from Tcl_DoOneEvent , then Tcl_SetTimer need not do anything. Tcl_ServiceModeHook is called by the platform-independent portion of the notifier when client code makes a call to Tcl_SetServiceMode . This hook is provided to support operating systems that require special event handling when the application is in a modal loop (the Windows notifier, for instance, uses this hook to create a communication window). On Unix systems, the file event source also needs support from the notifier. The file event source consists of the Tcl_CreateFileHandler and Tcl_DeleteFileHandler procedures, which are described in the Tcl_CreateFileHandler manual page. The Tcl_Sleep and Tcl_DoOneEvent interfaces are described in their respective manual pages. The easiest way to create a new notifier is to look at the code for an existing notifier, such as the files unix/tclUnixNotfy.c or win/tclWinNotify.c in the Tcl source distribution. REPLACING THE NOTIFIER A notifier that has been written according to the conventions above can also be installed in a running process in place of the standard notifier. This mechanism is used so that a single executable can be used (with the standard notifier) as a stand-alone program and reused (with a replacement notifier in a loadable extension) as an extension to another program, such as a Web browser plugin. To do this, the extension makes a call to Tcl_SetNotifier passing a pointer to a Tcl_NotifierProcs data structure. The structure has the following layout: typedef struct Tcl_NotifierProcs { Tcl_SetTimerProc * setTimerProc ; Tcl_WaitForEventProc * waitForEventProc ; Tcl_CreateFileHandlerProc * createFileHandlerProc ; Tcl_DeleteFileHandlerProc * deleteFileHandlerProc ; Tcl_InitNotifierProc * initNotifierProc ; Tcl_FinalizeNotifierProc * finalizeNotifierProc ; Tcl_AlertNotifierProc * alertNotifierProc ; Tcl_ServiceModeHookProc * serviceModeHookProc ; } Tcl_NotifierProcs ; Following the call to Tcl_SetNotifier , the pointers given in the Tcl_NotifierProcs structure replace whatever notifier had been installed in the process. It is extraordinarily unwise to replace a running notifier. Normally, Tcl_SetNotifier should be called at process initialization time before the first call to Tcl_InitNotifier . EXTERNAL EVENT LOOPS The notifier interfaces are designed so that Tcl can be embedded into applications that have their own private event loops. In this case, the application does not call Tcl_DoOneEvent except in the case of recursive event loops such as calls to the Tcl commands update or vwait . Most of the time is spent in the external event loop of the application. In this case the notifier must arrange for the external event loop to call back into Tcl when something happens on the various Tcl event sources. These callbacks should arrange for appropriate Tcl events to be placed on the Tcl event queue. Because the external event loop is not calling Tcl_DoOneEvent on a regular basis, it is up to the notifier to arrange for Tcl_ServiceEvent to be called whenever events are pending on the Tcl event queue. The easiest way to do this is to invoke Tcl_ServiceAll at the end of each callback from the external event loop. This will ensure that all of the event sources are polled, any queued events are serviced, and any pending idle handlers are processed before returning control to the application. In addition, event sources that need to poll for events can call Tcl_SetMaxBlockTime to force the external event loop to call Tcl even if no events are available on the system event queue. As a side effect of processing events detected in the main external event loop, Tcl may invoke Tcl_DoOneEvent to start a recursive event loop in commands like vwait . Tcl_DoOneEvent will invoke the external event loop, which will result in callbacks as described in the preceding paragraph, which will result in calls to Tcl_ServiceAll . However, in these cases it is undesirable to service events in Tcl_ServiceAll . Servicing events there is unnecessary because control will immediately return to the external event loop and hence to Tcl_DoOneEvent , which can service the events itself. Furthermore, Tcl_DoOneEvent is supposed to service only a single event, whereas Tcl_ServiceAll normally services all pending events. To handle this situation, Tcl_DoOneEvent sets a flag for Tcl_ServiceAll that causes it to return without servicing any events. This flag is called the service mode ; Tcl_DoOneEvent restores it to its previous value before it returns. In some cases, however, it may be necessary for Tcl_ServiceAll to service events even when it has been invoked from Tcl_DoOneEvent . This happens when there is yet another recursive event loop invoked via an event handler called by Tcl_DoOneEvent (such as one that is part of a native widget). In this case, Tcl_DoOneEvent may not have a chance to service events so Tcl_ServiceAll must service them all. Any recursive event loop that calls an external event loop rather than Tcl_DoOneEvent must reset the service mode so that all events get processed in Tcl_ServiceAll . This is done by invoking the Tcl_SetServiceMode procedure. If Tcl_SetServiceMode is passed TCL_SERVICE_NONE , then calls to Tcl_ServiceAll will return immediately without processing any events. If Tcl_SetServiceMode is passed TCL_SERVICE_ALL , then calls to Tcl_ServiceAll will behave normally. Tcl_SetServiceMode returns the previous value of the service mode, which should be restored when the recursive loop exits. Tcl_GetServiceMode returns the current value of the service mode. SEE ALSO Tcl_CreateFileHandler(3), Tcl_DeleteFileHandler(3), Tcl_Sleep(3), Tcl_DoOneEvent(3), Thread(3) KEYWORDS event, notifier, event queue, event sources, file events, timer, idle, service mode, threads","title":"NAME"},{"location":"Notifier/#name","text":"Tcl_CreateEventSource, Tcl_DeleteEventSource, Tcl_SetMaxBlockTime, Tcl_QueueEvent, Tcl_ThreadQueueEvent, Tcl_ThreadAlert, Tcl_GetCurrentThread, Tcl_DeleteEvents, Tcl_InitNotifier, Tcl_FinalizeNotifier, Tcl_WaitForEvent, Tcl_AlertNotifier, Tcl_SetTimer, Tcl_ServiceAll, Tcl_ServiceEvent, Tcl_GetServiceMode, Tcl_SetServiceMode, Tcl_ServiceModeHook, Tcl_SetNotifier - the event queue and notifier interfaces","title":"NAME"},{"location":"Notifier/#synopsis","text":"#include <tcl.h> void Tcl_CreateEventSource(setupProc, checkProc, clientData) void Tcl_DeleteEventSource(setupProc, checkProc, clientData) void Tcl_SetMaxBlockTime(timePtr) void Tcl_QueueEvent(evPtr, position) void Tcl_ThreadQueueEvent(threadId, evPtr, position) void Tcl_ThreadAlert(threadId) Tcl_ThreadId Tcl_GetCurrentThread() void Tcl_DeleteEvents(deleteProc, clientData) void * Tcl_InitNotifier() void Tcl_FinalizeNotifier(clientData) int Tcl_WaitForEvent(timePtr) void Tcl_AlertNotifier(clientData) void Tcl_SetTimer(timePtr) int Tcl_ServiceAll() int Tcl_ServiceEvent(flags) int Tcl_GetServiceMode() int Tcl_SetServiceMode(mode) void Tcl_ServiceModeHook(mode) void Tcl_SetNotifier(notifierProcPtr)","title":"SYNOPSIS"},{"location":"Notifier/#arguments","text":"Procedure to invoke to prepare for event wait in Tcl_DoOneEvent . Procedure for Tcl_DoOneEvent to invoke after waiting for events. Checks to see if any events have occurred and, if so, queues them. Arbitrary one-word value to pass to setupProc , checkProc , or deleteProc . Indicates the maximum amount of time to wait for an event. This is specified as an interval (how long to wait), not an absolute time (when to wakeup). If the pointer passed to Tcl_WaitForEvent is NULL, it means there is no maximum wait time: wait forever if necessary. An event to add to the event queue. The storage for the event must have been allocated by the caller using Tcl_Alloc . Where to add the new event in the queue: TCL_QUEUE_TAIL , TCL_QUEUE_HEAD , TCL_QUEUE_MARK , and whether to do an alert if the queue is empty: TCL_QUEUE_ALERT_IF_EMPTY . A unique identifier for a thread. Procedure to invoke for each queued event in Tcl_DeleteEvents . What types of events to service. These flags are the same as those passed to Tcl_DoOneEvent . Indicates whether events should be serviced by Tcl_ServiceAll . Must be one of TCL_SERVICE_NONE or TCL_SERVICE_ALL . Structure of function pointers describing notifier procedures that are to replace the ones installed in the executable. See REPLACING THE NOTIFIER for details.","title":"ARGUMENTS"},{"location":"Notifier/#introduction","text":"The interfaces described here are used to customize the Tcl event loop. The two most common customizations are to add new sources of events and to merge Tcl\\'s event loop with some other event loop, such as one provided by an application in which Tcl is embedded. Each of these tasks is described in a separate section below. The procedures in this manual entry are the building blocks out of which the Tcl event notifier is constructed. The event notifier is the lowest layer in the Tcl event mechanism. It consists of three things: [1] : Event sources: these represent the ways in which events can be generated. For example, there is a timer event source that implements the Tcl_CreateTimerHandler procedure and the after command, and there is a file event source that implements the Tcl_CreateFileHandler procedure on Unix systems. An event source must work with the notifier to detect events at the right times, record them on the event queue, and eventually notify higher-level software that they have occurred. The procedures Tcl_CreateEventSource , Tcl_DeleteEventSource , and Tcl_SetMaxBlockTime , Tcl_QueueEvent , and Tcl_DeleteEvents are used primarily by event sources. [2] : The event queue: there is a single queue for each thread containing a Tcl interpreter, containing events that have been detected but not yet serviced. Event sources place events onto the queue so that they may be processed in order at appropriate times during the event loop. The event queue guarantees a fair discipline of event handling, so that no event source can starve the others. It also allows events to be saved for servicing at a future time. Tcl_QueueEvent is used (primarily by event sources) to add events to the current thread\\'s event queue and Tcl_DeleteEvents is used to remove events from the queue without processing them. [3] : The event loop: in order to detect and process events, the application enters a loop that waits for events to occur, places them on the event queue, and then processes them. Most applications will do this by calling the procedure Tcl_DoOneEvent , which is described in a separate manual entry. Most Tcl applications need not worry about any of the internals of the Tcl notifier. However, the notifier now has enough flexibility to be retargeted either for a new platform or to use an external event loop (such as the Motif event loop, when Tcl is embedded in a Motif application). The procedures Tcl_WaitForEvent and Tcl_SetTimer are normally implemented by Tcl, but may be replaced with new versions to retarget the notifier (the Tcl_InitNotifier , Tcl_AlertNotifier , Tcl_FinalizeNotifier , Tcl_Sleep , Tcl_CreateFileHandler , and Tcl_DeleteFileHandler must also be replaced; see CREATING A NEW NOTIFIER below for details). The procedures Tcl_ServiceAll , Tcl_ServiceEvent , Tcl_GetServiceMode , and Tcl_SetServiceMode are provided to help connect Tcl\\'s event loop to an external event loop such as Motif\\'s.","title":"INTRODUCTION"},{"location":"Notifier/#notifier-basics","text":"The easiest way to understand how the notifier works is to consider what happens when Tcl_DoOneEvent is called. Tcl_DoOneEvent is passed a flags argument that indicates what sort of events it is OK to process and also whether or not to block if no events are ready. Tcl_DoOneEvent does the following things: [1] : Check the event queue to see if it contains any events that can be serviced. If so, service the first possible event, remove it from the queue, and return. It does this by calling Tcl_ServiceEvent and passing in the flags argument. [2] : Prepare to block for an event. To do this, Tcl_DoOneEvent invokes a setup procedure in each event source. The event source will perform event-source specific initialization and possibly call Tcl_SetMaxBlockTime to limit how long Tcl_WaitForEvent will block if no new events occur. [3] : Call Tcl_WaitForEvent . This procedure is implemented differently on different platforms; it waits for an event to occur, based on the information provided by the event sources. It may cause the application to block if timePtr specifies an interval other than 0. Tcl_WaitForEvent returns when something has happened, such as a file becoming readable or the interval given by timePtr expiring. If there are no events for Tcl_WaitForEvent to wait for, so that it would block forever, then it returns immediately and Tcl_DoOneEvent returns 0. [4] : Call a check procedure in each event source. The check procedure determines whether any events of interest to this source occurred. If so, the events are added to the event queue. [5] : Check the event queue to see if it contains any events that can be serviced. If so, service the first possible event, remove it from the queue, and return. [6] : See if there are idle callbacks pending. If so, invoke all of them and return. [7] : Either return 0 to indicate that no events were ready, or go back to step [2] if blocking was requested by the caller.","title":"NOTIFIER BASICS"},{"location":"Notifier/#creating-a-new-event-source","text":"An event source consists of three procedures invoked by the notifier, plus additional C procedures that are invoked by higher-level code to arrange for event-driven callbacks. The three procedures called by the notifier consist of the setup and check procedures described above, plus an additional procedure that is invoked when an event is removed from the event queue for servicing. The procedure Tcl_CreateEventSource creates a new event source. Its arguments specify the setup procedure and check procedure for the event source. SetupProc should match the following prototype: typedef void Tcl_EventSetupProc ( void * clientData , int flags ); The clientData argument will be the same as the clientData argument to Tcl_CreateEventSource ; it is typically used to point to private information managed by the event source. The flags argument will be the same as the flags argument passed to Tcl_DoOneEvent except that it will never be 0 ( Tcl_DoOneEvent replaces 0 with TCL_ALL_EVENTS ). Flags indicates what kinds of events should be considered; if the bit corresponding to this event source is not set, the event source should return immediately without doing anything. For example, the file event source checks for the TCL_FILE_EVENTS bit. SetupProc \\'s job is to make sure that the application wakes up when events of the desired type occur. This is typically done in a platform-dependent fashion. For example, under Unix an event source might call Tcl_CreateFileHandler ; under Windows it might request notification with a Windows event. For timer-driven event sources such as timer events or any polled event, the event source can call Tcl_SetMaxBlockTime to force the application to wake up after a specified time even if no events have occurred. If no event source calls Tcl_SetMaxBlockTime then Tcl_WaitForEvent will wait as long as necessary for an event to occur; otherwise, it will only wait as long as the shortest interval passed to Tcl_SetMaxBlockTime by one of the event sources. If an event source knows that it already has events ready to report, it can request a zero maximum block time. For example, the setup procedure for the X event source looks to see if there are events already queued. If there are, it calls Tcl_SetMaxBlockTime with a 0 block time so that Tcl_WaitForEvent does not block if there is no new data on the X connection. The timePtr argument to Tcl_WaitForEvent points to a structure that describes a time interval in seconds and microseconds: typedef struct Tcl_Time { long sec ; long usec ; } Tcl_Time ; The usec field should be less than 1000000. Information provided to Tcl_SetMaxBlockTime is only used for the next call to Tcl_WaitForEvent ; it is discarded after Tcl_WaitForEvent returns. The next time an event wait is done each of the event sources\\' setup procedures will be called again, and they can specify new information for that event wait. If the application uses an external event loop rather than Tcl_DoOneEvent , the event sources may need to call Tcl_SetMaxBlockTime at other times. For example, if a new event handler is registered that needs to poll for events, the event source may call Tcl_SetMaxBlockTime to set the block time to zero to force the external event loop to call Tcl. In this case, Tcl_SetMaxBlockTime invokes Tcl_SetTimer with the shortest interval seen since the last call to Tcl_DoOneEvent or Tcl_ServiceAll . In addition to the generic procedure Tcl_SetMaxBlockTime , other platform-specific procedures may also be available for setupProc , if there is additional information needed by Tcl_WaitForEvent on that platform. For example, on Unix systems the Tcl_CreateFileHandler interface can be used to wait for file events. The second procedure provided by each event source is its check procedure, indicated by the checkProc argument to Tcl_CreateEventSource . CheckProc must match the following prototype: typedef void Tcl_EventCheckProc ( void * clientData , int flags ); The arguments to this procedure are the same as those for setupProc . CheckProc is invoked by Tcl_DoOneEvent after it has waited for events. Presumably at least one event source is now prepared to queue an event. Tcl_DoOneEvent calls each of the event sources in turn, so they all have a chance to queue any events that are ready. The check procedure does two things. First, it must see if any events have triggered. Different event sources do this in different ways. If an event source\\'s check procedure detects an interesting event, it must add the event to Tcl\\'s event queue. To do this, the event source calls Tcl_QueueEvent . The evPtr argument is a pointer to a dynamically allocated structure containing the event (see below for more information on memory management issues). Each event source can define its own event structure with whatever information is relevant to that event source. However, the first element of the structure must be a structure of type Tcl_Event , and the address of this structure is used when communicating between the event source and the rest of the notifier. A Tcl_Event has the following definition: typedef struct { Tcl_EventProc * proc ; struct Tcl_Event * nextPtr ; } Tcl_Event ; The event source must fill in the proc field of the event before calling Tcl_QueueEvent . The nextPtr is used to link together the events in the queue and should not be modified by the event source. An event may be added to the queue at any of three positions, depending on the position argument to Tcl_QueueEvent : TCL_QUEUE_TAIL : Add the event at the back of the queue, so that all other pending events will be serviced first. This is almost always the right place for new events. TCL_QUEUE_HEAD : Add the event at the front of the queue, so that it will be serviced before all other queued events. TCL_QUEUE_MARK : Add the event at the front of the queue, unless there are other events at the front whose position is TCL_QUEUE_MARK ; if so, add the new event just after all other TCL_QUEUE_MARK events. This value of position is used to insert an ordered sequence of events at the front of the queue, such as a series of Enter and Leave events synthesized during a grab or ungrab operation in Tk. TCL_QUEUE_ALERT_IF_EMPTY : When used in Tcl_ThreadQueueEvent arranges for an automatic call of Tcl_ThreadAlert when the queue was empty. When it is time to handle an event from the queue (steps 1 and 4 above) Tcl_ServiceEvent will invoke the proc specified in the first queued Tcl_Event structure. Proc must match the following prototype: typedef int Tcl_EventProc ( Tcl_Event * evPtr , int flags ); The first argument to proc is a pointer to the event, which will be the same as the first argument to the Tcl_QueueEvent call that added the event to the queue. The second argument to proc is the flags argument for the current call to Tcl_ServiceEvent ; this is used by the event source to return immediately if its events are not relevant. It is up to proc to handle the event, typically by invoking one or more Tcl commands or C-level callbacks. Once the event source has finished handling the event it returns 1 to indicate that the event can be removed from the queue. If for some reason the event source decides that the event cannot be handled at this time, it may return 0 to indicate that the event should be deferred for processing later; in this case Tcl_ServiceEvent will go on to the next event in the queue and attempt to service it. There are several reasons why an event source might defer an event. One possibility is that events of this type are excluded by the flags argument. For example, the file event source will always return 0 if the TCL_FILE_EVENTS bit is not set in flags . Another example of deferring events happens in Tk if Tk_RestrictEvents has been invoked to defer certain kinds of window events. When proc returns 1, Tcl_ServiceEvent will remove the event from the event queue and free its storage. Note that the storage for an event must be allocated by the event source (using Tcl_Alloc ) before calling Tcl_QueueEvent , but it will be freed by Tcl_ServiceEvent , not by the event source. Calling Tcl_QueueEvent adds an event to the current thread\\'s queue. To add an event to another thread\\'s queue, use Tcl_ThreadQueueEvent . Tcl_ThreadQueueEvent accepts as an argument a Tcl_ThreadId argument, which uniquely identifies a thread in a Tcl application. To obtain the Tcl_ThreadId for the current thread, use the Tcl_GetCurrentThread procedure. (A thread would then need to pass this identifier to other threads for those threads to be able to add events to its queue.) After adding an event to another thread\\'s queue, you then typically need to call Tcl_ThreadAlert to that thread\\'s notifier to alert it to the new event. Tcl_DeleteEvents can be used to explicitly remove one or more events from the event queue. Tcl_DeleteEvents calls proc for each event in the queue, deleting those for with the procedure returns 1. Events for which the procedure returns 0 are left in the queue. Proc should match the following prototype: typedef int Tcl_EventDeleteProc ( Tcl_Event * evPtr , void * clientData ); The clientData argument will be the same as the clientData argument to Tcl_DeleteEvents ; it is typically used to point to private information managed by the event source. The evPtr will point to the next event in the queue. Tcl_DeleteEventSource deletes an event source. The setupProc , checkProc , and clientData arguments must exactly match those provided to the Tcl_CreateEventSource for the event source to be deleted. If no such source exists, Tcl_DeleteEventSource has no effect.","title":"CREATING A NEW EVENT SOURCE"},{"location":"Notifier/#creating-a-new-notifier","text":"The notifier consists of all the procedures described in this manual entry, plus Tcl_DoOneEvent and Tcl_Sleep , which are available on all platforms, and Tcl_CreateFileHandler and Tcl_DeleteFileHandler , which are Unix-specific. Most of these procedures are generic, in that they are the same for all notifiers. However, none of the procedures are notifier-dependent: Tcl_InitNotifier , Tcl_AlertNotifier , Tcl_FinalizeNotifier , Tcl_SetTimer , Tcl_Sleep , Tcl_WaitForEvent , Tcl_CreateFileHandler , Tcl_DeleteFileHandler and Tcl_ServiceModeHook . To support a new platform or to integrate Tcl with an application-specific event loop, you must write new versions of these procedures. Tcl_InitNotifier initializes the notifier state and returns a handle to the notifier state. Tcl calls this procedure when initializing a Tcl interpreter. Similarly, Tcl_FinalizeNotifier shuts down the notifier, and is called by Tcl_Finalize when shutting down a Tcl interpreter. Tcl_WaitForEvent is the lowest-level procedure in the notifier; it is responsible for waiting for an event to occur or for a given time to elapse. Before Tcl_WaitForEvent is invoked, each of the event sources\\' setup procedure will have been invoked. The timePtr argument to Tcl_WaitForEvent gives the maximum time to block for an event, based on calls to Tcl_SetMaxBlockTime made by setup procedures and on other information (such as the TCL_DONT_WAIT bit in flags ). Ideally, Tcl_WaitForEvent should only wait for an event to occur; it should not actually process the event in any way. Later on, the event sources will process the raw events and create Tcl_Events on the event queue in their checkProc procedures. However, on some platforms (such as Windows) this is not possible; events may be processed in Tcl_WaitForEvent , including queuing Tcl_Events and more (for example, callbacks for native widgets may be invoked). The return value from Tcl_WaitForEvent must be either 0, 1, or -1. On platforms such as Windows where events get processed in Tcl_WaitForEvent , a return value of 1 means that there may be more events still pending that have not been processed. This is a sign to the caller that it must call Tcl_WaitForEvent again if it wants all pending events to be processed. A 0 return value means that calling Tcl_WaitForEvent again will not have any effect: either this is a platform where Tcl_WaitForEvent only waits without doing any event processing, or Tcl_WaitForEvent knows for sure that there are no additional events to process (e.g. it returned because the time elapsed). Finally, a return value of -1 means that the event loop is no longer operational and the application should probably unwind and terminate. Under Windows this happens when a WM_QUIT message is received; under Unix it happens when Tcl_WaitForEvent would have waited forever because there were no active event sources and the timeout was infinite. Tcl_AlertNotifier is used to allow any thread to the notifier to alert it to new events on its queue. Tcl_AlertNotifier requires as an argument the notifier handle returned by Tcl_InitNotifier . If the notifier will be used with an external event loop, then it must also support the Tcl_SetTimer interface. Tcl_SetTimer is invoked by Tcl_SetMaxBlockTime whenever the maximum blocking time has been reduced. Tcl_SetTimer should arrange for the external event loop to invoke Tcl_ServiceAll after the specified interval even if no events have occurred. This interface is needed because Tcl_WaitForEvent is not invoked when there is an external event loop. If the notifier will only be used from Tcl_DoOneEvent , then Tcl_SetTimer need not do anything. Tcl_ServiceModeHook is called by the platform-independent portion of the notifier when client code makes a call to Tcl_SetServiceMode . This hook is provided to support operating systems that require special event handling when the application is in a modal loop (the Windows notifier, for instance, uses this hook to create a communication window). On Unix systems, the file event source also needs support from the notifier. The file event source consists of the Tcl_CreateFileHandler and Tcl_DeleteFileHandler procedures, which are described in the Tcl_CreateFileHandler manual page. The Tcl_Sleep and Tcl_DoOneEvent interfaces are described in their respective manual pages. The easiest way to create a new notifier is to look at the code for an existing notifier, such as the files unix/tclUnixNotfy.c or win/tclWinNotify.c in the Tcl source distribution.","title":"CREATING A NEW NOTIFIER"},{"location":"Notifier/#replacing-the-notifier","text":"A notifier that has been written according to the conventions above can also be installed in a running process in place of the standard notifier. This mechanism is used so that a single executable can be used (with the standard notifier) as a stand-alone program and reused (with a replacement notifier in a loadable extension) as an extension to another program, such as a Web browser plugin. To do this, the extension makes a call to Tcl_SetNotifier passing a pointer to a Tcl_NotifierProcs data structure. The structure has the following layout: typedef struct Tcl_NotifierProcs { Tcl_SetTimerProc * setTimerProc ; Tcl_WaitForEventProc * waitForEventProc ; Tcl_CreateFileHandlerProc * createFileHandlerProc ; Tcl_DeleteFileHandlerProc * deleteFileHandlerProc ; Tcl_InitNotifierProc * initNotifierProc ; Tcl_FinalizeNotifierProc * finalizeNotifierProc ; Tcl_AlertNotifierProc * alertNotifierProc ; Tcl_ServiceModeHookProc * serviceModeHookProc ; } Tcl_NotifierProcs ; Following the call to Tcl_SetNotifier , the pointers given in the Tcl_NotifierProcs structure replace whatever notifier had been installed in the process. It is extraordinarily unwise to replace a running notifier. Normally, Tcl_SetNotifier should be called at process initialization time before the first call to Tcl_InitNotifier .","title":"REPLACING THE NOTIFIER"},{"location":"Notifier/#external-event-loops","text":"The notifier interfaces are designed so that Tcl can be embedded into applications that have their own private event loops. In this case, the application does not call Tcl_DoOneEvent except in the case of recursive event loops such as calls to the Tcl commands update or vwait . Most of the time is spent in the external event loop of the application. In this case the notifier must arrange for the external event loop to call back into Tcl when something happens on the various Tcl event sources. These callbacks should arrange for appropriate Tcl events to be placed on the Tcl event queue. Because the external event loop is not calling Tcl_DoOneEvent on a regular basis, it is up to the notifier to arrange for Tcl_ServiceEvent to be called whenever events are pending on the Tcl event queue. The easiest way to do this is to invoke Tcl_ServiceAll at the end of each callback from the external event loop. This will ensure that all of the event sources are polled, any queued events are serviced, and any pending idle handlers are processed before returning control to the application. In addition, event sources that need to poll for events can call Tcl_SetMaxBlockTime to force the external event loop to call Tcl even if no events are available on the system event queue. As a side effect of processing events detected in the main external event loop, Tcl may invoke Tcl_DoOneEvent to start a recursive event loop in commands like vwait . Tcl_DoOneEvent will invoke the external event loop, which will result in callbacks as described in the preceding paragraph, which will result in calls to Tcl_ServiceAll . However, in these cases it is undesirable to service events in Tcl_ServiceAll . Servicing events there is unnecessary because control will immediately return to the external event loop and hence to Tcl_DoOneEvent , which can service the events itself. Furthermore, Tcl_DoOneEvent is supposed to service only a single event, whereas Tcl_ServiceAll normally services all pending events. To handle this situation, Tcl_DoOneEvent sets a flag for Tcl_ServiceAll that causes it to return without servicing any events. This flag is called the service mode ; Tcl_DoOneEvent restores it to its previous value before it returns. In some cases, however, it may be necessary for Tcl_ServiceAll to service events even when it has been invoked from Tcl_DoOneEvent . This happens when there is yet another recursive event loop invoked via an event handler called by Tcl_DoOneEvent (such as one that is part of a native widget). In this case, Tcl_DoOneEvent may not have a chance to service events so Tcl_ServiceAll must service them all. Any recursive event loop that calls an external event loop rather than Tcl_DoOneEvent must reset the service mode so that all events get processed in Tcl_ServiceAll . This is done by invoking the Tcl_SetServiceMode procedure. If Tcl_SetServiceMode is passed TCL_SERVICE_NONE , then calls to Tcl_ServiceAll will return immediately without processing any events. If Tcl_SetServiceMode is passed TCL_SERVICE_ALL , then calls to Tcl_ServiceAll will behave normally. Tcl_SetServiceMode returns the previous value of the service mode, which should be restored when the recursive loop exits. Tcl_GetServiceMode returns the current value of the service mode.","title":"EXTERNAL EVENT LOOPS"},{"location":"Notifier/#see-also","text":"Tcl_CreateFileHandler(3), Tcl_DeleteFileHandler(3), Tcl_Sleep(3), Tcl_DoOneEvent(3), Thread(3)","title":"SEE ALSO"},{"location":"Notifier/#keywords","text":"event, notifier, event queue, event sources, file events, timer, idle, service mode, threads","title":"KEYWORDS"},{"location":"Number/","text":"NAME Tcl_GetNumber, Tcl_GetNumberFromObj - get numeric value from Tcl value SYNOPSIS #include <tcl.h> #include <tclTomMath.h> int Tcl_GetNumber(interp, bytes, numBytes, clientDataPtr, typePtr) int Tcl_GetNumberFromObj(interp, objPtr, clientDataPtr, typePtr) ARGUMENTS When non-NULL, error information is recorded here when the value is not in any of the numeric formats recognized by Tcl. Points to first byte of the string value to be examined. The number of bytes, starting at bytes , that should be examined. If numBytes is negative, then all bytes should be examined until the first NUL byte terminates examination. Points to space where a pointer value may be written through which a numeric value is available to read. Points to space where a value may be written reporting what type of numeric storage is available to read. A Tcl value to be examined. DESCRIPTION These procedures enable callers to retrieve a numeric value from a Tcl value in a numeric format recognized by Tcl. Tcl recognizes many values as numbers. Several examples include: \\\"0\\\" , \\\" +1\\\" , \\\"-2 \\\" , \\\" 3 \\\" , \\\"0xdad1\\\" , \\\"0d09\\\" , \\\"1_000_000\\\" , \\\"4.0\\\" , \\\"1e-7\\\" , \\\"NaN\\\" , or \\\"Inf\\\" . When built-in Tcl commands act on these values as numbers, they are converted to a numeric representation for efficient handling in C code. Tcl makes use of three C types to store these representations: double , Tcl_WideInt , and mp_int . The double type is provided by the C language standard. The Tcl_WideInt type is declared in the Tcl header file, tcl.h , and is equivalent to the C standard type long long on most platforms. The mp_int type is declared in the header file tclTomMath.h , and implemented by the LibTomMath multiple-precision integer library, included with Tcl. The routines Tcl_GetNumber and Tcl_GetNumberFromObj perform the same function. They differ only in how the arguments present the Tcl value to be examined. Tcl_GetNumber accepts a counted string value in the arguments bytes and numBytes (or a NUL -terminated string value when numBytes is negative). Tcl_GetNumberFromObj accepts the Tcl value in objPtr . Both routines examine the Tcl value and determine whether Tcl recognizes it as a number. If not, both routines return TCL_ERROR and (when interp is not NULL) record an error message and error code in interp . If Tcl does recognize the examined value as a number, both routines return TCL_OK , and use the pointer arguments clientDataPtr and typePtr (which may not be NULL) to report information the caller can use to retrieve the numeric representation. Both routines write to * clientDataPtr a pointer to the internal storage location where Tcl holds the converted numeric value. When the converted numeric value is stored as a double , a call to math library routine isnan determines whether that value is not a number (NaN). If so, both Tcl_GetNumber and Tcl_GetNumberFromObj write the value TCL_NUMBER_NAN to * typePtr . If not, both routines write the value TCL_NUMBER_DOUBLE to * typePtr . These routines report different type values in these cases because Tcl_GetDoubleFromObj raises an error on NaN values. For both reported type values, the storage pointer may be cast to type const double * and the double numeric value may be read through it. When the converted numeric value is stored as a Tcl_WideInt , both Tcl_GetNumber and Tcl_GetNumberFromObj write the value TCL_NUMBER_INT to * typePtr . The storage pointer may be cast to type const Tcl_WideInt * and the Tcl_WideInt numeric value may be read through it. When the converted numeric value is stored as an mp_int , both Tcl_GetNumber and Tcl_GetNumberFromObj write the value TCL_NUMBER_BIG to * typePtr . The storage pointer may be cast to type const mp_int * and the mp_int numeric value may be read through it. Future releases of Tcl might expand or revise the recognition of values as numbers. If additional storage representations are adopted, these routines will add new values to be written to * typePtr to identify them. Callers should consider how they should react to unknown values written to * typePtr . When callers of these routines read numeric values through the reported storage pointer, they are accessing memory that belongs to the Tcl library. The Tcl library has the power to overwrite or free this memory. The storage pointer reported by a call to Tcl_GetNumber or Tcl_GetNumberFromObj should not be used after the same thread has possibly returned control to the Tcl library. If longer term access to the numeric value is needed, it should be copied into memory controlled by the caller. Callers must not attempt to write through or free the storage pointer. SEE ALSO Tcl_GetDouble, Tcl_GetDoubleFromObj, Tcl_GetWideIntFromObj KEYWORDS double, double value, double type, integer, integer value, integer type, internal representation, value, value type, string representation","title":"NAME"},{"location":"Number/#name","text":"Tcl_GetNumber, Tcl_GetNumberFromObj - get numeric value from Tcl value","title":"NAME"},{"location":"Number/#synopsis","text":"#include <tcl.h> #include <tclTomMath.h> int Tcl_GetNumber(interp, bytes, numBytes, clientDataPtr, typePtr) int Tcl_GetNumberFromObj(interp, objPtr, clientDataPtr, typePtr)","title":"SYNOPSIS"},{"location":"Number/#arguments","text":"When non-NULL, error information is recorded here when the value is not in any of the numeric formats recognized by Tcl. Points to first byte of the string value to be examined. The number of bytes, starting at bytes , that should be examined. If numBytes is negative, then all bytes should be examined until the first NUL byte terminates examination. Points to space where a pointer value may be written through which a numeric value is available to read. Points to space where a value may be written reporting what type of numeric storage is available to read. A Tcl value to be examined.","title":"ARGUMENTS"},{"location":"Number/#description","text":"These procedures enable callers to retrieve a numeric value from a Tcl value in a numeric format recognized by Tcl. Tcl recognizes many values as numbers. Several examples include: \\\"0\\\" , \\\" +1\\\" , \\\"-2 \\\" , \\\" 3 \\\" , \\\"0xdad1\\\" , \\\"0d09\\\" , \\\"1_000_000\\\" , \\\"4.0\\\" , \\\"1e-7\\\" , \\\"NaN\\\" , or \\\"Inf\\\" . When built-in Tcl commands act on these values as numbers, they are converted to a numeric representation for efficient handling in C code. Tcl makes use of three C types to store these representations: double , Tcl_WideInt , and mp_int . The double type is provided by the C language standard. The Tcl_WideInt type is declared in the Tcl header file, tcl.h , and is equivalent to the C standard type long long on most platforms. The mp_int type is declared in the header file tclTomMath.h , and implemented by the LibTomMath multiple-precision integer library, included with Tcl. The routines Tcl_GetNumber and Tcl_GetNumberFromObj perform the same function. They differ only in how the arguments present the Tcl value to be examined. Tcl_GetNumber accepts a counted string value in the arguments bytes and numBytes (or a NUL -terminated string value when numBytes is negative). Tcl_GetNumberFromObj accepts the Tcl value in objPtr . Both routines examine the Tcl value and determine whether Tcl recognizes it as a number. If not, both routines return TCL_ERROR and (when interp is not NULL) record an error message and error code in interp . If Tcl does recognize the examined value as a number, both routines return TCL_OK , and use the pointer arguments clientDataPtr and typePtr (which may not be NULL) to report information the caller can use to retrieve the numeric representation. Both routines write to * clientDataPtr a pointer to the internal storage location where Tcl holds the converted numeric value. When the converted numeric value is stored as a double , a call to math library routine isnan determines whether that value is not a number (NaN). If so, both Tcl_GetNumber and Tcl_GetNumberFromObj write the value TCL_NUMBER_NAN to * typePtr . If not, both routines write the value TCL_NUMBER_DOUBLE to * typePtr . These routines report different type values in these cases because Tcl_GetDoubleFromObj raises an error on NaN values. For both reported type values, the storage pointer may be cast to type const double * and the double numeric value may be read through it. When the converted numeric value is stored as a Tcl_WideInt , both Tcl_GetNumber and Tcl_GetNumberFromObj write the value TCL_NUMBER_INT to * typePtr . The storage pointer may be cast to type const Tcl_WideInt * and the Tcl_WideInt numeric value may be read through it. When the converted numeric value is stored as an mp_int , both Tcl_GetNumber and Tcl_GetNumberFromObj write the value TCL_NUMBER_BIG to * typePtr . The storage pointer may be cast to type const mp_int * and the mp_int numeric value may be read through it. Future releases of Tcl might expand or revise the recognition of values as numbers. If additional storage representations are adopted, these routines will add new values to be written to * typePtr to identify them. Callers should consider how they should react to unknown values written to * typePtr . When callers of these routines read numeric values through the reported storage pointer, they are accessing memory that belongs to the Tcl library. The Tcl library has the power to overwrite or free this memory. The storage pointer reported by a call to Tcl_GetNumber or Tcl_GetNumberFromObj should not be used after the same thread has possibly returned control to the Tcl library. If longer term access to the numeric value is needed, it should be copied into memory controlled by the caller. Callers must not attempt to write through or free the storage pointer.","title":"DESCRIPTION"},{"location":"Number/#see-also","text":"Tcl_GetDouble, Tcl_GetDoubleFromObj, Tcl_GetWideIntFromObj","title":"SEE ALSO"},{"location":"Number/#keywords","text":"double, double value, double type, integer, integer value, integer type, internal representation, value, value type, string representation","title":"KEYWORDS"},{"location":"OOInitStubs/","text":"NAME Tcl_OOInitStubs - initialize library access to TclOO functionality SYNOPSIS #include <tclOO.h> const char * Tcl_OOInitStubs(interp) ARGUMENTS The Tcl interpreter that the TclOO API is integrated with and whose C interface is going to be used. DESCRIPTION When an extension library is going to use the C interface exposed by TclOO, it should use Tcl_OOInitStubs to initialize its access to that interface from within its * _Init (or * _SafeInit ) function, passing in the interp that was passed into that routine as context. If the result of calling Tcl_OOInitStubs is NULL, the initialization failed and an error message will have been left in the interpreter\\'s result. Otherwise, the initialization succeeded and the TclOO API may thereafter be used; the version of the TclOO API is returned. When using this function, either the C #define symbol USE_TCLOO_STUBS should be defined and your library code linked against the Tcl stub library, or that #define symbol should not be defined and your library code linked against the Tcl main library directly. BACKWARD COMPATIBILITY NOTE If you are linking against the Tcl 8.5 forward compatibility package for TclOO, only the stub-enabled configuration is supported and you should also link against the TclOO independent stub library; that library is an integrated part of the main Tcl stub library in Tcl 8.6. KEYWORDS stubs SEE ALSO Tcl_InitStubs(3)","title":"NAME"},{"location":"OOInitStubs/#name","text":"Tcl_OOInitStubs - initialize library access to TclOO functionality","title":"NAME"},{"location":"OOInitStubs/#synopsis","text":"#include <tclOO.h> const char * Tcl_OOInitStubs(interp)","title":"SYNOPSIS"},{"location":"OOInitStubs/#arguments","text":"The Tcl interpreter that the TclOO API is integrated with and whose C interface is going to be used.","title":"ARGUMENTS"},{"location":"OOInitStubs/#description","text":"When an extension library is going to use the C interface exposed by TclOO, it should use Tcl_OOInitStubs to initialize its access to that interface from within its * _Init (or * _SafeInit ) function, passing in the interp that was passed into that routine as context. If the result of calling Tcl_OOInitStubs is NULL, the initialization failed and an error message will have been left in the interpreter\\'s result. Otherwise, the initialization succeeded and the TclOO API may thereafter be used; the version of the TclOO API is returned. When using this function, either the C #define symbol USE_TCLOO_STUBS should be defined and your library code linked against the Tcl stub library, or that #define symbol should not be defined and your library code linked against the Tcl main library directly.","title":"DESCRIPTION"},{"location":"OOInitStubs/#backward-compatibility-note","text":"If you are linking against the Tcl 8.5 forward compatibility package for TclOO, only the stub-enabled configuration is supported and you should also link against the TclOO independent stub library; that library is an integrated part of the main Tcl stub library in Tcl 8.6.","title":"BACKWARD COMPATIBILITY NOTE"},{"location":"OOInitStubs/#keywords","text":"stubs","title":"KEYWORDS"},{"location":"OOInitStubs/#see-also","text":"Tcl_InitStubs(3)","title":"SEE ALSO"},{"location":"Object/","text":"NAME oo::object - root class of the class hierarchy SYNOPSIS package require tcl::oo oo::object method ?arg ...? CLASS HIERARCHY oo::object DESCRIPTION The oo::object class is the root class of the object hierarchy; every object is an instance of this class. Since classes are themselves objects, they are instances of this class too. Objects are always referred to by their name, and may be rename d while maintaining their identity. Instances of objects may be made with either the create or new methods of the oo::object object itself, or by invoking those methods on any of the subclass objects; see oo::class for more details. The configuration of individual objects (i.e., instance-specific methods, mixed-in classes, etc.) may be controlled with the oo::objdefine command. Each object has a unique namespace associated with it, the instance namespace. This namespace holds all the instance variables of the object, and will be the current namespace whenever a method of the object is invoked (including a method of the class of the object). When the object is destroyed, its instance namespace is deleted. The instance namespace contains the object\\'s my command, which may be used to invoke non-exported methods of the object or to create a reference to the object for the purpose of invocation which persists across renamings of the object. CONSTRUCTOR The oo::object class does not define an explicit constructor. DESTRUCTOR The oo::object class does not define an explicit destructor. EXPORTED METHODS The oo::object class supports the following exported methods: obj destroy : This method destroys the object, obj , that it is invoked upon, invoking any destructors on the object\\'s class in the process. It is equivalent to using rename to delete the object command. The result of this method is always the empty string. NON-EXPORTED METHODS The oo::object class supports the following non-exported methods: obj eval ? arg ... ? : This method concatenates the arguments, arg , as if with concat , and then evaluates the resulting script in the namespace that is uniquely associated with obj , returning the result of the evaluation. obj unknown ? methodName ? ? arg ... ? : This method is called when an attempt to invoke the method methodName on object obj fails. The arguments that the user supplied to the method are given as arg arguments. If methodName is absent, the object was invoked with no method name at all (or any other arguments). The default implementation (i.e., the one defined by the oo::object class) generates a suitable error, detailing what methods the object supports given whether the object was invoked by its public name or through the my command. obj variable ? varName ... ? : This method arranges for each variable called varName to be linked from the object obj \\'s unique namespace into the caller\\'s context. Thus, if it is invoked from inside a procedure then the namespace variable in the object is linked to the local variable in the procedure. Each varName argument must not have any namespace separators in it. The result is the empty string. obj varname varName : This method returns the globally qualified name of the variable varName in the unique namespace for the object obj . obj \\<cloned> sourceObjectName : This method is used by the oo::object command to copy the state of one object to another. It is responsible for copying the procedures and variables of the namespace of the source object ( sourceObjectName ) to the current object. It does not copy any other types of commands or any traces on the variables; that can be added if desired by overriding this method in a subclass. EXAMPLES This example demonstrates basic use of an object. set obj [ oo::object new] \\$obj foo \u2192 error \\\"unknown method foo\\\" oo::objdefine \\$obj method foo {} { my variable count puts \\\"bar[incr count]\\\" } \\$obj foo \u2192 prints \\\"bar1\\\" \\$obj foo \u2192 prints \\\"bar2\\\" \\$obj variable count \u2192 error \\\"unknown method variable\\\" \\$obj destroy \\$obj foo \u2192 error \\\"unknown command obj\\\" SEE ALSO my(n), oo::class(n) KEYWORDS base class, class, object, root class","title":"NAME"},{"location":"Object/#name","text":"oo::object - root class of the class hierarchy","title":"NAME"},{"location":"Object/#synopsis","text":"package require tcl::oo oo::object method ?arg ...?","title":"SYNOPSIS"},{"location":"Object/#class-hierarchy","text":"oo::object","title":"CLASS HIERARCHY"},{"location":"Object/#description","text":"The oo::object class is the root class of the object hierarchy; every object is an instance of this class. Since classes are themselves objects, they are instances of this class too. Objects are always referred to by their name, and may be rename d while maintaining their identity. Instances of objects may be made with either the create or new methods of the oo::object object itself, or by invoking those methods on any of the subclass objects; see oo::class for more details. The configuration of individual objects (i.e., instance-specific methods, mixed-in classes, etc.) may be controlled with the oo::objdefine command. Each object has a unique namespace associated with it, the instance namespace. This namespace holds all the instance variables of the object, and will be the current namespace whenever a method of the object is invoked (including a method of the class of the object). When the object is destroyed, its instance namespace is deleted. The instance namespace contains the object\\'s my command, which may be used to invoke non-exported methods of the object or to create a reference to the object for the purpose of invocation which persists across renamings of the object.","title":"DESCRIPTION"},{"location":"Object/#constructor","text":"The oo::object class does not define an explicit constructor.","title":"CONSTRUCTOR"},{"location":"Object/#destructor","text":"The oo::object class does not define an explicit destructor.","title":"DESTRUCTOR"},{"location":"Object/#exported-methods","text":"The oo::object class supports the following exported methods: obj destroy : This method destroys the object, obj , that it is invoked upon, invoking any destructors on the object\\'s class in the process. It is equivalent to using rename to delete the object command. The result of this method is always the empty string.","title":"EXPORTED METHODS"},{"location":"Object/#non-exported-methods","text":"The oo::object class supports the following non-exported methods: obj eval ? arg ... ? : This method concatenates the arguments, arg , as if with concat , and then evaluates the resulting script in the namespace that is uniquely associated with obj , returning the result of the evaluation. obj unknown ? methodName ? ? arg ... ? : This method is called when an attempt to invoke the method methodName on object obj fails. The arguments that the user supplied to the method are given as arg arguments. If methodName is absent, the object was invoked with no method name at all (or any other arguments). The default implementation (i.e., the one defined by the oo::object class) generates a suitable error, detailing what methods the object supports given whether the object was invoked by its public name or through the my command. obj variable ? varName ... ? : This method arranges for each variable called varName to be linked from the object obj \\'s unique namespace into the caller\\'s context. Thus, if it is invoked from inside a procedure then the namespace variable in the object is linked to the local variable in the procedure. Each varName argument must not have any namespace separators in it. The result is the empty string. obj varname varName : This method returns the globally qualified name of the variable varName in the unique namespace for the object obj . obj \\<cloned> sourceObjectName : This method is used by the oo::object command to copy the state of one object to another. It is responsible for copying the procedures and variables of the namespace of the source object ( sourceObjectName ) to the current object. It does not copy any other types of commands or any traces on the variables; that can be added if desired by overriding this method in a subclass.","title":"NON-EXPORTED METHODS"},{"location":"Object/#examples","text":"This example demonstrates basic use of an object. set obj [ oo::object new] \\$obj foo \u2192 error \\\"unknown method foo\\\" oo::objdefine \\$obj method foo {} { my variable count puts \\\"bar[incr count]\\\" } \\$obj foo \u2192 prints \\\"bar1\\\" \\$obj foo \u2192 prints \\\"bar2\\\" \\$obj variable count \u2192 error \\\"unknown method variable\\\" \\$obj destroy \\$obj foo \u2192 error \\\"unknown command obj\\\"","title":"EXAMPLES"},{"location":"Object/#see-also","text":"my(n), oo::class(n)","title":"SEE ALSO"},{"location":"Object/#keywords","text":"base class, class, object, root class","title":"KEYWORDS"},{"location":"ObjectType/","text":"NAME Tcl_RegisterObjType, Tcl_GetObjType, Tcl_AppendAllObjTypes, Tcl_ConvertToType - manipulate Tcl value types SYNOPSIS #include <tcl.h> Tcl_RegisterObjType(typePtr) const Tcl_ObjType * Tcl_GetObjType(typeName) int Tcl_AppendAllObjTypes(interp, objPtr) int Tcl_ConvertToType(interp, objPtr, typePtr) ARGUMENTS Points to the structure containing information about the Tcl value type. This storage must live forever, typically by being statically allocated. The name of a Tcl value type that Tcl_GetObjType should look up. Interpreter to use for error reporting. For Tcl_AppendAllObjTypes , this points to the value onto which it appends the name of each value type as a list element. For Tcl_ConvertToType , this points to a value that must have been the result of a previous call to Tcl_NewObj . DESCRIPTION The procedures in this man page manage Tcl value types (sometimes referred to as object types or Tcl_ObjType s for historical reasons). They are used to register new value types, look up types, and force conversions from one type to another. Tcl_RegisterObjType registers a new Tcl value type in the table of all value types that Tcl_GetObjType can look up by name. There are other value types supported by Tcl as well, which Tcl chooses not to register. Extensions can likewise choose to register the value types they create or not. The argument typePtr points to a Tcl_ObjType structure that describes the new type by giving its name and by supplying pointers to four procedures that implement the type. If the type table already contains a type with the same name as in typePtr , it is replaced with the new type. The Tcl_ObjType structure is described in the section THE TCL_OBJTYPE STRUCTURE below. Tcl_GetObjType returns a pointer to the registered Tcl_ObjType with name typeName . It returns NULL if no type with that name is registered. Tcl_AppendAllObjTypes appends the name of each registered value type as a list element onto the Tcl value referenced by objPtr . The return value is TCL_OK unless there was an error converting objPtr to a list value; in that case TCL_ERROR is returned. Tcl_ConvertToType converts a value from one type to another if possible. It creates a new internal representation for objPtr appropriate for the target type typePtr and sets its typePtr member as determined by calling the typePtr->setFromAnyProc routine. Any internal representation for objPtr \\'s old type is freed. If an error occurs during conversion, it returns TCL_ERROR and leaves an error message in the result value for interp unless interp is NULL. Otherwise, it returns TCL_OK . Passing a NULL interp allows this procedure to be used as a test whether the conversion can be done (and in fact was done). In many cases, the typePtr->setFromAnyProc routine will set objPtr->typePtr to the argument value typePtr , but that is no longer guaranteed. The setFromAnyProc is free to set the internal representation for objPtr to make use of another related Tcl_ObjType, if it sees fit. THE TCL_OBJTYPE STRUCTURE Extension writers can define new value types by defining four procedures and initializing a Tcl_ObjType structure to describe the type. Extension writers may also pass a pointer to their Tcl_ObjType structure to Tcl_RegisterObjType if they wish to permit other extensions to look up their Tcl_ObjType by name with the Tcl_GetObjType routine. The Tcl_ObjType structure is defined as follows: typedef struct Tcl_ObjType { const char * name ; Tcl_FreeInternalRepProc * freeIntRepProc ; Tcl_DupInternalRepProc * dupIntRepProc ; Tcl_UpdateStringProc * updateStringProc ; Tcl_SetFromAnyProc * setFromAnyProc ; size_t version ; } Tcl_ObjType ; THE NAME FIELD The name member describes the name of the type, e.g. int . When a type is registered, this is the name used by callers of Tcl_GetObjType to lookup the type. For unregistered types, the name field is primarily of value for debugging. The remaining four members are pointers to procedures called by the generic Tcl value code: THE SETFROMANYPROC FIELD The setFromAnyProc member contains the address of a function called to create a valid internal representation from a value\\'s string representation. typedef int Tcl_SetFromAnyProc ( Tcl_Interp * interp , Tcl_Obj * objPtr ); If an internal representation cannot be created from the string, it returns TCL_ERROR and puts a message describing the error in the result value for interp unless interp is NULL. If setFromAnyProc is successful, it stores the new internal representation, sets objPtr \\'s typePtr member to point to the Tcl_ObjType struct corresponding to the new internal representation, and returns TCL_OK . Before setting the new internal representation, the setFromAnyProc must free any internal representation of objPtr \\'s old type; it does this by calling the old type\\'s freeIntRepProc if it is not NULL. As an example, the setFromAnyProc for the built-in Tcl list type gets an up-to-date string representation for objPtr by calling Tcl_GetStringFromObj . It parses the string to verify it is in a valid list format and to obtain each element value in the list, and, if this succeeds, stores the list elements in objPtr \\'s internal representation and sets objPtr \\'s typePtr member to point to the list type\\'s Tcl_ObjType structure. Do not release objPtr \\'s old internal representation unless you replace it with a new one or reset the typePtr member to NULL. The setFromAnyProc member may be set to NULL, if the routines making use of the internal representation have no need to derive that internal representation from an arbitrary string value. However, in this case, passing a pointer to the type to Tcl_ConvertToType will lead to a panic, so to avoid this possibility, the type should not be registered. THE UPDATESTRINGPROC FIELD The updateStringProc member contains the address of a function called to create a valid string representation from a value\\'s internal representation. typedef void Tcl_UpdateStringProc ( Tcl_Obj * objPtr ); objPtr \\'s bytes member is always NULL when it is called. It must always set bytes non-NULL before returning. We require the string representation\\'s byte array to have a null after the last byte, at offset length , and to have no null bytes before that; this allows string representations to be treated as conventional null character-terminated C strings. These restrictions are easily met by using Tcl\\'s internal UTF encoding for the string representation, same as one would do for other Tcl routines accepting string values as arguments. Storage for the byte array must be allocated in the heap by Tcl_Alloc . Note that updateStringProc s must allocate enough storage for the string\\'s bytes and the terminating null byte. The updateStringProc for Tcl\\'s built-in double type, for example, calls Tcl_PrintDouble to write to a buffer of size TCL_DOUBLE_SPACE, then allocates and copies the string representation to just enough space to hold it. A pointer to the allocated space is stored in the bytes member. The updateStringProc member may be set to NULL, if the routines making use of the internal representation are written so that the string representation is never invalidated. Failure to meet this obligation will lead to panics or crashes when Tcl_GetStringFromObj or other similar routines ask for the string representation. THE DUPINTREPPROC FIELD The dupIntRepProc member contains the address of a function called to copy an internal representation from one value to another. typedef void Tcl_DupInternalRepProc ( Tcl_Obj * srcPtr , Tcl_Obj * dupPtr ); dupPtr \\'s internal representation is made a copy of srcPtr \\'s internal representation. Before the call, srcPtr \\'s internal representation is valid and dupPtr \\'s is not. srcPtr \\'s value type determines what copying its internal representation means. For example, the dupIntRepProc for the Tcl integer type simply copies an integer. The built-in list type\\'s dupIntRepProc uses a far more sophisticated scheme to continue sharing storage as much as it reasonably can. THE FREEINTREPPROC FIELD The freeIntRepProc member contains the address of a function that is called when a value is freed. typedef void Tcl_FreeInternalRepProc ( Tcl_Obj * objPtr ); The freeIntRepProc function can deallocate the storage for the value\\'s internal representation and do other type-specific processing necessary when a value is freed. For example, the list type\\'s freeIntRepProc respects the storage sharing scheme established by the dupIntRepProc so that it only frees storage when the last value sharing it is being freed. The freeIntRepProc member can be set to NULL to indicate that the internal representation does not require freeing. The freeIntRepProc implementation must not access the bytes member of the value, since Tcl makes its own internal uses of that field during value deletion. The defined tasks for the freeIntRepProc have no need to consult the bytes member. Note that if a subsidiary value has its reference count reduced to zero during the running of a freeIntRepProc , that value may be not freed immediately, in order to limit stack usage. However, the value will be freed before the outermost current Tcl_DecrRefCount returns. THE VERSION FIELD The version member provides for future extensibility of the structure and should be set to TCL_OBJTYPE_V0 . REFERENCE COUNT MANAGEMENT The objPtr argument to Tcl_AppendAllObjTypes should be an unshared value; this function will not modify the reference count of that value, but will modify its contents. If objPtr is not (interpretable as) a list, this function will set the interpreter result and produce an error; using an unshared empty value is strongly recommended. The objPtr argument to Tcl_ConvertToType can have any non-zero reference count; this function will not modify the reference count, but may write to the interpreter result on error so values that originate from there should have an additional reference made before calling this. None of the callback functions in the Tcl_ObjType structure should modify the reference count of their arguments, but if the values contain subsidiary values (e.g., the elements of a list or the keys of a dictionary) then those subsidiary values may have their reference counts modified. SEE ALSO Tcl_NewObj(3), Tcl_DecrRefCount(3), Tcl_IncrRefCount(3) KEYWORDS internal representation, value, value type, string representation, type conversion","title":"NAME"},{"location":"ObjectType/#name","text":"Tcl_RegisterObjType, Tcl_GetObjType, Tcl_AppendAllObjTypes, Tcl_ConvertToType - manipulate Tcl value types","title":"NAME"},{"location":"ObjectType/#synopsis","text":"#include <tcl.h> Tcl_RegisterObjType(typePtr) const Tcl_ObjType * Tcl_GetObjType(typeName) int Tcl_AppendAllObjTypes(interp, objPtr) int Tcl_ConvertToType(interp, objPtr, typePtr)","title":"SYNOPSIS"},{"location":"ObjectType/#arguments","text":"Points to the structure containing information about the Tcl value type. This storage must live forever, typically by being statically allocated. The name of a Tcl value type that Tcl_GetObjType should look up. Interpreter to use for error reporting. For Tcl_AppendAllObjTypes , this points to the value onto which it appends the name of each value type as a list element. For Tcl_ConvertToType , this points to a value that must have been the result of a previous call to Tcl_NewObj .","title":"ARGUMENTS"},{"location":"ObjectType/#description","text":"The procedures in this man page manage Tcl value types (sometimes referred to as object types or Tcl_ObjType s for historical reasons). They are used to register new value types, look up types, and force conversions from one type to another. Tcl_RegisterObjType registers a new Tcl value type in the table of all value types that Tcl_GetObjType can look up by name. There are other value types supported by Tcl as well, which Tcl chooses not to register. Extensions can likewise choose to register the value types they create or not. The argument typePtr points to a Tcl_ObjType structure that describes the new type by giving its name and by supplying pointers to four procedures that implement the type. If the type table already contains a type with the same name as in typePtr , it is replaced with the new type. The Tcl_ObjType structure is described in the section THE TCL_OBJTYPE STRUCTURE below. Tcl_GetObjType returns a pointer to the registered Tcl_ObjType with name typeName . It returns NULL if no type with that name is registered. Tcl_AppendAllObjTypes appends the name of each registered value type as a list element onto the Tcl value referenced by objPtr . The return value is TCL_OK unless there was an error converting objPtr to a list value; in that case TCL_ERROR is returned. Tcl_ConvertToType converts a value from one type to another if possible. It creates a new internal representation for objPtr appropriate for the target type typePtr and sets its typePtr member as determined by calling the typePtr->setFromAnyProc routine. Any internal representation for objPtr \\'s old type is freed. If an error occurs during conversion, it returns TCL_ERROR and leaves an error message in the result value for interp unless interp is NULL. Otherwise, it returns TCL_OK . Passing a NULL interp allows this procedure to be used as a test whether the conversion can be done (and in fact was done). In many cases, the typePtr->setFromAnyProc routine will set objPtr->typePtr to the argument value typePtr , but that is no longer guaranteed. The setFromAnyProc is free to set the internal representation for objPtr to make use of another related Tcl_ObjType, if it sees fit.","title":"DESCRIPTION"},{"location":"ObjectType/#the-tcl_objtype-structure","text":"Extension writers can define new value types by defining four procedures and initializing a Tcl_ObjType structure to describe the type. Extension writers may also pass a pointer to their Tcl_ObjType structure to Tcl_RegisterObjType if they wish to permit other extensions to look up their Tcl_ObjType by name with the Tcl_GetObjType routine. The Tcl_ObjType structure is defined as follows: typedef struct Tcl_ObjType { const char * name ; Tcl_FreeInternalRepProc * freeIntRepProc ; Tcl_DupInternalRepProc * dupIntRepProc ; Tcl_UpdateStringProc * updateStringProc ; Tcl_SetFromAnyProc * setFromAnyProc ; size_t version ; } Tcl_ObjType ;","title":"THE TCL_OBJTYPE STRUCTURE"},{"location":"ObjectType/#the-name-field","text":"The name member describes the name of the type, e.g. int . When a type is registered, this is the name used by callers of Tcl_GetObjType to lookup the type. For unregistered types, the name field is primarily of value for debugging. The remaining four members are pointers to procedures called by the generic Tcl value code:","title":"THE NAME FIELD"},{"location":"ObjectType/#the-setfromanyproc-field","text":"The setFromAnyProc member contains the address of a function called to create a valid internal representation from a value\\'s string representation. typedef int Tcl_SetFromAnyProc ( Tcl_Interp * interp , Tcl_Obj * objPtr ); If an internal representation cannot be created from the string, it returns TCL_ERROR and puts a message describing the error in the result value for interp unless interp is NULL. If setFromAnyProc is successful, it stores the new internal representation, sets objPtr \\'s typePtr member to point to the Tcl_ObjType struct corresponding to the new internal representation, and returns TCL_OK . Before setting the new internal representation, the setFromAnyProc must free any internal representation of objPtr \\'s old type; it does this by calling the old type\\'s freeIntRepProc if it is not NULL. As an example, the setFromAnyProc for the built-in Tcl list type gets an up-to-date string representation for objPtr by calling Tcl_GetStringFromObj . It parses the string to verify it is in a valid list format and to obtain each element value in the list, and, if this succeeds, stores the list elements in objPtr \\'s internal representation and sets objPtr \\'s typePtr member to point to the list type\\'s Tcl_ObjType structure. Do not release objPtr \\'s old internal representation unless you replace it with a new one or reset the typePtr member to NULL. The setFromAnyProc member may be set to NULL, if the routines making use of the internal representation have no need to derive that internal representation from an arbitrary string value. However, in this case, passing a pointer to the type to Tcl_ConvertToType will lead to a panic, so to avoid this possibility, the type should not be registered.","title":"THE SETFROMANYPROC FIELD"},{"location":"ObjectType/#the-updatestringproc-field","text":"The updateStringProc member contains the address of a function called to create a valid string representation from a value\\'s internal representation. typedef void Tcl_UpdateStringProc ( Tcl_Obj * objPtr ); objPtr \\'s bytes member is always NULL when it is called. It must always set bytes non-NULL before returning. We require the string representation\\'s byte array to have a null after the last byte, at offset length , and to have no null bytes before that; this allows string representations to be treated as conventional null character-terminated C strings. These restrictions are easily met by using Tcl\\'s internal UTF encoding for the string representation, same as one would do for other Tcl routines accepting string values as arguments. Storage for the byte array must be allocated in the heap by Tcl_Alloc . Note that updateStringProc s must allocate enough storage for the string\\'s bytes and the terminating null byte. The updateStringProc for Tcl\\'s built-in double type, for example, calls Tcl_PrintDouble to write to a buffer of size TCL_DOUBLE_SPACE, then allocates and copies the string representation to just enough space to hold it. A pointer to the allocated space is stored in the bytes member. The updateStringProc member may be set to NULL, if the routines making use of the internal representation are written so that the string representation is never invalidated. Failure to meet this obligation will lead to panics or crashes when Tcl_GetStringFromObj or other similar routines ask for the string representation.","title":"THE UPDATESTRINGPROC FIELD"},{"location":"ObjectType/#the-dupintrepproc-field","text":"The dupIntRepProc member contains the address of a function called to copy an internal representation from one value to another. typedef void Tcl_DupInternalRepProc ( Tcl_Obj * srcPtr , Tcl_Obj * dupPtr ); dupPtr \\'s internal representation is made a copy of srcPtr \\'s internal representation. Before the call, srcPtr \\'s internal representation is valid and dupPtr \\'s is not. srcPtr \\'s value type determines what copying its internal representation means. For example, the dupIntRepProc for the Tcl integer type simply copies an integer. The built-in list type\\'s dupIntRepProc uses a far more sophisticated scheme to continue sharing storage as much as it reasonably can.","title":"THE DUPINTREPPROC FIELD"},{"location":"ObjectType/#the-freeintrepproc-field","text":"The freeIntRepProc member contains the address of a function that is called when a value is freed. typedef void Tcl_FreeInternalRepProc ( Tcl_Obj * objPtr ); The freeIntRepProc function can deallocate the storage for the value\\'s internal representation and do other type-specific processing necessary when a value is freed. For example, the list type\\'s freeIntRepProc respects the storage sharing scheme established by the dupIntRepProc so that it only frees storage when the last value sharing it is being freed. The freeIntRepProc member can be set to NULL to indicate that the internal representation does not require freeing. The freeIntRepProc implementation must not access the bytes member of the value, since Tcl makes its own internal uses of that field during value deletion. The defined tasks for the freeIntRepProc have no need to consult the bytes member. Note that if a subsidiary value has its reference count reduced to zero during the running of a freeIntRepProc , that value may be not freed immediately, in order to limit stack usage. However, the value will be freed before the outermost current Tcl_DecrRefCount returns.","title":"THE FREEINTREPPROC FIELD"},{"location":"ObjectType/#the-version-field","text":"The version member provides for future extensibility of the structure and should be set to TCL_OBJTYPE_V0 .","title":"THE VERSION FIELD"},{"location":"ObjectType/#reference-count-management","text":"The objPtr argument to Tcl_AppendAllObjTypes should be an unshared value; this function will not modify the reference count of that value, but will modify its contents. If objPtr is not (interpretable as) a list, this function will set the interpreter result and produce an error; using an unshared empty value is strongly recommended. The objPtr argument to Tcl_ConvertToType can have any non-zero reference count; this function will not modify the reference count, but may write to the interpreter result on error so values that originate from there should have an additional reference made before calling this. None of the callback functions in the Tcl_ObjType structure should modify the reference count of their arguments, but if the values contain subsidiary values (e.g., the elements of a list or the keys of a dictionary) then those subsidiary values may have their reference counts modified.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"ObjectType/#see-also","text":"Tcl_NewObj(3), Tcl_DecrRefCount(3), Tcl_IncrRefCount(3)","title":"SEE ALSO"},{"location":"ObjectType/#keywords","text":"internal representation, value, value type, string representation, type conversion","title":"KEYWORDS"},{"location":"OpenFileChnl/","text":"NAME Tcl_OpenFileChannel, Tcl_OpenCommandChannel, Tcl_MakeFileChannel, Tcl_GetChannel, Tcl_GetChannelNames, Tcl_GetChannelNamesEx, Tcl_RegisterChannel, Tcl_UnregisterChannel, Tcl_DetachChannel, Tcl_IsStandardChannel, Tcl_Close, Tcl_ReadChars, Tcl_Read, Tcl_GetsObj, Tcl_Gets, Tcl_WriteObj, Tcl_WriteChars, Tcl_Write, Tcl_Flush, Tcl_Seek, Tcl_Tell, Tcl_TruncateChannel, Tcl_GetChannelOption, Tcl_SetChannelOption, Tcl_Eof, Tcl_InputBlocked, Tcl_InputBuffered, Tcl_OutputBuffered, Tcl_Ungets, Tcl_ReadRaw, Tcl_WriteRaw - buffered I/O facilities using channels SYNOPSIS #include <tcl.h> Tcl_Channel Tcl_OpenFileChannel(interp, fileName, mode, permissions) Tcl_Channel Tcl_OpenCommandChannel(interp, argc, argv, flags) Tcl_Channel Tcl_MakeFileChannel(handle, readOrWrite) Tcl_Channel Tcl_GetChannel(interp, channelName, modePtr) int Tcl_GetChannelNames(interp) int Tcl_GetChannelNamesEx(interp, pattern) void Tcl_RegisterChannel(interp, channel) int Tcl_UnregisterChannel(interp, channel) int Tcl_DetachChannel(interp, channel) int Tcl_IsStandardChannel(channel) int Tcl_Close(interp, channel) int Tcl_ReadChars(channel, readObjPtr, charsToRead, appendFlag) int Tcl_Read(channel, readBuf, bytesToRead) Tcl_Size Tcl_GetsObj(channel, lineObjPtr) Tcl_Size Tcl_Gets(channel, lineRead) Tcl_Size Tcl_Ungets(channel, input, inputLen, addAtEnd) Tcl_Size Tcl_WriteObj(channel, writeObjPtr) Tcl_Size Tcl_WriteChars(channel, charBuf, bytesToWrite) Tcl_Size Tcl_Write(channel, byteBuf, bytesToWrite) Tcl_Size Tcl_ReadRaw(channel, readBuf, bytesToRead) Tcl_Size Tcl_WriteRaw(channel, byteBuf, bytesToWrite) int Tcl_Eof(channel) int Tcl_Flush(channel) int Tcl_InputBlocked(channel) int Tcl_InputBuffered(channel) int Tcl_OutputBuffered(channel) long long Tcl_Seek(channel, offset, seekMode) long long Tcl_Tell(channel) int Tcl_TruncateChannel(channel, length) int Tcl_GetChannelOption(interp, channel, optionName, optionValue) int Tcl_SetChannelOption(interp, channel, optionName, newValue) ARGUMENTS Used for error reporting and to look up a channel registered in it. The name of a local or network file. Specifies how the file is to be accessed. May have any of the values allowed for the mode argument to the Tcl open command. POSIX-style permission flags such as 0644. If a new file is created, these permissions will be set on the created file. The number of elements in argv . Arguments for constructing a command pipeline. These values have the same meaning as the non-switch arguments to the Tcl exec command. Specifies the disposition of the stdio handles in pipeline: OR-ed combination of TCL_STDIN , TCL_STDOUT , TCL_STDERR , and TCL_ENFORCE_MODE . If TCL_STDIN is set, stdin for the first child in the pipe is the pipe channel, otherwise it is the same as the standard input of the invoking process; likewise for TCL_STDOUT and TCL_STDERR . If TCL_ENFORCE_MODE is not set, then the pipe can redirect stdio handles to override the stdio handles for which TCL_STDIN , TCL_STDOUT and TCL_STDERR have been set. If it is set, then such redirections cause an error. Operating system specific handle for I/O to a file. For Unix this is a file descriptor, for Windows it is a HANDLE. OR-ed combination of TCL_READABLE and TCL_WRITABLE to indicate what operations are valid on handle . The name of the channel. Points at an integer variable that will receive an OR-ed combination of TCL_READABLE and TCL_WRITABLE denoting whether the channel is open for reading and writing. The pattern to match on, passed to Tcl_StringMatch, or NULL. A Tcl channel for input or output. Must have been the return value from a procedure such as Tcl_OpenFileChannel . A pointer to a Tcl value in which to store the characters read from the channel. The number of characters to read from the channel. If the channel\\'s encoding is binary , this is equivalent to the number of bytes to read from the channel. If non-zero, data read from the channel will be appended to the value. Otherwise, the data will replace the existing contents of the value. A buffer in which to store the bytes read from the channel. The number of bytes to read from the channel. The buffer readBuf must be large enough to hold this many bytes. A pointer to a Tcl value in which to store the line read from the channel. The line read will be appended to the current value of the value. A pointer to a Tcl dynamic string in which to store the line read from the channel. Must have been initialized by the caller. The line read will be appended to any data already in the dynamic string. The input to add to a channel buffer. Length of the input Flag indicating whether the input should be added to the end or beginning of the channel buffer. A pointer to a Tcl value whose contents will be output to the channel. A buffer containing the characters to output to the channel. A buffer containing the bytes to output to the channel. The number of bytes to consume from charBuf or byteBuf and output to the channel. How far to move the access point in the channel at which the next input or output operation will be applied, measured in bytes from the position given by seekMode . May be either positive or negative. Relative to which point to seek; used with offset to calculate the new access point for the channel. Legal values are SEEK_SET , SEEK_CUR , and SEEK_END . The (non-negative) length to truncate the channel the channel to. The name of an option applicable to this channel, such as -blocking . May have any of the values accepted by the fconfigure command. Where to store the value of an option or a list of all options and their values. Must have been initialized by the caller. New value for the option given by optionName . DESCRIPTION The Tcl channel mechanism provides a device-independent and platform-independent mechanism for performing buffered input and output operations on a variety of file, socket, and device types. The channel mechanism is extensible to new channel types, by providing a low-level channel driver for the new type; the channel driver interface is described in the manual entry for Tcl_CreateChannel . The channel mechanism provides a buffering scheme modeled after Unix\\'s standard I/O, and it also allows for nonblocking I/O on channels. The procedures described in this manual entry comprise the C APIs of the generic layer of the channel architecture. For a description of the channel driver architecture and how to implement channel drivers for new types of channels, see the manual entry for Tcl_CreateChannel . TCL_OPENFILECHANNEL Tcl_OpenFileChannel opens a file specified by fileName and returns a channel handle that can be used to perform input and output on the file. This API is modeled after the fopen procedure of the Unix standard I/O library. The syntax and meaning of all arguments is similar to those given in the Tcl open command when opening a file. If an error occurs while opening the channel, Tcl_OpenFileChannel returns NULL and records a POSIX error code that can be retrieved with Tcl_GetErrno . In addition, if interp is non-NULL, Tcl_OpenFileChannel leaves an error message in interp \\'s result after any error. As of Tcl 8.4, the value-based API Tcl_FSOpenFileChannel should be used in preference to Tcl_OpenFileChannel wherever possible. The newly created channel is not registered in the supplied interpreter; to register it, use Tcl_RegisterChannel , described below. If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel. TCL_OPENCOMMANDCHANNEL Tcl_OpenCommandChannel provides a C-level interface to the functions of the exec and open commands. It creates a sequence of subprocesses specified by the argv and argc arguments and returns a channel that can be used to communicate with these subprocesses. The flags argument indicates what sort of communication will exist with the command pipeline. If the TCL_STDIN flag is set then the standard input for the first subprocess will be tied to the channel: writing to the channel will provide input to the subprocess. If TCL_STDIN is not set, then standard input for the first subprocess will be the same as this application\\'s standard input. If TCL_STDOUT is set then standard output from the last subprocess can be read from the channel; otherwise it goes to this application\\'s standard output. If TCL_STDERR is set, standard error output for all subprocesses is returned to the channel and results in an error when the channel is closed; otherwise it goes to this application\\'s standard error. If TCL_ENFORCE_MODE is not set, then argc and argv can redirect the stdio handles to override TCL_STDIN , TCL_STDOUT , and TCL_STDERR ; if it is set, then it is an error for argc and argv to override stdio channels for which TCL_STDIN , TCL_STDOUT , and TCL_STDERR have been set. If an error occurs while opening the channel, Tcl_OpenCommandChannel returns NULL and records a POSIX error code that can be retrieved with Tcl_GetErrno . In addition, Tcl_OpenCommandChannel leaves an error message in the interpreter\\'s result. interp cannot be NULL. The newly created channel is not registered in the supplied interpreter; to register it, use Tcl_RegisterChannel , described below. If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel. TCL_MAKEFILECHANNEL Tcl_MakeFileChannel makes a Tcl_Channel from an existing, platform-specific, file handle. The newly created channel is not registered in the supplied interpreter; to register it, use Tcl_RegisterChannel , described below. If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel. TCL_GETCHANNEL Tcl_GetChannel returns a channel given the channelName used to create it with Tcl_CreateChannel and a pointer to a Tcl interpreter in interp . If a channel by that name is not registered in that interpreter, the procedure returns NULL. If the modePtr argument is not NULL, it points at an integer variable that will receive an OR-ed combination of TCL_READABLE and TCL_WRITABLE describing whether the channel is open for reading and writing. Tcl_GetChannelNames and Tcl_GetChannelNamesEx write the names of the registered channels to the interpreter\\'s result as a list value. Tcl_GetChannelNamesEx will filter these names according to the pattern . If pattern is NULL, then it will not do any filtering. The return value is TCL_OK if no errors occurred writing to the result, otherwise it is TCL_ERROR , and the error message is left in the interpreter\\'s result. TCL_REGISTERCHANNEL Tcl_RegisterChannel adds a channel to the set of channels accessible in interp . After this call, Tcl programs executing in that interpreter can refer to the channel in input or output operations using the name given in the call to Tcl_CreateChannel . After this call, the channel becomes the property of the interpreter, and the caller should not call Tcl_Close for the channel; the channel will be closed automatically when it is unregistered from the interpreter. Code executing outside of any Tcl interpreter can call Tcl_RegisterChannel with interp as NULL, to indicate that it wishes to hold a reference to this channel. Subsequently, the channel can be registered in a Tcl interpreter and it will only be closed when the matching number of calls to Tcl_UnregisterChannel have been made. This allows code executing outside of any interpreter to safely hold a reference to a channel that is also registered in a Tcl interpreter. This procedure interacts with the code managing the standard channels. If no standard channels were initialized before the first call to Tcl_RegisterChannel , they will get initialized by that call. See Tcl_StandardChannels for a general treatise about standard channels and the behavior of the Tcl library with regard to them. TCL_UNREGISTERCHANNEL Tcl_UnregisterChannel removes a channel from the set of channels accessible in interp . After this call, Tcl programs will no longer be able to use the channel\\'s name to refer to the channel in that interpreter. If this operation removed the last registration of the channel in any interpreter, the channel is also closed and destroyed. Code not associated with a Tcl interpreter can call Tcl_UnregisterChannel with interp as NULL, to indicate to Tcl that it no longer holds a reference to that channel. If this is the last reference to the channel, it will now be closed. Tcl_UnregisterChannel is very similar to Tcl_DetachChannel except that it will also close the channel if no further references to it exist. TCL_DETACHCHANNEL Tcl_DetachChannel removes a channel from the set of channels accessible in interp . After this call, Tcl programs will no longer be able to use the channel\\'s name to refer to the channel in that interpreter. Beyond that, this command has no further effect. It cannot be used on the standard channels ( stdout , stderr , stdin ), and will return TCL_ERROR if passed one of those channels. Code not associated with a Tcl interpreter can call Tcl_DetachChannel with interp as NULL, to indicate to Tcl that it no longer holds a reference to that channel. If this is the last reference to the channel, unlike Tcl_UnregisterChannel , it will not be closed. TCL_ISSTANDARDCHANNEL Tcl_IsStandardChannel tests whether a channel is one of the three standard channels, stdin , stdout or stderr . If so, it returns 1, otherwise 0. No attempt is made to check whether the given channel or the standard channels are initialized or otherwise valid. TCL_CLOSE Tcl_Close destroys the channel channel , which must denote a currently open channel. The channel should not be registered in any interpreter when Tcl_Close is called. Buffered output is flushed to the channel\\'s output device prior to destroying the channel, and any buffered input is discarded. If this is a blocking channel, the call does not return until all buffered data is successfully sent to the channel\\'s output device. If this is a nonblocking channel and there is buffered output that cannot be written without blocking, the call returns immediately; output is flushed in the background and the channel will be closed once all of the buffered data has been output. In this case errors during flushing are not reported. If the channel was closed successfully, Tcl_Close returns TCL_OK . If an error occurs, Tcl_Close returns TCL_ERROR and records a POSIX error code that can be retrieved with Tcl_GetErrno . If the channel is being closed synchronously and an error occurs during closing of the channel and interp is not NULL, an error message is left in the interpreter\\'s result. Note: it is not safe to call Tcl_Close on a channel that has been registered using Tcl_RegisterChannel ; see the documentation for Tcl_RegisterChannel , above, for details. If the channel has ever been given as the chan argument in a call to Tcl_RegisterChannel , you should instead use Tcl_UnregisterChannel , which will internally call Tcl_Close when all calls to Tcl_RegisterChannel have been matched by corresponding calls to Tcl_UnregisterChannel . TCL_READCHARS AND TCL_READ Tcl_ReadChars consumes bytes from channel , converting the bytes to UTF-8 based on the channel\\'s encoding and storing the produced data in readObjPtr \\'s string representation. The return value of Tcl_ReadChars is the number of characters, up to charsToRead , that were stored in readObjPtr . If an error occurs while reading, the return value is -1 and Tcl_ReadChars records a POSIX error code that can be retrieved with Tcl_GetErrno . Setting charsToRead to -1 will cause the command to read all characters currently available (non-blocking) or everything until eof (blocking mode). The return value may be smaller than the value to read, indicating that less data than requested was available. This is called a short read . In blocking mode, this can only happen on an end-of-file. In nonblocking mode, a short read can also occur if there is not enough input currently available: Tcl_ReadChars returns a short count rather than waiting for more data. If the channel is in blocking mode, a return value of zero indicates an end-of-file condition. If the channel is in nonblocking mode, a return value of zero indicates either that no input is currently available or an end-of-file condition. Use Tcl_Eof and Tcl_InputBlocked to tell which of these conditions actually occurred. Tcl_ReadChars translates the various end-of-line representations into the canonical \\n internal representation according to the current end-of-line recognition mode. End-of-line recognition and the various platform-specific modes are described in the manual entry for the Tcl fconfigure command. As a performance optimization, when reading from a channel with the encoding binary , the bytes are not converted to UTF-8 as they are read. Instead, they are stored in readObjPtr \\'s internal representation as a byte-array value. The string representation of this value will only be constructed if it is needed (e.g., because of a call to Tcl_GetStringFromObj ). In this way, byte-oriented data can be read from a channel, manipulated by calling Tcl_GetByteArrayFromObj and related functions, and then written to a channel without the expense of ever converting to or from UTF-8. Tcl_Read is similar to Tcl_ReadChars , except that it does not do encoding conversions, regardless of the channel\\'s encoding. It is deprecated and exists for backwards compatibility with non-internationalized Tcl extensions. It consumes bytes from channel and stores them in readBuf , performing end-of-line translations on the way. The return value of Tcl_Read is the number of bytes, up to bytesToRead , written in readBuf . The buffer produced by Tcl_Read is not null-terminated. Its contents are valid from the zeroth position up to and excluding the position indicated by the return value. Tcl_ReadRaw is the same as Tcl_Read but does not compensate for stacking. While Tcl_Read (and the other functions in the API) always get their data from the topmost channel in the stack the supplied channel is part of, Tcl_ReadRaw does not. Thus this function is only usable for transformational channel drivers, i.e. drivers used in the middle of a stack of channels, to move data from the channel below into the transformation. TCL_GETSOBJ AND TCL_GETS Tcl_GetsObj consumes bytes from channel , converting the bytes to UTF-8 based on the channel\\'s encoding, until a full line of input has been seen. If the channel\\'s encoding is binary , each byte read from the channel is treated as an individual Unicode character. All of the characters of the line except for the terminating end-of-line character(s) are appended to lineObjPtr \\'s string representation. The end-of-line character(s) are read and discarded. If a line was successfully read, the return value is greater than or equal to zero and indicates the number of bytes stored in lineObjPtr . If an error occurs, Tcl_GetsObj returns -1 and records a POSIX error code that can be retrieved with Tcl_GetErrno . Tcl_GetsObj also returns -1 if the end of the file is reached; the Tcl_Eof procedure can be used to distinguish an error from an end-of-file condition. If the channel is in nonblocking mode, the return value can also be -1 if no data was available or the data that was available did not contain an end-of-line character. When -1 is returned, the Tcl_InputBlocked procedure may be invoked to determine if the channel is blocked because of input unavailability. Tcl_Gets is the same as Tcl_GetsObj except the resulting characters are appended to the dynamic string given by lineRead rather than a Tcl value. TCL_UNGETS Tcl_Ungets is used to add data to the input queue of a channel, at either the head or tail of the queue. The pointer input points to the data that is to be added. The length of the input to add is given by inputLen . A non-zero value of addAtEnd indicates that the data is to be added at the end of queue; otherwise it will be added at the head of the queue. If channel has a EOF set, no data will be added to the input queue. Tcl_Ungets returns inputLen or -1 if an error occurs. TCL_WRITECHARS, TCL_WRITEOBJ, AND TCL_WRITE Tcl_WriteChars accepts bytesToWrite bytes of character data at charBuf . The UTF-8 characters in the buffer are converted to the channel\\'s encoding and queued for output to channel . If bytesToWrite is negative, Tcl_WriteChars expects charBuf to be null-terminated and it outputs everything up to the null. Data queued for output may not appear on the output device immediately, due to internal buffering. If the data should appear immediately, call Tcl_Flush after the call to Tcl_WriteChars , or set the -buffering option on the channel to none . If you wish the data to appear as soon as a complete line is accepted for output, set the -buffering option on the channel to line mode. The return value of Tcl_WriteChars is a count of how many bytes were accepted for output to the channel. This is either -1 to indicate that an error occurred or another number greater than zero to indicate success. If an error occurs, Tcl_WriteChars records a POSIX error code that may be retrieved with Tcl_GetErrno . Newline characters in the output data are translated to platform-specific end-of-line sequences according to the -translation option for the channel. This is done even if the channel has no encoding. Tcl_WriteObj is similar to Tcl_WriteChars except it accepts a Tcl value whose contents will be output to the channel. The UTF-8 characters in writeObjPtr \\'s string representation are converted to the channel\\'s encoding and queued for output to channel . As a performance optimization, when writing to a channel with the encoding binary , UTF-8 characters are not converted as they are written. Instead, the bytes in writeObjPtr \\'s internal representation as a byte-array value are written to the channel. The byte-array representation of the value will be constructed if it is needed. In this way, byte-oriented data can be read from a channel, manipulated by calling Tcl_GetByteArrayFromObj and related functions, and then written to a channel without the expense of ever converting to or from UTF-8. Tcl_Write is similar to Tcl_WriteChars except that it does not do encoding conversions, regardless of the channel\\'s encoding. It is deprecated and exists for backwards compatibility with non-internationalized Tcl extensions. It accepts bytesToWrite bytes of data at byteBuf and queues them for output to channel . If bytesToWrite is negative, Tcl_Write expects byteBuf to be null-terminated and it outputs everything up to the null. Tcl_WriteRaw is the same as Tcl_Write but does not compensate for stacking. While Tcl_Write (and the other functions in the API) always feed their input to the topmost channel in the stack the supplied channel is part of, Tcl_WriteRaw does not. Thus this function is only usable for transformational channel drivers, i.e. drivers used in the middle of a stack of channels, to move data from the transformation into the channel below it. TCL_FLUSH Tcl_Flush causes all of the buffered output data for channel to be written to its underlying file or device as soon as possible. If the channel is in blocking mode, the call does not return until all the buffered data has been sent to the channel or some error occurred. The call returns immediately if the channel is nonblocking; it starts a background flush that will write the buffered data to the channel eventually, as fast as the channel is able to absorb it. The return value is normally TCL_OK . If an error occurs, Tcl_Flush returns TCL_ERROR and records a POSIX error code that can be retrieved with Tcl_GetErrno . TCL_SEEK Tcl_Seek moves the access point in channel where subsequent data will be read or written. Buffered output is flushed to the channel and buffered input is discarded, prior to the seek operation. Tcl_Seek normally returns the new access point. If an error occurs, Tcl_Seek returns -1 and records a POSIX error code that can be retrieved with Tcl_GetErrno . After an error, the access point may or may not have been moved. TCL_TELL Tcl_Tell returns the current access point for a channel. The returned value is -1 if the channel does not support seeking. TCL_TRUNCATECHANNEL Tcl_TruncateChannel truncates the file underlying channel to a given length of bytes. It returns TCL_OK if the operation succeeded, and TCL_ERROR otherwise. TCL_GETCHANNELOPTION Tcl_GetChannelOption retrieves, in optionValue , the value of one of the options currently in effect for a channel, or a list of all options and their values. The channel argument identifies the channel for which to query an option or retrieve all options and their values. If optionName is not NULL, it is the name of the option to query; the option\\'s value is copied to the Tcl dynamic string denoted by optionValue . If optionName is NULL, the function stores an alternating list of option names and their values in optionValue , using a series of calls to Tcl_DStringAppendElement . The various preexisting options and their possible values are described in the manual entry for the Tcl fconfigure command. Other options can be added by each channel type. These channel type specific options are described in the manual entry for the Tcl command that creates a channel of that type; for example, the additional options for TCP-based channels are described in the manual entry for the Tcl socket command. The procedure normally returns TCL_OK . If an error occurs, it returns TCL_ERROR and calls Tcl_SetErrno to store an appropriate POSIX error code. TCL_SETCHANNELOPTION Tcl_SetChannelOption sets a new value newValue for an option optionName on channel . The procedure normally returns TCL_OK . If an error occurs, it returns TCL_ERROR ; in addition, if interp is non-NULL, Tcl_SetChannelOption leaves an error message in the interpreter\\'s result. TCL_EOF Tcl_Eof returns a nonzero value if channel encountered an end of file during the last input operation. TCL_INPUTBLOCKED Tcl_InputBlocked returns a nonzero value if channel is in nonblocking mode and the last input operation returned less data than requested because there was insufficient data available. The call always returns zero if the channel is in blocking mode. TCL_INPUTBUFFERED Tcl_InputBuffered returns the number of bytes of input currently buffered in the internal buffers for a channel. If the channel is not open for reading, this function always returns zero. TCL_OUTPUTBUFFERED Tcl_OutputBuffered returns the number of bytes of output currently buffered in the internal buffers for a channel. If the channel is not open for writing, this function always returns zero. PLATFORM ISSUES The handles returned from Tcl_GetChannelHandle depend on the platform and the channel type. On Unix platforms, the handle is always a Unix file descriptor as returned from the open system call. On Windows platforms, the handle is a file HANDLE when the channel was created with Tcl_OpenFileChannel , Tcl_OpenCommandChannel , or Tcl_MakeFileChannel . Other channel types may return a different type of handle on Windows platforms. REFERENCE COUNT MANAGEMENT The readObjPtr argument to Tcl_ReadChars must be an unshared value; it will be modified by this function. Using the interpreter result for this purpose is strongly not recommended; the preferred pattern is to use a new value from Tcl_NewObj to receive the data and only to pass it to Tcl_SetObjResult if this function succeeds. The lineObjPtr argument to Tcl_GetsObj must be an unshared value; it will be modified by this function. Using the interpreter result for this purpose is strongly not recommended; the preferred pattern is to use a new value from Tcl_NewObj to receive the data and only to pass it to Tcl_SetObjResult if this function succeeds. The writeObjPtr argument to Tcl_WriteObj should be a value with any reference count. This function will not modify the reference count. Using the interpreter result without adding an additional reference to it is not recommended. SEE ALSO DString(3), fconfigure(n), filename(n), fopen(3), Tcl_CreateChannel(3) KEYWORDS access point, blocking, buffered I/O, channel, channel driver, end of file, flush, input, nonblocking, output, read, seek, write","title":"NAME"},{"location":"OpenFileChnl/#name","text":"Tcl_OpenFileChannel, Tcl_OpenCommandChannel, Tcl_MakeFileChannel, Tcl_GetChannel, Tcl_GetChannelNames, Tcl_GetChannelNamesEx, Tcl_RegisterChannel, Tcl_UnregisterChannel, Tcl_DetachChannel, Tcl_IsStandardChannel, Tcl_Close, Tcl_ReadChars, Tcl_Read, Tcl_GetsObj, Tcl_Gets, Tcl_WriteObj, Tcl_WriteChars, Tcl_Write, Tcl_Flush, Tcl_Seek, Tcl_Tell, Tcl_TruncateChannel, Tcl_GetChannelOption, Tcl_SetChannelOption, Tcl_Eof, Tcl_InputBlocked, Tcl_InputBuffered, Tcl_OutputBuffered, Tcl_Ungets, Tcl_ReadRaw, Tcl_WriteRaw - buffered I/O facilities using channels","title":"NAME"},{"location":"OpenFileChnl/#synopsis","text":"#include <tcl.h> Tcl_Channel Tcl_OpenFileChannel(interp, fileName, mode, permissions) Tcl_Channel Tcl_OpenCommandChannel(interp, argc, argv, flags) Tcl_Channel Tcl_MakeFileChannel(handle, readOrWrite) Tcl_Channel Tcl_GetChannel(interp, channelName, modePtr) int Tcl_GetChannelNames(interp) int Tcl_GetChannelNamesEx(interp, pattern) void Tcl_RegisterChannel(interp, channel) int Tcl_UnregisterChannel(interp, channel) int Tcl_DetachChannel(interp, channel) int Tcl_IsStandardChannel(channel) int Tcl_Close(interp, channel) int Tcl_ReadChars(channel, readObjPtr, charsToRead, appendFlag) int Tcl_Read(channel, readBuf, bytesToRead) Tcl_Size Tcl_GetsObj(channel, lineObjPtr) Tcl_Size Tcl_Gets(channel, lineRead) Tcl_Size Tcl_Ungets(channel, input, inputLen, addAtEnd) Tcl_Size Tcl_WriteObj(channel, writeObjPtr) Tcl_Size Tcl_WriteChars(channel, charBuf, bytesToWrite) Tcl_Size Tcl_Write(channel, byteBuf, bytesToWrite) Tcl_Size Tcl_ReadRaw(channel, readBuf, bytesToRead) Tcl_Size Tcl_WriteRaw(channel, byteBuf, bytesToWrite) int Tcl_Eof(channel) int Tcl_Flush(channel) int Tcl_InputBlocked(channel) int Tcl_InputBuffered(channel) int Tcl_OutputBuffered(channel) long long Tcl_Seek(channel, offset, seekMode) long long Tcl_Tell(channel) int Tcl_TruncateChannel(channel, length) int Tcl_GetChannelOption(interp, channel, optionName, optionValue) int Tcl_SetChannelOption(interp, channel, optionName, newValue)","title":"SYNOPSIS"},{"location":"OpenFileChnl/#arguments","text":"Used for error reporting and to look up a channel registered in it. The name of a local or network file. Specifies how the file is to be accessed. May have any of the values allowed for the mode argument to the Tcl open command. POSIX-style permission flags such as 0644. If a new file is created, these permissions will be set on the created file. The number of elements in argv . Arguments for constructing a command pipeline. These values have the same meaning as the non-switch arguments to the Tcl exec command. Specifies the disposition of the stdio handles in pipeline: OR-ed combination of TCL_STDIN , TCL_STDOUT , TCL_STDERR , and TCL_ENFORCE_MODE . If TCL_STDIN is set, stdin for the first child in the pipe is the pipe channel, otherwise it is the same as the standard input of the invoking process; likewise for TCL_STDOUT and TCL_STDERR . If TCL_ENFORCE_MODE is not set, then the pipe can redirect stdio handles to override the stdio handles for which TCL_STDIN , TCL_STDOUT and TCL_STDERR have been set. If it is set, then such redirections cause an error. Operating system specific handle for I/O to a file. For Unix this is a file descriptor, for Windows it is a HANDLE. OR-ed combination of TCL_READABLE and TCL_WRITABLE to indicate what operations are valid on handle . The name of the channel. Points at an integer variable that will receive an OR-ed combination of TCL_READABLE and TCL_WRITABLE denoting whether the channel is open for reading and writing. The pattern to match on, passed to Tcl_StringMatch, or NULL. A Tcl channel for input or output. Must have been the return value from a procedure such as Tcl_OpenFileChannel . A pointer to a Tcl value in which to store the characters read from the channel. The number of characters to read from the channel. If the channel\\'s encoding is binary , this is equivalent to the number of bytes to read from the channel. If non-zero, data read from the channel will be appended to the value. Otherwise, the data will replace the existing contents of the value. A buffer in which to store the bytes read from the channel. The number of bytes to read from the channel. The buffer readBuf must be large enough to hold this many bytes. A pointer to a Tcl value in which to store the line read from the channel. The line read will be appended to the current value of the value. A pointer to a Tcl dynamic string in which to store the line read from the channel. Must have been initialized by the caller. The line read will be appended to any data already in the dynamic string. The input to add to a channel buffer. Length of the input Flag indicating whether the input should be added to the end or beginning of the channel buffer. A pointer to a Tcl value whose contents will be output to the channel. A buffer containing the characters to output to the channel. A buffer containing the bytes to output to the channel. The number of bytes to consume from charBuf or byteBuf and output to the channel. How far to move the access point in the channel at which the next input or output operation will be applied, measured in bytes from the position given by seekMode . May be either positive or negative. Relative to which point to seek; used with offset to calculate the new access point for the channel. Legal values are SEEK_SET , SEEK_CUR , and SEEK_END . The (non-negative) length to truncate the channel the channel to. The name of an option applicable to this channel, such as -blocking . May have any of the values accepted by the fconfigure command. Where to store the value of an option or a list of all options and their values. Must have been initialized by the caller. New value for the option given by optionName .","title":"ARGUMENTS"},{"location":"OpenFileChnl/#description","text":"The Tcl channel mechanism provides a device-independent and platform-independent mechanism for performing buffered input and output operations on a variety of file, socket, and device types. The channel mechanism is extensible to new channel types, by providing a low-level channel driver for the new type; the channel driver interface is described in the manual entry for Tcl_CreateChannel . The channel mechanism provides a buffering scheme modeled after Unix\\'s standard I/O, and it also allows for nonblocking I/O on channels. The procedures described in this manual entry comprise the C APIs of the generic layer of the channel architecture. For a description of the channel driver architecture and how to implement channel drivers for new types of channels, see the manual entry for Tcl_CreateChannel .","title":"DESCRIPTION"},{"location":"OpenFileChnl/#tcl_openfilechannel","text":"Tcl_OpenFileChannel opens a file specified by fileName and returns a channel handle that can be used to perform input and output on the file. This API is modeled after the fopen procedure of the Unix standard I/O library. The syntax and meaning of all arguments is similar to those given in the Tcl open command when opening a file. If an error occurs while opening the channel, Tcl_OpenFileChannel returns NULL and records a POSIX error code that can be retrieved with Tcl_GetErrno . In addition, if interp is non-NULL, Tcl_OpenFileChannel leaves an error message in interp \\'s result after any error. As of Tcl 8.4, the value-based API Tcl_FSOpenFileChannel should be used in preference to Tcl_OpenFileChannel wherever possible. The newly created channel is not registered in the supplied interpreter; to register it, use Tcl_RegisterChannel , described below. If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel.","title":"TCL_OPENFILECHANNEL"},{"location":"OpenFileChnl/#tcl_opencommandchannel","text":"Tcl_OpenCommandChannel provides a C-level interface to the functions of the exec and open commands. It creates a sequence of subprocesses specified by the argv and argc arguments and returns a channel that can be used to communicate with these subprocesses. The flags argument indicates what sort of communication will exist with the command pipeline. If the TCL_STDIN flag is set then the standard input for the first subprocess will be tied to the channel: writing to the channel will provide input to the subprocess. If TCL_STDIN is not set, then standard input for the first subprocess will be the same as this application\\'s standard input. If TCL_STDOUT is set then standard output from the last subprocess can be read from the channel; otherwise it goes to this application\\'s standard output. If TCL_STDERR is set, standard error output for all subprocesses is returned to the channel and results in an error when the channel is closed; otherwise it goes to this application\\'s standard error. If TCL_ENFORCE_MODE is not set, then argc and argv can redirect the stdio handles to override TCL_STDIN , TCL_STDOUT , and TCL_STDERR ; if it is set, then it is an error for argc and argv to override stdio channels for which TCL_STDIN , TCL_STDOUT , and TCL_STDERR have been set. If an error occurs while opening the channel, Tcl_OpenCommandChannel returns NULL and records a POSIX error code that can be retrieved with Tcl_GetErrno . In addition, Tcl_OpenCommandChannel leaves an error message in the interpreter\\'s result. interp cannot be NULL. The newly created channel is not registered in the supplied interpreter; to register it, use Tcl_RegisterChannel , described below. If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel.","title":"TCL_OPENCOMMANDCHANNEL"},{"location":"OpenFileChnl/#tcl_makefilechannel","text":"Tcl_MakeFileChannel makes a Tcl_Channel from an existing, platform-specific, file handle. The newly created channel is not registered in the supplied interpreter; to register it, use Tcl_RegisterChannel , described below. If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel.","title":"TCL_MAKEFILECHANNEL"},{"location":"OpenFileChnl/#tcl_getchannel","text":"Tcl_GetChannel returns a channel given the channelName used to create it with Tcl_CreateChannel and a pointer to a Tcl interpreter in interp . If a channel by that name is not registered in that interpreter, the procedure returns NULL. If the modePtr argument is not NULL, it points at an integer variable that will receive an OR-ed combination of TCL_READABLE and TCL_WRITABLE describing whether the channel is open for reading and writing. Tcl_GetChannelNames and Tcl_GetChannelNamesEx write the names of the registered channels to the interpreter\\'s result as a list value. Tcl_GetChannelNamesEx will filter these names according to the pattern . If pattern is NULL, then it will not do any filtering. The return value is TCL_OK if no errors occurred writing to the result, otherwise it is TCL_ERROR , and the error message is left in the interpreter\\'s result.","title":"TCL_GETCHANNEL"},{"location":"OpenFileChnl/#tcl_registerchannel","text":"Tcl_RegisterChannel adds a channel to the set of channels accessible in interp . After this call, Tcl programs executing in that interpreter can refer to the channel in input or output operations using the name given in the call to Tcl_CreateChannel . After this call, the channel becomes the property of the interpreter, and the caller should not call Tcl_Close for the channel; the channel will be closed automatically when it is unregistered from the interpreter. Code executing outside of any Tcl interpreter can call Tcl_RegisterChannel with interp as NULL, to indicate that it wishes to hold a reference to this channel. Subsequently, the channel can be registered in a Tcl interpreter and it will only be closed when the matching number of calls to Tcl_UnregisterChannel have been made. This allows code executing outside of any interpreter to safely hold a reference to a channel that is also registered in a Tcl interpreter. This procedure interacts with the code managing the standard channels. If no standard channels were initialized before the first call to Tcl_RegisterChannel , they will get initialized by that call. See Tcl_StandardChannels for a general treatise about standard channels and the behavior of the Tcl library with regard to them.","title":"TCL_REGISTERCHANNEL"},{"location":"OpenFileChnl/#tcl_unregisterchannel","text":"Tcl_UnregisterChannel removes a channel from the set of channels accessible in interp . After this call, Tcl programs will no longer be able to use the channel\\'s name to refer to the channel in that interpreter. If this operation removed the last registration of the channel in any interpreter, the channel is also closed and destroyed. Code not associated with a Tcl interpreter can call Tcl_UnregisterChannel with interp as NULL, to indicate to Tcl that it no longer holds a reference to that channel. If this is the last reference to the channel, it will now be closed. Tcl_UnregisterChannel is very similar to Tcl_DetachChannel except that it will also close the channel if no further references to it exist.","title":"TCL_UNREGISTERCHANNEL"},{"location":"OpenFileChnl/#tcl_detachchannel","text":"Tcl_DetachChannel removes a channel from the set of channels accessible in interp . After this call, Tcl programs will no longer be able to use the channel\\'s name to refer to the channel in that interpreter. Beyond that, this command has no further effect. It cannot be used on the standard channels ( stdout , stderr , stdin ), and will return TCL_ERROR if passed one of those channels. Code not associated with a Tcl interpreter can call Tcl_DetachChannel with interp as NULL, to indicate to Tcl that it no longer holds a reference to that channel. If this is the last reference to the channel, unlike Tcl_UnregisterChannel , it will not be closed.","title":"TCL_DETACHCHANNEL"},{"location":"OpenFileChnl/#tcl_isstandardchannel","text":"Tcl_IsStandardChannel tests whether a channel is one of the three standard channels, stdin , stdout or stderr . If so, it returns 1, otherwise 0. No attempt is made to check whether the given channel or the standard channels are initialized or otherwise valid.","title":"TCL_ISSTANDARDCHANNEL"},{"location":"OpenFileChnl/#tcl_close","text":"Tcl_Close destroys the channel channel , which must denote a currently open channel. The channel should not be registered in any interpreter when Tcl_Close is called. Buffered output is flushed to the channel\\'s output device prior to destroying the channel, and any buffered input is discarded. If this is a blocking channel, the call does not return until all buffered data is successfully sent to the channel\\'s output device. If this is a nonblocking channel and there is buffered output that cannot be written without blocking, the call returns immediately; output is flushed in the background and the channel will be closed once all of the buffered data has been output. In this case errors during flushing are not reported. If the channel was closed successfully, Tcl_Close returns TCL_OK . If an error occurs, Tcl_Close returns TCL_ERROR and records a POSIX error code that can be retrieved with Tcl_GetErrno . If the channel is being closed synchronously and an error occurs during closing of the channel and interp is not NULL, an error message is left in the interpreter\\'s result. Note: it is not safe to call Tcl_Close on a channel that has been registered using Tcl_RegisterChannel ; see the documentation for Tcl_RegisterChannel , above, for details. If the channel has ever been given as the chan argument in a call to Tcl_RegisterChannel , you should instead use Tcl_UnregisterChannel , which will internally call Tcl_Close when all calls to Tcl_RegisterChannel have been matched by corresponding calls to Tcl_UnregisterChannel .","title":"TCL_CLOSE"},{"location":"OpenFileChnl/#tcl_readchars-and-tcl_read","text":"Tcl_ReadChars consumes bytes from channel , converting the bytes to UTF-8 based on the channel\\'s encoding and storing the produced data in readObjPtr \\'s string representation. The return value of Tcl_ReadChars is the number of characters, up to charsToRead , that were stored in readObjPtr . If an error occurs while reading, the return value is -1 and Tcl_ReadChars records a POSIX error code that can be retrieved with Tcl_GetErrno . Setting charsToRead to -1 will cause the command to read all characters currently available (non-blocking) or everything until eof (blocking mode). The return value may be smaller than the value to read, indicating that less data than requested was available. This is called a short read . In blocking mode, this can only happen on an end-of-file. In nonblocking mode, a short read can also occur if there is not enough input currently available: Tcl_ReadChars returns a short count rather than waiting for more data. If the channel is in blocking mode, a return value of zero indicates an end-of-file condition. If the channel is in nonblocking mode, a return value of zero indicates either that no input is currently available or an end-of-file condition. Use Tcl_Eof and Tcl_InputBlocked to tell which of these conditions actually occurred. Tcl_ReadChars translates the various end-of-line representations into the canonical \\n internal representation according to the current end-of-line recognition mode. End-of-line recognition and the various platform-specific modes are described in the manual entry for the Tcl fconfigure command. As a performance optimization, when reading from a channel with the encoding binary , the bytes are not converted to UTF-8 as they are read. Instead, they are stored in readObjPtr \\'s internal representation as a byte-array value. The string representation of this value will only be constructed if it is needed (e.g., because of a call to Tcl_GetStringFromObj ). In this way, byte-oriented data can be read from a channel, manipulated by calling Tcl_GetByteArrayFromObj and related functions, and then written to a channel without the expense of ever converting to or from UTF-8. Tcl_Read is similar to Tcl_ReadChars , except that it does not do encoding conversions, regardless of the channel\\'s encoding. It is deprecated and exists for backwards compatibility with non-internationalized Tcl extensions. It consumes bytes from channel and stores them in readBuf , performing end-of-line translations on the way. The return value of Tcl_Read is the number of bytes, up to bytesToRead , written in readBuf . The buffer produced by Tcl_Read is not null-terminated. Its contents are valid from the zeroth position up to and excluding the position indicated by the return value. Tcl_ReadRaw is the same as Tcl_Read but does not compensate for stacking. While Tcl_Read (and the other functions in the API) always get their data from the topmost channel in the stack the supplied channel is part of, Tcl_ReadRaw does not. Thus this function is only usable for transformational channel drivers, i.e. drivers used in the middle of a stack of channels, to move data from the channel below into the transformation.","title":"TCL_READCHARS AND TCL_READ"},{"location":"OpenFileChnl/#tcl_getsobj-and-tcl_gets","text":"Tcl_GetsObj consumes bytes from channel , converting the bytes to UTF-8 based on the channel\\'s encoding, until a full line of input has been seen. If the channel\\'s encoding is binary , each byte read from the channel is treated as an individual Unicode character. All of the characters of the line except for the terminating end-of-line character(s) are appended to lineObjPtr \\'s string representation. The end-of-line character(s) are read and discarded. If a line was successfully read, the return value is greater than or equal to zero and indicates the number of bytes stored in lineObjPtr . If an error occurs, Tcl_GetsObj returns -1 and records a POSIX error code that can be retrieved with Tcl_GetErrno . Tcl_GetsObj also returns -1 if the end of the file is reached; the Tcl_Eof procedure can be used to distinguish an error from an end-of-file condition. If the channel is in nonblocking mode, the return value can also be -1 if no data was available or the data that was available did not contain an end-of-line character. When -1 is returned, the Tcl_InputBlocked procedure may be invoked to determine if the channel is blocked because of input unavailability. Tcl_Gets is the same as Tcl_GetsObj except the resulting characters are appended to the dynamic string given by lineRead rather than a Tcl value.","title":"TCL_GETSOBJ AND TCL_GETS"},{"location":"OpenFileChnl/#tcl_ungets","text":"Tcl_Ungets is used to add data to the input queue of a channel, at either the head or tail of the queue. The pointer input points to the data that is to be added. The length of the input to add is given by inputLen . A non-zero value of addAtEnd indicates that the data is to be added at the end of queue; otherwise it will be added at the head of the queue. If channel has a EOF set, no data will be added to the input queue. Tcl_Ungets returns inputLen or -1 if an error occurs.","title":"TCL_UNGETS"},{"location":"OpenFileChnl/#tcl_writechars-tcl_writeobj-and-tcl_write","text":"Tcl_WriteChars accepts bytesToWrite bytes of character data at charBuf . The UTF-8 characters in the buffer are converted to the channel\\'s encoding and queued for output to channel . If bytesToWrite is negative, Tcl_WriteChars expects charBuf to be null-terminated and it outputs everything up to the null. Data queued for output may not appear on the output device immediately, due to internal buffering. If the data should appear immediately, call Tcl_Flush after the call to Tcl_WriteChars , or set the -buffering option on the channel to none . If you wish the data to appear as soon as a complete line is accepted for output, set the -buffering option on the channel to line mode. The return value of Tcl_WriteChars is a count of how many bytes were accepted for output to the channel. This is either -1 to indicate that an error occurred or another number greater than zero to indicate success. If an error occurs, Tcl_WriteChars records a POSIX error code that may be retrieved with Tcl_GetErrno . Newline characters in the output data are translated to platform-specific end-of-line sequences according to the -translation option for the channel. This is done even if the channel has no encoding. Tcl_WriteObj is similar to Tcl_WriteChars except it accepts a Tcl value whose contents will be output to the channel. The UTF-8 characters in writeObjPtr \\'s string representation are converted to the channel\\'s encoding and queued for output to channel . As a performance optimization, when writing to a channel with the encoding binary , UTF-8 characters are not converted as they are written. Instead, the bytes in writeObjPtr \\'s internal representation as a byte-array value are written to the channel. The byte-array representation of the value will be constructed if it is needed. In this way, byte-oriented data can be read from a channel, manipulated by calling Tcl_GetByteArrayFromObj and related functions, and then written to a channel without the expense of ever converting to or from UTF-8. Tcl_Write is similar to Tcl_WriteChars except that it does not do encoding conversions, regardless of the channel\\'s encoding. It is deprecated and exists for backwards compatibility with non-internationalized Tcl extensions. It accepts bytesToWrite bytes of data at byteBuf and queues them for output to channel . If bytesToWrite is negative, Tcl_Write expects byteBuf to be null-terminated and it outputs everything up to the null. Tcl_WriteRaw is the same as Tcl_Write but does not compensate for stacking. While Tcl_Write (and the other functions in the API) always feed their input to the topmost channel in the stack the supplied channel is part of, Tcl_WriteRaw does not. Thus this function is only usable for transformational channel drivers, i.e. drivers used in the middle of a stack of channels, to move data from the transformation into the channel below it.","title":"TCL_WRITECHARS, TCL_WRITEOBJ, AND TCL_WRITE"},{"location":"OpenFileChnl/#tcl_flush","text":"Tcl_Flush causes all of the buffered output data for channel to be written to its underlying file or device as soon as possible. If the channel is in blocking mode, the call does not return until all the buffered data has been sent to the channel or some error occurred. The call returns immediately if the channel is nonblocking; it starts a background flush that will write the buffered data to the channel eventually, as fast as the channel is able to absorb it. The return value is normally TCL_OK . If an error occurs, Tcl_Flush returns TCL_ERROR and records a POSIX error code that can be retrieved with Tcl_GetErrno .","title":"TCL_FLUSH"},{"location":"OpenFileChnl/#tcl_seek","text":"Tcl_Seek moves the access point in channel where subsequent data will be read or written. Buffered output is flushed to the channel and buffered input is discarded, prior to the seek operation. Tcl_Seek normally returns the new access point. If an error occurs, Tcl_Seek returns -1 and records a POSIX error code that can be retrieved with Tcl_GetErrno . After an error, the access point may or may not have been moved.","title":"TCL_SEEK"},{"location":"OpenFileChnl/#tcl_tell","text":"Tcl_Tell returns the current access point for a channel. The returned value is -1 if the channel does not support seeking.","title":"TCL_TELL"},{"location":"OpenFileChnl/#tcl_truncatechannel","text":"Tcl_TruncateChannel truncates the file underlying channel to a given length of bytes. It returns TCL_OK if the operation succeeded, and TCL_ERROR otherwise.","title":"TCL_TRUNCATECHANNEL"},{"location":"OpenFileChnl/#tcl_getchanneloption","text":"Tcl_GetChannelOption retrieves, in optionValue , the value of one of the options currently in effect for a channel, or a list of all options and their values. The channel argument identifies the channel for which to query an option or retrieve all options and their values. If optionName is not NULL, it is the name of the option to query; the option\\'s value is copied to the Tcl dynamic string denoted by optionValue . If optionName is NULL, the function stores an alternating list of option names and their values in optionValue , using a series of calls to Tcl_DStringAppendElement . The various preexisting options and their possible values are described in the manual entry for the Tcl fconfigure command. Other options can be added by each channel type. These channel type specific options are described in the manual entry for the Tcl command that creates a channel of that type; for example, the additional options for TCP-based channels are described in the manual entry for the Tcl socket command. The procedure normally returns TCL_OK . If an error occurs, it returns TCL_ERROR and calls Tcl_SetErrno to store an appropriate POSIX error code.","title":"TCL_GETCHANNELOPTION"},{"location":"OpenFileChnl/#tcl_setchanneloption","text":"Tcl_SetChannelOption sets a new value newValue for an option optionName on channel . The procedure normally returns TCL_OK . If an error occurs, it returns TCL_ERROR ; in addition, if interp is non-NULL, Tcl_SetChannelOption leaves an error message in the interpreter\\'s result.","title":"TCL_SETCHANNELOPTION"},{"location":"OpenFileChnl/#tcl_eof","text":"Tcl_Eof returns a nonzero value if channel encountered an end of file during the last input operation.","title":"TCL_EOF"},{"location":"OpenFileChnl/#tcl_inputblocked","text":"Tcl_InputBlocked returns a nonzero value if channel is in nonblocking mode and the last input operation returned less data than requested because there was insufficient data available. The call always returns zero if the channel is in blocking mode.","title":"TCL_INPUTBLOCKED"},{"location":"OpenFileChnl/#tcl_inputbuffered","text":"Tcl_InputBuffered returns the number of bytes of input currently buffered in the internal buffers for a channel. If the channel is not open for reading, this function always returns zero.","title":"TCL_INPUTBUFFERED"},{"location":"OpenFileChnl/#tcl_outputbuffered","text":"Tcl_OutputBuffered returns the number of bytes of output currently buffered in the internal buffers for a channel. If the channel is not open for writing, this function always returns zero.","title":"TCL_OUTPUTBUFFERED"},{"location":"OpenFileChnl/#platform-issues","text":"The handles returned from Tcl_GetChannelHandle depend on the platform and the channel type. On Unix platforms, the handle is always a Unix file descriptor as returned from the open system call. On Windows platforms, the handle is a file HANDLE when the channel was created with Tcl_OpenFileChannel , Tcl_OpenCommandChannel , or Tcl_MakeFileChannel . Other channel types may return a different type of handle on Windows platforms.","title":"PLATFORM ISSUES"},{"location":"OpenFileChnl/#reference-count-management","text":"The readObjPtr argument to Tcl_ReadChars must be an unshared value; it will be modified by this function. Using the interpreter result for this purpose is strongly not recommended; the preferred pattern is to use a new value from Tcl_NewObj to receive the data and only to pass it to Tcl_SetObjResult if this function succeeds. The lineObjPtr argument to Tcl_GetsObj must be an unshared value; it will be modified by this function. Using the interpreter result for this purpose is strongly not recommended; the preferred pattern is to use a new value from Tcl_NewObj to receive the data and only to pass it to Tcl_SetObjResult if this function succeeds. The writeObjPtr argument to Tcl_WriteObj should be a value with any reference count. This function will not modify the reference count. Using the interpreter result without adding an additional reference to it is not recommended.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"OpenFileChnl/#see-also","text":"DString(3), fconfigure(n), filename(n), fopen(3), Tcl_CreateChannel(3)","title":"SEE ALSO"},{"location":"OpenFileChnl/#keywords","text":"access point, blocking, buffered I/O, channel, channel driver, end of file, flush, input, nonblocking, output, read, seek, write","title":"KEYWORDS"},{"location":"OpenTcp/","text":"NAME Tcl_OpenTcpClient, Tcl_MakeTcpClientChannel, Tcl_OpenTcpServer, Tcl_OpenTcpServerEx - procedures to open channels using TCP sockets SYNOPSIS #include <tcl.h> Tcl_Channel Tcl_OpenTcpClient(interp, port, host, myaddr, myport, async) Tcl_Channel Tcl_MakeTcpClientChannel(sock) Tcl_Channel Tcl_OpenTcpServer(interp, port, myaddr, proc, clientData) Tcl_Channel Tcl_OpenTcpServerEx(interp, service, myaddr, flags, backlog, proc, clientData) ARGUMENTS Tcl interpreter to use for error reporting. If non-NULL and an error occurs, an error message is left in the interpreter\\'s result. A port number to connect to as a client or to listen on as a server. A string specifying the port number to connect to as a client or to listen on as a server. A string specifying a host name or address for the remote end of the connection. A port number for the client\\'s end of the socket. If 0, a port number is allocated at random. A string specifying the host name or address for network interface to use for the local end of the connection. If NULL, a default interface is chosen. If nonzero, the client socket is connected asynchronously to the server. Length of OS listen backlog queue. Use -1 for default value. ORed combination of TCL_TCPSERVER flags that specify additional informations about the socket being created. Platform-specific handle for client TCP socket. Pointer to a procedure to invoke each time a new connection is accepted via the socket. Arbitrary one-word value to pass to proc . DESCRIPTION These functions are convenience procedures for creating channels that communicate over TCP sockets. The operations on a channel are described in the manual entry for Tcl_OpenFileChannel . TCL_OPENTCPCLIENT Tcl_OpenTcpClient opens a client TCP socket connected to a port on a specific host , and returns a channel that can be used to communicate with the server. The host to connect to can be specified either as a domain name style name (e.g. www.sunlabs.com ), or as a string containing the alphanumeric representation of its four-byte address (e.g. 127.0.0.1 ). Use the string localhost to connect to a TCP socket on the host on which the function is invoked. The myaddr and myport arguments allow a client to specify an address for the local end of the connection. If myaddr is NULL, then an interface is chosen automatically by the operating system. If myport is 0, then a port number is chosen at random by the operating system. If async is zero, the call to Tcl_OpenTcpClient returns only after the client socket has either successfully connected to the server, or the attempted connection has failed. If async is nonzero the socket is connected asynchronously and the returned channel may not yet be connected to the server when the call to Tcl_OpenTcpClient returns. If the channel is in blocking mode and an input or output operation is done on the channel before the connection is completed or fails, that operation will wait until the connection either completes successfully or fails. If the channel is in nonblocking mode, the input or output operation will return immediately and a subsequent call to Tcl_InputBlocked on the channel will return nonzero. The returned channel is opened for reading and writing. If an error occurs in opening the socket, Tcl_OpenTcpClient returns NULL and records a POSIX error code that can be retrieved with Tcl_GetErrno . In addition, if interp is non-NULL, an error message is left in the interpreter\\'s result. The newly created channel is not registered in the supplied interpreter; to register it, use Tcl_RegisterChannel . If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel. TCL_MAKETCPCLIENTCHANNEL Tcl_MakeTcpClientChannel creates a Tcl_Channel around an existing, platform specific, handle for a client TCP socket. The newly created channel is not registered in the supplied interpreter; to register it, use Tcl_RegisterChannel . If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel. TCL_OPENTCPSERVER Tcl_OpenTcpServer opens a TCP socket on the local host on a specified port and uses the Tcl event mechanism to accept requests from clients to connect to it. The myaddr argument specifies the network interface. If myaddr is NULL the special address INADDR_ANY should be used to allow connections from any network interface. Each time a client connects to this socket, Tcl creates a channel for the new connection and invokes proc with information about the channel. Proc must match the following prototype: typedef void Tcl_TcpAcceptProc ( void * clientData , Tcl_Channel channel , char * hostName , int port ); The clientData argument will be the same as the clientData argument to Tcl_OpenTcpServer , channel will be the handle for the new channel, hostName points to a string containing the name of the client host making the connection, and port will contain the client\\'s port number. The new channel is opened for both input and output. If proc raises an error, the connection is closed automatically. Proc has no return value, but if it wishes to reject the connection it can close channel . Tcl_OpenTcpServer normally returns a pointer to a channel representing the server socket. If an error occurs, Tcl_OpenTcpServer returns NULL and records a POSIX error code that can be retrieved with Tcl_GetErrno . In addition, if the interpreter is non-NULL, an error message is left in the interpreter\\'s result. The channel returned by Tcl_OpenTcpServer cannot be used for either input or output. It is simply a handle for the socket used to accept connections. The caller can close the channel to shut down the server and disallow further connections from new clients. TCP server channels operate correctly only in applications that dispatch events through Tcl_DoOneEvent or through Tcl commands such as vwait ; otherwise Tcl will never notice that a connection request from a remote client is pending. The newly created channel is not registered in the supplied interpreter; to register it, use Tcl_RegisterChannel . If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel. TCL_OPENTCPSERVEREX Tcl_OpenTcpServerEx behaviour is identical to Tcl_OpenTcpServer but gives more flexibility to the user by providing a mean to further customize some aspects of the socket via the flags parameter. PLATFORM ISSUES On Unix platforms, the socket handle is a Unix file descriptor as returned by the socket system call. On the Windows platform, the socket handle is a SOCKET as defined in the WinSock API. SEE ALSO Tcl_OpenFileChannel(3), Tcl_RegisterChannel(3), vwait(n) KEYWORDS channel, client, server, socket, TCP","title":"NAME"},{"location":"OpenTcp/#name","text":"Tcl_OpenTcpClient, Tcl_MakeTcpClientChannel, Tcl_OpenTcpServer, Tcl_OpenTcpServerEx - procedures to open channels using TCP sockets","title":"NAME"},{"location":"OpenTcp/#synopsis","text":"#include <tcl.h> Tcl_Channel Tcl_OpenTcpClient(interp, port, host, myaddr, myport, async) Tcl_Channel Tcl_MakeTcpClientChannel(sock) Tcl_Channel Tcl_OpenTcpServer(interp, port, myaddr, proc, clientData) Tcl_Channel Tcl_OpenTcpServerEx(interp, service, myaddr, flags, backlog, proc, clientData)","title":"SYNOPSIS"},{"location":"OpenTcp/#arguments","text":"Tcl interpreter to use for error reporting. If non-NULL and an error occurs, an error message is left in the interpreter\\'s result. A port number to connect to as a client or to listen on as a server. A string specifying the port number to connect to as a client or to listen on as a server. A string specifying a host name or address for the remote end of the connection. A port number for the client\\'s end of the socket. If 0, a port number is allocated at random. A string specifying the host name or address for network interface to use for the local end of the connection. If NULL, a default interface is chosen. If nonzero, the client socket is connected asynchronously to the server. Length of OS listen backlog queue. Use -1 for default value. ORed combination of TCL_TCPSERVER flags that specify additional informations about the socket being created. Platform-specific handle for client TCP socket. Pointer to a procedure to invoke each time a new connection is accepted via the socket. Arbitrary one-word value to pass to proc .","title":"ARGUMENTS"},{"location":"OpenTcp/#description","text":"These functions are convenience procedures for creating channels that communicate over TCP sockets. The operations on a channel are described in the manual entry for Tcl_OpenFileChannel .","title":"DESCRIPTION"},{"location":"OpenTcp/#tcl_opentcpclient","text":"Tcl_OpenTcpClient opens a client TCP socket connected to a port on a specific host , and returns a channel that can be used to communicate with the server. The host to connect to can be specified either as a domain name style name (e.g. www.sunlabs.com ), or as a string containing the alphanumeric representation of its four-byte address (e.g. 127.0.0.1 ). Use the string localhost to connect to a TCP socket on the host on which the function is invoked. The myaddr and myport arguments allow a client to specify an address for the local end of the connection. If myaddr is NULL, then an interface is chosen automatically by the operating system. If myport is 0, then a port number is chosen at random by the operating system. If async is zero, the call to Tcl_OpenTcpClient returns only after the client socket has either successfully connected to the server, or the attempted connection has failed. If async is nonzero the socket is connected asynchronously and the returned channel may not yet be connected to the server when the call to Tcl_OpenTcpClient returns. If the channel is in blocking mode and an input or output operation is done on the channel before the connection is completed or fails, that operation will wait until the connection either completes successfully or fails. If the channel is in nonblocking mode, the input or output operation will return immediately and a subsequent call to Tcl_InputBlocked on the channel will return nonzero. The returned channel is opened for reading and writing. If an error occurs in opening the socket, Tcl_OpenTcpClient returns NULL and records a POSIX error code that can be retrieved with Tcl_GetErrno . In addition, if interp is non-NULL, an error message is left in the interpreter\\'s result. The newly created channel is not registered in the supplied interpreter; to register it, use Tcl_RegisterChannel . If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel.","title":"TCL_OPENTCPCLIENT"},{"location":"OpenTcp/#tcl_maketcpclientchannel","text":"Tcl_MakeTcpClientChannel creates a Tcl_Channel around an existing, platform specific, handle for a client TCP socket. The newly created channel is not registered in the supplied interpreter; to register it, use Tcl_RegisterChannel . If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel.","title":"TCL_MAKETCPCLIENTCHANNEL"},{"location":"OpenTcp/#tcl_opentcpserver","text":"Tcl_OpenTcpServer opens a TCP socket on the local host on a specified port and uses the Tcl event mechanism to accept requests from clients to connect to it. The myaddr argument specifies the network interface. If myaddr is NULL the special address INADDR_ANY should be used to allow connections from any network interface. Each time a client connects to this socket, Tcl creates a channel for the new connection and invokes proc with information about the channel. Proc must match the following prototype: typedef void Tcl_TcpAcceptProc ( void * clientData , Tcl_Channel channel , char * hostName , int port ); The clientData argument will be the same as the clientData argument to Tcl_OpenTcpServer , channel will be the handle for the new channel, hostName points to a string containing the name of the client host making the connection, and port will contain the client\\'s port number. The new channel is opened for both input and output. If proc raises an error, the connection is closed automatically. Proc has no return value, but if it wishes to reject the connection it can close channel . Tcl_OpenTcpServer normally returns a pointer to a channel representing the server socket. If an error occurs, Tcl_OpenTcpServer returns NULL and records a POSIX error code that can be retrieved with Tcl_GetErrno . In addition, if the interpreter is non-NULL, an error message is left in the interpreter\\'s result. The channel returned by Tcl_OpenTcpServer cannot be used for either input or output. It is simply a handle for the socket used to accept connections. The caller can close the channel to shut down the server and disallow further connections from new clients. TCP server channels operate correctly only in applications that dispatch events through Tcl_DoOneEvent or through Tcl commands such as vwait ; otherwise Tcl will never notice that a connection request from a remote client is pending. The newly created channel is not registered in the supplied interpreter; to register it, use Tcl_RegisterChannel . If one of the standard channels, stdin , stdout or stderr was previously closed, the act of creating the new channel also assigns it as a replacement for the standard channel.","title":"TCL_OPENTCPSERVER"},{"location":"OpenTcp/#tcl_opentcpserverex","text":"Tcl_OpenTcpServerEx behaviour is identical to Tcl_OpenTcpServer but gives more flexibility to the user by providing a mean to further customize some aspects of the socket via the flags parameter.","title":"TCL_OPENTCPSERVEREX"},{"location":"OpenTcp/#platform-issues","text":"On Unix platforms, the socket handle is a Unix file descriptor as returned by the socket system call. On the Windows platform, the socket handle is a SOCKET as defined in the WinSock API.","title":"PLATFORM ISSUES"},{"location":"OpenTcp/#see-also","text":"Tcl_OpenFileChannel(3), Tcl_RegisterChannel(3), vwait(n)","title":"SEE ALSO"},{"location":"OpenTcp/#keywords","text":"channel, client, server, socket, TCP","title":"KEYWORDS"},{"location":"Panic/","text":"NAME Tcl_Panic, Tcl_SetPanicProc, Tcl_ConsolePanic - report fatal error and abort SYNOPSIS #include <tcl.h> void Tcl_Panic(format, arg, arg, ...) const char * Tcl_SetPanicProc(panicProc) void Tcl_ConsolePanic(format, arg, arg, ...) ARGUMENTS A printf-style format string. Arguments matching the format string. Procedure to report fatal error message and abort. DESCRIPTION When the Tcl library detects that its internal data structures are in an inconsistent state, or that its C procedures have been called in a manner inconsistent with their documentation, it calls Tcl_Panic to display a message describing the error and abort the process. The format argument is a format string describing how to format the remaining arguments arg into an error message, according to the same formatting rules used by the printf family of functions. The same formatting rules are also used by the built-in Tcl command format . In a freshly loaded Tcl library, Tcl_Panic prints the formatted error message to the standard error file of the process, and then calls abort to terminate the process. Tcl_Panic does not return. On Windows, when a debugger is running, the formatted error message is sent to the debugger instead. If the windows executable does not have a stderr channel (e.g. wish.exe ), then a system dialog box is used to display the panic message. If your application doesn\\'t use Tcl_Main or Tk_Main and you want to implicitly use the stderr channel of your application\\'s C runtime (instead of the stderr channel of the C runtime used by Tcl), you can call Tcl_SetPanicProc with Tcl_ConsolePanic as its argument. On platforms which only have one C runtime (almost all platforms except Windows) Tcl_ConsolePanic is equivalent to NULL. Tcl_SetPanicProc may be used to modify the behavior of Tcl_Panic . The panicProc argument should match the type Tcl_PanicProc : typedef void Tcl_PanicProc ( const char * format , arg , arg ,...); After Tcl_SetPanicProc returns, any future calls to Tcl_Panic will call panicProc , passing along the format and arg arguments. panicProc should avoid making calls into the Tcl library, or into other libraries that may call the Tcl library, since the original call to Tcl_Panic indicates the Tcl library is not in a state of reliable operation. The result of Tcl_SetPanicProc is the full Tcl version with build information (e.g., 9.0.0+abcdef...abcdef.gcc-1002 ). The typical use of Tcl_SetPanicProc arranges for the error message to be displayed or reported in a manner more suitable for the application or the platform. Tcl_SetPanicProc can not be used in stub-enabled extensions. Although the primary callers of Tcl_Panic are the procedures of the Tcl library, Tcl_Panic is a public function and may be called by any extension or application that wishes to abort the process and have a panic message displayed the same way that panic messages from Tcl will be displayed. SEE ALSO abort(3), printf(3), exec(n), format(n) KEYWORDS abort, fatal, error","title":"NAME"},{"location":"Panic/#name","text":"Tcl_Panic, Tcl_SetPanicProc, Tcl_ConsolePanic - report fatal error and abort","title":"NAME"},{"location":"Panic/#synopsis","text":"#include <tcl.h> void Tcl_Panic(format, arg, arg, ...) const char * Tcl_SetPanicProc(panicProc) void Tcl_ConsolePanic(format, arg, arg, ...)","title":"SYNOPSIS"},{"location":"Panic/#arguments","text":"A printf-style format string. Arguments matching the format string. Procedure to report fatal error message and abort.","title":"ARGUMENTS"},{"location":"Panic/#description","text":"When the Tcl library detects that its internal data structures are in an inconsistent state, or that its C procedures have been called in a manner inconsistent with their documentation, it calls Tcl_Panic to display a message describing the error and abort the process. The format argument is a format string describing how to format the remaining arguments arg into an error message, according to the same formatting rules used by the printf family of functions. The same formatting rules are also used by the built-in Tcl command format . In a freshly loaded Tcl library, Tcl_Panic prints the formatted error message to the standard error file of the process, and then calls abort to terminate the process. Tcl_Panic does not return. On Windows, when a debugger is running, the formatted error message is sent to the debugger instead. If the windows executable does not have a stderr channel (e.g. wish.exe ), then a system dialog box is used to display the panic message. If your application doesn\\'t use Tcl_Main or Tk_Main and you want to implicitly use the stderr channel of your application\\'s C runtime (instead of the stderr channel of the C runtime used by Tcl), you can call Tcl_SetPanicProc with Tcl_ConsolePanic as its argument. On platforms which only have one C runtime (almost all platforms except Windows) Tcl_ConsolePanic is equivalent to NULL. Tcl_SetPanicProc may be used to modify the behavior of Tcl_Panic . The panicProc argument should match the type Tcl_PanicProc : typedef void Tcl_PanicProc ( const char * format , arg , arg ,...); After Tcl_SetPanicProc returns, any future calls to Tcl_Panic will call panicProc , passing along the format and arg arguments. panicProc should avoid making calls into the Tcl library, or into other libraries that may call the Tcl library, since the original call to Tcl_Panic indicates the Tcl library is not in a state of reliable operation. The result of Tcl_SetPanicProc is the full Tcl version with build information (e.g., 9.0.0+abcdef...abcdef.gcc-1002 ). The typical use of Tcl_SetPanicProc arranges for the error message to be displayed or reported in a manner more suitable for the application or the platform. Tcl_SetPanicProc can not be used in stub-enabled extensions. Although the primary callers of Tcl_Panic are the procedures of the Tcl library, Tcl_Panic is a public function and may be called by any extension or application that wishes to abort the process and have a panic message displayed the same way that panic messages from Tcl will be displayed.","title":"DESCRIPTION"},{"location":"Panic/#see-also","text":"abort(3), printf(3), exec(n), format(n)","title":"SEE ALSO"},{"location":"Panic/#keywords","text":"abort, fatal, error","title":"KEYWORDS"},{"location":"ParseArgs/","text":"NAME Tcl_ParseArgsObjv - parse arguments according to a tabular description SYNOPSIS #include <tcl.h> int Tcl_ParseArgsObjv(interp, argTable, objcPtr, objv, remObjv) ARGUMENTS Where to store error messages. Pointer to array of option descriptors. A pointer to variable holding number of arguments in objv . Will be modified to hold number of arguments left in the unprocessed argument list stored in remObjv . The array of arguments to be parsed. Pointer to a variable that will hold the array of unprocessed arguments. Should be NULL if no return of unprocessed arguments is required. If objcPtr is updated to a non-zero value, the array returned through this must be deallocated using Tcl_Free . DESCRIPTION The Tcl_ParseArgsObjv function provides a system for parsing argument lists of the form Such argument lists are commonly found both in the arguments to a program and in the arguments to an individual Tcl command. This parser assumes that the order of the arguments does not matter, other than in so far as later copies of a duplicated option overriding earlier ones. The argument array is described by the objcPtr and objv parameters, and an array of unprocessed arguments is returned through the objcPtr and remObjv parameters; if no return of unprocessed arguments is desired, the remObjv parameter should be NULL. If any problems happen, including if the option is selected, an error message is left in the interpreter result and TCL_ERROR is returned. Otherwise, the interpreter result is left unchanged and TCL_OK is returned. The collection of arguments to be parsed is described by the argTable parameter. This points to a table of descriptor structures that is terminated by an entry with the type field set to TCL_ARGV_END. As convenience, the following prototypical entries are provided: TCL_ARGV_AUTO_HELP : Enables the argument processor to provide help when passed the argument <!-- --> TCL_ARGV_AUTO_REST : Instructs the argument processor that arguments after are to be unprocessed. TCL_ARGV_TABLE_END : Marks the end of the table of argument descriptors. ARGUMENT DESCRIPTOR ENTRIES Each entry of the argument descriptor table must be a structure of type Tcl_ArgvInfo . The structure is defined as this: typedef struct { int type ; const char * keyStr ; void * srcPtr ; void * dstPtr ; const char * helpStr ; void * clientData ; } Tcl_ArgvInfo ; The keyStr field contains the name of the option; by convention, this will normally begin with a character. The type , srcPtr , dstPtr and clientData fields describe the interpretation of the value of the argument, as described below. The helpStr field gives some text that is used to provide help to users when they request it. As noted above, the type field is used to describe the interpretation of the argument\\'s value. The following values are acceptable values for type : TCL_ARGV_CONSTANT : The argument does not take any following value argument. If this argument is present, the (integer) value of the srcPtr field is copied to the variable pointed to by the dstPtr field. The clientData field is ignored. TCL_ARGV_END : This value marks the end of all option descriptors in the table. All other fields are ignored. TCL_ARGV_FLOAT : This argument takes a following floating point value argument. The value (once parsed by Tcl_GetDoubleFromObj ) will be stored as a double-precision value in the variable pointed to by the dstPtr field. The srcPtr and clientData fields are ignored. TCL_ARGV_FUNC : This argument optionally takes a following value argument; it is up to the handler callback function passed in srcPtr to decide. That function will have the following signature: typedef int (**Tcl_ArgvFuncProc**)( void \\**clientData*, Tcl_Obj \\**objPtr*, void \\**dstPtr*); The result is a boolean value indicating whether to consume the following argument. The *clientData* is the value from the table entry, the *objPtr* is the value that represents the following argument or NULL if there are no following arguments at all, and the *dstPtr* argument to the **Tcl_ArgvFuncProc** is the location to write the parsed value to. TCL_ARGV_GENFUNC : This argument takes zero or more following arguments; the handler callback function passed in srcPtr returns how many (or a negative number to signal an error, in which case it should also set the interpreter result). The function will have the following signature: typedef int (**Tcl_ArgvGenFuncProc**)( void \\**clientData*, Tcl_Interp \\**interp*, int *objc*, Tcl_Obj \\*const \\**objv*, void \\**dstPtr*); The *clientData* is the value from the table entry, the *interp* is where to store any error messages, the *keyStr* is the name of the argument, *objc* and *objv* describe an array of all the remaining arguments, and *dstPtr* argument to the **Tcl_ArgvGenFuncProc** is the location to write the parsed value (or values) to. TCL_ARGV_HELP : This special argument does not take any following value argument, but instead causes Tcl_ParseArgsObjv to generate an error message describing the arguments supported. All other fields except the helpStr field are ignored. TCL_ARGV_INT : This argument takes a following integer value argument. The value (once parsed by Tcl_GetIntFromObj ) will be stored as an int in the variable pointed to by the dstPtr field. The srcPtr field is ignored. TCL_ARGV_REST : This special argument does not take any following value argument, but instead marks all following arguments to be left unprocessed. The srcPtr , dstPtr and clientData fields are ignored. TCL_ARGV_STRING : This argument takes a following string value argument. A pointer to the string will be stored at dstPtr ; the string inside will have a lifetime linked to the lifetime of the string representation of the argument value that it came from, and so should be copied if it needs to be retained. The srcPtr and clientData fields are ignored. REFERENCE COUNT MANAGEMENT The values in the objv argument to Tcl_ParseArgsObjv will not have their reference counts modified by this function. The interpreter result may be modified on error; the values passed should not be the interpreter result with no further reference added. SEE ALSO Tcl_GetIndexFromObj(3), Tcl_Main(3), Tcl_CreateObjCommand(3) KEYWORDS argument, parse","title":"NAME"},{"location":"ParseArgs/#name","text":"Tcl_ParseArgsObjv - parse arguments according to a tabular description","title":"NAME"},{"location":"ParseArgs/#synopsis","text":"#include <tcl.h> int Tcl_ParseArgsObjv(interp, argTable, objcPtr, objv, remObjv)","title":"SYNOPSIS"},{"location":"ParseArgs/#arguments","text":"Where to store error messages. Pointer to array of option descriptors. A pointer to variable holding number of arguments in objv . Will be modified to hold number of arguments left in the unprocessed argument list stored in remObjv . The array of arguments to be parsed. Pointer to a variable that will hold the array of unprocessed arguments. Should be NULL if no return of unprocessed arguments is required. If objcPtr is updated to a non-zero value, the array returned through this must be deallocated using Tcl_Free .","title":"ARGUMENTS"},{"location":"ParseArgs/#description","text":"The Tcl_ParseArgsObjv function provides a system for parsing argument lists of the form Such argument lists are commonly found both in the arguments to a program and in the arguments to an individual Tcl command. This parser assumes that the order of the arguments does not matter, other than in so far as later copies of a duplicated option overriding earlier ones. The argument array is described by the objcPtr and objv parameters, and an array of unprocessed arguments is returned through the objcPtr and remObjv parameters; if no return of unprocessed arguments is desired, the remObjv parameter should be NULL. If any problems happen, including if the option is selected, an error message is left in the interpreter result and TCL_ERROR is returned. Otherwise, the interpreter result is left unchanged and TCL_OK is returned. The collection of arguments to be parsed is described by the argTable parameter. This points to a table of descriptor structures that is terminated by an entry with the type field set to TCL_ARGV_END. As convenience, the following prototypical entries are provided: TCL_ARGV_AUTO_HELP : Enables the argument processor to provide help when passed the argument <!-- --> TCL_ARGV_AUTO_REST : Instructs the argument processor that arguments after are to be unprocessed. TCL_ARGV_TABLE_END : Marks the end of the table of argument descriptors.","title":"DESCRIPTION"},{"location":"ParseArgs/#argument-descriptor-entries","text":"Each entry of the argument descriptor table must be a structure of type Tcl_ArgvInfo . The structure is defined as this: typedef struct { int type ; const char * keyStr ; void * srcPtr ; void * dstPtr ; const char * helpStr ; void * clientData ; } Tcl_ArgvInfo ; The keyStr field contains the name of the option; by convention, this will normally begin with a character. The type , srcPtr , dstPtr and clientData fields describe the interpretation of the value of the argument, as described below. The helpStr field gives some text that is used to provide help to users when they request it. As noted above, the type field is used to describe the interpretation of the argument\\'s value. The following values are acceptable values for type : TCL_ARGV_CONSTANT : The argument does not take any following value argument. If this argument is present, the (integer) value of the srcPtr field is copied to the variable pointed to by the dstPtr field. The clientData field is ignored. TCL_ARGV_END : This value marks the end of all option descriptors in the table. All other fields are ignored. TCL_ARGV_FLOAT : This argument takes a following floating point value argument. The value (once parsed by Tcl_GetDoubleFromObj ) will be stored as a double-precision value in the variable pointed to by the dstPtr field. The srcPtr and clientData fields are ignored. TCL_ARGV_FUNC : This argument optionally takes a following value argument; it is up to the handler callback function passed in srcPtr to decide. That function will have the following signature: typedef int (**Tcl_ArgvFuncProc**)( void \\**clientData*, Tcl_Obj \\**objPtr*, void \\**dstPtr*); The result is a boolean value indicating whether to consume the following argument. The *clientData* is the value from the table entry, the *objPtr* is the value that represents the following argument or NULL if there are no following arguments at all, and the *dstPtr* argument to the **Tcl_ArgvFuncProc** is the location to write the parsed value to. TCL_ARGV_GENFUNC : This argument takes zero or more following arguments; the handler callback function passed in srcPtr returns how many (or a negative number to signal an error, in which case it should also set the interpreter result). The function will have the following signature: typedef int (**Tcl_ArgvGenFuncProc**)( void \\**clientData*, Tcl_Interp \\**interp*, int *objc*, Tcl_Obj \\*const \\**objv*, void \\**dstPtr*); The *clientData* is the value from the table entry, the *interp* is where to store any error messages, the *keyStr* is the name of the argument, *objc* and *objv* describe an array of all the remaining arguments, and *dstPtr* argument to the **Tcl_ArgvGenFuncProc** is the location to write the parsed value (or values) to. TCL_ARGV_HELP : This special argument does not take any following value argument, but instead causes Tcl_ParseArgsObjv to generate an error message describing the arguments supported. All other fields except the helpStr field are ignored. TCL_ARGV_INT : This argument takes a following integer value argument. The value (once parsed by Tcl_GetIntFromObj ) will be stored as an int in the variable pointed to by the dstPtr field. The srcPtr field is ignored. TCL_ARGV_REST : This special argument does not take any following value argument, but instead marks all following arguments to be left unprocessed. The srcPtr , dstPtr and clientData fields are ignored. TCL_ARGV_STRING : This argument takes a following string value argument. A pointer to the string will be stored at dstPtr ; the string inside will have a lifetime linked to the lifetime of the string representation of the argument value that it came from, and so should be copied if it needs to be retained. The srcPtr and clientData fields are ignored.","title":"ARGUMENT DESCRIPTOR ENTRIES"},{"location":"ParseArgs/#reference-count-management","text":"The values in the objv argument to Tcl_ParseArgsObjv will not have their reference counts modified by this function. The interpreter result may be modified on error; the values passed should not be the interpreter result with no further reference added.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"ParseArgs/#see-also","text":"Tcl_GetIndexFromObj(3), Tcl_Main(3), Tcl_CreateObjCommand(3)","title":"SEE ALSO"},{"location":"ParseArgs/#keywords","text":"argument, parse","title":"KEYWORDS"},{"location":"ParseCmd/","text":"NAME Tcl_ParseCommand, Tcl_ParseExpr, Tcl_ParseBraces, Tcl_ParseQuotedString, Tcl_ParseVarName, Tcl_ParseVar, Tcl_FreeParse, Tcl_EvalTokensStandard - parse Tcl scripts and expressions SYNOPSIS #include <tcl.h> int Tcl_ParseCommand(interp, start, numBytes, nested, parsePtr) int Tcl_ParseExpr(interp, start, numBytes, parsePtr) int Tcl_ParseBraces(interp, start, numBytes, parsePtr, append, termPtr) int Tcl_ParseQuotedString(interp, start, numBytes, parsePtr, append, termPtr) int Tcl_ParseVarName(interp, start, numBytes, parsePtr, append) const char * Tcl_ParseVar(interp, start, termPtr) Tcl_FreeParse(usedParsePtr) int Tcl_EvalTokensStandard(interp, tokenPtr, numTokens) ARGUMENTS For procedures other than Tcl_FreeParse and Tcl_EvalTokensStandard , used only for error reporting; if NULL, then no error messages are left after errors. For Tcl_EvalTokensStandard , determines the context for evaluating the script and also is used for error reporting; must not be NULL. Pointer to first character in string to parse. Number of bytes in string to parse, not including any terminating null character. If less than 0 then the script consists of all characters following start up to the first null character. Non-zero means that the script is part of a command substitution so an unquoted close bracket should be treated as a command terminator. If zero, close brackets have no special meaning. Non-zero means that *parsePtr already contains valid tokens; the new tokens should be appended to those already present. Zero means that *parsePtr is uninitialized; any information in it is ignored. This argument is normally 0. Points to structure to fill in with information about the parsed command, expression, variable name, etc. Any previous information in this structure is ignored, unless append is non-zero in a call to Tcl_ParseBraces , Tcl_ParseQuotedString , or Tcl_ParseVarName . If not NULL, points to a location where Tcl_ParseBraces , Tcl_ParseQuotedString , and Tcl_ParseVar will store a pointer to the character just after the terminating character (the close-brace, the last character of the variable name, or the close-quote (respectively)) if the parse was successful. Points to structure that was filled in by a previous call to Tcl_ParseCommand , Tcl_ParseExpr , Tcl_ParseVarName , etc. DESCRIPTION These procedures parse Tcl commands or portions of Tcl commands such as expressions or references to variables. Each procedure takes a pointer to a script (or portion thereof) and fills in the structure pointed to by parsePtr with a collection of tokens describing the information that was parsed. The procedures normally return TCL_OK . However, if an error occurs then they return TCL_ERROR , leave an error message in interp \\'s result (if interp is not NULL), and leave nothing in parsePtr . Tcl_ParseCommand is a procedure that parses Tcl scripts. Given a pointer to a script, it parses the first command from the script. If the command was parsed successfully, Tcl_ParseCommand returns TCL_OK and fills in the structure pointed to by parsePtr with information about the structure of the command (see below for details). If an error occurred in parsing the command then TCL_ERROR is returned, an error message is left in interp \\'s result, and no information is left at *parsePtr . Tcl_ParseExpr parses Tcl expressions. Given a pointer to a script containing an expression, Tcl_ParseExpr parses the expression. If the expression was parsed successfully, Tcl_ParseExpr returns TCL_OK and fills in the structure pointed to by parsePtr with information about the structure of the expression (see below for details). If an error occurred in parsing the command then TCL_ERROR is returned, an error message is left in interp \\'s result, and no information is left at *parsePtr . Tcl_ParseBraces parses a string or command argument enclosed in braces such as {hello} or {string \\t with \\t tabs} from the beginning of its argument start . The first character of start must be { . If the braced string was parsed successfully, Tcl_ParseBraces returns TCL_OK , fills in the structure pointed to by parsePtr with information about the structure of the string (see below for details), and stores a pointer to the character just after the terminating } in the location given by *termPtr . If an error occurs while parsing the string then TCL_ERROR is returned, an error message is left in interp \\'s result, and no information is left at *parsePtr or *termPtr . Tcl_ParseQuotedString parses a double-quoted string such as \\\"sum is [expr {\\$a+\\$b}]\\\" from the beginning of the argument start . The first character of start must be . If the double-quoted string was parsed successfully, Tcl_ParseQuotedString returns TCL_OK , fills in the structure pointed to by parsePtr with information about the structure of the string (see below for details), and stores a pointer to the character just after the terminating in the location given by *termPtr . If an error occurs while parsing the string then TCL_ERROR is returned, an error message is left in interp \\'s result, and no information is left at *parsePtr or *termPtr . Tcl_ParseVarName parses a Tcl variable reference such as \\$abc or \\$x([expr {\\$index + 1}]) from the beginning of its start argument. The first character of start must be \\$ . If a variable name was parsed successfully, Tcl_ParseVarName returns TCL_OK and fills in the structure pointed to by parsePtr with information about the structure of the variable name (see below for details). If an error occurs while parsing the command then TCL_ERROR is returned, an error message is left in interp \\'s result (if interp is not NULL), and no information is left at *parsePtr . Tcl_ParseVar parse a Tcl variable reference such as \\$abc or \\$x([expr {\\$index + 1}]) from the beginning of its start argument. The first character of start must be \\$ . If the variable name is parsed successfully, Tcl_ParseVar returns a pointer to the string value of the variable. If an error occurs while parsing, then NULL is returned and an error message is left in interp \\'s result. The information left at *parsePtr by Tcl_ParseCommand , Tcl_ParseExpr , Tcl_ParseBraces , Tcl_ParseQuotedString , and Tcl_ParseVarName may include dynamically allocated memory. If these five parsing procedures return TCL_OK then the caller must invoke Tcl_FreeParse to release the storage at *parsePtr . These procedures ignore any existing information in *parsePtr (unless append is non-zero), so if repeated calls are being made to any of them then Tcl_FreeParse must be invoked once after each call. Tcl_EvalTokensStandard evaluates a sequence of parse tokens from a Tcl_Parse structure. The tokens typically consist of all the tokens in a word or all the tokens that make up the index for a reference to an array variable. Tcl_EvalTokensStandard performs the substitutions requested by the tokens and concatenates the resulting values. The return value from Tcl_EvalTokensStandard is a Tcl completion code with one of the values TCL_OK , TCL_ERROR , TCL_RETURN , TCL_BREAK , or TCL_CONTINUE , or possibly some other integer value originating in an extension. In addition, a result value or error message is left in interp \\'s result; it can be retrieved using Tcl_GetObjResult . TCL_PARSE STRUCTURE Tcl_ParseCommand , Tcl_ParseExpr , Tcl_ParseBraces , Tcl_ParseQuotedString , and Tcl_ParseVarName return parse information in two data structures, Tcl_Parse and Tcl_Token: typedef struct Tcl_Parse { const char * commentStart ; Tcl_Size commentSize ; const char * commandStart ; Tcl_Size commandSize ; Tcl_Size numWords ; Tcl_Token * tokenPtr ; Tcl_Size numTokens ; ... } Tcl_Parse ; typedef struct Tcl_Token { int type ; const char * start ; Tcl_Size size ; Tcl_Size numComponents ; } Tcl_Token ; The first five fields of a Tcl_Parse structure are filled in only by Tcl_ParseCommand . These fields are not used by the other parsing procedures. Tcl_ParseCommand fills in a Tcl_Parse structure with information that describes one Tcl command and any comments that precede the command. If there are comments, the commentStart field points to the # character that begins the first comment and commentSize indicates the number of bytes in all of the comments preceding the command, including the newline character that terminates the last comment. If the command is not preceded by any comments, commentSize is 0. Tcl_ParseCommand also sets the commandStart field to point to the first character of the first word in the command (skipping any comments and leading space) and commandSize gives the total number of bytes in the command, including the character pointed to by commandStart up to and including the newline, close bracket, or semicolon character that terminates the command. The numWords field gives the total number of words in the command. All parsing procedures set the remaining fields, tokenPtr and numTokens . The tokenPtr field points to the first in an array of Tcl_Token structures that describe the components of the entity being parsed. The numTokens field gives the total number of tokens present in the array. Each token contains four fields. The type field selects one of several token types that are described below. The start field points to the first character in the token and the size field gives the total number of characters in the token. Some token types, such as TCL_TOKEN_WORD and TCL_TOKEN_VARIABLE , consist of several component tokens, which immediately follow the parent token; the numComponents field describes how many of these there are. The type field has one of the following values: TCL_TOKEN_WORD : This token ordinarily describes one word of a command but it may also describe a quoted or braced string in an expression. The token describes a component of the script that is the result of concatenating together a sequence of subcomponents, each described by a separate subtoken. The token starts with the first non-blank character of the component (which may be a double-quote or open brace) and includes all characters in the component up to but not including the space, semicolon, close bracket, close quote, or close brace that terminates the component. The numComponents field counts the total number of sub-tokens that make up the word, including sub-tokens of TCL_TOKEN_VARIABLE and TCL_TOKEN_BS tokens. TCL_TOKEN_SIMPLE_WORD : This token has the same meaning as TCL_TOKEN_WORD , except that the word is guaranteed to consist of a single TCL_TOKEN_TEXT sub-token. The numComponents field is always 1. TCL_TOKEN_EXPAND_WORD : This token has the same meaning as TCL_TOKEN_WORD , except that the command parser notes this word began with the expansion prefix {*} , indicating that after substitution, the list value of this word should be expanded to form multiple arguments in command evaluation. This token type can only be created by Tcl_ParseCommand. TCL_TOKEN_TEXT : The token describes a range of literal text that is part of a word. The numComponents field is always 0. TCL_TOKEN_BS : The token describes a backslash sequence such as \\n or \\0xA3 . The numComponents field is always 0. TCL_TOKEN_COMMAND : The token describes a command whose result must be substituted into the word. The token includes the square brackets that surround the command. The numComponents field is always 0 (the nested command is not parsed; call Tcl_ParseCommand recursively if you want to see its tokens). TCL_TOKEN_VARIABLE : The token describes a variable substitution, including the \\$ , variable name, and array index (if there is one) up through the close parenthesis that terminates the index. This token is followed by one or more additional tokens that describe the variable name and array index. If numComponents is 1 then the variable is a scalar and the next token is a TCL_TOKEN_TEXT token that gives the variable name. If numComponents is greater than 1 then the variable is an array: the first sub-token is a TCL_TOKEN_TEXT token giving the array name and the remaining sub-tokens are TCL_TOKEN_TEXT , TCL_TOKEN_BS , TCL_TOKEN_COMMAND , and TCL_TOKEN_VARIABLE tokens that must be concatenated to produce the array index. The numComponents field includes nested sub-tokens that are part of TCL_TOKEN_VARIABLE tokens in the array index. TCL_TOKEN_SUB_EXPR : The token describes one subexpression of an expression (or an entire expression). A subexpression may consist of a value such as an integer literal, variable substitution, or parenthesized subexpression; it may also consist of an operator and its operands. The token starts with the first non-blank character of the subexpression up to but not including the space, brace, close-paren, or bracket that terminates the subexpression. This token is followed by one or more additional tokens that describe the subexpression. If the first sub-token after the TCL_TOKEN_SUB_EXPR token is a TCL_TOKEN_OPERATOR token, the subexpression consists of an operator and its token operands. If the operator has no operands, the subexpression consists of just the TCL_TOKEN_OPERATOR token. Each operand is described by a TCL_TOKEN_SUB_EXPR token. Otherwise, the subexpression is a value described by one of the token types TCL_TOKEN_WORD , TCL_TOKEN_TEXT , TCL_TOKEN_BS , TCL_TOKEN_COMMAND , TCL_TOKEN_VARIABLE , and TCL_TOKEN_SUB_EXPR . The numComponents field counts the total number of sub-tokens that make up the subexpression; this includes the sub-tokens for any nested TCL_TOKEN_SUB_EXPR tokens. TCL_TOKEN_OPERATOR : The token describes one operator of an expression such as && or hypot . A TCL_TOKEN_OPERATOR token is always preceded by a TCL_TOKEN_SUB_EXPR token that describes the operator and its operands; the TCL_TOKEN_SUB_EXPR token\\'s numComponents field can be used to determine the number of operands. A binary operator such as * is followed by two TCL_TOKEN_SUB_EXPR tokens that describe its operands. A unary operator like - is followed by a single TCL_TOKEN_SUB_EXPR token for its operand. If the operator is a math function such as log10 , the TCL_TOKEN_OPERATOR token will give its name and the following TCL_TOKEN_SUB_EXPR tokens will describe its operands; if there are no operands (as with rand ), no TCL_TOKEN_SUB_EXPR tokens follow. There is one trinary operator, ? , that appears in if-then-else subexpressions such as x ? y : z ; in this case, the ? TCL_TOKEN_OPERATOR token is followed by three TCL_TOKEN_SUB_EXPR tokens for the operands x , y , and z . The numComponents field for a TCL_TOKEN_OPERATOR token is always 0. After Tcl_ParseCommand returns, the first token pointed to by the tokenPtr field of the Tcl_Parse structure always has type TCL_TOKEN_WORD or TCL_TOKEN_SIMPLE_WORD or TCL_TOKEN_EXPAND_WORD . It is followed by the sub-tokens that must be concatenated to produce the value of that word. The next token is the TCL_TOKEN_WORD or TCL_TOKEN_SIMPLE_WORD of TCL_TOKEN_EXPAND_WORD token for the second word, followed by sub-tokens for that word, and so on until all numWords have been accounted for. After Tcl_ParseExpr returns, the first token pointed to by the tokenPtr field of the Tcl_Parse structure always has type TCL_TOKEN_SUB_EXPR . It is followed by the sub-tokens that must be evaluated to produce the value of the expression. Only the token information in the Tcl_Parse structure is modified: the commentStart , commentSize , commandStart , and commandSize fields are not modified by Tcl_ParseExpr . After Tcl_ParseBraces returns, the array of tokens pointed to by the tokenPtr field of the Tcl_Parse structure will contain a single TCL_TOKEN_TEXT token if the braced string does not contain any backslash-newlines. If the string does contain backslash-newlines, the array of tokens will contain one or more TCL_TOKEN_TEXT or TCL_TOKEN_BS sub-tokens that must be concatenated to produce the value of the string. If the braced string was just {} (that is, the string was empty), the single TCL_TOKEN_TEXT token will have a size field containing zero; this ensures that at least one token appears to describe the braced string. Only the token information in the Tcl_Parse structure is modified: the commentStart , commentSize , commandStart , and commandSize fields are not modified by Tcl_ParseBraces . After Tcl_ParseQuotedString returns, the array of tokens pointed to by the tokenPtr field of the Tcl_Parse structure depends on the contents of the quoted string. It will consist of one or more TCL_TOKEN_TEXT , TCL_TOKEN_BS , TCL_TOKEN_COMMAND , and TCL_TOKEN_VARIABLE sub-tokens. The array always contains at least one token; for example, if the argument start is empty, the array returned consists of a single TCL_TOKEN_TEXT token with a zero size field. Only the token information in the Tcl_Parse structure is modified: the commentStart , commentSize , commandStart , and commandSize fields are not modified. After Tcl_ParseVarName returns, the first token pointed to by the tokenPtr field of the Tcl_Parse structure always has type TCL_TOKEN_VARIABLE . It is followed by the sub-tokens that make up the variable name as described above. The total length of the variable name is contained in the size field of the first token. As in Tcl_ParseExpr , only the token information in the Tcl_Parse structure is modified by Tcl_ParseVarName : the commentStart , commentSize , commandStart , and commandSize fields are not modified. All of the character pointers in the Tcl_Parse and Tcl_Token structures refer to characters in the start argument passed to Tcl_ParseCommand , Tcl_ParseExpr , Tcl_ParseBraces , Tcl_ParseQuotedString , and Tcl_ParseVarName . There are additional fields in the Tcl_Parse structure after the numTokens field, but these are for the private use of Tcl_ParseCommand , Tcl_ParseExpr , Tcl_ParseBraces , Tcl_ParseQuotedString , and Tcl_ParseVarName ; they should not be referenced by code outside of these procedures. KEYWORDS backslash substitution, braces, command, expression, parse, token, variable substitution","title":"NAME"},{"location":"ParseCmd/#name","text":"Tcl_ParseCommand, Tcl_ParseExpr, Tcl_ParseBraces, Tcl_ParseQuotedString, Tcl_ParseVarName, Tcl_ParseVar, Tcl_FreeParse, Tcl_EvalTokensStandard - parse Tcl scripts and expressions","title":"NAME"},{"location":"ParseCmd/#synopsis","text":"#include <tcl.h> int Tcl_ParseCommand(interp, start, numBytes, nested, parsePtr) int Tcl_ParseExpr(interp, start, numBytes, parsePtr) int Tcl_ParseBraces(interp, start, numBytes, parsePtr, append, termPtr) int Tcl_ParseQuotedString(interp, start, numBytes, parsePtr, append, termPtr) int Tcl_ParseVarName(interp, start, numBytes, parsePtr, append) const char * Tcl_ParseVar(interp, start, termPtr) Tcl_FreeParse(usedParsePtr) int Tcl_EvalTokensStandard(interp, tokenPtr, numTokens)","title":"SYNOPSIS"},{"location":"ParseCmd/#arguments","text":"For procedures other than Tcl_FreeParse and Tcl_EvalTokensStandard , used only for error reporting; if NULL, then no error messages are left after errors. For Tcl_EvalTokensStandard , determines the context for evaluating the script and also is used for error reporting; must not be NULL. Pointer to first character in string to parse. Number of bytes in string to parse, not including any terminating null character. If less than 0 then the script consists of all characters following start up to the first null character. Non-zero means that the script is part of a command substitution so an unquoted close bracket should be treated as a command terminator. If zero, close brackets have no special meaning. Non-zero means that *parsePtr already contains valid tokens; the new tokens should be appended to those already present. Zero means that *parsePtr is uninitialized; any information in it is ignored. This argument is normally 0. Points to structure to fill in with information about the parsed command, expression, variable name, etc. Any previous information in this structure is ignored, unless append is non-zero in a call to Tcl_ParseBraces , Tcl_ParseQuotedString , or Tcl_ParseVarName . If not NULL, points to a location where Tcl_ParseBraces , Tcl_ParseQuotedString , and Tcl_ParseVar will store a pointer to the character just after the terminating character (the close-brace, the last character of the variable name, or the close-quote (respectively)) if the parse was successful. Points to structure that was filled in by a previous call to Tcl_ParseCommand , Tcl_ParseExpr , Tcl_ParseVarName , etc.","title":"ARGUMENTS"},{"location":"ParseCmd/#description","text":"These procedures parse Tcl commands or portions of Tcl commands such as expressions or references to variables. Each procedure takes a pointer to a script (or portion thereof) and fills in the structure pointed to by parsePtr with a collection of tokens describing the information that was parsed. The procedures normally return TCL_OK . However, if an error occurs then they return TCL_ERROR , leave an error message in interp \\'s result (if interp is not NULL), and leave nothing in parsePtr . Tcl_ParseCommand is a procedure that parses Tcl scripts. Given a pointer to a script, it parses the first command from the script. If the command was parsed successfully, Tcl_ParseCommand returns TCL_OK and fills in the structure pointed to by parsePtr with information about the structure of the command (see below for details). If an error occurred in parsing the command then TCL_ERROR is returned, an error message is left in interp \\'s result, and no information is left at *parsePtr . Tcl_ParseExpr parses Tcl expressions. Given a pointer to a script containing an expression, Tcl_ParseExpr parses the expression. If the expression was parsed successfully, Tcl_ParseExpr returns TCL_OK and fills in the structure pointed to by parsePtr with information about the structure of the expression (see below for details). If an error occurred in parsing the command then TCL_ERROR is returned, an error message is left in interp \\'s result, and no information is left at *parsePtr . Tcl_ParseBraces parses a string or command argument enclosed in braces such as {hello} or {string \\t with \\t tabs} from the beginning of its argument start . The first character of start must be { . If the braced string was parsed successfully, Tcl_ParseBraces returns TCL_OK , fills in the structure pointed to by parsePtr with information about the structure of the string (see below for details), and stores a pointer to the character just after the terminating } in the location given by *termPtr . If an error occurs while parsing the string then TCL_ERROR is returned, an error message is left in interp \\'s result, and no information is left at *parsePtr or *termPtr . Tcl_ParseQuotedString parses a double-quoted string such as \\\"sum is [expr {\\$a+\\$b}]\\\" from the beginning of the argument start . The first character of start must be . If the double-quoted string was parsed successfully, Tcl_ParseQuotedString returns TCL_OK , fills in the structure pointed to by parsePtr with information about the structure of the string (see below for details), and stores a pointer to the character just after the terminating in the location given by *termPtr . If an error occurs while parsing the string then TCL_ERROR is returned, an error message is left in interp \\'s result, and no information is left at *parsePtr or *termPtr . Tcl_ParseVarName parses a Tcl variable reference such as \\$abc or \\$x([expr {\\$index + 1}]) from the beginning of its start argument. The first character of start must be \\$ . If a variable name was parsed successfully, Tcl_ParseVarName returns TCL_OK and fills in the structure pointed to by parsePtr with information about the structure of the variable name (see below for details). If an error occurs while parsing the command then TCL_ERROR is returned, an error message is left in interp \\'s result (if interp is not NULL), and no information is left at *parsePtr . Tcl_ParseVar parse a Tcl variable reference such as \\$abc or \\$x([expr {\\$index + 1}]) from the beginning of its start argument. The first character of start must be \\$ . If the variable name is parsed successfully, Tcl_ParseVar returns a pointer to the string value of the variable. If an error occurs while parsing, then NULL is returned and an error message is left in interp \\'s result. The information left at *parsePtr by Tcl_ParseCommand , Tcl_ParseExpr , Tcl_ParseBraces , Tcl_ParseQuotedString , and Tcl_ParseVarName may include dynamically allocated memory. If these five parsing procedures return TCL_OK then the caller must invoke Tcl_FreeParse to release the storage at *parsePtr . These procedures ignore any existing information in *parsePtr (unless append is non-zero), so if repeated calls are being made to any of them then Tcl_FreeParse must be invoked once after each call. Tcl_EvalTokensStandard evaluates a sequence of parse tokens from a Tcl_Parse structure. The tokens typically consist of all the tokens in a word or all the tokens that make up the index for a reference to an array variable. Tcl_EvalTokensStandard performs the substitutions requested by the tokens and concatenates the resulting values. The return value from Tcl_EvalTokensStandard is a Tcl completion code with one of the values TCL_OK , TCL_ERROR , TCL_RETURN , TCL_BREAK , or TCL_CONTINUE , or possibly some other integer value originating in an extension. In addition, a result value or error message is left in interp \\'s result; it can be retrieved using Tcl_GetObjResult .","title":"DESCRIPTION"},{"location":"ParseCmd/#tcl_parse-structure","text":"Tcl_ParseCommand , Tcl_ParseExpr , Tcl_ParseBraces , Tcl_ParseQuotedString , and Tcl_ParseVarName return parse information in two data structures, Tcl_Parse and Tcl_Token: typedef struct Tcl_Parse { const char * commentStart ; Tcl_Size commentSize ; const char * commandStart ; Tcl_Size commandSize ; Tcl_Size numWords ; Tcl_Token * tokenPtr ; Tcl_Size numTokens ; ... } Tcl_Parse ; typedef struct Tcl_Token { int type ; const char * start ; Tcl_Size size ; Tcl_Size numComponents ; } Tcl_Token ; The first five fields of a Tcl_Parse structure are filled in only by Tcl_ParseCommand . These fields are not used by the other parsing procedures. Tcl_ParseCommand fills in a Tcl_Parse structure with information that describes one Tcl command and any comments that precede the command. If there are comments, the commentStart field points to the # character that begins the first comment and commentSize indicates the number of bytes in all of the comments preceding the command, including the newline character that terminates the last comment. If the command is not preceded by any comments, commentSize is 0. Tcl_ParseCommand also sets the commandStart field to point to the first character of the first word in the command (skipping any comments and leading space) and commandSize gives the total number of bytes in the command, including the character pointed to by commandStart up to and including the newline, close bracket, or semicolon character that terminates the command. The numWords field gives the total number of words in the command. All parsing procedures set the remaining fields, tokenPtr and numTokens . The tokenPtr field points to the first in an array of Tcl_Token structures that describe the components of the entity being parsed. The numTokens field gives the total number of tokens present in the array. Each token contains four fields. The type field selects one of several token types that are described below. The start field points to the first character in the token and the size field gives the total number of characters in the token. Some token types, such as TCL_TOKEN_WORD and TCL_TOKEN_VARIABLE , consist of several component tokens, which immediately follow the parent token; the numComponents field describes how many of these there are. The type field has one of the following values: TCL_TOKEN_WORD : This token ordinarily describes one word of a command but it may also describe a quoted or braced string in an expression. The token describes a component of the script that is the result of concatenating together a sequence of subcomponents, each described by a separate subtoken. The token starts with the first non-blank character of the component (which may be a double-quote or open brace) and includes all characters in the component up to but not including the space, semicolon, close bracket, close quote, or close brace that terminates the component. The numComponents field counts the total number of sub-tokens that make up the word, including sub-tokens of TCL_TOKEN_VARIABLE and TCL_TOKEN_BS tokens. TCL_TOKEN_SIMPLE_WORD : This token has the same meaning as TCL_TOKEN_WORD , except that the word is guaranteed to consist of a single TCL_TOKEN_TEXT sub-token. The numComponents field is always 1. TCL_TOKEN_EXPAND_WORD : This token has the same meaning as TCL_TOKEN_WORD , except that the command parser notes this word began with the expansion prefix {*} , indicating that after substitution, the list value of this word should be expanded to form multiple arguments in command evaluation. This token type can only be created by Tcl_ParseCommand. TCL_TOKEN_TEXT : The token describes a range of literal text that is part of a word. The numComponents field is always 0. TCL_TOKEN_BS : The token describes a backslash sequence such as \\n or \\0xA3 . The numComponents field is always 0. TCL_TOKEN_COMMAND : The token describes a command whose result must be substituted into the word. The token includes the square brackets that surround the command. The numComponents field is always 0 (the nested command is not parsed; call Tcl_ParseCommand recursively if you want to see its tokens). TCL_TOKEN_VARIABLE : The token describes a variable substitution, including the \\$ , variable name, and array index (if there is one) up through the close parenthesis that terminates the index. This token is followed by one or more additional tokens that describe the variable name and array index. If numComponents is 1 then the variable is a scalar and the next token is a TCL_TOKEN_TEXT token that gives the variable name. If numComponents is greater than 1 then the variable is an array: the first sub-token is a TCL_TOKEN_TEXT token giving the array name and the remaining sub-tokens are TCL_TOKEN_TEXT , TCL_TOKEN_BS , TCL_TOKEN_COMMAND , and TCL_TOKEN_VARIABLE tokens that must be concatenated to produce the array index. The numComponents field includes nested sub-tokens that are part of TCL_TOKEN_VARIABLE tokens in the array index. TCL_TOKEN_SUB_EXPR : The token describes one subexpression of an expression (or an entire expression). A subexpression may consist of a value such as an integer literal, variable substitution, or parenthesized subexpression; it may also consist of an operator and its operands. The token starts with the first non-blank character of the subexpression up to but not including the space, brace, close-paren, or bracket that terminates the subexpression. This token is followed by one or more additional tokens that describe the subexpression. If the first sub-token after the TCL_TOKEN_SUB_EXPR token is a TCL_TOKEN_OPERATOR token, the subexpression consists of an operator and its token operands. If the operator has no operands, the subexpression consists of just the TCL_TOKEN_OPERATOR token. Each operand is described by a TCL_TOKEN_SUB_EXPR token. Otherwise, the subexpression is a value described by one of the token types TCL_TOKEN_WORD , TCL_TOKEN_TEXT , TCL_TOKEN_BS , TCL_TOKEN_COMMAND , TCL_TOKEN_VARIABLE , and TCL_TOKEN_SUB_EXPR . The numComponents field counts the total number of sub-tokens that make up the subexpression; this includes the sub-tokens for any nested TCL_TOKEN_SUB_EXPR tokens. TCL_TOKEN_OPERATOR : The token describes one operator of an expression such as && or hypot . A TCL_TOKEN_OPERATOR token is always preceded by a TCL_TOKEN_SUB_EXPR token that describes the operator and its operands; the TCL_TOKEN_SUB_EXPR token\\'s numComponents field can be used to determine the number of operands. A binary operator such as * is followed by two TCL_TOKEN_SUB_EXPR tokens that describe its operands. A unary operator like - is followed by a single TCL_TOKEN_SUB_EXPR token for its operand. If the operator is a math function such as log10 , the TCL_TOKEN_OPERATOR token will give its name and the following TCL_TOKEN_SUB_EXPR tokens will describe its operands; if there are no operands (as with rand ), no TCL_TOKEN_SUB_EXPR tokens follow. There is one trinary operator, ? , that appears in if-then-else subexpressions such as x ? y : z ; in this case, the ? TCL_TOKEN_OPERATOR token is followed by three TCL_TOKEN_SUB_EXPR tokens for the operands x , y , and z . The numComponents field for a TCL_TOKEN_OPERATOR token is always 0. After Tcl_ParseCommand returns, the first token pointed to by the tokenPtr field of the Tcl_Parse structure always has type TCL_TOKEN_WORD or TCL_TOKEN_SIMPLE_WORD or TCL_TOKEN_EXPAND_WORD . It is followed by the sub-tokens that must be concatenated to produce the value of that word. The next token is the TCL_TOKEN_WORD or TCL_TOKEN_SIMPLE_WORD of TCL_TOKEN_EXPAND_WORD token for the second word, followed by sub-tokens for that word, and so on until all numWords have been accounted for. After Tcl_ParseExpr returns, the first token pointed to by the tokenPtr field of the Tcl_Parse structure always has type TCL_TOKEN_SUB_EXPR . It is followed by the sub-tokens that must be evaluated to produce the value of the expression. Only the token information in the Tcl_Parse structure is modified: the commentStart , commentSize , commandStart , and commandSize fields are not modified by Tcl_ParseExpr . After Tcl_ParseBraces returns, the array of tokens pointed to by the tokenPtr field of the Tcl_Parse structure will contain a single TCL_TOKEN_TEXT token if the braced string does not contain any backslash-newlines. If the string does contain backslash-newlines, the array of tokens will contain one or more TCL_TOKEN_TEXT or TCL_TOKEN_BS sub-tokens that must be concatenated to produce the value of the string. If the braced string was just {} (that is, the string was empty), the single TCL_TOKEN_TEXT token will have a size field containing zero; this ensures that at least one token appears to describe the braced string. Only the token information in the Tcl_Parse structure is modified: the commentStart , commentSize , commandStart , and commandSize fields are not modified by Tcl_ParseBraces . After Tcl_ParseQuotedString returns, the array of tokens pointed to by the tokenPtr field of the Tcl_Parse structure depends on the contents of the quoted string. It will consist of one or more TCL_TOKEN_TEXT , TCL_TOKEN_BS , TCL_TOKEN_COMMAND , and TCL_TOKEN_VARIABLE sub-tokens. The array always contains at least one token; for example, if the argument start is empty, the array returned consists of a single TCL_TOKEN_TEXT token with a zero size field. Only the token information in the Tcl_Parse structure is modified: the commentStart , commentSize , commandStart , and commandSize fields are not modified. After Tcl_ParseVarName returns, the first token pointed to by the tokenPtr field of the Tcl_Parse structure always has type TCL_TOKEN_VARIABLE . It is followed by the sub-tokens that make up the variable name as described above. The total length of the variable name is contained in the size field of the first token. As in Tcl_ParseExpr , only the token information in the Tcl_Parse structure is modified by Tcl_ParseVarName : the commentStart , commentSize , commandStart , and commandSize fields are not modified. All of the character pointers in the Tcl_Parse and Tcl_Token structures refer to characters in the start argument passed to Tcl_ParseCommand , Tcl_ParseExpr , Tcl_ParseBraces , Tcl_ParseQuotedString , and Tcl_ParseVarName . There are additional fields in the Tcl_Parse structure after the numTokens field, but these are for the private use of Tcl_ParseCommand , Tcl_ParseExpr , Tcl_ParseBraces , Tcl_ParseQuotedString , and Tcl_ParseVarName ; they should not be referenced by code outside of these procedures.","title":"TCL_PARSE STRUCTURE"},{"location":"ParseCmd/#keywords","text":"backslash substitution, braces, command, expression, parse, token, variable substitution","title":"KEYWORDS"},{"location":"PkgRequire/","text":"NAME Tcl_PkgRequire, Tcl_PkgRequireEx, Tcl_PkgRequireProc, Tcl_PkgPresent, Tcl_PkgPresentEx, Tcl_PkgProvide, Tcl_PkgProvideEx - package version control SYNOPSIS #include <tcl.h> const char * Tcl_PkgRequire(interp, name, version, exact) const char * Tcl_PkgRequireEx(interp, name, version, exact, clientDataPtr) int Tcl_PkgRequireProc(interp, name, objc, objv, clientDataPtr) const char * Tcl_PkgPresent(interp, name, version, exact) const char * Tcl_PkgPresentEx(interp, name, version, exact, clientDataPtr) int Tcl_PkgProvide(interp, name, version) int Tcl_PkgProvideEx(interp, name, version, clientData) ARGUMENTS Interpreter where package is needed or available. Name of package. A version string consisting of one or more decimal numbers separated by dots. Non-zero means that only the particular version specified by version is acceptable. Zero means that newer versions than version are also acceptable as long as they have the same major version number as version . Arbitrary value to be associated with the package. Pointer to place to store the value associated with the matching package. It is only changed if the pointer is not NULL and the function completed successfully. The storage can be any pointer type with the same size as a void pointer. Number of requirements. Array of requirements. DESCRIPTION These procedures provide C-level interfaces to Tcl\\'s package and version management facilities. Tcl_PkgRequire is equivalent to the package require command, Tcl_PkgPresent is equivalent to the package present command, and Tcl_PkgProvide is equivalent to the package provide command. See the documentation for the Tcl commands for details on what these procedures do. If Tcl_PkgPresent or Tcl_PkgRequire complete successfully they return a pointer to the version string for the version of the package that is provided in the interpreter (which may be different than version ); if an error occurs they return NULL and leave an error message in the interpreter\\'s result. Tcl_PkgProvide returns TCL_OK if it completes successfully; if an error occurs it returns TCL_ERROR and leaves an error message in the interpreter\\'s result. Tcl_PkgProvideEx , Tcl_PkgPresentEx and Tcl_PkgRequireEx allow the setting and retrieving of the client data associated with the package. In all other respects they are equivalent to the matching functions. Tcl_PkgRequireProc is the form of package require handling multiple requirements. The other forms are present for backward compatibility and translate their invocations to this form. REFERENCE COUNT MANAGEMENT The requirements values given (in the objv argument) to Tcl_PkgRequireProc must have non-zero reference counts. KEYWORDS package, present, provide, require, version SEE ALSO package(n), Tcl_StaticLibrary(3)","title":"NAME"},{"location":"PkgRequire/#name","text":"Tcl_PkgRequire, Tcl_PkgRequireEx, Tcl_PkgRequireProc, Tcl_PkgPresent, Tcl_PkgPresentEx, Tcl_PkgProvide, Tcl_PkgProvideEx - package version control","title":"NAME"},{"location":"PkgRequire/#synopsis","text":"#include <tcl.h> const char * Tcl_PkgRequire(interp, name, version, exact) const char * Tcl_PkgRequireEx(interp, name, version, exact, clientDataPtr) int Tcl_PkgRequireProc(interp, name, objc, objv, clientDataPtr) const char * Tcl_PkgPresent(interp, name, version, exact) const char * Tcl_PkgPresentEx(interp, name, version, exact, clientDataPtr) int Tcl_PkgProvide(interp, name, version) int Tcl_PkgProvideEx(interp, name, version, clientData)","title":"SYNOPSIS"},{"location":"PkgRequire/#arguments","text":"Interpreter where package is needed or available. Name of package. A version string consisting of one or more decimal numbers separated by dots. Non-zero means that only the particular version specified by version is acceptable. Zero means that newer versions than version are also acceptable as long as they have the same major version number as version . Arbitrary value to be associated with the package. Pointer to place to store the value associated with the matching package. It is only changed if the pointer is not NULL and the function completed successfully. The storage can be any pointer type with the same size as a void pointer. Number of requirements. Array of requirements.","title":"ARGUMENTS"},{"location":"PkgRequire/#description","text":"These procedures provide C-level interfaces to Tcl\\'s package and version management facilities. Tcl_PkgRequire is equivalent to the package require command, Tcl_PkgPresent is equivalent to the package present command, and Tcl_PkgProvide is equivalent to the package provide command. See the documentation for the Tcl commands for details on what these procedures do. If Tcl_PkgPresent or Tcl_PkgRequire complete successfully they return a pointer to the version string for the version of the package that is provided in the interpreter (which may be different than version ); if an error occurs they return NULL and leave an error message in the interpreter\\'s result. Tcl_PkgProvide returns TCL_OK if it completes successfully; if an error occurs it returns TCL_ERROR and leaves an error message in the interpreter\\'s result. Tcl_PkgProvideEx , Tcl_PkgPresentEx and Tcl_PkgRequireEx allow the setting and retrieving of the client data associated with the package. In all other respects they are equivalent to the matching functions. Tcl_PkgRequireProc is the form of package require handling multiple requirements. The other forms are present for backward compatibility and translate their invocations to this form.","title":"DESCRIPTION"},{"location":"PkgRequire/#reference-count-management","text":"The requirements values given (in the objv argument) to Tcl_PkgRequireProc must have non-zero reference counts.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"PkgRequire/#keywords","text":"package, present, provide, require, version","title":"KEYWORDS"},{"location":"PkgRequire/#see-also","text":"package(n), Tcl_StaticLibrary(3)","title":"SEE ALSO"},{"location":"Preserve/","text":"NAME Tcl_Preserve, Tcl_Release, Tcl_EventuallyFree - avoid freeing storage while it is being used SYNOPSIS #include <tcl.h> Tcl_Preserve(clientData) Tcl_Release(clientData) Tcl_EventuallyFree(clientData, freeProc) ARGUMENTS Token describing structure to be freed or reallocated. Usually a pointer to memory for structure. Procedure to invoke to free clientData . DESCRIPTION These three procedures help implement a simple reference count mechanism for managing storage. They are designed to solve a problem having to do with widget deletion, but are also useful in many other situations. When a widget is deleted, its widget record (the structure holding information specific to the widget) must be returned to the storage allocator. However, it is possible that the widget record is in active use by one of the procedures on the stack at the time of the deletion. This can happen, for example, if the command associated with a button widget causes the button to be destroyed: an X event causes an event-handling C procedure in the button to be invoked, which in turn causes the button\\'s associated Tcl command to be executed, which in turn causes the button to be deleted, which in turn causes the button\\'s widget record to be de-allocated. Unfortunately, when the Tcl command returns, the button\\'s event-handling procedure will need to reference the button\\'s widget record. Because of this, the widget record must not be freed as part of the deletion, but must be retained until the event-handling procedure has finished with it. In other situations where the widget is deleted, it may be possible to free the widget record immediately. Tcl_Preserve and Tcl_Release implement short-term reference counts for their clientData argument. The clientData argument identifies an object and usually consists of the address of a structure. The reference counts guarantee that an object will not be freed until each call to Tcl_Preserve for the object has been matched by calls to Tcl_Release . There may be any number of unmatched Tcl_Preserve calls in effect at once. Tcl_EventuallyFree is invoked to free up its clientData argument. It checks to see if there are unmatched Tcl_Preserve calls for the object. If not, then Tcl_EventuallyFree calls freeProc immediately. Otherwise Tcl_EventuallyFree records the fact that clientData needs eventually to be freed. When all calls to Tcl_Preserve have been matched with calls to Tcl_Release then freeProc will be called by Tcl_Release to do the cleanup. All the work of freeing the object is carried out by freeProc . FreeProc must have arguments and result that match the type Tcl_FreeProc : typedef void Tcl_FreeProc ( char * blockPtr ); The blockPtr argument to freeProc will be the same as the clientData argument to Tcl_EventuallyFree . The type of blockPtr ( char * ) is different than the type of the clientData argument to Tcl_EventuallyFree for historical reasons, but the value is the same. When the clientData argument to Tcl_EventuallyFree refers to storage allocated and returned by a prior call to Tcl_Alloc or another function of the Tcl library, then the freeProc argument should be given the special value of TCL_DYNAMIC . This mechanism can be used to solve the problem described above by placing Tcl_Preserve and Tcl_Release calls around actions that may cause undesired storage re-allocation. The mechanism is intended only for short-term use (i.e. while procedures are pending on the stack); it will not work efficiently as a mechanism for long-term reference counts. The implementation does not depend in any way on the internal structure of the objects being freed; it keeps the reference counts in a separate structure. SEE ALSO Tcl_Interp, Tcl_Alloc KEYWORDS free, reference count, storage","title":"NAME"},{"location":"Preserve/#name","text":"Tcl_Preserve, Tcl_Release, Tcl_EventuallyFree - avoid freeing storage while it is being used","title":"NAME"},{"location":"Preserve/#synopsis","text":"#include <tcl.h> Tcl_Preserve(clientData) Tcl_Release(clientData) Tcl_EventuallyFree(clientData, freeProc)","title":"SYNOPSIS"},{"location":"Preserve/#arguments","text":"Token describing structure to be freed or reallocated. Usually a pointer to memory for structure. Procedure to invoke to free clientData .","title":"ARGUMENTS"},{"location":"Preserve/#description","text":"These three procedures help implement a simple reference count mechanism for managing storage. They are designed to solve a problem having to do with widget deletion, but are also useful in many other situations. When a widget is deleted, its widget record (the structure holding information specific to the widget) must be returned to the storage allocator. However, it is possible that the widget record is in active use by one of the procedures on the stack at the time of the deletion. This can happen, for example, if the command associated with a button widget causes the button to be destroyed: an X event causes an event-handling C procedure in the button to be invoked, which in turn causes the button\\'s associated Tcl command to be executed, which in turn causes the button to be deleted, which in turn causes the button\\'s widget record to be de-allocated. Unfortunately, when the Tcl command returns, the button\\'s event-handling procedure will need to reference the button\\'s widget record. Because of this, the widget record must not be freed as part of the deletion, but must be retained until the event-handling procedure has finished with it. In other situations where the widget is deleted, it may be possible to free the widget record immediately. Tcl_Preserve and Tcl_Release implement short-term reference counts for their clientData argument. The clientData argument identifies an object and usually consists of the address of a structure. The reference counts guarantee that an object will not be freed until each call to Tcl_Preserve for the object has been matched by calls to Tcl_Release . There may be any number of unmatched Tcl_Preserve calls in effect at once. Tcl_EventuallyFree is invoked to free up its clientData argument. It checks to see if there are unmatched Tcl_Preserve calls for the object. If not, then Tcl_EventuallyFree calls freeProc immediately. Otherwise Tcl_EventuallyFree records the fact that clientData needs eventually to be freed. When all calls to Tcl_Preserve have been matched with calls to Tcl_Release then freeProc will be called by Tcl_Release to do the cleanup. All the work of freeing the object is carried out by freeProc . FreeProc must have arguments and result that match the type Tcl_FreeProc : typedef void Tcl_FreeProc ( char * blockPtr ); The blockPtr argument to freeProc will be the same as the clientData argument to Tcl_EventuallyFree . The type of blockPtr ( char * ) is different than the type of the clientData argument to Tcl_EventuallyFree for historical reasons, but the value is the same. When the clientData argument to Tcl_EventuallyFree refers to storage allocated and returned by a prior call to Tcl_Alloc or another function of the Tcl library, then the freeProc argument should be given the special value of TCL_DYNAMIC . This mechanism can be used to solve the problem described above by placing Tcl_Preserve and Tcl_Release calls around actions that may cause undesired storage re-allocation. The mechanism is intended only for short-term use (i.e. while procedures are pending on the stack); it will not work efficiently as a mechanism for long-term reference counts. The implementation does not depend in any way on the internal structure of the objects being freed; it keeps the reference counts in a separate structure.","title":"DESCRIPTION"},{"location":"Preserve/#see-also","text":"Tcl_Interp, Tcl_Alloc","title":"SEE ALSO"},{"location":"Preserve/#keywords","text":"free, reference count, storage","title":"KEYWORDS"},{"location":"PrintDbl/","text":"NAME Tcl_PrintDouble - Convert floating value to string SYNOPSIS #include <tcl.h> Tcl_PrintDouble(interp, value, dst) ARGUMENTS This argument is ignored. Floating-point value to be converted. Where to store the string representing value . Must have at least TCL_DOUBLE_SPACE characters of storage. DESCRIPTION Tcl_PrintDouble generates a string that represents the value of value and stores it in memory at the location given by dst . It uses %g format to generate the string, with one special twist: the string is guaranteed to contain either a or an so that it does not look like an integer. Where %g would generate an integer with no decimal point, Tcl_PrintDouble adds The result will have the fewest digits needed to represent the number in such a way that Tcl_NewDoubleObj will generate the same number when presented with the given string. IEEE semantics of rounding to even apply to the conversion. KEYWORDS conversion, double-precision, floating-point, string","title":"NAME"},{"location":"PrintDbl/#name","text":"Tcl_PrintDouble - Convert floating value to string","title":"NAME"},{"location":"PrintDbl/#synopsis","text":"#include <tcl.h> Tcl_PrintDouble(interp, value, dst)","title":"SYNOPSIS"},{"location":"PrintDbl/#arguments","text":"This argument is ignored. Floating-point value to be converted. Where to store the string representing value . Must have at least TCL_DOUBLE_SPACE characters of storage.","title":"ARGUMENTS"},{"location":"PrintDbl/#description","text":"Tcl_PrintDouble generates a string that represents the value of value and stores it in memory at the location given by dst . It uses %g format to generate the string, with one special twist: the string is guaranteed to contain either a or an so that it does not look like an integer. Where %g would generate an integer with no decimal point, Tcl_PrintDouble adds The result will have the fewest digits needed to represent the number in such a way that Tcl_NewDoubleObj will generate the same number when presented with the given string. IEEE semantics of rounding to even apply to the conversion.","title":"DESCRIPTION"},{"location":"PrintDbl/#keywords","text":"conversion, double-precision, floating-point, string","title":"KEYWORDS"},{"location":"RecEvalObj/","text":"NAME Tcl_RecordAndEvalObj - save command on history list before evaluating SYNOPSIS #include <tcl.h> int Tcl_RecordAndEvalObj(interp, cmdPtr, flags) ARGUMENTS Tcl interpreter in which to evaluate command. Points to a Tcl value containing a command (or sequence of commands) to execute. An OR\\'ed combination of flag bits. TCL_NO_EVAL means record the command but do not evaluate it. TCL_EVAL_GLOBAL means evaluate the command at global level instead of the current stack level. DESCRIPTION Tcl_RecordAndEvalObj is invoked to record a command as an event on the history list and then execute it using Tcl_EvalObjEx . It returns a completion code such as TCL_OK just like Tcl_EvalObjEx , as well as a result value containing additional information (a result value or error message) that can be retrieved using Tcl_GetObjResult . If you do not want the command recorded on the history list then you should invoke Tcl_EvalObjEx instead of Tcl_RecordAndEvalObj . Normally Tcl_RecordAndEvalObj is only called with top-level commands typed by the user, since the purpose of history is to allow the user to re-issue recently invoked commands. If the flags argument contains the TCL_NO_EVAL bit then the command is recorded without being evaluated. REFERENCE COUNT MANAGEMENT The reference count of the cmdPtr argument to Tcl_RecordAndEvalObj must be at least 1. This function will modify the interpreter result; do not use an existing result as cmdPtr directly without incrementing its reference count. SEE ALSO Tcl_EvalObjEx, Tcl_GetObjResult KEYWORDS command, event, execute, history, interpreter, value, record","title":"NAME"},{"location":"RecEvalObj/#name","text":"Tcl_RecordAndEvalObj - save command on history list before evaluating","title":"NAME"},{"location":"RecEvalObj/#synopsis","text":"#include <tcl.h> int Tcl_RecordAndEvalObj(interp, cmdPtr, flags)","title":"SYNOPSIS"},{"location":"RecEvalObj/#arguments","text":"Tcl interpreter in which to evaluate command. Points to a Tcl value containing a command (or sequence of commands) to execute. An OR\\'ed combination of flag bits. TCL_NO_EVAL means record the command but do not evaluate it. TCL_EVAL_GLOBAL means evaluate the command at global level instead of the current stack level.","title":"ARGUMENTS"},{"location":"RecEvalObj/#description","text":"Tcl_RecordAndEvalObj is invoked to record a command as an event on the history list and then execute it using Tcl_EvalObjEx . It returns a completion code such as TCL_OK just like Tcl_EvalObjEx , as well as a result value containing additional information (a result value or error message) that can be retrieved using Tcl_GetObjResult . If you do not want the command recorded on the history list then you should invoke Tcl_EvalObjEx instead of Tcl_RecordAndEvalObj . Normally Tcl_RecordAndEvalObj is only called with top-level commands typed by the user, since the purpose of history is to allow the user to re-issue recently invoked commands. If the flags argument contains the TCL_NO_EVAL bit then the command is recorded without being evaluated.","title":"DESCRIPTION"},{"location":"RecEvalObj/#reference-count-management","text":"The reference count of the cmdPtr argument to Tcl_RecordAndEvalObj must be at least 1. This function will modify the interpreter result; do not use an existing result as cmdPtr directly without incrementing its reference count.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"RecEvalObj/#see-also","text":"Tcl_EvalObjEx, Tcl_GetObjResult","title":"SEE ALSO"},{"location":"RecEvalObj/#keywords","text":"command, event, execute, history, interpreter, value, record","title":"KEYWORDS"},{"location":"RecordEval/","text":"NAME Tcl_RecordAndEval - save command on history list before evaluating SYNOPSIS #include <tcl.h> int Tcl_RecordAndEval(interp, cmd, flags) ARGUMENTS Tcl interpreter in which to evaluate command. Command (or sequence of commands) to execute. An OR\\'ed combination of flag bits. TCL_NO_EVAL means record the command but do not evaluate it. TCL_EVAL_GLOBAL means evaluate the command at global level instead of the current stack level. DESCRIPTION Tcl_RecordAndEval is invoked to record a command as an event on the history list and then execute it using Tcl_Eval (or Tcl_GlobalEval if the TCL_EVAL_GLOBAL bit is set in flags ). It returns a completion code such as TCL_OK just like Tcl_Eval and it leaves information in the interpreter\\'s result. If you do not want the command recorded on the history list then you should invoke Tcl_Eval instead of Tcl_RecordAndEval . Normally Tcl_RecordAndEval is only called with top-level commands typed by the user, since the purpose of history is to allow the user to re-issue recently-invoked commands. If the flags argument contains the TCL_NO_EVAL bit then the command is recorded without being evaluated. Note that Tcl_RecordAndEval has been largely replaced by the value-based procedure Tcl_RecordAndEvalObj . That value-based procedure records and optionally executes a command held in a Tcl value instead of a string. SEE ALSO Tcl_RecordAndEvalObj KEYWORDS command, event, execute, history, interpreter, record","title":"NAME"},{"location":"RecordEval/#name","text":"Tcl_RecordAndEval - save command on history list before evaluating","title":"NAME"},{"location":"RecordEval/#synopsis","text":"#include <tcl.h> int Tcl_RecordAndEval(interp, cmd, flags)","title":"SYNOPSIS"},{"location":"RecordEval/#arguments","text":"Tcl interpreter in which to evaluate command. Command (or sequence of commands) to execute. An OR\\'ed combination of flag bits. TCL_NO_EVAL means record the command but do not evaluate it. TCL_EVAL_GLOBAL means evaluate the command at global level instead of the current stack level.","title":"ARGUMENTS"},{"location":"RecordEval/#description","text":"Tcl_RecordAndEval is invoked to record a command as an event on the history list and then execute it using Tcl_Eval (or Tcl_GlobalEval if the TCL_EVAL_GLOBAL bit is set in flags ). It returns a completion code such as TCL_OK just like Tcl_Eval and it leaves information in the interpreter\\'s result. If you do not want the command recorded on the history list then you should invoke Tcl_Eval instead of Tcl_RecordAndEval . Normally Tcl_RecordAndEval is only called with top-level commands typed by the user, since the purpose of history is to allow the user to re-issue recently-invoked commands. If the flags argument contains the TCL_NO_EVAL bit then the command is recorded without being evaluated. Note that Tcl_RecordAndEval has been largely replaced by the value-based procedure Tcl_RecordAndEvalObj . That value-based procedure records and optionally executes a command held in a Tcl value instead of a string.","title":"DESCRIPTION"},{"location":"RecordEval/#see-also","text":"Tcl_RecordAndEvalObj","title":"SEE ALSO"},{"location":"RecordEval/#keywords","text":"command, event, execute, history, interpreter, record","title":"KEYWORDS"},{"location":"RegConfig/","text":"NAME Tcl_RegisterConfig - procedures to register embedded configuration information SYNOPSIS #include <tcl.h> void Tcl_RegisterConfig(interp, pkgName, configuration, valEncoding) ARGUMENTS Refers to the interpreter the embedded configuration information is registered for. Must not be NULL. Contains the name of the package registering the embedded configuration as ASCII string. This means that this information is in UTF-8 too. Must not be NULL. Refers to an array of Tcl_Config entries containing the information embedded in the library. Must not be NULL. The end of the array is signaled by either a key identical to NULL, or a key referring to the empty string. Contains the name of the encoding used to store the configuration values as ASCII string. This means that this information is in UTF-8 too. Must not be NULL. DESCRIPTION The function described here has its base in TIP 59 and provides extensions with support for the embedding of configuration information into their library and the generation of a Tcl-level interface for querying this information. To embed configuration information into their library an extension has to define a non-volatile array of Tcl_Config entries in one if its source files and then call Tcl_RegisterConfig to register that information. Tcl_RegisterConfig takes four arguments; first, a reference to the interpreter we are registering the information with, second, the name of the package registering its configuration information, third, a pointer to an array of structures, and fourth a string declaring the encoding used by the configuration values. The string valEncoding contains the name of an encoding known to Tcl. All these names are use only characters in the ASCII subset of UTF-8 and are thus implicitly in the UTF-8 encoding. It is expected that keys are legible English text and therefore using the ASCII subset of UTF-8. In other words, they are expected to be in UTF-8 too. The values associated with the keys can be any string however. For these the contents of valEncoding define which encoding was used to represent the characters of the strings. Each element of the configuration array refers to two strings containing the key and the value associated with that key. The end of the array is signaled by either an empty key or a key identical to NULL. The function makes no copy of the configuration array. This means that the caller has to make sure that the memory holding this array is never released. This is the meaning behind the word non-volatile used earlier. The easiest way to accomplish this is to define a global static array of Tcl_Config entries. See the file in the sources of the Tcl core for an example. When called Tcl_RegisterConfig will (1) create a namespace having the provided pkgName , if not yet existing. (2) create the command pkgconfig in that namespace and link it to the provided information so that the keys from configuration and their associated values can be retrieved through calls to pkgconfig . The command pkgconfig will provide two subcommands, list and get : :: pkgName :: pkgconfig list : Returns a list containing the names of all defined keys. :: pkgName :: pkgconfig get key : Returns the configuration value associated with the specified key . TCL_CONFIG The Tcl_Config structure contains the following fields: typedef struct Tcl_Config { const char * key ; const char * value ; } Tcl_Config ; KEYWORDS embedding, configuration, library","title":"NAME"},{"location":"RegConfig/#name","text":"Tcl_RegisterConfig - procedures to register embedded configuration information","title":"NAME"},{"location":"RegConfig/#synopsis","text":"#include <tcl.h> void Tcl_RegisterConfig(interp, pkgName, configuration, valEncoding)","title":"SYNOPSIS"},{"location":"RegConfig/#arguments","text":"Refers to the interpreter the embedded configuration information is registered for. Must not be NULL. Contains the name of the package registering the embedded configuration as ASCII string. This means that this information is in UTF-8 too. Must not be NULL. Refers to an array of Tcl_Config entries containing the information embedded in the library. Must not be NULL. The end of the array is signaled by either a key identical to NULL, or a key referring to the empty string. Contains the name of the encoding used to store the configuration values as ASCII string. This means that this information is in UTF-8 too. Must not be NULL.","title":"ARGUMENTS"},{"location":"RegConfig/#description","text":"The function described here has its base in TIP 59 and provides extensions with support for the embedding of configuration information into their library and the generation of a Tcl-level interface for querying this information. To embed configuration information into their library an extension has to define a non-volatile array of Tcl_Config entries in one if its source files and then call Tcl_RegisterConfig to register that information. Tcl_RegisterConfig takes four arguments; first, a reference to the interpreter we are registering the information with, second, the name of the package registering its configuration information, third, a pointer to an array of structures, and fourth a string declaring the encoding used by the configuration values. The string valEncoding contains the name of an encoding known to Tcl. All these names are use only characters in the ASCII subset of UTF-8 and are thus implicitly in the UTF-8 encoding. It is expected that keys are legible English text and therefore using the ASCII subset of UTF-8. In other words, they are expected to be in UTF-8 too. The values associated with the keys can be any string however. For these the contents of valEncoding define which encoding was used to represent the characters of the strings. Each element of the configuration array refers to two strings containing the key and the value associated with that key. The end of the array is signaled by either an empty key or a key identical to NULL. The function makes no copy of the configuration array. This means that the caller has to make sure that the memory holding this array is never released. This is the meaning behind the word non-volatile used earlier. The easiest way to accomplish this is to define a global static array of Tcl_Config entries. See the file in the sources of the Tcl core for an example. When called Tcl_RegisterConfig will (1) create a namespace having the provided pkgName , if not yet existing. (2) create the command pkgconfig in that namespace and link it to the provided information so that the keys from configuration and their associated values can be retrieved through calls to pkgconfig . The command pkgconfig will provide two subcommands, list and get : :: pkgName :: pkgconfig list : Returns a list containing the names of all defined keys. :: pkgName :: pkgconfig get key : Returns the configuration value associated with the specified key .","title":"DESCRIPTION"},{"location":"RegConfig/#tcl_config","text":"The Tcl_Config structure contains the following fields: typedef struct Tcl_Config { const char * key ; const char * value ; } Tcl_Config ;","title":"TCL_CONFIG"},{"location":"RegConfig/#keywords","text":"embedding, configuration, library","title":"KEYWORDS"},{"location":"RegExp/","text":"NAME regexp - Match a regular expression against a string SYNOPSIS regexp ? switches ? exp string ? matchVar ? ? subMatchVar subMatchVar ... ? DESCRIPTION Determines whether the regular expression exp matches part or all of string and returns 1 if it does, 0 if it does not, unless -inline is specified (see below). (Regular expression matching is described in the re_syntax reference page.) If additional arguments are specified after string then they are treated as the names of variables in which to return information about which part(s) of string matched exp . MatchVar will be set to the range of string that matched all of exp . The first subMatchVar will contain the characters in string that matched the leftmost parenthesized subexpression within exp , the next subMatchVar will contain the characters that matched the next parenthesized subexpression to the right in exp , and so on. If the initial arguments to regexp start with - then they are treated as switches. The following switches are currently supported: -about : Instead of attempting to match the regular expression, returns a list containing information about the regular expression. The first element of the list is a subexpression count. The second element is a list of property names that describe various attributes of the regular expression. This switch is primarily intended for debugging purposes. -expanded : Enables use of the expanded regular expression syntax where whitespace and comments are ignored. This is the same as specifying the (?x) embedded option (see the re_syntax manual page). -indices : Changes what is stored in the matchVar and subMatchVar s. Instead of storing the matching characters from string , each variable will contain a list of two decimal strings giving the indices in string of the first and last characters in the matching range of characters. -line : Enables newline-sensitive matching. By default, newline is a completely ordinary character with no special meaning. With this flag, bracket expressions and never match newline, matches an empty string after any newline in addition to its normal function, and matches an empty string before any newline in addition to its normal function. This flag is equivalent to specifying both -linestop and -lineanchor , or the (?n) embedded option (see the re_syntax manual page). -linestop : Changes the behavior of bracket expressions and so that they stop at newlines. This is the same as specifying the (?p) embedded option (see the re_syntax manual page). -lineanchor : Changes the behavior of and (the so they match the beginning and end of a line respectively. This is the same as specifying the (?w) embedded option (see the re_syntax manual page). -nocase : Causes upper-case characters in string to be treated as lower case during the matching process. -all : Causes the regular expression to be matched as many times as possible in the string, returning the total number of matches found. If this is specified with match variables, they will contain information for the last match only. -inline : Causes the command to return, as a list, the data that would otherwise be placed in match variables. When using -inline , match variables may not be specified. If used with -all , the list will be concatenated at each iteration, such that a flat list is always returned. For each match iteration, the command will append the overall match data, plus one element for each subexpression in the regular expression. Examples are: **regexp** -inline \\-- {\\\\w(\\\\w)} \\\" inlined \\\" *\u2192 in n* **regexp** -all -inline \\-- {\\\\w(\\\\w)} \\\" inlined \\\" *\u2192 in n li i ne e* -start index : Specifies a character index offset into the string to start matching the regular expression at. The index value is interpreted in the same manner as the index argument to string index . When using this switch, will not match the beginning of the line, and \\A will still match the start of the string at index . If -indices is specified, the indices will be indexed starting from the absolute beginning of the input string. index will be constrained to the bounds of the input string. -\u2006- : Marks the end of switches. The argument following this one will be treated as exp even if it starts with a - . If there are more subMatchVar s than parenthesized subexpressions within exp , or if a particular subexpression in exp does not match the string (e.g. because it was in a portion of the expression that was not matched), then the corresponding subMatchVar will be set to if -indices has been specified or to an empty string otherwise. EXAMPLES Find the first occurrence of a word starting with foo in a string that is not actually an instance of foobar , and get the letters following it up to the end of the word into a variable: regexp {\\mfoo(?!bar\\M)(\\w*)} \\$string -> restOfWord Note that the whole matched substring has been placed in the variable which is a name chosen to look nice given that we are not actually interested in its contents. Find the index of the word badger (in any case) within a string and store that in the variable location : regexp -indices {(?i)\\mbadger\\M} \\$string location This could also be written as a basic regular expression (as opposed to using the default syntax of advanced regular expressions) match by prefixing the expression with a suitable flag: regexp -indices {(?ib)\\\\<badger\\>} \\$string location This counts the number of octal digits in a string: regexp -all {[0-7]} \\$string This lists all words (consisting of all sequences of non-whitespace characters) in a string, and is useful as a more powerful version of the split command: regexp -all -inline {\\S+} \\$string SEE ALSO re_syntax(n), regsub(n), string(n) KEYWORDS match, parsing, pattern, regular expression, splitting, string","title":"NAME"},{"location":"RegExp/#name","text":"regexp - Match a regular expression against a string","title":"NAME"},{"location":"RegExp/#synopsis","text":"regexp ? switches ? exp string ? matchVar ? ? subMatchVar subMatchVar ... ?","title":"SYNOPSIS"},{"location":"RegExp/#description","text":"Determines whether the regular expression exp matches part or all of string and returns 1 if it does, 0 if it does not, unless -inline is specified (see below). (Regular expression matching is described in the re_syntax reference page.) If additional arguments are specified after string then they are treated as the names of variables in which to return information about which part(s) of string matched exp . MatchVar will be set to the range of string that matched all of exp . The first subMatchVar will contain the characters in string that matched the leftmost parenthesized subexpression within exp , the next subMatchVar will contain the characters that matched the next parenthesized subexpression to the right in exp , and so on. If the initial arguments to regexp start with - then they are treated as switches. The following switches are currently supported: -about : Instead of attempting to match the regular expression, returns a list containing information about the regular expression. The first element of the list is a subexpression count. The second element is a list of property names that describe various attributes of the regular expression. This switch is primarily intended for debugging purposes. -expanded : Enables use of the expanded regular expression syntax where whitespace and comments are ignored. This is the same as specifying the (?x) embedded option (see the re_syntax manual page). -indices : Changes what is stored in the matchVar and subMatchVar s. Instead of storing the matching characters from string , each variable will contain a list of two decimal strings giving the indices in string of the first and last characters in the matching range of characters. -line : Enables newline-sensitive matching. By default, newline is a completely ordinary character with no special meaning. With this flag, bracket expressions and never match newline, matches an empty string after any newline in addition to its normal function, and matches an empty string before any newline in addition to its normal function. This flag is equivalent to specifying both -linestop and -lineanchor , or the (?n) embedded option (see the re_syntax manual page). -linestop : Changes the behavior of bracket expressions and so that they stop at newlines. This is the same as specifying the (?p) embedded option (see the re_syntax manual page). -lineanchor : Changes the behavior of and (the so they match the beginning and end of a line respectively. This is the same as specifying the (?w) embedded option (see the re_syntax manual page). -nocase : Causes upper-case characters in string to be treated as lower case during the matching process. -all : Causes the regular expression to be matched as many times as possible in the string, returning the total number of matches found. If this is specified with match variables, they will contain information for the last match only. -inline : Causes the command to return, as a list, the data that would otherwise be placed in match variables. When using -inline , match variables may not be specified. If used with -all , the list will be concatenated at each iteration, such that a flat list is always returned. For each match iteration, the command will append the overall match data, plus one element for each subexpression in the regular expression. Examples are: **regexp** -inline \\-- {\\\\w(\\\\w)} \\\" inlined \\\" *\u2192 in n* **regexp** -all -inline \\-- {\\\\w(\\\\w)} \\\" inlined \\\" *\u2192 in n li i ne e* -start index : Specifies a character index offset into the string to start matching the regular expression at. The index value is interpreted in the same manner as the index argument to string index . When using this switch, will not match the beginning of the line, and \\A will still match the start of the string at index . If -indices is specified, the indices will be indexed starting from the absolute beginning of the input string. index will be constrained to the bounds of the input string. -\u2006- : Marks the end of switches. The argument following this one will be treated as exp even if it starts with a - . If there are more subMatchVar s than parenthesized subexpressions within exp , or if a particular subexpression in exp does not match the string (e.g. because it was in a portion of the expression that was not matched), then the corresponding subMatchVar will be set to if -indices has been specified or to an empty string otherwise.","title":"DESCRIPTION"},{"location":"RegExp/#examples","text":"Find the first occurrence of a word starting with foo in a string that is not actually an instance of foobar , and get the letters following it up to the end of the word into a variable: regexp {\\mfoo(?!bar\\M)(\\w*)} \\$string -> restOfWord Note that the whole matched substring has been placed in the variable which is a name chosen to look nice given that we are not actually interested in its contents. Find the index of the word badger (in any case) within a string and store that in the variable location : regexp -indices {(?i)\\mbadger\\M} \\$string location This could also be written as a basic regular expression (as opposed to using the default syntax of advanced regular expressions) match by prefixing the expression with a suitable flag: regexp -indices {(?ib)\\\\<badger\\>} \\$string location This counts the number of octal digits in a string: regexp -all {[0-7]} \\$string This lists all words (consisting of all sequences of non-whitespace characters) in a string, and is useful as a more powerful version of the split command: regexp -all -inline {\\S+} \\$string","title":"EXAMPLES"},{"location":"RegExp/#see-also","text":"re_syntax(n), regsub(n), string(n)","title":"SEE ALSO"},{"location":"RegExp/#keywords","text":"match, parsing, pattern, regular expression, splitting, string","title":"KEYWORDS"},{"location":"SaveInterpState/","text":"NAME Tcl_SaveInterpState, Tcl_RestoreInterpState, Tcl_DiscardInterpState - Save and restore the state of an an interpreter. SYNOPSIS #include <tcl.h> Tcl_InterpState Tcl_SaveInterpState(interp, status) int Tcl_RestoreInterpState(interp, state) Tcl_DiscardInterpState(state) ARGUMENTS The interpreter for the operation. The return code for the state. A token for saved state. DESCRIPTION These routines save the state of an interpreter before a call to a routine such as Tcl_Eval , and restore the state afterwards. Tcl_SaveInterpState saves the parts of interp that comprise the result of a script, including the resulting value, the return code passed as status , and any options such as -errorinfo and -errorcode . It returns a token for the saved state. The interpreter result is not reset and no interpreter state is changed. Tcl_RestoreInterpState restores the state indicated by state and returns the status originally passed in the corresponding call to Tcl_SaveInterpState . If a saved state is not restored, Tcl_DiscardInterpState must be called to release it. A token used to discard or restore state must not be used again. KEYWORDS result, state, interp","title":"NAME"},{"location":"SaveInterpState/#name","text":"Tcl_SaveInterpState, Tcl_RestoreInterpState, Tcl_DiscardInterpState - Save and restore the state of an an interpreter.","title":"NAME"},{"location":"SaveInterpState/#synopsis","text":"#include <tcl.h> Tcl_InterpState Tcl_SaveInterpState(interp, status) int Tcl_RestoreInterpState(interp, state) Tcl_DiscardInterpState(state)","title":"SYNOPSIS"},{"location":"SaveInterpState/#arguments","text":"The interpreter for the operation. The return code for the state. A token for saved state.","title":"ARGUMENTS"},{"location":"SaveInterpState/#description","text":"These routines save the state of an interpreter before a call to a routine such as Tcl_Eval , and restore the state afterwards. Tcl_SaveInterpState saves the parts of interp that comprise the result of a script, including the resulting value, the return code passed as status , and any options such as -errorinfo and -errorcode . It returns a token for the saved state. The interpreter result is not reset and no interpreter state is changed. Tcl_RestoreInterpState restores the state indicated by state and returns the status originally passed in the corresponding call to Tcl_SaveInterpState . If a saved state is not restored, Tcl_DiscardInterpState must be called to release it. A token used to discard or restore state must not be used again.","title":"DESCRIPTION"},{"location":"SaveInterpState/#keywords","text":"result, state, interp","title":"KEYWORDS"},{"location":"SetChanErr/","text":"NAME Tcl_SetChannelError, Tcl_SetChannelErrorInterp, Tcl_GetChannelError, Tcl_GetChannelErrorInterp - functions to create/intercept Tcl errors by channel drivers. SYNOPSIS #include <tcl.h> void Tcl_SetChannelError(chan, msg) void Tcl_SetChannelErrorInterp(interp, msg) void Tcl_GetChannelError(chan, msgPtr) void Tcl_GetChannelErrorInterp(interp, msgPtr) ARGUMENTS Refers to the Tcl channel whose bypass area is accessed. Refers to the Tcl interpreter whose bypass area is accessed. Error message put into a bypass area. A list of return options and values, followed by a string message. Both message and the option/value information are optional. This must be a well-formed list. Reference to a place where the message stored in the accessed bypass area can be stored in. DESCRIPTION The standard definition of a Tcl channel driver does not permit the direct return of arbitrary error messages, except for the setting and retrieval of channel options. All other functions are restricted to POSIX error codes. The functions described here overcome this limitation. Channel drivers are allowed to use Tcl_SetChannelError and Tcl_SetChannelErrorInterp to place arbitrary error messages in bypass areas defined for channels and interpreters. And the generic I/O layer uses Tcl_GetChannelError and Tcl_GetChannelErrorInterp to look for messages in the bypass areas and arrange for their return as errors. The POSIX error codes set by a driver are used now if and only if no messages are present. Tcl_SetChannelError stores error information in the bypass area of the specified channel. The number of references to the msg value goes up by one. Previously stored information will be discarded, by releasing the reference held by the channel. The channel reference must not be NULL. Tcl_SetChannelErrorInterp stores error information in the bypass area of the specified interpreter. The number of references to the msg value goes up by one. Previously stored information will be discarded, by releasing the reference held by the interpreter. The interpreter reference must not be NULL. Tcl_GetChannelError places either the error message held in the bypass area of the specified channel into msgPtr , or NULL; and resets the bypass, that is, after an invocation all following invocations will return NULL, until an intervening invocation of Tcl_SetChannelError with a non-NULL message. The msgPtr must not be NULL. The reference count of the message is not touched. The reference previously held by the channel is now held by the caller of the function and it is its responsibility to release that reference when it is done with the value. Tcl_GetChannelErrorInterp places either the error message held in the bypass area of the specified interpreter into msgPtr , or NULL; and resets the bypass, that is, after an invocation all following invocations will return NULL, until an intervening invocation of Tcl_SetChannelErrorInterp with a non-NULL message. The msgPtr must not be NULL. The reference count of the message is not touched. The reference previously held by the interpreter is now held by the caller of the function and it is its responsibility to release that reference when it is done with the value. Which functions of a channel driver are allowed to use which bypass function is listed below, as is which functions of the public channel API may leave a messages in the bypass areas. Tcl_DriverInputProc : May use Tcl_SetChannelError , and only this function. Tcl_DriverOutputProc : May use Tcl_SetChannelError , and only this function. Tcl_DriverWideSeekProc : May use Tcl_SetChannelError , and only this function. Tcl_DriverSetOptionProc : Has already the ability to pass arbitrary error messages. Must not use any of the new functions. Tcl_DriverGetOptionProc : Has already the ability to pass arbitrary error messages. Must not use any of the new functions. Tcl_DriverWatchProc : Must not use any of the new functions. Is internally called and has no ability to return any type of error whatsoever. Tcl_DriverBlockModeProc : May use Tcl_SetChannelError , and only this function. Tcl_DriverGetHandleProc : Must not use any of the new functions. It is only a low-level function, and not used by Tcl commands. Tcl_DriverHandlerProc : Must not use any of the new functions. Is internally called and has no ability to return any type of error whatsoever. Given the information above the following public functions of the Tcl C API are affected by these changes; when these functions are called, the channel may now contain a stored arbitrary error message requiring processing by the caller. Tcl_Flush Tcl_GetsObj Tcl_Gets Tcl_ReadChars Tcl_ReadRaw Tcl_Read Tcl_Seek Tcl_StackChannel Tcl_Tell Tcl_WriteChars Tcl_WriteObj Tcl_WriteRaw Tcl_Write All other API functions are unchanged. In particular, the functions below leave all their error information in the interpreter result. Tcl_Close Tcl_UnstackChannel Tcl_UnregisterChannel REFERENCE COUNT MANAGEMENT The msg argument to Tcl_SetChannelError and Tcl_SetChannelErrorInterp , if not NULL, may have any reference count; these functions will copy. Tcl_GetChannelError and Tcl_GetChannelErrorInterp write a value reference into their msgPtr , but do not manipulate its reference count. The reference count will be at least 1 (unless the reference is NULL). SEE ALSO Tcl_Close(3), Tcl_OpenFileChannel(3), Tcl_SetErrno(3) KEYWORDS channel driver, error messages, channel type","title":"NAME"},{"location":"SetChanErr/#name","text":"Tcl_SetChannelError, Tcl_SetChannelErrorInterp, Tcl_GetChannelError, Tcl_GetChannelErrorInterp - functions to create/intercept Tcl errors by channel drivers.","title":"NAME"},{"location":"SetChanErr/#synopsis","text":"#include <tcl.h> void Tcl_SetChannelError(chan, msg) void Tcl_SetChannelErrorInterp(interp, msg) void Tcl_GetChannelError(chan, msgPtr) void Tcl_GetChannelErrorInterp(interp, msgPtr)","title":"SYNOPSIS"},{"location":"SetChanErr/#arguments","text":"Refers to the Tcl channel whose bypass area is accessed. Refers to the Tcl interpreter whose bypass area is accessed. Error message put into a bypass area. A list of return options and values, followed by a string message. Both message and the option/value information are optional. This must be a well-formed list. Reference to a place where the message stored in the accessed bypass area can be stored in.","title":"ARGUMENTS"},{"location":"SetChanErr/#description","text":"The standard definition of a Tcl channel driver does not permit the direct return of arbitrary error messages, except for the setting and retrieval of channel options. All other functions are restricted to POSIX error codes. The functions described here overcome this limitation. Channel drivers are allowed to use Tcl_SetChannelError and Tcl_SetChannelErrorInterp to place arbitrary error messages in bypass areas defined for channels and interpreters. And the generic I/O layer uses Tcl_GetChannelError and Tcl_GetChannelErrorInterp to look for messages in the bypass areas and arrange for their return as errors. The POSIX error codes set by a driver are used now if and only if no messages are present. Tcl_SetChannelError stores error information in the bypass area of the specified channel. The number of references to the msg value goes up by one. Previously stored information will be discarded, by releasing the reference held by the channel. The channel reference must not be NULL. Tcl_SetChannelErrorInterp stores error information in the bypass area of the specified interpreter. The number of references to the msg value goes up by one. Previously stored information will be discarded, by releasing the reference held by the interpreter. The interpreter reference must not be NULL. Tcl_GetChannelError places either the error message held in the bypass area of the specified channel into msgPtr , or NULL; and resets the bypass, that is, after an invocation all following invocations will return NULL, until an intervening invocation of Tcl_SetChannelError with a non-NULL message. The msgPtr must not be NULL. The reference count of the message is not touched. The reference previously held by the channel is now held by the caller of the function and it is its responsibility to release that reference when it is done with the value. Tcl_GetChannelErrorInterp places either the error message held in the bypass area of the specified interpreter into msgPtr , or NULL; and resets the bypass, that is, after an invocation all following invocations will return NULL, until an intervening invocation of Tcl_SetChannelErrorInterp with a non-NULL message. The msgPtr must not be NULL. The reference count of the message is not touched. The reference previously held by the interpreter is now held by the caller of the function and it is its responsibility to release that reference when it is done with the value. Which functions of a channel driver are allowed to use which bypass function is listed below, as is which functions of the public channel API may leave a messages in the bypass areas. Tcl_DriverInputProc : May use Tcl_SetChannelError , and only this function. Tcl_DriverOutputProc : May use Tcl_SetChannelError , and only this function. Tcl_DriverWideSeekProc : May use Tcl_SetChannelError , and only this function. Tcl_DriverSetOptionProc : Has already the ability to pass arbitrary error messages. Must not use any of the new functions. Tcl_DriverGetOptionProc : Has already the ability to pass arbitrary error messages. Must not use any of the new functions. Tcl_DriverWatchProc : Must not use any of the new functions. Is internally called and has no ability to return any type of error whatsoever. Tcl_DriverBlockModeProc : May use Tcl_SetChannelError , and only this function. Tcl_DriverGetHandleProc : Must not use any of the new functions. It is only a low-level function, and not used by Tcl commands. Tcl_DriverHandlerProc : Must not use any of the new functions. Is internally called and has no ability to return any type of error whatsoever. Given the information above the following public functions of the Tcl C API are affected by these changes; when these functions are called, the channel may now contain a stored arbitrary error message requiring processing by the caller. Tcl_Flush Tcl_GetsObj Tcl_Gets Tcl_ReadChars Tcl_ReadRaw Tcl_Read Tcl_Seek Tcl_StackChannel Tcl_Tell Tcl_WriteChars Tcl_WriteObj Tcl_WriteRaw Tcl_Write All other API functions are unchanged. In particular, the functions below leave all their error information in the interpreter result. Tcl_Close Tcl_UnstackChannel Tcl_UnregisterChannel","title":"DESCRIPTION"},{"location":"SetChanErr/#reference-count-management","text":"The msg argument to Tcl_SetChannelError and Tcl_SetChannelErrorInterp , if not NULL, may have any reference count; these functions will copy. Tcl_GetChannelError and Tcl_GetChannelErrorInterp write a value reference into their msgPtr , but do not manipulate its reference count. The reference count will be at least 1 (unless the reference is NULL).","title":"REFERENCE COUNT MANAGEMENT"},{"location":"SetChanErr/#see-also","text":"Tcl_Close(3), Tcl_OpenFileChannel(3), Tcl_SetErrno(3)","title":"SEE ALSO"},{"location":"SetChanErr/#keywords","text":"channel driver, error messages, channel type","title":"KEYWORDS"},{"location":"SetErrno/","text":"NAME Tcl_SetErrno, Tcl_GetErrno, Tcl_ErrnoId, Tcl_ErrnoMsg - manipulate errno to store and retrieve error codes SYNOPSIS #include <tcl.h> void Tcl_SetErrno(errorCode) int Tcl_GetErrno() const char * Tcl_ErrnoId() const char * Tcl_ErrnoMsg(errorCode) ARGUMENTS A POSIX error code such as ENOENT . DESCRIPTION Tcl_SetErrno and Tcl_GetErrno provide portable access to the errno variable, which is used to record a POSIX error code after system calls and other operations such as Tcl_Gets . These procedures are necessary because global variable accesses cannot be made across module boundaries on some platforms. Tcl_SetErrno sets the errno variable to the value of the errorCode argument C procedures that wish to return error information to their callers via errno should call Tcl_SetErrno rather than setting errno directly. Tcl_GetErrno returns the current value of errno . Procedures wishing to access errno should call this procedure instead of accessing errno directly. Tcl_ErrnoId and Tcl_ErrnoMsg return string representations of errno values. Tcl_ErrnoId returns a machine-readable textual identifier such as that corresponds to the current value of errno . Tcl_ErrnoMsg returns a human-readable string such as that corresponds to the value of its errorCode argument. The errorCode argument is typically the value returned by Tcl_GetErrno . The strings returned by these functions are statically allocated and the caller must not free or modify them. KEYWORDS errno, error code, global variables","title":"NAME"},{"location":"SetErrno/#name","text":"Tcl_SetErrno, Tcl_GetErrno, Tcl_ErrnoId, Tcl_ErrnoMsg - manipulate errno to store and retrieve error codes","title":"NAME"},{"location":"SetErrno/#synopsis","text":"#include <tcl.h> void Tcl_SetErrno(errorCode) int Tcl_GetErrno() const char * Tcl_ErrnoId() const char * Tcl_ErrnoMsg(errorCode)","title":"SYNOPSIS"},{"location":"SetErrno/#arguments","text":"A POSIX error code such as ENOENT .","title":"ARGUMENTS"},{"location":"SetErrno/#description","text":"Tcl_SetErrno and Tcl_GetErrno provide portable access to the errno variable, which is used to record a POSIX error code after system calls and other operations such as Tcl_Gets . These procedures are necessary because global variable accesses cannot be made across module boundaries on some platforms. Tcl_SetErrno sets the errno variable to the value of the errorCode argument C procedures that wish to return error information to their callers via errno should call Tcl_SetErrno rather than setting errno directly. Tcl_GetErrno returns the current value of errno . Procedures wishing to access errno should call this procedure instead of accessing errno directly. Tcl_ErrnoId and Tcl_ErrnoMsg return string representations of errno values. Tcl_ErrnoId returns a machine-readable textual identifier such as that corresponds to the current value of errno . Tcl_ErrnoMsg returns a human-readable string such as that corresponds to the value of its errorCode argument. The errorCode argument is typically the value returned by Tcl_GetErrno . The strings returned by these functions are statically allocated and the caller must not free or modify them.","title":"DESCRIPTION"},{"location":"SetErrno/#keywords","text":"errno, error code, global variables","title":"KEYWORDS"},{"location":"SetRecLmt/","text":"NAME Tcl_SetRecursionLimit - set maximum allowable nesting depth in interpreter SYNOPSIS #include <tcl.h> Tcl_Size Tcl_SetRecursionLimit(interp, depth) ARGUMENTS Interpreter whose recursion limit is to be set. Must be greater than zero. New limit for nested calls to Tcl_Eval for interp . DESCRIPTION At any given time Tcl enforces a limit on the number of recursive calls that may be active for Tcl_Eval and related procedures such as Tcl_EvalEx . Any call to Tcl_Eval that exceeds this depth is aborted with an error. By default the recursion limit is 1000. Tcl_SetRecursionLimit may be used to change the maximum allowable nesting depth for an interpreter. The depth argument specifies a new limit for interp , and Tcl_SetRecursionLimit returns the old limit. To read out the old limit without modifying it, invoke Tcl_SetRecursionLimit with depth equal to 0. The Tcl_SetRecursionLimit only sets the size of the Tcl call stack: it cannot by itself prevent stack overflows on the C stack being used by the application. If your machine has a limit on the size of the C stack, you may get stack overflows before reaching the limit set by Tcl_SetRecursionLimit . If this happens, see if there is a mechanism in your system for increasing the maximum size of the C stack. KEYWORDS nesting depth, recursion","title":"NAME"},{"location":"SetRecLmt/#name","text":"Tcl_SetRecursionLimit - set maximum allowable nesting depth in interpreter","title":"NAME"},{"location":"SetRecLmt/#synopsis","text":"#include <tcl.h> Tcl_Size Tcl_SetRecursionLimit(interp, depth)","title":"SYNOPSIS"},{"location":"SetRecLmt/#arguments","text":"Interpreter whose recursion limit is to be set. Must be greater than zero. New limit for nested calls to Tcl_Eval for interp .","title":"ARGUMENTS"},{"location":"SetRecLmt/#description","text":"At any given time Tcl enforces a limit on the number of recursive calls that may be active for Tcl_Eval and related procedures such as Tcl_EvalEx . Any call to Tcl_Eval that exceeds this depth is aborted with an error. By default the recursion limit is 1000. Tcl_SetRecursionLimit may be used to change the maximum allowable nesting depth for an interpreter. The depth argument specifies a new limit for interp , and Tcl_SetRecursionLimit returns the old limit. To read out the old limit without modifying it, invoke Tcl_SetRecursionLimit with depth equal to 0. The Tcl_SetRecursionLimit only sets the size of the Tcl call stack: it cannot by itself prevent stack overflows on the C stack being used by the application. If your machine has a limit on the size of the C stack, you may get stack overflows before reaching the limit set by Tcl_SetRecursionLimit . If this happens, see if there is a mechanism in your system for increasing the maximum size of the C stack.","title":"DESCRIPTION"},{"location":"SetRecLmt/#keywords","text":"nesting depth, recursion","title":"KEYWORDS"},{"location":"SetResult/","text":"NAME Tcl_SetObjResult, Tcl_GetObjResult, Tcl_SetResult, Tcl_GetStringResult, Tcl_AppendResult, Tcl_AppendElement, Tcl_ResetResult, Tcl_TransferResult - manipulate Tcl result SYNOPSIS #include <tcl.h> Tcl_SetObjResult(interp, objPtr) Tcl_Obj * Tcl_GetObjResult(interp) Tcl_SetResult(interp, result, freeProc) const char * Tcl_GetStringResult(interp) Tcl_AppendResult(interp, result, result, ... , (char *) NULL) Tcl_ResetResult(interp) Tcl_TransferResult(sourceInterp, code, targetInterp) Tcl_AppendElement(interp, element) ARGUMENTS The interpreter get or set the result for. A value to set the result to. The string value set the result to, or to append to the existing result. The string value to append as a list element to the existing result of interp . Pointer to a procedure to call to release storage at result . The interpreter to transfer the result and return options from. The interpreter to transfer the result and return options to. Return code value that controls transfer of return options. DESCRIPTION These procedures manipulate the result of an interpreter. Some procedures provide a Tcl_Obj interface while others provide a string interface. For example, Tcl_SetObjResult accepts a Tcl_Obj and Tcl_SetResult accepts a char *. Similarly, Tcl_GetObjResult produces a Tcl_Obj * and Tcl_GetStringResult produces a char *. The procedures can be mixed and matched. For example, if Tcl_SetObjResult is called to set the result to a Tcl_Obj value, and then Tcl_GetStringResult is called, it returns a char * (but see caveats below). Tcl_SetObjResult sets objPtr as the result for interp , replacing any existing result. Tcl_GetObjResult returns the result for interp , without incrementing its reference count. Tcl_SetResult sets result as the result for interp , replacing any existing result, and calls freeProc to free result . See THE TCL_FREEPROC ARGUMENT TO TCL_SETRESULT below. If result is NULL , ignores freeProc and sets the result for interp to point to the empty string. Tcl_GetStringResult returns the result for interp as a string, i.e. the bytes of the Tcl_Obj for the result, which can be decoded using Tcl_UtfToExternal . This value is freed when its corresponding Tcl_Obj is freed.Programmers are encouraged to use the newer Tcl_Obj API procedures, e.g. to call Tcl_GetObjResult instead. Tcl_ResetResult sets the empty string as the result for interp and clears the error state managed by Tcl_AddErrorInfo , Tcl_AddObjErrorInfo , and Tcl_SetErrorCode . Tcl_AppendResult builds up a result from smaller pieces, appending each result in order to the current result for interp . It may be called repeatedly as additional pieces of the result are produced, and manages the storage for the interp \\'s result, allocating a larger result area if necessary. It also manages conversion to and from the result field of the interp to handle backward-compatibility with old-style extensions. Any number of result arguments may be passed in a single call; the last argument in the list must be a NULL pointer. Tcl_TransferResult transfers interpreter state from sourceInterp to targetInterp , both of which must have been created in the same thread, resets the result in sourceInterp , and moves the return options dictionary as controlled by the return code value code in the same manner as Tcl_GetReturnOptions . If sourceInterp and targetInterp are the same, nothing is done. DEPRECATED INTERFACES OLD STRING PROCEDURES The following procedures are deprecated since they manipulate the Tcl result as a string. Procedures such as Tcl_SetObjResult can be significantly more efficient. Tcl_AppendElement is like Tcl_AppendResult , but it appends only one piece, and also appends that piece as a list item. Tcl_AppendElement adds backslashes or braces as necessary to ensure that element is properly formatted as a list item. Under normal conditions, Tcl_AppendElement adds a space character to interp \\'s result just before adding the new list element, so that the list elements in the result are properly separated. However if the new list element is the first item in the list or sublist (i.e. interp \\'s current result is empty, or consists of the single character or ends in the characters then no space is added. THE TCL_FREEPROC ARGUMENT TO TCL_SETRESULT FreeProc has the following type: typedef void Tcl_FreeProc ( char * blockPtr ); When freeProc is called, blockPtr is the result value passed to Tcl_SetResult . SEE ALSO Tcl_AddErrorInfo, Tcl_CreateObjCommand, Tcl_SetErrorCode, Tcl_Interp, Tcl_GetReturnOptions KEYWORDS append, command, element, list, value, result, return value, interpreter","title":"NAME"},{"location":"SetResult/#name","text":"Tcl_SetObjResult, Tcl_GetObjResult, Tcl_SetResult, Tcl_GetStringResult, Tcl_AppendResult, Tcl_AppendElement, Tcl_ResetResult, Tcl_TransferResult - manipulate Tcl result","title":"NAME"},{"location":"SetResult/#synopsis","text":"#include <tcl.h> Tcl_SetObjResult(interp, objPtr) Tcl_Obj * Tcl_GetObjResult(interp) Tcl_SetResult(interp, result, freeProc) const char * Tcl_GetStringResult(interp) Tcl_AppendResult(interp, result, result, ... , (char *) NULL) Tcl_ResetResult(interp) Tcl_TransferResult(sourceInterp, code, targetInterp) Tcl_AppendElement(interp, element)","title":"SYNOPSIS"},{"location":"SetResult/#arguments","text":"The interpreter get or set the result for. A value to set the result to. The string value set the result to, or to append to the existing result. The string value to append as a list element to the existing result of interp . Pointer to a procedure to call to release storage at result . The interpreter to transfer the result and return options from. The interpreter to transfer the result and return options to. Return code value that controls transfer of return options.","title":"ARGUMENTS"},{"location":"SetResult/#description","text":"These procedures manipulate the result of an interpreter. Some procedures provide a Tcl_Obj interface while others provide a string interface. For example, Tcl_SetObjResult accepts a Tcl_Obj and Tcl_SetResult accepts a char *. Similarly, Tcl_GetObjResult produces a Tcl_Obj * and Tcl_GetStringResult produces a char *. The procedures can be mixed and matched. For example, if Tcl_SetObjResult is called to set the result to a Tcl_Obj value, and then Tcl_GetStringResult is called, it returns a char * (but see caveats below). Tcl_SetObjResult sets objPtr as the result for interp , replacing any existing result. Tcl_GetObjResult returns the result for interp , without incrementing its reference count. Tcl_SetResult sets result as the result for interp , replacing any existing result, and calls freeProc to free result . See THE TCL_FREEPROC ARGUMENT TO TCL_SETRESULT below. If result is NULL , ignores freeProc and sets the result for interp to point to the empty string. Tcl_GetStringResult returns the result for interp as a string, i.e. the bytes of the Tcl_Obj for the result, which can be decoded using Tcl_UtfToExternal . This value is freed when its corresponding Tcl_Obj is freed.Programmers are encouraged to use the newer Tcl_Obj API procedures, e.g. to call Tcl_GetObjResult instead. Tcl_ResetResult sets the empty string as the result for interp and clears the error state managed by Tcl_AddErrorInfo , Tcl_AddObjErrorInfo , and Tcl_SetErrorCode . Tcl_AppendResult builds up a result from smaller pieces, appending each result in order to the current result for interp . It may be called repeatedly as additional pieces of the result are produced, and manages the storage for the interp \\'s result, allocating a larger result area if necessary. It also manages conversion to and from the result field of the interp to handle backward-compatibility with old-style extensions. Any number of result arguments may be passed in a single call; the last argument in the list must be a NULL pointer. Tcl_TransferResult transfers interpreter state from sourceInterp to targetInterp , both of which must have been created in the same thread, resets the result in sourceInterp , and moves the return options dictionary as controlled by the return code value code in the same manner as Tcl_GetReturnOptions . If sourceInterp and targetInterp are the same, nothing is done.","title":"DESCRIPTION"},{"location":"SetResult/#deprecated-interfaces","text":"","title":"DEPRECATED INTERFACES"},{"location":"SetResult/#old-string-procedures","text":"The following procedures are deprecated since they manipulate the Tcl result as a string. Procedures such as Tcl_SetObjResult can be significantly more efficient. Tcl_AppendElement is like Tcl_AppendResult , but it appends only one piece, and also appends that piece as a list item. Tcl_AppendElement adds backslashes or braces as necessary to ensure that element is properly formatted as a list item. Under normal conditions, Tcl_AppendElement adds a space character to interp \\'s result just before adding the new list element, so that the list elements in the result are properly separated. However if the new list element is the first item in the list or sublist (i.e. interp \\'s current result is empty, or consists of the single character or ends in the characters then no space is added.","title":"OLD STRING PROCEDURES"},{"location":"SetResult/#the-tcl_freeproc-argument-to-tcl_setresult","text":"FreeProc has the following type: typedef void Tcl_FreeProc ( char * blockPtr ); When freeProc is called, blockPtr is the result value passed to Tcl_SetResult .","title":"THE TCL_FREEPROC ARGUMENT TO TCL_SETRESULT"},{"location":"SetResult/#see-also","text":"Tcl_AddErrorInfo, Tcl_CreateObjCommand, Tcl_SetErrorCode, Tcl_Interp, Tcl_GetReturnOptions","title":"SEE ALSO"},{"location":"SetResult/#keywords","text":"append, command, element, list, value, result, return value, interpreter","title":"KEYWORDS"},{"location":"SetVar/","text":"NAME Tcl_SetVar2Ex, Tcl_SetVar, Tcl_SetVar2, Tcl_ObjSetVar2, Tcl_GetVar2Ex, Tcl_GetVar, Tcl_GetVar2, Tcl_ObjGetVar2, Tcl_UnsetVar, Tcl_UnsetVar2 - manipulate Tcl variables SYNOPSIS #include <tcl.h> Tcl_Obj * Tcl_SetVar2Ex(interp, name1, name2, newValuePtr, flags) const char * Tcl_SetVar(interp, varName, newValue, flags) const char * Tcl_SetVar2(interp, name1, name2, newValue, flags) Tcl_Obj * Tcl_ObjSetVar2(interp, part1Ptr, part2Ptr, newValuePtr, flags) Tcl_Obj * Tcl_GetVar2Ex(interp, name1, name2, flags) const char * Tcl_GetVar(interp, varName, flags) const char * Tcl_GetVar2(interp, name1, name2, flags) Tcl_Obj * Tcl_ObjGetVar2(interp, part1Ptr, part2Ptr, flags) int Tcl_UnsetVar(interp, varName, flags) int Tcl_UnsetVar2(interp, name1, name2, flags) ARGUMENTS Interpreter containing variable. Contains the name of an array variable (if name2 is non-NULL) or (if name2 is NULL) either the name of a scalar variable or a complete name including both variable name and index. May include :: namespace qualifiers to specify a variable in a particular namespace. If non-NULL, gives name of element within array; in this case name1 must refer to an array variable. Points to a Tcl value containing the new value for the variable. OR-ed combination of bits providing additional information. See below for valid values. Name of variable. May include :: namespace qualifiers to specify a variable in a particular namespace. May refer to a scalar variable or an element of an array. New value for variable, specified as a null-terminated string. A copy of this value is stored in the variable. Points to a Tcl value containing the variable\\'s name. The name may include a series of :: namespace qualifiers to specify a variable in a particular namespace. May refer to a scalar variable or an element of an array variable. If non-NULL, points to a value containing the name of an element within an array and part1Ptr must refer to an array variable. DESCRIPTION These procedures are used to create, modify, read, and delete Tcl variables from C code. Tcl_SetVar2Ex , Tcl_SetVar , Tcl_SetVar2 , and Tcl_ObjSetVar2 will create a new variable or modify an existing one. These procedures set the given variable to the value given by newValuePtr or newValue and return a pointer to the variable\\'s new value, which is stored in Tcl\\'s variable structure. Tcl_SetVar2Ex and Tcl_ObjSetVar2 take the new value as a Tcl_Obj and return a pointer to a Tcl_Obj. Tcl_SetVar and Tcl_SetVar2 take the new value as a string and return a string; they are usually less efficient than Tcl_ObjSetVar2 . Note that the return value may be different than the newValuePtr or newValue argument, due to modifications made by write traces. If an error occurs in setting the variable (e.g. an array variable is referenced without giving an index into the array) NULL is returned and an error message is left in interp \\'s result if the TCL_LEAVE_ERR_MSG flag bit is set. Tcl_GetVar2Ex , Tcl_GetVar , Tcl_GetVar2 , and Tcl_ObjGetVar2 return the current value of a variable. The arguments to these procedures are treated in the same way as the arguments to the procedures described above. Under normal circumstances, the return value is a pointer to the variable\\'s value. For Tcl_GetVar2Ex and Tcl_ObjGetVar2 the value is returned as a pointer to a Tcl_Obj. For Tcl_GetVar and Tcl_GetVar2 the value is returned as a string; this is usually less efficient, so Tcl_GetVar2Ex or Tcl_ObjGetVar2 are preferred. If an error occurs while reading the variable (e.g. the variable does not exist or an array element is specified for a scalar variable), then NULL is returned and an error message is left in interp \\'s result if the TCL_LEAVE_ERR_MSG flag bit is set. Tcl_UnsetVar and Tcl_UnsetVar2 may be used to remove a variable, so that future attempts to read the variable will return an error. The arguments to these procedures are treated in the same way as the arguments to the procedures above. If the variable is successfully removed then TCL_OK is returned. If the variable cannot be removed because it does not exist then TCL_ERROR is returned and an error message is left in interp \\'s result if the TCL_LEAVE_ERR_MSG flag bit is set. If an array element is specified, the given element is removed but the array remains. If an array name is specified without an index, then the entire array is removed. The name of a variable may be specified to these procedures in four ways: [1] : If Tcl_SetVar , Tcl_GetVar , or Tcl_UnsetVar is invoked, the variable name is given as a single string, varName . If varName contains an open parenthesis and ends with a close parenthesis, then the value between the parentheses is treated as an index (which can have any string value) and the characters before the first open parenthesis are treated as the name of an array variable. If varName does not have parentheses as described above, then the entire string is treated as the name of a scalar variable. [2] : If the name1 and name2 arguments are provided and name2 is non-NULL, then an array element is specified and the array name and index have already been separated by the caller: name1 contains the name and name2 contains the index. An error is generated if name1 contains an open parenthesis and ends with a close parenthesis (array element) and name2 is non-NULL. [3] : If name2 is NULL, name1 is treated just like varName in case [1] above (it can be either a scalar or an array element variable name). The flags argument may be used to specify any of several options to the procedures. It consists of an OR-ed combination of the following bits. TCL_GLOBAL_ONLY : Under normal circumstances the procedures look up variables as follows. If a procedure call is active in interp , the variable is looked up at the current level of procedure call. Otherwise, the variable is looked up first in the current namespace, then in the global namespace. However, if this bit is set in flags then the variable is looked up only in the global namespace even if there is a procedure call active. If both TCL_GLOBAL_ONLY and TCL_NAMESPACE_ONLY are given, TCL_GLOBAL_ONLY is ignored. TCL_NAMESPACE_ONLY : If this bit is set in flags then the variable is looked up only in the current namespace; if a procedure is active its variables are ignored, and the global namespace is also ignored unless it is the current namespace. TCL_LEAVE_ERR_MSG : If an error is returned and this bit is set in flags , then an error message will be left in the interpreter\\'s result, where it can be retrieved with Tcl_GetObjResult or Tcl_GetStringResult . If this flag bit is not set then no error message is left and the interpreter\\'s result will not be modified. TCL_APPEND_VALUE : If this bit is set then newValuePtr or newValue is appended to the current value instead of replacing it. If the variable is currently undefined, then the bit is ignored. This bit is only used by the Tcl_Set* procedures. TCL_LIST_ELEMENT : If this bit is set, then newValue is converted to a valid Tcl list element before setting (or appending to) the variable. A separator space is appended before the new list element unless the list element is going to be the first element in a list or sublist (i.e. the variable\\'s current value is empty, or contains the single character or ends in When appending, the original value of the variable must also be a valid list, so that the operation is the appending of a new list element onto a list. Tcl_GetVar and Tcl_GetVar2 return the current value of a variable. The arguments to these procedures are treated in the same way as the arguments to Tcl_SetVar and Tcl_SetVar2 . Under normal circumstances, the return value is a pointer to the variable\\'s value (which is stored in Tcl\\'s variable structure and will not change before the next call to Tcl_SetVar or Tcl_SetVar2 ). Tcl_GetVar and Tcl_GetVar2 use the flag bits TCL_GLOBAL_ONLY and TCL_LEAVE_ERR_MSG , both of which have the same meaning as for Tcl_SetVar . If an error occurs in reading the variable (e.g. the variable does not exist or an array element is specified for a scalar variable), then NULL is returned. Tcl_UnsetVar and Tcl_UnsetVar2 may be used to remove a variable, so that future calls to Tcl_GetVar or Tcl_GetVar2 for the variable will return an error. The arguments to these procedures are treated in the same way as the arguments to Tcl_GetVar and Tcl_GetVar2 . If the variable is successfully removed then TCL_OK is returned. If the variable cannot be removed because it does not exist then TCL_ERROR is returned. If an array element is specified, the given element is removed but the array remains. If an array name is specified without an index, then the entire array is removed. REFERENCE COUNT MANAGEMENT The result of Tcl_SetVar2Ex , Tcl_ObjSetVar2 , Tcl_GetVar2Ex , and Tcl_ObjGetVar2 is (if non-NULL) a value with a reference of at least 1, where that reference is held by the variable that the function has just operated upon. The newValuePtr argument to Tcl_SetVar2Ex and Tcl_ObjSetVar2 may be an arbitrary reference count value. Its reference count is incremented on success. On failure, if its reference count is zero, it is decremented and freed so the caller need do nothing with it. The part1Ptr argument to Tcl_ObjSetVar2 and Tcl_ObjGetVar2 can have any reference count. These functions never modify it. The part2Ptr argument to Tcl_ObjSetVar2 and Tcl_ObjGetVar2 , if non-NULL, should not have a zero reference count as these functions may retain a reference to it, particularly when it is used to create an array element that did not previously exist, and decrementing the reference count later would leave them pointing to a freed Tcl_Obj. SEE ALSO Tcl_GetObjResult, Tcl_GetStringResult, Tcl_TraceVar KEYWORDS array, get variable, interpreter, scalar, set, unset, value, variable","title":"NAME"},{"location":"SetVar/#name","text":"Tcl_SetVar2Ex, Tcl_SetVar, Tcl_SetVar2, Tcl_ObjSetVar2, Tcl_GetVar2Ex, Tcl_GetVar, Tcl_GetVar2, Tcl_ObjGetVar2, Tcl_UnsetVar, Tcl_UnsetVar2 - manipulate Tcl variables","title":"NAME"},{"location":"SetVar/#synopsis","text":"#include <tcl.h> Tcl_Obj * Tcl_SetVar2Ex(interp, name1, name2, newValuePtr, flags) const char * Tcl_SetVar(interp, varName, newValue, flags) const char * Tcl_SetVar2(interp, name1, name2, newValue, flags) Tcl_Obj * Tcl_ObjSetVar2(interp, part1Ptr, part2Ptr, newValuePtr, flags) Tcl_Obj * Tcl_GetVar2Ex(interp, name1, name2, flags) const char * Tcl_GetVar(interp, varName, flags) const char * Tcl_GetVar2(interp, name1, name2, flags) Tcl_Obj * Tcl_ObjGetVar2(interp, part1Ptr, part2Ptr, flags) int Tcl_UnsetVar(interp, varName, flags) int Tcl_UnsetVar2(interp, name1, name2, flags)","title":"SYNOPSIS"},{"location":"SetVar/#arguments","text":"Interpreter containing variable. Contains the name of an array variable (if name2 is non-NULL) or (if name2 is NULL) either the name of a scalar variable or a complete name including both variable name and index. May include :: namespace qualifiers to specify a variable in a particular namespace. If non-NULL, gives name of element within array; in this case name1 must refer to an array variable. Points to a Tcl value containing the new value for the variable. OR-ed combination of bits providing additional information. See below for valid values. Name of variable. May include :: namespace qualifiers to specify a variable in a particular namespace. May refer to a scalar variable or an element of an array. New value for variable, specified as a null-terminated string. A copy of this value is stored in the variable. Points to a Tcl value containing the variable\\'s name. The name may include a series of :: namespace qualifiers to specify a variable in a particular namespace. May refer to a scalar variable or an element of an array variable. If non-NULL, points to a value containing the name of an element within an array and part1Ptr must refer to an array variable.","title":"ARGUMENTS"},{"location":"SetVar/#description","text":"These procedures are used to create, modify, read, and delete Tcl variables from C code. Tcl_SetVar2Ex , Tcl_SetVar , Tcl_SetVar2 , and Tcl_ObjSetVar2 will create a new variable or modify an existing one. These procedures set the given variable to the value given by newValuePtr or newValue and return a pointer to the variable\\'s new value, which is stored in Tcl\\'s variable structure. Tcl_SetVar2Ex and Tcl_ObjSetVar2 take the new value as a Tcl_Obj and return a pointer to a Tcl_Obj. Tcl_SetVar and Tcl_SetVar2 take the new value as a string and return a string; they are usually less efficient than Tcl_ObjSetVar2 . Note that the return value may be different than the newValuePtr or newValue argument, due to modifications made by write traces. If an error occurs in setting the variable (e.g. an array variable is referenced without giving an index into the array) NULL is returned and an error message is left in interp \\'s result if the TCL_LEAVE_ERR_MSG flag bit is set. Tcl_GetVar2Ex , Tcl_GetVar , Tcl_GetVar2 , and Tcl_ObjGetVar2 return the current value of a variable. The arguments to these procedures are treated in the same way as the arguments to the procedures described above. Under normal circumstances, the return value is a pointer to the variable\\'s value. For Tcl_GetVar2Ex and Tcl_ObjGetVar2 the value is returned as a pointer to a Tcl_Obj. For Tcl_GetVar and Tcl_GetVar2 the value is returned as a string; this is usually less efficient, so Tcl_GetVar2Ex or Tcl_ObjGetVar2 are preferred. If an error occurs while reading the variable (e.g. the variable does not exist or an array element is specified for a scalar variable), then NULL is returned and an error message is left in interp \\'s result if the TCL_LEAVE_ERR_MSG flag bit is set. Tcl_UnsetVar and Tcl_UnsetVar2 may be used to remove a variable, so that future attempts to read the variable will return an error. The arguments to these procedures are treated in the same way as the arguments to the procedures above. If the variable is successfully removed then TCL_OK is returned. If the variable cannot be removed because it does not exist then TCL_ERROR is returned and an error message is left in interp \\'s result if the TCL_LEAVE_ERR_MSG flag bit is set. If an array element is specified, the given element is removed but the array remains. If an array name is specified without an index, then the entire array is removed. The name of a variable may be specified to these procedures in four ways: [1] : If Tcl_SetVar , Tcl_GetVar , or Tcl_UnsetVar is invoked, the variable name is given as a single string, varName . If varName contains an open parenthesis and ends with a close parenthesis, then the value between the parentheses is treated as an index (which can have any string value) and the characters before the first open parenthesis are treated as the name of an array variable. If varName does not have parentheses as described above, then the entire string is treated as the name of a scalar variable. [2] : If the name1 and name2 arguments are provided and name2 is non-NULL, then an array element is specified and the array name and index have already been separated by the caller: name1 contains the name and name2 contains the index. An error is generated if name1 contains an open parenthesis and ends with a close parenthesis (array element) and name2 is non-NULL. [3] : If name2 is NULL, name1 is treated just like varName in case [1] above (it can be either a scalar or an array element variable name). The flags argument may be used to specify any of several options to the procedures. It consists of an OR-ed combination of the following bits. TCL_GLOBAL_ONLY : Under normal circumstances the procedures look up variables as follows. If a procedure call is active in interp , the variable is looked up at the current level of procedure call. Otherwise, the variable is looked up first in the current namespace, then in the global namespace. However, if this bit is set in flags then the variable is looked up only in the global namespace even if there is a procedure call active. If both TCL_GLOBAL_ONLY and TCL_NAMESPACE_ONLY are given, TCL_GLOBAL_ONLY is ignored. TCL_NAMESPACE_ONLY : If this bit is set in flags then the variable is looked up only in the current namespace; if a procedure is active its variables are ignored, and the global namespace is also ignored unless it is the current namespace. TCL_LEAVE_ERR_MSG : If an error is returned and this bit is set in flags , then an error message will be left in the interpreter\\'s result, where it can be retrieved with Tcl_GetObjResult or Tcl_GetStringResult . If this flag bit is not set then no error message is left and the interpreter\\'s result will not be modified. TCL_APPEND_VALUE : If this bit is set then newValuePtr or newValue is appended to the current value instead of replacing it. If the variable is currently undefined, then the bit is ignored. This bit is only used by the Tcl_Set* procedures. TCL_LIST_ELEMENT : If this bit is set, then newValue is converted to a valid Tcl list element before setting (or appending to) the variable. A separator space is appended before the new list element unless the list element is going to be the first element in a list or sublist (i.e. the variable\\'s current value is empty, or contains the single character or ends in When appending, the original value of the variable must also be a valid list, so that the operation is the appending of a new list element onto a list. Tcl_GetVar and Tcl_GetVar2 return the current value of a variable. The arguments to these procedures are treated in the same way as the arguments to Tcl_SetVar and Tcl_SetVar2 . Under normal circumstances, the return value is a pointer to the variable\\'s value (which is stored in Tcl\\'s variable structure and will not change before the next call to Tcl_SetVar or Tcl_SetVar2 ). Tcl_GetVar and Tcl_GetVar2 use the flag bits TCL_GLOBAL_ONLY and TCL_LEAVE_ERR_MSG , both of which have the same meaning as for Tcl_SetVar . If an error occurs in reading the variable (e.g. the variable does not exist or an array element is specified for a scalar variable), then NULL is returned. Tcl_UnsetVar and Tcl_UnsetVar2 may be used to remove a variable, so that future calls to Tcl_GetVar or Tcl_GetVar2 for the variable will return an error. The arguments to these procedures are treated in the same way as the arguments to Tcl_GetVar and Tcl_GetVar2 . If the variable is successfully removed then TCL_OK is returned. If the variable cannot be removed because it does not exist then TCL_ERROR is returned. If an array element is specified, the given element is removed but the array remains. If an array name is specified without an index, then the entire array is removed.","title":"DESCRIPTION"},{"location":"SetVar/#reference-count-management","text":"The result of Tcl_SetVar2Ex , Tcl_ObjSetVar2 , Tcl_GetVar2Ex , and Tcl_ObjGetVar2 is (if non-NULL) a value with a reference of at least 1, where that reference is held by the variable that the function has just operated upon. The newValuePtr argument to Tcl_SetVar2Ex and Tcl_ObjSetVar2 may be an arbitrary reference count value. Its reference count is incremented on success. On failure, if its reference count is zero, it is decremented and freed so the caller need do nothing with it. The part1Ptr argument to Tcl_ObjSetVar2 and Tcl_ObjGetVar2 can have any reference count. These functions never modify it. The part2Ptr argument to Tcl_ObjSetVar2 and Tcl_ObjGetVar2 , if non-NULL, should not have a zero reference count as these functions may retain a reference to it, particularly when it is used to create an array element that did not previously exist, and decrementing the reference count later would leave them pointing to a freed Tcl_Obj.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"SetVar/#see-also","text":"Tcl_GetObjResult, Tcl_GetStringResult, Tcl_TraceVar","title":"SEE ALSO"},{"location":"SetVar/#keywords","text":"array, get variable, interpreter, scalar, set, unset, value, variable","title":"KEYWORDS"},{"location":"Signal/","text":"NAME Tcl_SignalId, Tcl_SignalMsg - Convert signal codes SYNOPSIS #include <tcl.h> const char * Tcl_SignalId(sig) const char * Tcl_SignalMsg(sig) ARGUMENTS A POSIX signal number such as SIGPIPE . DESCRIPTION Tcl_SignalId and Tcl_SignalMsg return a string representation of the provided signal number ( sig ). Tcl_SignalId returns a machine-readable textual identifier such as Tcl_SignalMsg returns a human-readable string such as The strings returned by these functions are statically allocated and the caller must not free or modify them. KEYWORDS signals, signal numbers","title":"NAME"},{"location":"Signal/#name","text":"Tcl_SignalId, Tcl_SignalMsg - Convert signal codes","title":"NAME"},{"location":"Signal/#synopsis","text":"#include <tcl.h> const char * Tcl_SignalId(sig) const char * Tcl_SignalMsg(sig)","title":"SYNOPSIS"},{"location":"Signal/#arguments","text":"A POSIX signal number such as SIGPIPE .","title":"ARGUMENTS"},{"location":"Signal/#description","text":"Tcl_SignalId and Tcl_SignalMsg return a string representation of the provided signal number ( sig ). Tcl_SignalId returns a machine-readable textual identifier such as Tcl_SignalMsg returns a human-readable string such as The strings returned by these functions are statically allocated and the caller must not free or modify them.","title":"DESCRIPTION"},{"location":"Signal/#keywords","text":"signals, signal numbers","title":"KEYWORDS"},{"location":"Sleep/","text":"NAME Tcl_Sleep - delay execution for a given number of milliseconds SYNOPSIS #include <tcl.h> Tcl_Sleep(ms) ARGUMENTS Number of milliseconds to sleep. DESCRIPTION This procedure delays the calling process by the number of milliseconds given by the ms parameter and returns after that time has elapsed. It is typically used for things like flashing a button, where the delay is short and the application need not do anything while it waits. For longer delays where the application needs to respond to other events during the delay, the procedure Tcl_CreateTimerHandler should be used instead of Tcl_Sleep . KEYWORDS sleep, time, wait","title":"NAME"},{"location":"Sleep/#name","text":"Tcl_Sleep - delay execution for a given number of milliseconds","title":"NAME"},{"location":"Sleep/#synopsis","text":"#include <tcl.h> Tcl_Sleep(ms)","title":"SYNOPSIS"},{"location":"Sleep/#arguments","text":"Number of milliseconds to sleep.","title":"ARGUMENTS"},{"location":"Sleep/#description","text":"This procedure delays the calling process by the number of milliseconds given by the ms parameter and returns after that time has elapsed. It is typically used for things like flashing a button, where the delay is short and the application need not do anything while it waits. For longer delays where the application needs to respond to other events during the delay, the procedure Tcl_CreateTimerHandler should be used instead of Tcl_Sleep .","title":"DESCRIPTION"},{"location":"Sleep/#keywords","text":"sleep, time, wait","title":"KEYWORDS"},{"location":"SourceRCFile/","text":"NAME Tcl_SourceRCFile - source the Tcl rc file SYNOPSIS #include <tcl.h> void Tcl_SourceRCFile(interp) ARGUMENTS Tcl interpreter to source rc file into. DESCRIPTION Tcl_SourceRCFile is used to source the Tcl rc file at startup. It is typically invoked by Tcl_Main or Tk_Main. The name of the file sourced is obtained from the global variable tcl_rcFileName in the interpreter given by interp . If this variable is not defined, or if the file it indicates cannot be found, no action is taken. KEYWORDS application-specific initialization, main program, rc file","title":"NAME"},{"location":"SourceRCFile/#name","text":"Tcl_SourceRCFile - source the Tcl rc file","title":"NAME"},{"location":"SourceRCFile/#synopsis","text":"#include <tcl.h> void Tcl_SourceRCFile(interp)","title":"SYNOPSIS"},{"location":"SourceRCFile/#arguments","text":"Tcl interpreter to source rc file into.","title":"ARGUMENTS"},{"location":"SourceRCFile/#description","text":"Tcl_SourceRCFile is used to source the Tcl rc file at startup. It is typically invoked by Tcl_Main or Tk_Main. The name of the file sourced is obtained from the global variable tcl_rcFileName in the interpreter given by interp . If this variable is not defined, or if the file it indicates cannot be found, no action is taken.","title":"DESCRIPTION"},{"location":"SourceRCFile/#keywords","text":"application-specific initialization, main program, rc file","title":"KEYWORDS"},{"location":"SplitList/","text":"NAME Tcl_SplitList, Tcl_Merge, Tcl_ScanElement, Tcl_ConvertElement, Tcl_ScanCountedElement, Tcl_ConvertCountedElement - manipulate Tcl lists SYNOPSIS #include <tcl.h> int Tcl_SplitList(interp, list, argcPtr, argvPtr) char * Tcl_Merge(argc, argv) Tcl_Size Tcl_ScanElement(src, flagsPtr) Tcl_Size Tcl_ScanCountedElement(src, length, flagsPtr) Tcl_Size Tcl_ConvertElement(src, dst, flags) Tcl_Size Tcl_ConvertCountedElement(src, length, dst, flags) ARGUMENTS Interpreter to use for error reporting. If NULL, then no error message is left. Pointer to a string with proper list structure. Filled in with number of elements in list . *argvPtr will be filled in with the address of an array of pointers to the strings that are the extracted elements of list . There will be *argcPtr valid entries in the array, followed by a NULL entry. Number of elements in argv . Array of strings to merge together into a single list. Each string will become a separate element of the list. String that is to become an element of a list. Pointer to word to fill in with information about src . The value of * flagsPtr must be passed to Tcl_ConvertElement . Number of bytes in string src . Place to copy converted list element. Must contain enough characters to hold converted string. Information about src . Must be value returned by previous call to Tcl_ScanElement , possibly OR-ed with TCL_DONT_USE_BRACES . DESCRIPTION These procedures may be used to disassemble and reassemble Tcl lists. Tcl_SplitList breaks a list up into its constituent elements, returning an array of pointers to the elements using argcPtr and argvPtr . While extracting the arguments, Tcl_SplitList obeys the usual rules for backslash substitutions and braces. The area of memory pointed to by *argvPtr is dynamically allocated; in addition to the array of pointers, it also holds copies of all the list elements. It is the caller\\'s responsibility to free up all of this storage. For example, suppose that you have called Tcl_SplitList with the following code: Tcl_Size argc; int code; char *string; char **argv; ... code = Tcl_SplitList (interp, string, &argc, &argv); Then you should eventually free the storage with a call like the following: Tcl_Free(argv); Tcl_SplitList normally returns TCL_OK , which means the list was successfully parsed. If sizePtr points to a variable of type int and the list contains more than 2**31 key/value pairs, or there was a syntax error in list , then TCL_ERROR is returned and the interpreter\\'s result will point to an error message describing the problem (if interp was not NULL). If TCL_ERROR is returned then no memory is allocated and *argvPtr is not modified. Tcl_Merge is the inverse of Tcl_SplitList : it takes a collection of strings given by argc and argv and generates a result string that has proper list structure. This means that commands like index may be used to extract the original elements again. In addition, if the result of Tcl_Merge is passed to Tcl_Eval , it will be parsed into argc words whose values will be the same as the argv strings passed to Tcl_Merge . Tcl_Merge will modify the list elements with braces and/or backslashes in order to produce proper Tcl list structure. The result string is dynamically allocated using Tcl_Alloc ; the caller must eventually release the space using Tcl_Free . If the result of Tcl_Merge is passed to Tcl_SplitList , the elements returned by Tcl_SplitList will be identical to those passed into Tcl_Merge . However, the converse is not true: if Tcl_SplitList is passed a given string, and the resulting argc and argv are passed to Tcl_Merge , the resulting string may not be the same as the original string passed to Tcl_SplitList . This is because Tcl_Merge may use backslashes and braces differently than the original string. Tcl_ScanElement and Tcl_ConvertElement are the procedures that do all of the real work of Tcl_Merge . Tcl_ScanElement scans its src argument and determines how to use backslashes and braces when converting it to a list element. It returns an overestimate of the number of characters required to represent src as a list element, and it stores information in *flagsPtr that is needed by Tcl_ConvertElement . Tcl_ConvertElement is a companion procedure to Tcl_ScanElement . It does the actual work of converting a string to a list element. Its flags argument must be the same as the value returned by Tcl_ScanElement . Tcl_ConvertElement writes a proper list element to memory starting at * dst and returns a count of the total number of characters written, which will be no more than the result returned by Tcl_ScanElement . Tcl_ConvertElement writes out only the actual list element without any leading or trailing spaces: it is up to the caller to include spaces between adjacent list elements. Tcl_ConvertElement uses one of two different approaches to handle the special characters in src . Wherever possible, it handles special characters by surrounding the string with braces. This produces clean-looking output, but cannot be used in some situations, such as when src contains unmatched braces. In these situations, Tcl_ConvertElement handles special characters by generating backslash sequences for them. The caller may insist on the second approach by OR-ing the flag value returned by Tcl_ScanElement with TCL_DONT_USE_BRACES . Although this will produce an uglier result, it is useful in some special situations, such as when Tcl_ConvertElement is being used to generate a portion of an argument for a Tcl command. In this case, surrounding src with curly braces would cause the command not to be parsed correctly. By default, Tcl_ConvertElement will use quoting in its output to be sure the first character of an element is not the hash character This is to be sure the first element of any list passed to eval is not mis-parsed as the beginning of a comment. When a list element is not the first element of a list, this quoting is not necessary. When the caller can be sure that the element is not the first element of a list, it can disable quoting of the leading hash character by OR-ing the flag value returned by Tcl_ScanElement with TCL_DONT_QUOTE_HASH . Tcl_ScanCountedElement and Tcl_ConvertCountedElement are the same as Tcl_ScanElement and Tcl_ConvertElement , except the length of string src is specified by the length argument, and the string may contain embedded nulls. SEE ALSO Tcl_ListObjGetElements(3) KEYWORDS backslash, convert, element, list, merge, split, strings","title":"NAME"},{"location":"SplitList/#name","text":"Tcl_SplitList, Tcl_Merge, Tcl_ScanElement, Tcl_ConvertElement, Tcl_ScanCountedElement, Tcl_ConvertCountedElement - manipulate Tcl lists","title":"NAME"},{"location":"SplitList/#synopsis","text":"#include <tcl.h> int Tcl_SplitList(interp, list, argcPtr, argvPtr) char * Tcl_Merge(argc, argv) Tcl_Size Tcl_ScanElement(src, flagsPtr) Tcl_Size Tcl_ScanCountedElement(src, length, flagsPtr) Tcl_Size Tcl_ConvertElement(src, dst, flags) Tcl_Size Tcl_ConvertCountedElement(src, length, dst, flags)","title":"SYNOPSIS"},{"location":"SplitList/#arguments","text":"Interpreter to use for error reporting. If NULL, then no error message is left. Pointer to a string with proper list structure. Filled in with number of elements in list . *argvPtr will be filled in with the address of an array of pointers to the strings that are the extracted elements of list . There will be *argcPtr valid entries in the array, followed by a NULL entry. Number of elements in argv . Array of strings to merge together into a single list. Each string will become a separate element of the list. String that is to become an element of a list. Pointer to word to fill in with information about src . The value of * flagsPtr must be passed to Tcl_ConvertElement . Number of bytes in string src . Place to copy converted list element. Must contain enough characters to hold converted string. Information about src . Must be value returned by previous call to Tcl_ScanElement , possibly OR-ed with TCL_DONT_USE_BRACES .","title":"ARGUMENTS"},{"location":"SplitList/#description","text":"These procedures may be used to disassemble and reassemble Tcl lists. Tcl_SplitList breaks a list up into its constituent elements, returning an array of pointers to the elements using argcPtr and argvPtr . While extracting the arguments, Tcl_SplitList obeys the usual rules for backslash substitutions and braces. The area of memory pointed to by *argvPtr is dynamically allocated; in addition to the array of pointers, it also holds copies of all the list elements. It is the caller\\'s responsibility to free up all of this storage. For example, suppose that you have called Tcl_SplitList with the following code: Tcl_Size argc; int code; char *string; char **argv; ... code = Tcl_SplitList (interp, string, &argc, &argv); Then you should eventually free the storage with a call like the following: Tcl_Free(argv); Tcl_SplitList normally returns TCL_OK , which means the list was successfully parsed. If sizePtr points to a variable of type int and the list contains more than 2**31 key/value pairs, or there was a syntax error in list , then TCL_ERROR is returned and the interpreter\\'s result will point to an error message describing the problem (if interp was not NULL). If TCL_ERROR is returned then no memory is allocated and *argvPtr is not modified. Tcl_Merge is the inverse of Tcl_SplitList : it takes a collection of strings given by argc and argv and generates a result string that has proper list structure. This means that commands like index may be used to extract the original elements again. In addition, if the result of Tcl_Merge is passed to Tcl_Eval , it will be parsed into argc words whose values will be the same as the argv strings passed to Tcl_Merge . Tcl_Merge will modify the list elements with braces and/or backslashes in order to produce proper Tcl list structure. The result string is dynamically allocated using Tcl_Alloc ; the caller must eventually release the space using Tcl_Free . If the result of Tcl_Merge is passed to Tcl_SplitList , the elements returned by Tcl_SplitList will be identical to those passed into Tcl_Merge . However, the converse is not true: if Tcl_SplitList is passed a given string, and the resulting argc and argv are passed to Tcl_Merge , the resulting string may not be the same as the original string passed to Tcl_SplitList . This is because Tcl_Merge may use backslashes and braces differently than the original string. Tcl_ScanElement and Tcl_ConvertElement are the procedures that do all of the real work of Tcl_Merge . Tcl_ScanElement scans its src argument and determines how to use backslashes and braces when converting it to a list element. It returns an overestimate of the number of characters required to represent src as a list element, and it stores information in *flagsPtr that is needed by Tcl_ConvertElement . Tcl_ConvertElement is a companion procedure to Tcl_ScanElement . It does the actual work of converting a string to a list element. Its flags argument must be the same as the value returned by Tcl_ScanElement . Tcl_ConvertElement writes a proper list element to memory starting at * dst and returns a count of the total number of characters written, which will be no more than the result returned by Tcl_ScanElement . Tcl_ConvertElement writes out only the actual list element without any leading or trailing spaces: it is up to the caller to include spaces between adjacent list elements. Tcl_ConvertElement uses one of two different approaches to handle the special characters in src . Wherever possible, it handles special characters by surrounding the string with braces. This produces clean-looking output, but cannot be used in some situations, such as when src contains unmatched braces. In these situations, Tcl_ConvertElement handles special characters by generating backslash sequences for them. The caller may insist on the second approach by OR-ing the flag value returned by Tcl_ScanElement with TCL_DONT_USE_BRACES . Although this will produce an uglier result, it is useful in some special situations, such as when Tcl_ConvertElement is being used to generate a portion of an argument for a Tcl command. In this case, surrounding src with curly braces would cause the command not to be parsed correctly. By default, Tcl_ConvertElement will use quoting in its output to be sure the first character of an element is not the hash character This is to be sure the first element of any list passed to eval is not mis-parsed as the beginning of a comment. When a list element is not the first element of a list, this quoting is not necessary. When the caller can be sure that the element is not the first element of a list, it can disable quoting of the leading hash character by OR-ing the flag value returned by Tcl_ScanElement with TCL_DONT_QUOTE_HASH . Tcl_ScanCountedElement and Tcl_ConvertCountedElement are the same as Tcl_ScanElement and Tcl_ConvertElement , except the length of string src is specified by the length argument, and the string may contain embedded nulls.","title":"DESCRIPTION"},{"location":"SplitList/#see-also","text":"Tcl_ListObjGetElements(3)","title":"SEE ALSO"},{"location":"SplitList/#keywords","text":"backslash, convert, element, list, merge, split, strings","title":"KEYWORDS"},{"location":"SplitPath/","text":"NAME Tcl_SplitPath, Tcl_JoinPath, Tcl_GetPathType - manipulate platform-dependent file paths SYNOPSIS #include <tcl.h> Tcl_SplitPath(path, argcPtr, argvPtr) char * Tcl_JoinPath(argc, argv, resultPtr) Tcl_PathType Tcl_GetPathType(path) ARGUMENTS File path in a form appropriate for the current platform (see the filename manual entry for acceptable forms for path names). Filled in with number of path elements in path . *argvPtr will be filled in with the address of an array of pointers to the strings that are the extracted elements of path . There will be *argcPtr valid entries in the array, followed by a NULL entry. Number of elements in argv . Array of path elements to merge together into a single path. A pointer to an initialized Tcl_DString to which the result of Tcl_JoinPath will be appended. DESCRIPTION These procedures have been superseded by the Tcl-value-aware procedures in the FileSystem man page, which are more efficient. These procedures may be used to disassemble and reassemble file paths in a platform independent manner: they provide C-level access to the same functionality as the file split , file join , and file pathtype commands. Tcl_SplitPath breaks a path into its constituent elements, returning an array of pointers to the elements using argcPtr and argvPtr . The area of memory pointed to by *argvPtr is dynamically allocated; in addition to the array of pointers, it also holds copies of all the path elements. It is the caller\\'s responsibility to free all of this storage. For example, suppose that you have called Tcl_SplitPath with the following code: Tcl_Size argc; char *path; char **argv; ... Tcl_SplitPath(string, &argc, &argv); Then you should eventually free the storage with a call like the following: Tcl_Free(argv); Tcl_JoinPath is the inverse of Tcl_SplitPath : it takes a collection of path elements given by argc and argv and generates a result string that is a properly constructed path. The result string is appended to resultPtr . ResultPtr must refer to an initialized Tcl_DString . If the result of Tcl_SplitPath is passed to Tcl_JoinPath , the result will refer to the same location, but may not be in the same form. This is because Tcl_SplitPath and Tcl_JoinPath eliminate duplicate path separators and return a normalized form for each platform. Tcl_GetPathType returns the type of the specified path , where Tcl_PathType is one of TCL_PATH_ABSOLUTE , TCL_PATH_RELATIVE , or TCL_PATH_VOLUME_RELATIVE . See the filename manual entry for a description of the path types for each platform. KEYWORDS file, filename, join, path, split, type","title":"NAME"},{"location":"SplitPath/#name","text":"Tcl_SplitPath, Tcl_JoinPath, Tcl_GetPathType - manipulate platform-dependent file paths","title":"NAME"},{"location":"SplitPath/#synopsis","text":"#include <tcl.h> Tcl_SplitPath(path, argcPtr, argvPtr) char * Tcl_JoinPath(argc, argv, resultPtr) Tcl_PathType Tcl_GetPathType(path)","title":"SYNOPSIS"},{"location":"SplitPath/#arguments","text":"File path in a form appropriate for the current platform (see the filename manual entry for acceptable forms for path names). Filled in with number of path elements in path . *argvPtr will be filled in with the address of an array of pointers to the strings that are the extracted elements of path . There will be *argcPtr valid entries in the array, followed by a NULL entry. Number of elements in argv . Array of path elements to merge together into a single path. A pointer to an initialized Tcl_DString to which the result of Tcl_JoinPath will be appended.","title":"ARGUMENTS"},{"location":"SplitPath/#description","text":"These procedures have been superseded by the Tcl-value-aware procedures in the FileSystem man page, which are more efficient. These procedures may be used to disassemble and reassemble file paths in a platform independent manner: they provide C-level access to the same functionality as the file split , file join , and file pathtype commands. Tcl_SplitPath breaks a path into its constituent elements, returning an array of pointers to the elements using argcPtr and argvPtr . The area of memory pointed to by *argvPtr is dynamically allocated; in addition to the array of pointers, it also holds copies of all the path elements. It is the caller\\'s responsibility to free all of this storage. For example, suppose that you have called Tcl_SplitPath with the following code: Tcl_Size argc; char *path; char **argv; ... Tcl_SplitPath(string, &argc, &argv); Then you should eventually free the storage with a call like the following: Tcl_Free(argv); Tcl_JoinPath is the inverse of Tcl_SplitPath : it takes a collection of path elements given by argc and argv and generates a result string that is a properly constructed path. The result string is appended to resultPtr . ResultPtr must refer to an initialized Tcl_DString . If the result of Tcl_SplitPath is passed to Tcl_JoinPath , the result will refer to the same location, but may not be in the same form. This is because Tcl_SplitPath and Tcl_JoinPath eliminate duplicate path separators and return a normalized form for each platform. Tcl_GetPathType returns the type of the specified path , where Tcl_PathType is one of TCL_PATH_ABSOLUTE , TCL_PATH_RELATIVE , or TCL_PATH_VOLUME_RELATIVE . See the filename manual entry for a description of the path types for each platform.","title":"DESCRIPTION"},{"location":"SplitPath/#keywords","text":"file, filename, join, path, split, type","title":"KEYWORDS"},{"location":"StaticLibrary/","text":"NAME Tcl_StaticLibrary, Tcl_StaticPackage - make a statically linked library available via the \\'load\\' command SYNOPSIS #include <tcl.h> Tcl_StaticLibrary(interp, prefix, initProc, safeInitProc) Tcl_StaticPackage(interp, prefix, initProc, safeInitProc) ARGUMENTS If not NULL, points to an interpreter into which the library has already been incorporated (i.e., the caller has already invoked the appropriate initialization procedure). NULL means the library has not yet been incorporated into any interpreter. Prefix for library initialization function. Normally in titlecase (first letter upper-case, all others lower-case), but this is no longer required. Procedure to invoke to incorporate this library into a trusted interpreter. Procedure to call to incorporate this library into a safe interpreter (one that will execute untrusted scripts). NULL means the library cannot be used in safe interpreters. DESCRIPTION This procedure may be invoked to announce that a library has been linked statically with a Tcl application and, optionally, that it has already been incorporated into an interpreter. Once Tcl_StaticLibrary has been invoked for a library, it may be incorporated into interpreters using the load command. Tcl_StaticLibrary is normally invoked only by the Tcl_AppInit procedure for the application, not by libraries for themselves ( Tcl_StaticLibrary should only be invoked for statically linked libraries, and code in the library itself should not need to know whether the library is dynamically loaded or statically linked). When the load command is used later to incorporate the library into an interpreter, one of initProc and safeInitProc will be invoked, depending on whether the target interpreter is safe or not. initProc and safeInitProc must both match the following prototype: typedef int Tcl_LibraryInitProc ( Tcl_Interp * interp ); The interp argument identifies the interpreter in which the library is to be incorporated. The initialization procedure must return TCL_OK or TCL_ERROR to indicate whether or not it completed successfully; in the event of an error it should set the interpreter\\'s result to point to an error message. The result or error from the initialization procedure will be returned as the result of the load command that caused the initialization procedure to be invoked. Tcl_StaticLibrary was named Tcl_StaticPackage in Tcl 8.6 and earlier, but the old name is deprecated now. Tcl_StaticLibrary can not be used in stub-enabled extensions. KEYWORDS initialization procedure, package, static linking SEE ALSO load(n), package(n), Tcl_PkgRequire(3)","title":"NAME"},{"location":"StaticLibrary/#name","text":"Tcl_StaticLibrary, Tcl_StaticPackage - make a statically linked library available via the \\'load\\' command","title":"NAME"},{"location":"StaticLibrary/#synopsis","text":"#include <tcl.h> Tcl_StaticLibrary(interp, prefix, initProc, safeInitProc) Tcl_StaticPackage(interp, prefix, initProc, safeInitProc)","title":"SYNOPSIS"},{"location":"StaticLibrary/#arguments","text":"If not NULL, points to an interpreter into which the library has already been incorporated (i.e., the caller has already invoked the appropriate initialization procedure). NULL means the library has not yet been incorporated into any interpreter. Prefix for library initialization function. Normally in titlecase (first letter upper-case, all others lower-case), but this is no longer required. Procedure to invoke to incorporate this library into a trusted interpreter. Procedure to call to incorporate this library into a safe interpreter (one that will execute untrusted scripts). NULL means the library cannot be used in safe interpreters.","title":"ARGUMENTS"},{"location":"StaticLibrary/#description","text":"This procedure may be invoked to announce that a library has been linked statically with a Tcl application and, optionally, that it has already been incorporated into an interpreter. Once Tcl_StaticLibrary has been invoked for a library, it may be incorporated into interpreters using the load command. Tcl_StaticLibrary is normally invoked only by the Tcl_AppInit procedure for the application, not by libraries for themselves ( Tcl_StaticLibrary should only be invoked for statically linked libraries, and code in the library itself should not need to know whether the library is dynamically loaded or statically linked). When the load command is used later to incorporate the library into an interpreter, one of initProc and safeInitProc will be invoked, depending on whether the target interpreter is safe or not. initProc and safeInitProc must both match the following prototype: typedef int Tcl_LibraryInitProc ( Tcl_Interp * interp ); The interp argument identifies the interpreter in which the library is to be incorporated. The initialization procedure must return TCL_OK or TCL_ERROR to indicate whether or not it completed successfully; in the event of an error it should set the interpreter\\'s result to point to an error message. The result or error from the initialization procedure will be returned as the result of the load command that caused the initialization procedure to be invoked. Tcl_StaticLibrary was named Tcl_StaticPackage in Tcl 8.6 and earlier, but the old name is deprecated now. Tcl_StaticLibrary can not be used in stub-enabled extensions.","title":"DESCRIPTION"},{"location":"StaticLibrary/#keywords","text":"initialization procedure, package, static linking","title":"KEYWORDS"},{"location":"StaticLibrary/#see-also","text":"load(n), package(n), Tcl_PkgRequire(3)","title":"SEE ALSO"},{"location":"StdChannels/","text":"NAME Tcl_StandardChannels - How the Tcl library deals with the standard channels DESCRIPTION This page explains the initialization and use of standard channels in the Tcl library. The term standard channels comes out of the Unix world and refers to the three channels automatically opened by the OS for each new application. They are stdin , stdout and stderr . The first is the standard input an application can read from, the other two refer to writable channels, one for regular output and the other for error messages. Tcl generalizes this concept in a cross-platform way and exposes standard channels to the script level. APPLICATION PROGRAMMING INTERFACES The public API procedures dealing directly with standard channels are Tcl_GetStdChannel and Tcl_SetStdChannel . Additional public APIs to consider are Tcl_RegisterChannel , Tcl_CreateChannel and Tcl_GetChannel . INITIALIZATION OF TCL STANDARD CHANNELS Standard channels are initialized by the Tcl library in three cases: when explicitly requested, when implicitly required before returning channel information, or when implicitly required during registration of a new channel. These cases differ in how they handle unavailable platform- specific standard channels. (A channel is not if it could not be successfully opened; for example, in a Tcl application run as a Windows NT service.) 1) : A single standard channel is initialized when it is explicitly specified in a call to Tcl_SetStdChannel . The states of the other standard channels are unaffected. Missing platform-specific standard channels do not matter here. This approach is not available at the script level. 2) : All uninitialized standard channels are initialized to platform-specific default values: \\(a\\) : when open channels are listed with **Tcl_GetChannelNames** (or the **file channels** script command), or \\(b\\) : when information about any standard channel is requested with a call to **Tcl_GetStdChannel**, or with a call to **Tcl_GetChannel** which specifies one of the standard names (**stdin**, **stdout** and **stderr**). In case of missing platform-specific standard channels, the Tcl standard channels are considered as initialized and then immediately closed. This means that the first three Tcl channels then opened by the application are designated as the Tcl standard channels. 3) : All uninitialized standard channels are initialized to platform-specific default values when a user-requested channel is registered with Tcl_RegisterChannel . In case of unavailable platform-specific standard channels the channel whose creation caused the initialization of the Tcl standard channels is made a normal channel. The next three Tcl channels opened by the application are designated as the Tcl standard channels. In other words, of the first four Tcl channels opened by the application the second to fourth are designated as the Tcl standard channels. RE-INITIALIZATION OF TCL STANDARD CHANNELS Once a Tcl standard channel is initialized through one of the methods above, closing this Tcl standard channel will cause the next call to Tcl_CreateChannel to make the new channel the new standard channel, too. If more than one Tcl standard channel was closed Tcl_CreateChannel will fill the empty slots in the order stdin , stdout and stderr . Tcl_CreateChannel will not try to reinitialize an empty slot if that slot was not initialized before. It is this behavior which enables an application to employ method 1 of initialization, i.e. to create and designate their own Tcl standard channels. SHELL-SPECIFIC DETAILS tclsh The Tcl shell (or rather the function Tcl_Main , which forms the core of the shell\\'s implementation) uses method 2 to initialize the standard channels. wish The windowing shell (or rather the function Tk_MainEx , which forms the core of the shell\\'s implementation) uses method 1 to initialize the standard channels (See Tk_InitConsoleChannels ) on non-Unix platforms. On Unix platforms, Tk_MainEx implicitly uses method 2 to initialize the standard channels. SEE ALSO Tcl_CreateChannel(3), Tcl_RegisterChannel(3), Tcl_GetChannel(3), Tcl_GetStdChannel(3), Tcl_SetStdChannel(3), Tk_InitConsoleChannels(3), tclsh(1), wish(1), Tcl_Main(3), Tk_MainEx(3) KEYWORDS standard channels","title":"NAME"},{"location":"StdChannels/#name","text":"Tcl_StandardChannels - How the Tcl library deals with the standard channels","title":"NAME"},{"location":"StdChannels/#description","text":"This page explains the initialization and use of standard channels in the Tcl library. The term standard channels comes out of the Unix world and refers to the three channels automatically opened by the OS for each new application. They are stdin , stdout and stderr . The first is the standard input an application can read from, the other two refer to writable channels, one for regular output and the other for error messages. Tcl generalizes this concept in a cross-platform way and exposes standard channels to the script level.","title":"DESCRIPTION"},{"location":"StdChannels/#application-programming-interfaces","text":"The public API procedures dealing directly with standard channels are Tcl_GetStdChannel and Tcl_SetStdChannel . Additional public APIs to consider are Tcl_RegisterChannel , Tcl_CreateChannel and Tcl_GetChannel .","title":"APPLICATION PROGRAMMING INTERFACES"},{"location":"StdChannels/#initialization-of-tcl-standard-channels","text":"Standard channels are initialized by the Tcl library in three cases: when explicitly requested, when implicitly required before returning channel information, or when implicitly required during registration of a new channel. These cases differ in how they handle unavailable platform- specific standard channels. (A channel is not if it could not be successfully opened; for example, in a Tcl application run as a Windows NT service.) 1) : A single standard channel is initialized when it is explicitly specified in a call to Tcl_SetStdChannel . The states of the other standard channels are unaffected. Missing platform-specific standard channels do not matter here. This approach is not available at the script level. 2) : All uninitialized standard channels are initialized to platform-specific default values: \\(a\\) : when open channels are listed with **Tcl_GetChannelNames** (or the **file channels** script command), or \\(b\\) : when information about any standard channel is requested with a call to **Tcl_GetStdChannel**, or with a call to **Tcl_GetChannel** which specifies one of the standard names (**stdin**, **stdout** and **stderr**). In case of missing platform-specific standard channels, the Tcl standard channels are considered as initialized and then immediately closed. This means that the first three Tcl channels then opened by the application are designated as the Tcl standard channels. 3) : All uninitialized standard channels are initialized to platform-specific default values when a user-requested channel is registered with Tcl_RegisterChannel . In case of unavailable platform-specific standard channels the channel whose creation caused the initialization of the Tcl standard channels is made a normal channel. The next three Tcl channels opened by the application are designated as the Tcl standard channels. In other words, of the first four Tcl channels opened by the application the second to fourth are designated as the Tcl standard channels.","title":"INITIALIZATION OF TCL STANDARD CHANNELS"},{"location":"StdChannels/#re-initialization-of-tcl-standard-channels","text":"Once a Tcl standard channel is initialized through one of the methods above, closing this Tcl standard channel will cause the next call to Tcl_CreateChannel to make the new channel the new standard channel, too. If more than one Tcl standard channel was closed Tcl_CreateChannel will fill the empty slots in the order stdin , stdout and stderr . Tcl_CreateChannel will not try to reinitialize an empty slot if that slot was not initialized before. It is this behavior which enables an application to employ method 1 of initialization, i.e. to create and designate their own Tcl standard channels.","title":"RE-INITIALIZATION OF TCL STANDARD CHANNELS"},{"location":"StdChannels/#shell-specific-details","text":"","title":"SHELL-SPECIFIC DETAILS"},{"location":"StdChannels/#tclsh","text":"The Tcl shell (or rather the function Tcl_Main , which forms the core of the shell\\'s implementation) uses method 2 to initialize the standard channels.","title":"tclsh"},{"location":"StdChannels/#wish","text":"The windowing shell (or rather the function Tk_MainEx , which forms the core of the shell\\'s implementation) uses method 1 to initialize the standard channels (See Tk_InitConsoleChannels ) on non-Unix platforms. On Unix platforms, Tk_MainEx implicitly uses method 2 to initialize the standard channels.","title":"wish"},{"location":"StdChannels/#see-also","text":"Tcl_CreateChannel(3), Tcl_RegisterChannel(3), Tcl_GetChannel(3), Tcl_GetStdChannel(3), Tcl_SetStdChannel(3), Tk_InitConsoleChannels(3), tclsh(1), wish(1), Tcl_Main(3), Tk_MainEx(3)","title":"SEE ALSO"},{"location":"StdChannels/#keywords","text":"standard channels","title":"KEYWORDS"},{"location":"StrMatch/","text":"NAME Tcl_StringMatch, Tcl_StringCaseMatch - test whether a string matches a pattern SYNOPSIS #include <tcl.h> int Tcl_StringMatch(str, pattern) int Tcl_StringCaseMatch(str, pattern, flags) ARGUMENTS String to test. Pattern to match against string. May contain special characters from the set *?\\[]. OR-ed combination of match flags, currently only TCL_MATCH_NOCASE . 0 specifies a case-sensitive search. DESCRIPTION This utility procedure determines whether a string matches a given pattern. If it does, then Tcl_StringMatch returns 1. Otherwise Tcl_StringMatch returns 0. The algorithm used for matching is the same algorithm used in the string match Tcl command and is similar to the algorithm used by the C-shell for file name matching; see the Tcl manual entry for details. In Tcl_StringCaseMatch , the algorithm is the same, but you have the option to make the matching case-insensitive. If you choose this (by passing TCL_MATCH_NOCASE ), then the string and pattern are essentially matched in the lower case. KEYWORDS match, pattern, string","title":"NAME"},{"location":"StrMatch/#name","text":"Tcl_StringMatch, Tcl_StringCaseMatch - test whether a string matches a pattern","title":"NAME"},{"location":"StrMatch/#synopsis","text":"#include <tcl.h> int Tcl_StringMatch(str, pattern) int Tcl_StringCaseMatch(str, pattern, flags)","title":"SYNOPSIS"},{"location":"StrMatch/#arguments","text":"String to test. Pattern to match against string. May contain special characters from the set *?\\[]. OR-ed combination of match flags, currently only TCL_MATCH_NOCASE . 0 specifies a case-sensitive search.","title":"ARGUMENTS"},{"location":"StrMatch/#description","text":"This utility procedure determines whether a string matches a given pattern. If it does, then Tcl_StringMatch returns 1. Otherwise Tcl_StringMatch returns 0. The algorithm used for matching is the same algorithm used in the string match Tcl command and is similar to the algorithm used by the C-shell for file name matching; see the Tcl manual entry for details. In Tcl_StringCaseMatch , the algorithm is the same, but you have the option to make the matching case-insensitive. If you choose this (by passing TCL_MATCH_NOCASE ), then the string and pattern are essentially matched in the lower case.","title":"DESCRIPTION"},{"location":"StrMatch/#keywords","text":"match, pattern, string","title":"KEYWORDS"},{"location":"StringObj/","text":"NAME Tcl_NewStringObj, Tcl_NewUnicodeObj, Tcl_SetStringObj, Tcl_SetUnicodeObj, Tcl_GetStringFromObj, Tcl_GetString, Tcl_GetUnicodeFromObj, Tcl_GetUnicode, Tcl_GetUniChar, Tcl_GetCharLength, Tcl_GetRange, Tcl_AppendToObj, Tcl_AppendUnicodeToObj, Tcl_AppendObjToObj, Tcl_AppendStringsToObj, Tcl_AppendLimitedToObj, Tcl_Format, Tcl_AppendFormatToObj, Tcl_ObjPrintf, Tcl_AppendPrintfToObj, Tcl_SetObjLength, Tcl_AttemptSetObjLength, Tcl_ConcatObj - manipulate Tcl values as strings SYNOPSIS #include <tcl.h> Tcl_Obj * Tcl_NewStringObj(bytes, length) Tcl_Obj * Tcl_NewUnicodeObj(unicode, numChars) void Tcl_SetStringObj(objPtr, bytes, length) void Tcl_SetUnicodeObj(objPtr, unicode, numChars) char * Tcl_GetStringFromObj(objPtr, lengthPtr) char * Tcl_GetString(objPtr) Tcl_UniChar * Tcl_GetUnicodeFromObj(objPtr, lengthPtr) Tcl_UniChar * Tcl_GetUnicode(objPtr) int Tcl_GetUniChar(objPtr, index) Tcl_Size Tcl_GetCharLength(objPtr) Tcl_Obj * Tcl_GetRange(objPtr, first, last) void Tcl_AppendToObj(objPtr, bytes, length) void Tcl_AppendUnicodeToObj(objPtr, unicode, numChars) void Tcl_AppendObjToObj(objPtr, appendObjPtr) void Tcl_AppendStringsToObj(objPtr, string, string, ... (char *) NULL) void Tcl_AppendLimitedToObj(objPtr, bytes, length, limit, ellipsis) Tcl_Obj * Tcl_Format(interp, format, objc, objv) int Tcl_AppendFormatToObj(interp, objPtr, format, objc, objv) Tcl_Obj * Tcl_ObjPrintf(format, ...) void Tcl_AppendPrintfToObj(objPtr, format, ...) void Tcl_SetObjLength(objPtr, newLength) int Tcl_AttemptSetObjLength(objPtr, newLength) Tcl_Obj * Tcl_ConcatObj(objc, objv) ARGUMENTS Points to the first byte of an array of UTF-8-encoded bytes used to set or append to a string value. This byte array may contain embedded null characters unless numChars is negative. (Applications needing null bytes should represent them as the two-byte sequence \\300\\200 , use Tcl_ExternalToUtf to convert, or Tcl_NewByteArrayObj if the string is a collection of uninterpreted bytes.) The number of bytes to copy from bytes when initializing, setting, or appending to a string value. If negative, all bytes up to the first null are used. Points to the first byte of an array of Unicode characters used to set or append to a string value. This byte array may contain embedded null characters unless numChars is negative. The number of Unicode characters to copy from unicode when initializing, setting, or appending to a string value. If negative, all characters up to the first null character are used. The index of the Unicode character to return. The index of the first Unicode character in the Unicode range to be returned as a new value. If negative, behave the same as if the value was 0. The index of the last Unicode character in the Unicode range to be returned as a new value. If negative, take all characters up to the last one available. A pointer to a value to read, or to an unshared value to modify. The value to append to objPtr in Tcl_AppendObjToObj . The location where Tcl_GetStringFromObj will store the length of a value\\'s string representation. May be (int *)NULL when not used. Null-terminated string value to append to objPtr . Maximum number of bytes to be appended. Suffix to append when the limit leads to string truncation. If NULL is passed then the suffix is used. Format control string including % conversion specifiers. The number of elements to format or concatenate. The array of values to format or concatenate. New length for the string value of objPtr , not including the final null character. DESCRIPTION The procedures described in this manual entry allow Tcl values to be manipulated as string values. They use the internal representation of the value to store additional information to make the string manipulations more efficient. In particular, they make a series of append operations efficient by allocating extra storage space for the string so that it does not have to be copied for each append. Also, indexing and length computations are optimized because the Unicode string representation is calculated and cached as needed. When using the Tcl_Append* family of functions where the interpreter\\'s result is the value being appended to, it is important to call Tcl_ResetResult first to ensure you are not unintentionally appending to existing data in the result value. Tcl_NewStringObj and Tcl_SetStringObj create a new value or modify an existing value to hold a copy of the string given by bytes and length . Tcl_NewUnicodeObj and Tcl_SetUnicodeObj create a new value or modify an existing value to hold a copy of the Unicode string given by unicode and numChars . Tcl_NewStringObj and Tcl_NewUnicodeObj return a pointer to a newly created value with reference count zero. All four procedures set the value to hold a copy of the specified string. Tcl_SetStringObj and Tcl_SetUnicodeObj free any old string representation as well as any old internal representation of the value. Tcl_GetStringFromObj and Tcl_GetString return a value\\'s string representation. This is given by the returned byte pointer and (for Tcl_GetStringFromObj ) length, which is stored in lengthPtr if it is non-NULL. If the value\\'s UTF string representation is invalid (its byte pointer is NULL), the string representation is regenerated from the value\\'s internal representation. The storage referenced by the returned byte pointer is owned by the value manager. It is passed back as a writable pointer so that extension author creating their own Tcl_ObjType will be able to modify the string representation within the Tcl_UpdateStringProc of their Tcl_ObjType . Except for that limited purpose, the pointer returned by Tcl_GetStringFromObj or Tcl_GetString should be treated as read-only. It is recommended that this pointer be assigned to a (const char *) variable. Even in the limited situations where writing to this pointer is acceptable, one should take care to respect the copy-on-write semantics required by Tcl_Obj \\'s, with appropriate calls to Tcl_IsShared and Tcl_DuplicateObj prior to any in-place modification of the string representation. If lengthPtr points to an int variable, and the string has more than 2\\^31 bytes, a panic will result. The procedure Tcl_GetString is used in the common case where the caller does not need the length of the string representation. Tcl_GetUnicodeFromObj and Tcl_GetUnicode return a value\\'s value as a Unicode string. This is given by the returned pointer and (for Tcl_GetUnicodeFromObj ) length, which is stored in lengthPtr if it is non-NULL. The storage referenced by the returned byte pointer is owned by the value manager and should not be modified by the caller. The procedure Tcl_GetUnicode is used in the common case where the caller does not need the length of the unicode string representation. If lengthPtr points to an int variable, and the string has more than 2\\^31 unicode characters, a panic will result. Tcl_GetUniChar returns the index \\'th character in the value\\'s Unicode representation. If the index is out of range or it references a low surrogate preceded by a high surrogate, it returns -1; Tcl_GetRange returns a newly created value comprised of the characters between first and last (inclusive) in the value\\'s Unicode representation. If the value\\'s Unicode representation is invalid, the Unicode representation is regenerated from the value\\'s string representation. If first is negative, then the returned string starts at the beginning of the value. If last negative, then the returned string ends at the end of the value. Tcl_GetCharLength returns the number of characters (as opposed to bytes) in the string value. Tcl_AppendToObj appends the data given by bytes and length to the string representation of the value specified by objPtr . If the value has an invalid string representation, then an attempt is made to convert bytes is to the Unicode format. If the conversion is successful, then the converted form of bytes is appended to the value\\'s Unicode representation. Otherwise, the value\\'s Unicode representation is invalidated and converted to the UTF format, and bytes is appended to the value\\'s new string representation. Tcl_AppendUnicodeToObj appends the Unicode string given by unicode and numChars to the value specified by objPtr . If the value has an invalid Unicode representation, then unicode is converted to the UTF format and appended to the value\\'s string representation. Appends are optimized to handle repeated appends relatively efficiently (it over-allocates the string or Unicode space to avoid repeated reallocations and copies of value\\'s string value). Tcl_AppendObjToObj is similar to Tcl_AppendToObj , but it appends the string or Unicode value (whichever exists and is best suited to be appended to objPtr ) of appendObjPtr to objPtr . Tcl_AppendStringsToObj is similar to Tcl_AppendToObj except that it can be passed more than one value to append and each value must be a null-terminated string (i.e. none of the values may contain internal null characters). Any number of string arguments may be provided, but the last argument must be a NULL pointer to indicate the end of the list. Tcl_AppendLimitedToObj is similar to Tcl_AppendToObj except that it imposes a limit on how many bytes are appended. This can be handy when the string to be appended might be very large, but the value being constructed should not be allowed to grow without bound. A common usage is when constructing an error message, where the end result should be kept short enough to be read. Bytes from bytes are appended to objPtr , but no more than limit bytes total are to be appended. If the limit prevents all length bytes that are available from being appended, then the appending is done so that the last bytes appended are from the string ellipsis . This allows for an indication of the truncation to be left in the string. When length is negative, all bytes up to the first zero byte are appended, subject to the limit. When ellipsis is NULL, the default string ... is used. When ellipsis is non-NULL, it must point to a zero-byte-terminated string in Tcl\\'s internal UTF encoding. The number of bytes appended can be less than the lesser of length and limit when appending fewer bytes is necessary to append only whole multi-byte characters. Tcl_Format is the C-level interface to the engine of the format command. The actual command procedure for format is little more than Tcl_Format (interp, Tcl_GetString (objv[1]), objc-2, objv+2); The objc Tcl_Obj values in objv are formatted into a string according to the conversion specification in format argument, following the documentation for the format command. The resulting formatted string is converted to a new Tcl_Obj with refcount of zero and returned. If some error happens during production of the formatted string, NULL is returned, and an error message is recorded in interp , if interp is non-NULL. Tcl_AppendFormatToObj is an appending alternative form of Tcl_Format with functionality equivalent to: Tcl_Obj *newPtr = Tcl_Format (interp, format, objc, objv); if (newPtr == NULL) return TCL_ERROR; Tcl_AppendObjToObj (objPtr, newPtr); Tcl_DecrRefCount (newPtr); return TCL_OK; but with greater convenience and efficiency when the appending functionality is needed. Tcl_ObjPrintf serves as a replacement for the common sequence char buf[SOME_SUITABLE_LENGTH]; sprintf(buf, format, ...); Tcl_NewStringObj (buf, -1); but with greater convenience and no need to determine SOME_SUITABLE_LENGTH . The formatting is done with the same core formatting engine used by Tcl_Format . This means the set of supported conversion specifiers is that of the format command and not that of the sprintf routine where the two sets differ. When a conversion specifier passed to Tcl_ObjPrintf includes a precision, the value is taken as a number of bytes, as sprintf does, and not as a number of characters, as format does. This is done on the assumption that C code is more likely to know how many bytes it is passing around than the number of encoded characters those bytes happen to represent. The variable number of arguments passed in should be of the types that would be suitable for passing to sprintf . Note in this example usage, x is of type int . int x = 5; Tcl_Obj *objPtr = Tcl_ObjPrintf (\\\"Value is %d\\\", x); If the value of format contains internal inconsistencies or invalid specifier formats, the formatted string result produced by Tcl_ObjPrintf will be an error message describing the error. It is impossible however to provide runtime protection against mismatches between the format and any subsequent arguments. Compile-time protection may be provided by some compilers. Tcl_AppendPrintfToObj is an appending alternative form of Tcl_ObjPrintf with functionality equivalent to Tcl_Obj *newPtr = Tcl_ObjPrintf (format, ...); Tcl_AppendObjToObj (objPtr, newPtr); Tcl_DecrRefCount (newPtr); but with greater convenience and efficiency when the appending functionality is needed. The Tcl_SetObjLength procedure changes the length of the string value of its objPtr argument. If the newLength argument is greater than the space allocated for the value\\'s string, then the string space is reallocated and the old value is copied to the new space; the bytes between the old length of the string and the new length may have arbitrary values. If the newLength argument is less than the current length of the value\\'s string, with objPtr->length is reduced without reallocating the string space; the original allocated size for the string is recorded in the value, so that the string length can be enlarged in a subsequent call to Tcl_SetObjLength without reallocating storage. In all cases Tcl_SetObjLength leaves a null character at objPtr->bytes[newLength] . Tcl_AttemptSetObjLength is identical in function to Tcl_SetObjLength except that if sufficient memory to satisfy the request cannot be allocated, it does not cause the Tcl interpreter to panic . Thus, if newLength is greater than the space allocated for the value\\'s string, and there is not enough memory available to satisfy the request, Tcl_AttemptSetObjLength will take no action and return 0 to indicate failure. If there is enough memory to satisfy the request, Tcl_AttemptSetObjLength behaves just like Tcl_SetObjLength and returns 1 to indicate success. The Tcl_ConcatObj function returns a new string value whose value is the space-separated concatenation of the string representations of all of the values in the objv array. Tcl_ConcatObj eliminates leading and trailing white space as it copies the string representations of the objv array to the result. If an element of the objv array consists of nothing but white space, then that value is ignored entirely. This white-space removal was added to make the output of the concat command cleaner-looking. Tcl_ConcatObj returns a pointer to a newly-created value whose ref count is zero. REFERENCE COUNT MANAGEMENT Tcl_NewStringObj , Tcl_NewUnicodeObj , Tcl_Format , Tcl_ObjPrintf , and Tcl_ConcatObj always return a zero-reference object, much like Tcl_NewObj . Tcl_GetStringFromObj , Tcl_GetString , Tcl_GetUnicodeFromObj , Tcl_GetUnicode , Tcl_GetUniChar , Tcl_GetCharLength , and Tcl_GetRange all only work with an existing value; they do not manipulate its reference count in any way. Tcl_SetStringObj , Tcl_SetUnicodeObj , Tcl_AppendToObj , Tcl_AppendUnicodeToObj , Tcl_AppendObjToObj , Tcl_AppendStringsToObj , Tcl_AppendStringsToObjVA , Tcl_AppendLimitedToObj , Tcl_AppendFormatToObj , Tcl_AppendPrintfToObj , Tcl_SetObjLength , and Tcl_AttemptSetObjLength and require their objPtr to be an unshared value (i.e, a reference count no more than 1) as they will modify it. Additional arguments to the above functions (the appendObjPtr argument to Tcl_AppendObjToObj , values in the objv argument to Tcl_Format , Tcl_AppendFormatToObj , and Tcl_ConcatObj ) can have any reference count, but reference counts of zero are not recommended. Tcl_Format and Tcl_AppendFormatToObj may modify the interpreter result, which involves changing the reference count of a value. SEE ALSO Tcl_NewObj(3), Tcl_IncrRefCount(3), Tcl_DecrRefCount(3), format(n), sprintf(3) KEYWORDS append, internal representation, value, value type, string value, string type, string representation, concat, concatenate, unicode","title":"NAME"},{"location":"StringObj/#name","text":"Tcl_NewStringObj, Tcl_NewUnicodeObj, Tcl_SetStringObj, Tcl_SetUnicodeObj, Tcl_GetStringFromObj, Tcl_GetString, Tcl_GetUnicodeFromObj, Tcl_GetUnicode, Tcl_GetUniChar, Tcl_GetCharLength, Tcl_GetRange, Tcl_AppendToObj, Tcl_AppendUnicodeToObj, Tcl_AppendObjToObj, Tcl_AppendStringsToObj, Tcl_AppendLimitedToObj, Tcl_Format, Tcl_AppendFormatToObj, Tcl_ObjPrintf, Tcl_AppendPrintfToObj, Tcl_SetObjLength, Tcl_AttemptSetObjLength, Tcl_ConcatObj - manipulate Tcl values as strings","title":"NAME"},{"location":"StringObj/#synopsis","text":"#include <tcl.h> Tcl_Obj * Tcl_NewStringObj(bytes, length) Tcl_Obj * Tcl_NewUnicodeObj(unicode, numChars) void Tcl_SetStringObj(objPtr, bytes, length) void Tcl_SetUnicodeObj(objPtr, unicode, numChars) char * Tcl_GetStringFromObj(objPtr, lengthPtr) char * Tcl_GetString(objPtr) Tcl_UniChar * Tcl_GetUnicodeFromObj(objPtr, lengthPtr) Tcl_UniChar * Tcl_GetUnicode(objPtr) int Tcl_GetUniChar(objPtr, index) Tcl_Size Tcl_GetCharLength(objPtr) Tcl_Obj * Tcl_GetRange(objPtr, first, last) void Tcl_AppendToObj(objPtr, bytes, length) void Tcl_AppendUnicodeToObj(objPtr, unicode, numChars) void Tcl_AppendObjToObj(objPtr, appendObjPtr) void Tcl_AppendStringsToObj(objPtr, string, string, ... (char *) NULL) void Tcl_AppendLimitedToObj(objPtr, bytes, length, limit, ellipsis) Tcl_Obj * Tcl_Format(interp, format, objc, objv) int Tcl_AppendFormatToObj(interp, objPtr, format, objc, objv) Tcl_Obj * Tcl_ObjPrintf(format, ...) void Tcl_AppendPrintfToObj(objPtr, format, ...) void Tcl_SetObjLength(objPtr, newLength) int Tcl_AttemptSetObjLength(objPtr, newLength) Tcl_Obj * Tcl_ConcatObj(objc, objv)","title":"SYNOPSIS"},{"location":"StringObj/#arguments","text":"Points to the first byte of an array of UTF-8-encoded bytes used to set or append to a string value. This byte array may contain embedded null characters unless numChars is negative. (Applications needing null bytes should represent them as the two-byte sequence \\300\\200 , use Tcl_ExternalToUtf to convert, or Tcl_NewByteArrayObj if the string is a collection of uninterpreted bytes.) The number of bytes to copy from bytes when initializing, setting, or appending to a string value. If negative, all bytes up to the first null are used. Points to the first byte of an array of Unicode characters used to set or append to a string value. This byte array may contain embedded null characters unless numChars is negative. The number of Unicode characters to copy from unicode when initializing, setting, or appending to a string value. If negative, all characters up to the first null character are used. The index of the Unicode character to return. The index of the first Unicode character in the Unicode range to be returned as a new value. If negative, behave the same as if the value was 0. The index of the last Unicode character in the Unicode range to be returned as a new value. If negative, take all characters up to the last one available. A pointer to a value to read, or to an unshared value to modify. The value to append to objPtr in Tcl_AppendObjToObj . The location where Tcl_GetStringFromObj will store the length of a value\\'s string representation. May be (int *)NULL when not used. Null-terminated string value to append to objPtr . Maximum number of bytes to be appended. Suffix to append when the limit leads to string truncation. If NULL is passed then the suffix is used. Format control string including % conversion specifiers. The number of elements to format or concatenate. The array of values to format or concatenate. New length for the string value of objPtr , not including the final null character.","title":"ARGUMENTS"},{"location":"StringObj/#description","text":"The procedures described in this manual entry allow Tcl values to be manipulated as string values. They use the internal representation of the value to store additional information to make the string manipulations more efficient. In particular, they make a series of append operations efficient by allocating extra storage space for the string so that it does not have to be copied for each append. Also, indexing and length computations are optimized because the Unicode string representation is calculated and cached as needed. When using the Tcl_Append* family of functions where the interpreter\\'s result is the value being appended to, it is important to call Tcl_ResetResult first to ensure you are not unintentionally appending to existing data in the result value. Tcl_NewStringObj and Tcl_SetStringObj create a new value or modify an existing value to hold a copy of the string given by bytes and length . Tcl_NewUnicodeObj and Tcl_SetUnicodeObj create a new value or modify an existing value to hold a copy of the Unicode string given by unicode and numChars . Tcl_NewStringObj and Tcl_NewUnicodeObj return a pointer to a newly created value with reference count zero. All four procedures set the value to hold a copy of the specified string. Tcl_SetStringObj and Tcl_SetUnicodeObj free any old string representation as well as any old internal representation of the value. Tcl_GetStringFromObj and Tcl_GetString return a value\\'s string representation. This is given by the returned byte pointer and (for Tcl_GetStringFromObj ) length, which is stored in lengthPtr if it is non-NULL. If the value\\'s UTF string representation is invalid (its byte pointer is NULL), the string representation is regenerated from the value\\'s internal representation. The storage referenced by the returned byte pointer is owned by the value manager. It is passed back as a writable pointer so that extension author creating their own Tcl_ObjType will be able to modify the string representation within the Tcl_UpdateStringProc of their Tcl_ObjType . Except for that limited purpose, the pointer returned by Tcl_GetStringFromObj or Tcl_GetString should be treated as read-only. It is recommended that this pointer be assigned to a (const char *) variable. Even in the limited situations where writing to this pointer is acceptable, one should take care to respect the copy-on-write semantics required by Tcl_Obj \\'s, with appropriate calls to Tcl_IsShared and Tcl_DuplicateObj prior to any in-place modification of the string representation. If lengthPtr points to an int variable, and the string has more than 2\\^31 bytes, a panic will result. The procedure Tcl_GetString is used in the common case where the caller does not need the length of the string representation. Tcl_GetUnicodeFromObj and Tcl_GetUnicode return a value\\'s value as a Unicode string. This is given by the returned pointer and (for Tcl_GetUnicodeFromObj ) length, which is stored in lengthPtr if it is non-NULL. The storage referenced by the returned byte pointer is owned by the value manager and should not be modified by the caller. The procedure Tcl_GetUnicode is used in the common case where the caller does not need the length of the unicode string representation. If lengthPtr points to an int variable, and the string has more than 2\\^31 unicode characters, a panic will result. Tcl_GetUniChar returns the index \\'th character in the value\\'s Unicode representation. If the index is out of range or it references a low surrogate preceded by a high surrogate, it returns -1; Tcl_GetRange returns a newly created value comprised of the characters between first and last (inclusive) in the value\\'s Unicode representation. If the value\\'s Unicode representation is invalid, the Unicode representation is regenerated from the value\\'s string representation. If first is negative, then the returned string starts at the beginning of the value. If last negative, then the returned string ends at the end of the value. Tcl_GetCharLength returns the number of characters (as opposed to bytes) in the string value. Tcl_AppendToObj appends the data given by bytes and length to the string representation of the value specified by objPtr . If the value has an invalid string representation, then an attempt is made to convert bytes is to the Unicode format. If the conversion is successful, then the converted form of bytes is appended to the value\\'s Unicode representation. Otherwise, the value\\'s Unicode representation is invalidated and converted to the UTF format, and bytes is appended to the value\\'s new string representation. Tcl_AppendUnicodeToObj appends the Unicode string given by unicode and numChars to the value specified by objPtr . If the value has an invalid Unicode representation, then unicode is converted to the UTF format and appended to the value\\'s string representation. Appends are optimized to handle repeated appends relatively efficiently (it over-allocates the string or Unicode space to avoid repeated reallocations and copies of value\\'s string value). Tcl_AppendObjToObj is similar to Tcl_AppendToObj , but it appends the string or Unicode value (whichever exists and is best suited to be appended to objPtr ) of appendObjPtr to objPtr . Tcl_AppendStringsToObj is similar to Tcl_AppendToObj except that it can be passed more than one value to append and each value must be a null-terminated string (i.e. none of the values may contain internal null characters). Any number of string arguments may be provided, but the last argument must be a NULL pointer to indicate the end of the list. Tcl_AppendLimitedToObj is similar to Tcl_AppendToObj except that it imposes a limit on how many bytes are appended. This can be handy when the string to be appended might be very large, but the value being constructed should not be allowed to grow without bound. A common usage is when constructing an error message, where the end result should be kept short enough to be read. Bytes from bytes are appended to objPtr , but no more than limit bytes total are to be appended. If the limit prevents all length bytes that are available from being appended, then the appending is done so that the last bytes appended are from the string ellipsis . This allows for an indication of the truncation to be left in the string. When length is negative, all bytes up to the first zero byte are appended, subject to the limit. When ellipsis is NULL, the default string ... is used. When ellipsis is non-NULL, it must point to a zero-byte-terminated string in Tcl\\'s internal UTF encoding. The number of bytes appended can be less than the lesser of length and limit when appending fewer bytes is necessary to append only whole multi-byte characters. Tcl_Format is the C-level interface to the engine of the format command. The actual command procedure for format is little more than Tcl_Format (interp, Tcl_GetString (objv[1]), objc-2, objv+2); The objc Tcl_Obj values in objv are formatted into a string according to the conversion specification in format argument, following the documentation for the format command. The resulting formatted string is converted to a new Tcl_Obj with refcount of zero and returned. If some error happens during production of the formatted string, NULL is returned, and an error message is recorded in interp , if interp is non-NULL. Tcl_AppendFormatToObj is an appending alternative form of Tcl_Format with functionality equivalent to: Tcl_Obj *newPtr = Tcl_Format (interp, format, objc, objv); if (newPtr == NULL) return TCL_ERROR; Tcl_AppendObjToObj (objPtr, newPtr); Tcl_DecrRefCount (newPtr); return TCL_OK; but with greater convenience and efficiency when the appending functionality is needed. Tcl_ObjPrintf serves as a replacement for the common sequence char buf[SOME_SUITABLE_LENGTH]; sprintf(buf, format, ...); Tcl_NewStringObj (buf, -1); but with greater convenience and no need to determine SOME_SUITABLE_LENGTH . The formatting is done with the same core formatting engine used by Tcl_Format . This means the set of supported conversion specifiers is that of the format command and not that of the sprintf routine where the two sets differ. When a conversion specifier passed to Tcl_ObjPrintf includes a precision, the value is taken as a number of bytes, as sprintf does, and not as a number of characters, as format does. This is done on the assumption that C code is more likely to know how many bytes it is passing around than the number of encoded characters those bytes happen to represent. The variable number of arguments passed in should be of the types that would be suitable for passing to sprintf . Note in this example usage, x is of type int . int x = 5; Tcl_Obj *objPtr = Tcl_ObjPrintf (\\\"Value is %d\\\", x); If the value of format contains internal inconsistencies or invalid specifier formats, the formatted string result produced by Tcl_ObjPrintf will be an error message describing the error. It is impossible however to provide runtime protection against mismatches between the format and any subsequent arguments. Compile-time protection may be provided by some compilers. Tcl_AppendPrintfToObj is an appending alternative form of Tcl_ObjPrintf with functionality equivalent to Tcl_Obj *newPtr = Tcl_ObjPrintf (format, ...); Tcl_AppendObjToObj (objPtr, newPtr); Tcl_DecrRefCount (newPtr); but with greater convenience and efficiency when the appending functionality is needed. The Tcl_SetObjLength procedure changes the length of the string value of its objPtr argument. If the newLength argument is greater than the space allocated for the value\\'s string, then the string space is reallocated and the old value is copied to the new space; the bytes between the old length of the string and the new length may have arbitrary values. If the newLength argument is less than the current length of the value\\'s string, with objPtr->length is reduced without reallocating the string space; the original allocated size for the string is recorded in the value, so that the string length can be enlarged in a subsequent call to Tcl_SetObjLength without reallocating storage. In all cases Tcl_SetObjLength leaves a null character at objPtr->bytes[newLength] . Tcl_AttemptSetObjLength is identical in function to Tcl_SetObjLength except that if sufficient memory to satisfy the request cannot be allocated, it does not cause the Tcl interpreter to panic . Thus, if newLength is greater than the space allocated for the value\\'s string, and there is not enough memory available to satisfy the request, Tcl_AttemptSetObjLength will take no action and return 0 to indicate failure. If there is enough memory to satisfy the request, Tcl_AttemptSetObjLength behaves just like Tcl_SetObjLength and returns 1 to indicate success. The Tcl_ConcatObj function returns a new string value whose value is the space-separated concatenation of the string representations of all of the values in the objv array. Tcl_ConcatObj eliminates leading and trailing white space as it copies the string representations of the objv array to the result. If an element of the objv array consists of nothing but white space, then that value is ignored entirely. This white-space removal was added to make the output of the concat command cleaner-looking. Tcl_ConcatObj returns a pointer to a newly-created value whose ref count is zero.","title":"DESCRIPTION"},{"location":"StringObj/#reference-count-management","text":"Tcl_NewStringObj , Tcl_NewUnicodeObj , Tcl_Format , Tcl_ObjPrintf , and Tcl_ConcatObj always return a zero-reference object, much like Tcl_NewObj . Tcl_GetStringFromObj , Tcl_GetString , Tcl_GetUnicodeFromObj , Tcl_GetUnicode , Tcl_GetUniChar , Tcl_GetCharLength , and Tcl_GetRange all only work with an existing value; they do not manipulate its reference count in any way. Tcl_SetStringObj , Tcl_SetUnicodeObj , Tcl_AppendToObj , Tcl_AppendUnicodeToObj , Tcl_AppendObjToObj , Tcl_AppendStringsToObj , Tcl_AppendStringsToObjVA , Tcl_AppendLimitedToObj , Tcl_AppendFormatToObj , Tcl_AppendPrintfToObj , Tcl_SetObjLength , and Tcl_AttemptSetObjLength and require their objPtr to be an unshared value (i.e, a reference count no more than 1) as they will modify it. Additional arguments to the above functions (the appendObjPtr argument to Tcl_AppendObjToObj , values in the objv argument to Tcl_Format , Tcl_AppendFormatToObj , and Tcl_ConcatObj ) can have any reference count, but reference counts of zero are not recommended. Tcl_Format and Tcl_AppendFormatToObj may modify the interpreter result, which involves changing the reference count of a value.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"StringObj/#see-also","text":"Tcl_NewObj(3), Tcl_IncrRefCount(3), Tcl_DecrRefCount(3), format(n), sprintf(3)","title":"SEE ALSO"},{"location":"StringObj/#keywords","text":"append, internal representation, value, value type, string value, string type, string representation, concat, concatenate, unicode","title":"KEYWORDS"},{"location":"SubstObj/","text":"NAME Tcl_SubstObj - perform substitutions on Tcl values SYNOPSIS #include <tcl.h> Tcl_Obj * Tcl_SubstObj(interp, objPtr, flags) ARGUMENTS Interpreter in which to execute Tcl scripts and lookup variables. If an error occurs, the interpreter\\'s result is modified to hold an error message. A Tcl value containing the string to perform substitutions on. OR\\'ed combination of flag bits that specify which substitutions to perform. The flags TCL_SUBST_COMMANDS , TCL_SUBST_VARIABLES and TCL_SUBST_BACKSLASHES are currently supported, and TCL_SUBST_ALL is provided as a convenience for the common case where all substitutions are desired. DESCRIPTION The Tcl_SubstObj function is used to perform substitutions on strings in the fashion of the subst command. It gets the value of the string contained in objPtr and scans it, copying characters and performing the chosen substitutions as it goes to an output value which is returned as the result of the function. In the event of an error occurring during the execution of a command or variable substitution, the function returns NULL and an error message is left in interp \\'s result. Three kinds of substitutions are supported. When the TCL_SUBST_BACKSLASHES bit is set in flags , sequences that look like backslash substitutions for Tcl commands are replaced by their corresponding character. When the TCL_SUBST_VARIABLES bit is set in flags , sequences that look like variable substitutions for Tcl commands are replaced by the contents of the named variable. When the TCL_SUBST_COMMANDS bit is set in flags , sequences that look like command substitutions for Tcl commands are replaced by the result of evaluating that script. Where an uncaught occurs during the evaluation of a command substitution, an empty string is substituted for the command. Where an uncaught occurs during the evaluation of a command substitution, the result of the whole substitution on objPtr will be truncated at the point immediately before the start of the command substitution, and no characters will be added to the result or substitutions performed after that point. REFERENCE COUNT MANAGEMENT The objPtr argument to Tcl_SubstObj must not have a reference count of zero. This function modifies the interpreter result, both on success and on failure; the result of this function on success is exactly the current interpreter result. Successful results should have their reference count incremented if they are to be retained. SEE ALSO subst(n) KEYWORDS backslash substitution, command substitution, variable substitution","title":"NAME"},{"location":"SubstObj/#name","text":"Tcl_SubstObj - perform substitutions on Tcl values","title":"NAME"},{"location":"SubstObj/#synopsis","text":"#include <tcl.h> Tcl_Obj * Tcl_SubstObj(interp, objPtr, flags)","title":"SYNOPSIS"},{"location":"SubstObj/#arguments","text":"Interpreter in which to execute Tcl scripts and lookup variables. If an error occurs, the interpreter\\'s result is modified to hold an error message. A Tcl value containing the string to perform substitutions on. OR\\'ed combination of flag bits that specify which substitutions to perform. The flags TCL_SUBST_COMMANDS , TCL_SUBST_VARIABLES and TCL_SUBST_BACKSLASHES are currently supported, and TCL_SUBST_ALL is provided as a convenience for the common case where all substitutions are desired.","title":"ARGUMENTS"},{"location":"SubstObj/#description","text":"The Tcl_SubstObj function is used to perform substitutions on strings in the fashion of the subst command. It gets the value of the string contained in objPtr and scans it, copying characters and performing the chosen substitutions as it goes to an output value which is returned as the result of the function. In the event of an error occurring during the execution of a command or variable substitution, the function returns NULL and an error message is left in interp \\'s result. Three kinds of substitutions are supported. When the TCL_SUBST_BACKSLASHES bit is set in flags , sequences that look like backslash substitutions for Tcl commands are replaced by their corresponding character. When the TCL_SUBST_VARIABLES bit is set in flags , sequences that look like variable substitutions for Tcl commands are replaced by the contents of the named variable. When the TCL_SUBST_COMMANDS bit is set in flags , sequences that look like command substitutions for Tcl commands are replaced by the result of evaluating that script. Where an uncaught occurs during the evaluation of a command substitution, an empty string is substituted for the command. Where an uncaught occurs during the evaluation of a command substitution, the result of the whole substitution on objPtr will be truncated at the point immediately before the start of the command substitution, and no characters will be added to the result or substitutions performed after that point.","title":"DESCRIPTION"},{"location":"SubstObj/#reference-count-management","text":"The objPtr argument to Tcl_SubstObj must not have a reference count of zero. This function modifies the interpreter result, both on success and on failure; the result of this function on success is exactly the current interpreter result. Successful results should have their reference count incremented if they are to be retained.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"SubstObj/#see-also","text":"subst(n)","title":"SEE ALSO"},{"location":"SubstObj/#keywords","text":"backslash substitution, command substitution, variable substitution","title":"KEYWORDS"},{"location":"TCL_MEM_DEBUG/","text":"NAME TCL_MEM_DEBUG - Compile-time flag to enable Tcl memory debugging DESCRIPTION When Tcl is compiled with TCL_MEM_DEBUG defined, a powerful set of memory debugging aids is included in the compiled binary. This includes C and Tcl functions which can aid with debugging memory leaks, memory allocation overruns, and other memory related errors. ENABLING MEMORY DEBUGGING To enable memory debugging, Tcl should be recompiled from scratch with TCL_MEM_DEBUG defined (e.g. by passing the --enable-symbols=mem flag to the configure script when building). This will also compile in a non-stub version of Tcl_InitMemory to add the memory command to Tcl. TCL_MEM_DEBUG must be either left defined for all modules or undefined for all modules that are going to be linked together. If they are not, link errors will occur, with either Tcl_DbCkfree and Tcl_DbCkalloc or Tcl_Alloc and Tcl_Free being undefined. Once memory debugging support has been compiled into Tcl, the C functions Tcl_ValidateAllMemory , and Tcl_DumpActiveMemory , and the Tcl memory command can be used to validate and examine memory usage. GUARD ZONES When memory debugging is enabled, whenever a call to Tcl_Alloc is made, slightly more memory than requested is allocated so the memory debugging code can keep track of the allocated memory, and eight-byte are placed in front of and behind the space that will be returned to the caller. (The sizes of the guard zones are defined by the C #define LOW_GUARD_SIZE and #define HIGH_GUARD_SIZE in the file generic/tclCkalloc.c --- it can be extended if you suspect large overwrite problems, at some cost in performance.) A known pattern is written into the guard zones and, on a call to Tcl_Free , the guard zones of the space being freed are checked to see if either zone has been modified in any way. If one has been, the guard bytes and their new contents are identified, and a or message is issued. The message includes the address of the memory packet and the file name and line number of the code that called Tcl_Free . This allows you to detect the common sorts of one-off problems, where not enough space was allocated to contain the data written, for example. DEBUGGING DIFFICULT MEMORY CORRUPTION PROBLEMS Normally, Tcl compiled with memory debugging enabled will make it easy to isolate a corruption problem. Turning on memory validation with the memory command can help isolate difficult problems. If you suspect (or know) that corruption is occurring before the Tcl interpreter comes up far enough for you to issue commands, you can set MEM_VALIDATE define, recompile tclCkalloc.c and rebuild Tcl. This will enable memory validation from the first call to Tcl_Alloc , again, at a large performance impact. If you are desperate and validating memory on every call to Tcl_Alloc and Tcl_Free is not enough, you can explicitly call Tcl_ValidateAllMemory directly at any point. It takes a char * and an int which are normally the filename and line number of the caller, but they can actually be anything you want. Remember to remove the calls after you find the problem. SEE ALSO Tcl_Alloc, memory, Tcl_ValidateAllMemory, Tcl_DumpActiveMemory KEYWORDS memory, debug","title":"NAME"},{"location":"TCL_MEM_DEBUG/#name","text":"TCL_MEM_DEBUG - Compile-time flag to enable Tcl memory debugging","title":"NAME"},{"location":"TCL_MEM_DEBUG/#description","text":"When Tcl is compiled with TCL_MEM_DEBUG defined, a powerful set of memory debugging aids is included in the compiled binary. This includes C and Tcl functions which can aid with debugging memory leaks, memory allocation overruns, and other memory related errors.","title":"DESCRIPTION"},{"location":"TCL_MEM_DEBUG/#enabling-memory-debugging","text":"To enable memory debugging, Tcl should be recompiled from scratch with TCL_MEM_DEBUG defined (e.g. by passing the --enable-symbols=mem flag to the configure script when building). This will also compile in a non-stub version of Tcl_InitMemory to add the memory command to Tcl. TCL_MEM_DEBUG must be either left defined for all modules or undefined for all modules that are going to be linked together. If they are not, link errors will occur, with either Tcl_DbCkfree and Tcl_DbCkalloc or Tcl_Alloc and Tcl_Free being undefined. Once memory debugging support has been compiled into Tcl, the C functions Tcl_ValidateAllMemory , and Tcl_DumpActiveMemory , and the Tcl memory command can be used to validate and examine memory usage.","title":"ENABLING MEMORY DEBUGGING"},{"location":"TCL_MEM_DEBUG/#guard-zones","text":"When memory debugging is enabled, whenever a call to Tcl_Alloc is made, slightly more memory than requested is allocated so the memory debugging code can keep track of the allocated memory, and eight-byte are placed in front of and behind the space that will be returned to the caller. (The sizes of the guard zones are defined by the C #define LOW_GUARD_SIZE and #define HIGH_GUARD_SIZE in the file generic/tclCkalloc.c --- it can be extended if you suspect large overwrite problems, at some cost in performance.) A known pattern is written into the guard zones and, on a call to Tcl_Free , the guard zones of the space being freed are checked to see if either zone has been modified in any way. If one has been, the guard bytes and their new contents are identified, and a or message is issued. The message includes the address of the memory packet and the file name and line number of the code that called Tcl_Free . This allows you to detect the common sorts of one-off problems, where not enough space was allocated to contain the data written, for example.","title":"GUARD ZONES"},{"location":"TCL_MEM_DEBUG/#debugging-difficult-memory-corruption-problems","text":"Normally, Tcl compiled with memory debugging enabled will make it easy to isolate a corruption problem. Turning on memory validation with the memory command can help isolate difficult problems. If you suspect (or know) that corruption is occurring before the Tcl interpreter comes up far enough for you to issue commands, you can set MEM_VALIDATE define, recompile tclCkalloc.c and rebuild Tcl. This will enable memory validation from the first call to Tcl_Alloc , again, at a large performance impact. If you are desperate and validating memory on every call to Tcl_Alloc and Tcl_Free is not enough, you can explicitly call Tcl_ValidateAllMemory directly at any point. It takes a char * and an int which are normally the filename and line number of the caller, but they can actually be anything you want. Remember to remove the calls after you find the problem.","title":"DEBUGGING DIFFICULT MEMORY CORRUPTION PROBLEMS"},{"location":"TCL_MEM_DEBUG/#see-also","text":"Tcl_Alloc, memory, Tcl_ValidateAllMemory, Tcl_DumpActiveMemory","title":"SEE ALSO"},{"location":"TCL_MEM_DEBUG/#keywords","text":"memory, debug","title":"KEYWORDS"},{"location":"Tcl/","text":"NAME Tcl - Tool Command Language SYNOPSIS Summary of Tcl language syntax. DESCRIPTION The following rules define the syntax and semantics of the Tcl language: [1] Script. : A script is composed of zero or more commands delimited by semi-colons or newlines. [2] Command. : A command is composed of zero or more words delimited by whitespace. The replacement for a substitution is included verbatim in the word. For example, a space in the replacement is included in the word rather than becoming a delimiter, and \\\\ becomes a single backslash in the word. Each word is processed from left to right and each substitution is performed as soon as it is complete. For example, the command set y \\[set x 0\\]\\[incr x\\]\\[incr x\\] is composed of three words, and sets the value of *y* to *012*. If hash is the first character of what would otherwise be the first word of a command, all characters up to the next newline are ignored. [3] Braced word. : If a word is enclosed in braces and , the braces are removed and the enclosed characters become the word. No substitutions are performed. Nested pairs of braces may occur within the word. A brace preceded by an odd number of backslashes is not considered part of a pair, and neither brace nor the backslashes are removed from the word. [4] Quoted word. : If a word is enclosed in double quotes , the double quotes are removed and the enclosed characters become the word. Substitutions are performed. [5] List. : A list has the form of a single command. Newline is whitespace, and semicolon has no special interpretation. There is no script evaluation so there is no argument expansion, variable substitution, or command substitution: Dollar-sign and open bracket have no special interpretation, and what would be argument expansion in a script is invalid in a list. [6] Argument expansion. : If prefixes a word, it is removed. After any remaining enclosing braces or quotes are processed and applicable substitutions performed, the word, which must be a list, is removed from the command, and in its place each word in the list becomes an additional word in the command. For example, cmd a {*}{b [c]} d {*}{\\$e f {g h}} is equivalent to cmd a b {[c]} d {\\$e} f {g h} . [7] Evaluation. : To evaluate a script, an interpreter evaluates each successive command. The first word identifies a procedure, and the remaining words are passed to that procedure for further evaluation. The procedure interprets each argument in its own way, e.g. as an integer, variable name, list, mathematical expression, script, or in some other arbitrary way. The result of the last command is the result of the script. [8] Command substitution. : Each pair of brackets and encloses a script and is replaced by the result of that script. [9] Variable substitution. : Each of the following forms begins with dollar sign and is replaced by the value of the identified variable. name names the variable and is composed of ASCII letters ( A -- Z and a -- z ), digits ( 0 -- 9 ), underscores, or namespace delimiters (two or more colons). index is the name of an individual variable within an array variable, and may be empty. \\$ name : name may not be empty. \\$ name ( index ) : name may be empty. Substitutions are performed on index . \\${ name } : name may be empty. \\${ name(index) } : name may be empty. No substitutions are performed. Variables that are not accessible through one of the forms above may be accessed through other mechanisms, e.g. the set command. [10] Backslash substitution. : Each backslash that is not part of one of the forms listed below is removed, and the next character is included in the word verbatim, which allows the inclusion of characters that would normally be interpreted, namely whitespace, braces, brackets, double quote, dollar sign, and backslash. The following sequences are replaced as described: \\ a : Audible alert (bell) (U+7). \\ b : Backspace (U+8). \\ f : Form feed (U+C). \\ n : Newline (U+A). \\ r : Carriage-return (U+D). \\ t : Tab (U+9). \\ v : Vertical tab (U+B). \\ \\<newline> whiteSpace : Newline preceded by an odd number of backslashes, along with the consecutive spaces and tabs that immediately follow it, is replaced by a single space. Because this happens before the command is split into words, it occurs even within braced words, and if the resulting space may subsequently be treated as a word delimiter. \\\\ : Backslash {=html} <!-- --> \\ ooo : Up to three octal digits form an eight-bit value for a Unicode character in the range 0 -- 377 , i.e. U+0--U+FF. Only the digits that result in a number in this range are consumed. \\ x hh : Up to two hexadecimal digits form an eight-bit value for a Unicode character in the range 0 -- FF . \\ u hhhh : Up to four hexadecimal digits form a 16-bit value for a Unicode character in the range 0 -- FFFF . \\ U hhhhhhhh : Up to eight hexadecimal digits form a 21-bit value for a Unicode character in the range 0 -- 10FFFF . Only the digits that result in a number in this range are consumed. KEYWORDS backslash, command, comment, script, substitution, variable","title":"NAME"},{"location":"Tcl/#name","text":"Tcl - Tool Command Language","title":"NAME"},{"location":"Tcl/#synopsis","text":"Summary of Tcl language syntax.","title":"SYNOPSIS"},{"location":"Tcl/#description","text":"The following rules define the syntax and semantics of the Tcl language: [1] Script. : A script is composed of zero or more commands delimited by semi-colons or newlines. [2] Command. : A command is composed of zero or more words delimited by whitespace. The replacement for a substitution is included verbatim in the word. For example, a space in the replacement is included in the word rather than becoming a delimiter, and \\\\ becomes a single backslash in the word. Each word is processed from left to right and each substitution is performed as soon as it is complete. For example, the command set y \\[set x 0\\]\\[incr x\\]\\[incr x\\] is composed of three words, and sets the value of *y* to *012*. If hash is the first character of what would otherwise be the first word of a command, all characters up to the next newline are ignored. [3] Braced word. : If a word is enclosed in braces and , the braces are removed and the enclosed characters become the word. No substitutions are performed. Nested pairs of braces may occur within the word. A brace preceded by an odd number of backslashes is not considered part of a pair, and neither brace nor the backslashes are removed from the word. [4] Quoted word. : If a word is enclosed in double quotes , the double quotes are removed and the enclosed characters become the word. Substitutions are performed. [5] List. : A list has the form of a single command. Newline is whitespace, and semicolon has no special interpretation. There is no script evaluation so there is no argument expansion, variable substitution, or command substitution: Dollar-sign and open bracket have no special interpretation, and what would be argument expansion in a script is invalid in a list. [6] Argument expansion. : If prefixes a word, it is removed. After any remaining enclosing braces or quotes are processed and applicable substitutions performed, the word, which must be a list, is removed from the command, and in its place each word in the list becomes an additional word in the command. For example, cmd a {*}{b [c]} d {*}{\\$e f {g h}} is equivalent to cmd a b {[c]} d {\\$e} f {g h} . [7] Evaluation. : To evaluate a script, an interpreter evaluates each successive command. The first word identifies a procedure, and the remaining words are passed to that procedure for further evaluation. The procedure interprets each argument in its own way, e.g. as an integer, variable name, list, mathematical expression, script, or in some other arbitrary way. The result of the last command is the result of the script. [8] Command substitution. : Each pair of brackets and encloses a script and is replaced by the result of that script. [9] Variable substitution. : Each of the following forms begins with dollar sign and is replaced by the value of the identified variable. name names the variable and is composed of ASCII letters ( A -- Z and a -- z ), digits ( 0 -- 9 ), underscores, or namespace delimiters (two or more colons). index is the name of an individual variable within an array variable, and may be empty. \\$ name : name may not be empty. \\$ name ( index ) : name may be empty. Substitutions are performed on index . \\${ name } : name may be empty. \\${ name(index) } : name may be empty. No substitutions are performed. Variables that are not accessible through one of the forms above may be accessed through other mechanisms, e.g. the set command. [10] Backslash substitution. : Each backslash that is not part of one of the forms listed below is removed, and the next character is included in the word verbatim, which allows the inclusion of characters that would normally be interpreted, namely whitespace, braces, brackets, double quote, dollar sign, and backslash. The following sequences are replaced as described: \\ a : Audible alert (bell) (U+7). \\ b : Backspace (U+8). \\ f : Form feed (U+C). \\ n : Newline (U+A). \\ r : Carriage-return (U+D). \\ t : Tab (U+9). \\ v : Vertical tab (U+B). \\ \\<newline> whiteSpace : Newline preceded by an odd number of backslashes, along with the consecutive spaces and tabs that immediately follow it, is replaced by a single space. Because this happens before the command is split into words, it occurs even within braced words, and if the resulting space may subsequently be treated as a word delimiter. \\\\ : Backslash {=html} <!-- --> \\ ooo : Up to three octal digits form an eight-bit value for a Unicode character in the range 0 -- 377 , i.e. U+0--U+FF. Only the digits that result in a number in this range are consumed. \\ x hh : Up to two hexadecimal digits form an eight-bit value for a Unicode character in the range 0 -- FF . \\ u hhhh : Up to four hexadecimal digits form a 16-bit value for a Unicode character in the range 0 -- FFFF . \\ U hhhhhhhh : Up to eight hexadecimal digits form a 21-bit value for a Unicode character in the range 0 -- 10FFFF . Only the digits that result in a number in this range are consumed.","title":"DESCRIPTION"},{"location":"Tcl/#keywords","text":"backslash, command, comment, script, substitution, variable","title":"KEYWORDS"},{"location":"TclZlib/","text":"NAME Tcl_ZlibAdler32, Tcl_ZlibCRC32, Tcl_ZlibDeflate, Tcl_ZlibInflate, Tcl_ZlibStreamChecksum, Tcl_ZlibStreamClose, Tcl_ZlibStreamEof, Tcl_ZlibStreamGet, Tcl_ZlibStreamGetCommandName, Tcl_ZlibStreamInit, Tcl_ZlibStreamPut - compression and decompression functions SYNOPSIS #include <tcl.h> int Tcl_ZlibDeflate(interp, format, dataObj, level, dictObj) int Tcl_ZlibInflate(interp, format, dataObj, dictObj) unsigned int Tcl_ZlibCRC32(initValue, bytes, length) unsigned int Tcl_ZlibAdler32(initValue, bytes, length) int Tcl_ZlibStreamInit(interp, mode, format, level, dictObj, zshandlePtr) Tcl_Obj * Tcl_ZlibStreamGetCommandName(zshandle) int Tcl_ZlibStreamEof(zshandle) int Tcl_ZlibStreamClose(zshandle) int Tcl_ZlibStreamReset(zshandle) int Tcl_ZlibStreamChecksum(zshandle) int Tcl_ZlibStreamPut(zshandle, dataObj, flush) int Tcl_ZlibStreamGet(zshandle, dataObj, count) Tcl_ZlibStreamSetCompressionDictionary(zshandle, compDict) ARGUMENTS The interpreter to store resulting compressed or uncompressed data in. Also where any error messages are written. For Tcl_ZlibStreamInit , this can be NULL to create a stream that is not bound to a command. What format of compressed data to work with. Must be one of TCL_ZLIB_FORMAT_ZLIB for zlib-format data, TCL_ZLIB_FORMAT_GZIP for gzip-format data, or TCL_ZLIB_FORMAT_RAW for raw compressed data. In addition, for decompression only, TCL_ZLIB_FORMAT_AUTO may also be chosen which can automatically detect whether the compressed data was in zlib or gzip format. A byte-array value containing the data to be compressed or decompressed, or to which the data extracted from the stream is appended when passed to Tcl_ZlibStreamGet . What level of compression to use. Should be a number from 0 to 9 or one of the following: TCL_ZLIB_COMPRESS_NONE for no compression, TCL_ZLIB_COMPRESS_FAST for fast but inefficient compression, TCL_ZLIB_COMPRESS_BEST for slow but maximal compression, or TCL_ZLIB_COMPRESS_DEFAULT for the level recommended by the zlib library. A dictionary that contains, or which will be updated to contain, a description of the gzip header associated with the compressed data. Only useful when the format is TCL_ZLIB_FORMAT_GZIP or TCL_ZLIB_FORMAT_AUTO . If a NULL is passed, a default header will be used on compression and the header will be ignored (apart from integrity checks) on decompression. See the section GZIP OPTIONS DICTIONARY for details about the contents of this dictionary. The initial value for the checksum algorithm. An array of bytes to run the checksum algorithm over, or NULL to get the recommended initial value for the checksum algorithm. The number of bytes in the array. What mode to operate the stream in. Should be either TCL_ZLIB_STREAM_DEFLATE for a compressing stream or TCL_ZLIB_STREAM_INFLATE for a decompressing stream. A pointer to a variable in which to write the abstract token for the stream upon successful creation. The abstract token for the stream to operate on. Whether and how to flush the stream after writing the data to it. Must be one of: TCL_ZLIB_NO_FLUSH if no flushing is to be done, TCL_ZLIB_FLUSH if the currently compressed data must be made available for access using Tcl_ZlibStreamGet , TCL_ZLIB_FULLFLUSH if the stream must be put into a state where the decompressor can recover from on corruption, or TCL_ZLIB_FINALIZE to ensure that the stream is finished and that any trailer demanded by the format is written. The maximum number of bytes to get from the stream, or -1 to get all remaining bytes from the stream\\'s buffers. A byte array value that is the compression dictionary to use with the stream. Note that this is not a Tcl dictionary , and it is recommended that this only ever be used with streams that were created with their format set to TCL_ZLIB_FORMAT_ZLIB because the other formats have no mechanism to indicate whether a compression dictionary was present other than to fail on decompression. DESCRIPTION These functions form the interface from the Tcl library to the Zlib library by Jean-loup Gailly and Mark Adler. Tcl_ZlibDeflate and Tcl_ZlibInflate respectively compress and decompress the data contained in the dataObj argument, according to the format and, for compression, level arguments. The dictionary in the dictObj parameter is used to convey additional header information about the compressed data when the compression format supports it; currently, the dictionary is only used when the format parameter is TCL_ZLIB_FORMAT_GZIP or TCL_ZLIB_FORMAT_AUTO . For details of the contents of the dictionary, see the GZIP OPTIONS DICTIONARY section below. Upon success, both functions leave the resulting compressed or decompressed data in a byte-array value that is the Tcl interpreter\\'s result; the returned value is a standard Tcl result code. Tcl_ZlibAdler32 and Tcl_ZlibCRC32 compute checksums on arrays of bytes, returning the computed checksum. Checksums are computed incrementally, allowing data to be processed one block at a time, but this requires the caller to maintain the current checksum and pass it in as the initValue parameter; the initial value to use for this can be obtained by using NULL for the bytes parameter instead of a pointer to the array of bytes to compute the checksum over. Thus, typical usage in the single data block case is like this: checksum = Tcl_ZlibCRC32 ( Tcl_ZlibCRC32 (0,NULL,0), data, length); Note that the Adler-32 algorithm is not a real checksum, but instead is a related type of hash that works best on longer data. ZLIB STREAMS Tcl_ZlibStreamInit creates a compressing or decompressing stream that is linked to a Tcl command, according to its arguments, and provides an abstract token for the stream and returns a normal Tcl result code; Tcl_ZlibStreamGetCommandName returns the name of that command given the stream token, or NULL if the stream has no command. Streams are not designed to be thread-safe; each stream should only ever be used from the thread that created it. When working with gzip streams, a dictionary (fields as given in the GZIP OPTIONS DICTIONARY section below) can be given via the dictObj parameter that on compression allows control over the generated headers, and on decompression allows discovery of the existing headers. Note that the dictionary will be written to on decompression once sufficient data has been read to have a complete header. This means that the dictionary must be an unshared value in that case; a blank value created with Tcl_NewObj is suggested. Once a stream has been constructed, Tcl_ZlibStreamPut is used to add data to the stream and Tcl_ZlibStreamGet is used to retrieve data from the stream after processing. Both return normal Tcl result codes and leave an error message in the result of the interpreter that the stream is registered with in the error case (if such a registration has been performed). With Tcl_ZlibStreamPut , the data buffer value passed to it should not be modified afterwards. With Tcl_ZlibStreamGet , the data buffer value passed to it will have the data bytes appended to it. Internally to the stream, data is kept compressed so as to minimize the cost of buffer space. Tcl_ZlibStreamChecksum returns the checksum computed over the uncompressed data according to the format, and Tcl_ZlibStreamEof returns a boolean value indicating whether the end of the uncompressed data has been reached. Tcl_ZlibStreamSetCompressionDictionary is used to control the compression dictionary used with the stream, a compression dictionary being an array of bytes (such as might be created with Tcl_NewByteArrayObj ) that is used to initialize the compression engine rather than leaving it to create it on the fly from the data being compressed. Setting a compression dictionary allows for more efficient compression in the case where the start of the data is highly regular, but it does require both the compressor and the decompressor to agreee on the value to use. Compression dictionaries are only fully supported for zlib-format data; on compression, they must be set before any data is sent in with Tcl_ZlibStreamPut , and on decompression they should be set when Tcl_ZlibStreamGet produces an error with its -errorcode set to the code will be the Adler-32 checksum (see Tcl_ZlibAdler32 ) of the compression dictionary sought. (Note that this is only true for zlib-format streams; gzip streams ignore compression dictionaries as the format specification doesn\\'t permit them, and raw streams just produce a data error if the compression dictionary is missing or incorrect.) If you wish to clear a stream and reuse it for a new compression or decompression action, Tcl_ZlibStreamReset will do this and return a normal Tcl result code to indicate whether it was successful; if the stream is registered with an interpreter, an error message will be left in the interpreter result when this function returns TCL_ERROR. Finally, Tcl_ZlibStreamClose will clean up the stream and delete the associated command: using Tcl_DeleteCommand on the stream\\'s command is equivalent (when such a command exists). GZIP OPTIONS DICTIONARY The dictObj parameter to Tcl_ZlibDeflate , Tcl_ZlibInflate and Tcl_ZlibStreamInit is used to pass a dictionary of options about that is used to describe the gzip header in the compressed data. When creating compressed data, the dictionary is read and when unpacking compressed data the dictionary is written (in which case the dictObj parameter must refer to an unshared dictionary value). The following fields in the dictionary value are understood. All other fields are ignored. No field is required when creating a gzip-format stream. comment : This holds the comment field of the header, if present. If absent, no comment was supplied (on decompression) or will be created (on compression). crc : A boolean value describing whether a CRC of the header is computed. Note that the gzip program does not use or allow a CRC on the header. filename : The name of the file that held the uncompressed data. This should not contain any directory separators, and should be sanitized before use on decompression with file tail . os : The operating system type code field from the header (if not the value). See RFC 1952 for the meaning of these codes. On compression, if this is absent then the field will be set to the value. size : The size of the uncompressed data. This is ignored on compression; the size of the data compressed depends on how much data is supplied to the compression engine. time : The time field from the header if non-zero, expected to be the time that the file named by the filename field was modified. Suitable for use with clock format . On creation, the right value to use is that from clock seconds or file mtime . type : The type of the uncompressed data (either binary or text ) if known. REFERENCE COUNT MANAGEMENT Tcl_ZlibDeflate and Tcl_ZlibInflate take a value with arbitrary reference count for their dataObj and dictObj arguments (the latter often being NULL instead), and set the interpreter result with their output value (or an error). The existing interpreter result should not be passed as any argument value unless an additional reference is held. Tcl_ZlibStreamInit takes a value with arbitrary reference count for its dictObj argument; it only reads from it. The existing interpreter result should not be passed unless an additional reference is held. Tcl_ZlibStreamGetCommandName returns a zero reference count value, much like Tcl_NewObj . The dataObj argument to Tcl_ZlibStreamPut is a value with arbitrary reference count; it is only ever read from. The dataObj argument to Tcl_ZlibStreamGet is an unshared value (see Tcl_IsShared ) that will be updated by the function. The compDict argument to Tcl_ZlibStreamSetCompressionDictionary , if non-NULL, may be duplicated or may have its reference count incremented. Using a zero reference count value is not recommended. PORTABILITY NOTES These functions will fail gracefully if Tcl is not linked with the zlib library. SEE ALSO Tcl_NewByteArrayObj(3), zlib(n) KEYWORDS compress, decompress, deflate, gzip, inflate","title":"NAME"},{"location":"TclZlib/#name","text":"Tcl_ZlibAdler32, Tcl_ZlibCRC32, Tcl_ZlibDeflate, Tcl_ZlibInflate, Tcl_ZlibStreamChecksum, Tcl_ZlibStreamClose, Tcl_ZlibStreamEof, Tcl_ZlibStreamGet, Tcl_ZlibStreamGetCommandName, Tcl_ZlibStreamInit, Tcl_ZlibStreamPut - compression and decompression functions","title":"NAME"},{"location":"TclZlib/#synopsis","text":"#include <tcl.h> int Tcl_ZlibDeflate(interp, format, dataObj, level, dictObj) int Tcl_ZlibInflate(interp, format, dataObj, dictObj) unsigned int Tcl_ZlibCRC32(initValue, bytes, length) unsigned int Tcl_ZlibAdler32(initValue, bytes, length) int Tcl_ZlibStreamInit(interp, mode, format, level, dictObj, zshandlePtr) Tcl_Obj * Tcl_ZlibStreamGetCommandName(zshandle) int Tcl_ZlibStreamEof(zshandle) int Tcl_ZlibStreamClose(zshandle) int Tcl_ZlibStreamReset(zshandle) int Tcl_ZlibStreamChecksum(zshandle) int Tcl_ZlibStreamPut(zshandle, dataObj, flush) int Tcl_ZlibStreamGet(zshandle, dataObj, count) Tcl_ZlibStreamSetCompressionDictionary(zshandle, compDict)","title":"SYNOPSIS"},{"location":"TclZlib/#arguments","text":"The interpreter to store resulting compressed or uncompressed data in. Also where any error messages are written. For Tcl_ZlibStreamInit , this can be NULL to create a stream that is not bound to a command. What format of compressed data to work with. Must be one of TCL_ZLIB_FORMAT_ZLIB for zlib-format data, TCL_ZLIB_FORMAT_GZIP for gzip-format data, or TCL_ZLIB_FORMAT_RAW for raw compressed data. In addition, for decompression only, TCL_ZLIB_FORMAT_AUTO may also be chosen which can automatically detect whether the compressed data was in zlib or gzip format. A byte-array value containing the data to be compressed or decompressed, or to which the data extracted from the stream is appended when passed to Tcl_ZlibStreamGet . What level of compression to use. Should be a number from 0 to 9 or one of the following: TCL_ZLIB_COMPRESS_NONE for no compression, TCL_ZLIB_COMPRESS_FAST for fast but inefficient compression, TCL_ZLIB_COMPRESS_BEST for slow but maximal compression, or TCL_ZLIB_COMPRESS_DEFAULT for the level recommended by the zlib library. A dictionary that contains, or which will be updated to contain, a description of the gzip header associated with the compressed data. Only useful when the format is TCL_ZLIB_FORMAT_GZIP or TCL_ZLIB_FORMAT_AUTO . If a NULL is passed, a default header will be used on compression and the header will be ignored (apart from integrity checks) on decompression. See the section GZIP OPTIONS DICTIONARY for details about the contents of this dictionary. The initial value for the checksum algorithm. An array of bytes to run the checksum algorithm over, or NULL to get the recommended initial value for the checksum algorithm. The number of bytes in the array. What mode to operate the stream in. Should be either TCL_ZLIB_STREAM_DEFLATE for a compressing stream or TCL_ZLIB_STREAM_INFLATE for a decompressing stream. A pointer to a variable in which to write the abstract token for the stream upon successful creation. The abstract token for the stream to operate on. Whether and how to flush the stream after writing the data to it. Must be one of: TCL_ZLIB_NO_FLUSH if no flushing is to be done, TCL_ZLIB_FLUSH if the currently compressed data must be made available for access using Tcl_ZlibStreamGet , TCL_ZLIB_FULLFLUSH if the stream must be put into a state where the decompressor can recover from on corruption, or TCL_ZLIB_FINALIZE to ensure that the stream is finished and that any trailer demanded by the format is written. The maximum number of bytes to get from the stream, or -1 to get all remaining bytes from the stream\\'s buffers. A byte array value that is the compression dictionary to use with the stream. Note that this is not a Tcl dictionary , and it is recommended that this only ever be used with streams that were created with their format set to TCL_ZLIB_FORMAT_ZLIB because the other formats have no mechanism to indicate whether a compression dictionary was present other than to fail on decompression.","title":"ARGUMENTS"},{"location":"TclZlib/#description","text":"These functions form the interface from the Tcl library to the Zlib library by Jean-loup Gailly and Mark Adler. Tcl_ZlibDeflate and Tcl_ZlibInflate respectively compress and decompress the data contained in the dataObj argument, according to the format and, for compression, level arguments. The dictionary in the dictObj parameter is used to convey additional header information about the compressed data when the compression format supports it; currently, the dictionary is only used when the format parameter is TCL_ZLIB_FORMAT_GZIP or TCL_ZLIB_FORMAT_AUTO . For details of the contents of the dictionary, see the GZIP OPTIONS DICTIONARY section below. Upon success, both functions leave the resulting compressed or decompressed data in a byte-array value that is the Tcl interpreter\\'s result; the returned value is a standard Tcl result code. Tcl_ZlibAdler32 and Tcl_ZlibCRC32 compute checksums on arrays of bytes, returning the computed checksum. Checksums are computed incrementally, allowing data to be processed one block at a time, but this requires the caller to maintain the current checksum and pass it in as the initValue parameter; the initial value to use for this can be obtained by using NULL for the bytes parameter instead of a pointer to the array of bytes to compute the checksum over. Thus, typical usage in the single data block case is like this: checksum = Tcl_ZlibCRC32 ( Tcl_ZlibCRC32 (0,NULL,0), data, length); Note that the Adler-32 algorithm is not a real checksum, but instead is a related type of hash that works best on longer data.","title":"DESCRIPTION"},{"location":"TclZlib/#zlib-streams","text":"Tcl_ZlibStreamInit creates a compressing or decompressing stream that is linked to a Tcl command, according to its arguments, and provides an abstract token for the stream and returns a normal Tcl result code; Tcl_ZlibStreamGetCommandName returns the name of that command given the stream token, or NULL if the stream has no command. Streams are not designed to be thread-safe; each stream should only ever be used from the thread that created it. When working with gzip streams, a dictionary (fields as given in the GZIP OPTIONS DICTIONARY section below) can be given via the dictObj parameter that on compression allows control over the generated headers, and on decompression allows discovery of the existing headers. Note that the dictionary will be written to on decompression once sufficient data has been read to have a complete header. This means that the dictionary must be an unshared value in that case; a blank value created with Tcl_NewObj is suggested. Once a stream has been constructed, Tcl_ZlibStreamPut is used to add data to the stream and Tcl_ZlibStreamGet is used to retrieve data from the stream after processing. Both return normal Tcl result codes and leave an error message in the result of the interpreter that the stream is registered with in the error case (if such a registration has been performed). With Tcl_ZlibStreamPut , the data buffer value passed to it should not be modified afterwards. With Tcl_ZlibStreamGet , the data buffer value passed to it will have the data bytes appended to it. Internally to the stream, data is kept compressed so as to minimize the cost of buffer space. Tcl_ZlibStreamChecksum returns the checksum computed over the uncompressed data according to the format, and Tcl_ZlibStreamEof returns a boolean value indicating whether the end of the uncompressed data has been reached. Tcl_ZlibStreamSetCompressionDictionary is used to control the compression dictionary used with the stream, a compression dictionary being an array of bytes (such as might be created with Tcl_NewByteArrayObj ) that is used to initialize the compression engine rather than leaving it to create it on the fly from the data being compressed. Setting a compression dictionary allows for more efficient compression in the case where the start of the data is highly regular, but it does require both the compressor and the decompressor to agreee on the value to use. Compression dictionaries are only fully supported for zlib-format data; on compression, they must be set before any data is sent in with Tcl_ZlibStreamPut , and on decompression they should be set when Tcl_ZlibStreamGet produces an error with its -errorcode set to the code will be the Adler-32 checksum (see Tcl_ZlibAdler32 ) of the compression dictionary sought. (Note that this is only true for zlib-format streams; gzip streams ignore compression dictionaries as the format specification doesn\\'t permit them, and raw streams just produce a data error if the compression dictionary is missing or incorrect.) If you wish to clear a stream and reuse it for a new compression or decompression action, Tcl_ZlibStreamReset will do this and return a normal Tcl result code to indicate whether it was successful; if the stream is registered with an interpreter, an error message will be left in the interpreter result when this function returns TCL_ERROR. Finally, Tcl_ZlibStreamClose will clean up the stream and delete the associated command: using Tcl_DeleteCommand on the stream\\'s command is equivalent (when such a command exists).","title":"ZLIB STREAMS"},{"location":"TclZlib/#gzip-options-dictionary","text":"The dictObj parameter to Tcl_ZlibDeflate , Tcl_ZlibInflate and Tcl_ZlibStreamInit is used to pass a dictionary of options about that is used to describe the gzip header in the compressed data. When creating compressed data, the dictionary is read and when unpacking compressed data the dictionary is written (in which case the dictObj parameter must refer to an unshared dictionary value). The following fields in the dictionary value are understood. All other fields are ignored. No field is required when creating a gzip-format stream. comment : This holds the comment field of the header, if present. If absent, no comment was supplied (on decompression) or will be created (on compression). crc : A boolean value describing whether a CRC of the header is computed. Note that the gzip program does not use or allow a CRC on the header. filename : The name of the file that held the uncompressed data. This should not contain any directory separators, and should be sanitized before use on decompression with file tail . os : The operating system type code field from the header (if not the value). See RFC 1952 for the meaning of these codes. On compression, if this is absent then the field will be set to the value. size : The size of the uncompressed data. This is ignored on compression; the size of the data compressed depends on how much data is supplied to the compression engine. time : The time field from the header if non-zero, expected to be the time that the file named by the filename field was modified. Suitable for use with clock format . On creation, the right value to use is that from clock seconds or file mtime . type : The type of the uncompressed data (either binary or text ) if known.","title":"GZIP OPTIONS DICTIONARY"},{"location":"TclZlib/#reference-count-management","text":"Tcl_ZlibDeflate and Tcl_ZlibInflate take a value with arbitrary reference count for their dataObj and dictObj arguments (the latter often being NULL instead), and set the interpreter result with their output value (or an error). The existing interpreter result should not be passed as any argument value unless an additional reference is held. Tcl_ZlibStreamInit takes a value with arbitrary reference count for its dictObj argument; it only reads from it. The existing interpreter result should not be passed unless an additional reference is held. Tcl_ZlibStreamGetCommandName returns a zero reference count value, much like Tcl_NewObj . The dataObj argument to Tcl_ZlibStreamPut is a value with arbitrary reference count; it is only ever read from. The dataObj argument to Tcl_ZlibStreamGet is an unshared value (see Tcl_IsShared ) that will be updated by the function. The compDict argument to Tcl_ZlibStreamSetCompressionDictionary , if non-NULL, may be duplicated or may have its reference count incremented. Using a zero reference count value is not recommended.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"TclZlib/#portability-notes","text":"These functions will fail gracefully if Tcl is not linked with the zlib library.","title":"PORTABILITY NOTES"},{"location":"TclZlib/#see-also","text":"Tcl_NewByteArrayObj(3), zlib(n)","title":"SEE ALSO"},{"location":"TclZlib/#keywords","text":"compress, decompress, deflate, gzip, inflate","title":"KEYWORDS"},{"location":"Tcl_Main/","text":"NAME Tcl_Main, Tcl_MainEx, Tcl_MainExW, Tcl_SetStartupScript, Tcl_GetStartupScript, Tcl_SetMainLoop - main program, startup script, and event loop definition for Tcl-based applications SYNOPSIS #include <tcl.h> Tcl_Main(argc, argv, appInitProc) Tcl_MainEx(argc, charargv, appInitProc, interp) Tcl_MainExW(argc, wideargv, appInitProc, interp) Tcl_SetStartupScript(path, encoding) Tcl_Obj * Tcl_GetStartupScript(encodingPtr) Tcl_SetMainLoop(mainLoopProc) ARGUMENTS Number of elements in argv . Array of strings containing command-line arguments. On Windows, when using -DUNICODE, the parameter type changes to wchar_t *. As argv, but does not change type to wchar_t. As argv, but type is always wchar_t. Address of an application-specific initialization procedure. The value for this argument is usually Tcl_AppInit . Name of file to use as startup script, or NULL. Encoding of file to use as startup script, or NULL. If non-NULL, location to write a copy of the (const char *) pointing to the encoding name. Address of an application-specific event loop procedure. Already created Tcl Interpreter. DESCRIPTION Tcl_Main can serve as the main program for Tcl-based shell applications. A is a program like tclsh or wish that supports both interactive interpretation of Tcl and evaluation of a script contained in a file given as a command line argument. Tcl_Main is offered as a convenience to developers of shell applications, so they do not have to reproduce all of the code for proper initialization of the Tcl library and interactive shell operation. Other styles of embedding Tcl in an application are not supported by Tcl_Main . Those must be achieved by calling lower level functions in the Tcl library directly. The Tcl_Main function has been offered by the Tcl library since release Tcl 7.4. In older releases of Tcl, the Tcl library itself defined a function main , but that lacks flexibility of embedding style and having a function main in a library (particularly a shared library) causes problems on many systems. Having main in the Tcl library would also make it hard to use Tcl in C++ programs, since C++ programs must have special C++ main functions. Normally each shell application contains a small main function that does nothing but invoke Tcl_Main . Tcl_Main then does all the work of creating and running a tclsh -like application. Tcl_Main is not provided by the public interface of Tcl\\'s stub library. Programs that call Tcl_Main must be linked against the standard Tcl library. If the standard Tcl library is a dll (so, not a static .lib/.a) , then the program must be linked against the stub library as well. Extensions (stub-enabled or not) are not intended to call Tcl_Main . Tcl_Main is not thread-safe. It should only be called by a single main thread of a multi-threaded application. This restriction is not a problem with normal use described above. Tcl_Main and therefore all applications based upon it, like tclsh , use Tcl_GetStdChannel to initialize the standard channels to their default values. See Tcl_StandardChannels for more information. Tcl_Main supports two modes of operation, depending on whether the filename and encoding of a startup script has been established. The routines Tcl_SetStartupScript and Tcl_GetStartupScript are the tools for controlling this configuration of Tcl_Main . Tcl_SetStartupScript registers the value path as the name of the file for Tcl_Main to evaluate as its startup script. The value encoding is Tcl\\'s name for the encoding used to store the text in that file. A value of NULL for encoding is a signal to use the system encoding. A value of NULL for path erases any existing registration so that Tcl_Main will not evaluate any startup script. Tcl_GetStartupScript queries the registered file name and encoding set by the most recent Tcl_SetStartupScript call in the same thread. The stored file name is returned, and the stored encoding name is written to space pointed to by encodingPtr , when that is not NULL. The file name and encoding values managed by the routines Tcl_SetStartupScript and Tcl_GetStartupScript are stored per-thread. Although the storage and retrieval functions of these routines work in any thread, only those calls in the same main thread as Tcl_Main can have any influence on it. The caller of Tcl_Main may call Tcl_SetStartupScript first to establish its desired startup script. If Tcl_Main finds that no such startup script has been established, it consults the first few arguments in argv . If they match ? -encoding name ? fileName , where fileName does not begin with the character - , then fileName is taken to be the name of a file containing a startup script , and name is taken to be the name of the encoding of the contents of that file. Tcl_Main then calls Tcl_SetStartupScript with these values. Tcl_Main then defines in its main interpreter the Tcl variables argc , argv , argv0 , and tcl_interactive , as described in the documentation for tclsh . When it has finished its own initialization, but before it processes commands, Tcl_Main calls the procedure given by the appInitProc argument. This procedure provides a for the application to perform its own initialization of the interpreter created by Tcl_Main , such as defining application-specific commands. The application initialization routine might also call Tcl_SetStartupScript to (re-)set the file and encoding to be used as a startup script. The procedure must have an interface that matches the type Tcl_AppInitProc : typedef int Tcl_AppInitProc ( Tcl_Interp * interp ); AppInitProc is almost always a pointer to Tcl_AppInit ; for more details on this procedure, see the documentation for Tcl_AppInit . When the appInitProc is finished, Tcl_Main calls Tcl_GetStartupScript to determine what startup script has been requested, if any. If a startup script has been provided, Tcl_Main attempts to evaluate it. Otherwise, interactive mode begins with examination of the variable tcl_rcFileName in the main interpreter. If that variable exists and holds the name of a readable file, the contents of that file are evaluated in the main interpreter. Then interactive operations begin, with prompts and command evaluation results written to the standard output channel, and commands read from the standard input channel and then evaluated. The prompts written to the standard output channel may be customized by defining the Tcl variables tcl_prompt1 and tcl_prompt2 as described in the documentation for tclsh . The prompts and command evaluation results are written to the standard output channel only if the Tcl variable tcl_interactive in the main interpreter holds a non-zero integer value. Tcl_SetMainLoop allows setting an event loop procedure to be run. This allows, for example, Tk to be dynamically loaded and set its event loop. The event loop will run following the startup script. If you are in interactive mode, setting the main loop procedure will cause the prompt to become fileevent based and then the loop procedure is called. When the loop procedure returns in interactive mode, interactive operation will continue. The main loop procedure must have an interface that matches the type Tcl_MainLoopProc : typedef void Tcl_MainLoopProc (void); Tcl_Main does not return. Normally a program based on Tcl_Main will terminate when the exit command is evaluated. In interactive mode, if an EOF or channel error is encountered on the standard input channel, then Tcl_Main itself will evaluate the exit command after the main loop procedure (if any) returns. In non-interactive mode, after Tcl_Main evaluates the startup script, and the main loop procedure (if any) returns, Tcl_Main will also evaluate the exit command. Tcl_Main can not be used in stub-enabled extensions. The difference between Tcl_MainEx and Tcl_MainExW is that the arguments are passed as characters or wide characters. When used in stub-enabled embedders, the stubs table must be first initialized using one of Tcl_InitSubsystems , Tcl_SetPanicProc , Tcl_FindExecutable or TclZipfs_AppHook . REFERENCE COUNT MANAGEMENT Tcl_SetStartupScript takes a value (or NULL) for its path argument, and will increment the reference count of it. Tcl_GetStartupScript returns a value with reference count at least 1, or NULL. It\\'s encodingPtr is also used (if non-NULL) to return a value with a reference count at least 1, or NULL. In both cases, the owner of the values is the current thread. SEE ALSO tclsh(1), Tcl_GetStdChannel(3), Tcl_StandardChannels(3), Tcl_AppInit(3), exit(n), encoding(n) KEYWORDS application-specific initialization, command-line arguments, main program","title":"NAME"},{"location":"Tcl_Main/#name","text":"Tcl_Main, Tcl_MainEx, Tcl_MainExW, Tcl_SetStartupScript, Tcl_GetStartupScript, Tcl_SetMainLoop - main program, startup script, and event loop definition for Tcl-based applications","title":"NAME"},{"location":"Tcl_Main/#synopsis","text":"#include <tcl.h> Tcl_Main(argc, argv, appInitProc) Tcl_MainEx(argc, charargv, appInitProc, interp) Tcl_MainExW(argc, wideargv, appInitProc, interp) Tcl_SetStartupScript(path, encoding) Tcl_Obj * Tcl_GetStartupScript(encodingPtr) Tcl_SetMainLoop(mainLoopProc)","title":"SYNOPSIS"},{"location":"Tcl_Main/#arguments","text":"Number of elements in argv . Array of strings containing command-line arguments. On Windows, when using -DUNICODE, the parameter type changes to wchar_t *. As argv, but does not change type to wchar_t. As argv, but type is always wchar_t. Address of an application-specific initialization procedure. The value for this argument is usually Tcl_AppInit . Name of file to use as startup script, or NULL. Encoding of file to use as startup script, or NULL. If non-NULL, location to write a copy of the (const char *) pointing to the encoding name. Address of an application-specific event loop procedure. Already created Tcl Interpreter.","title":"ARGUMENTS"},{"location":"Tcl_Main/#description","text":"Tcl_Main can serve as the main program for Tcl-based shell applications. A is a program like tclsh or wish that supports both interactive interpretation of Tcl and evaluation of a script contained in a file given as a command line argument. Tcl_Main is offered as a convenience to developers of shell applications, so they do not have to reproduce all of the code for proper initialization of the Tcl library and interactive shell operation. Other styles of embedding Tcl in an application are not supported by Tcl_Main . Those must be achieved by calling lower level functions in the Tcl library directly. The Tcl_Main function has been offered by the Tcl library since release Tcl 7.4. In older releases of Tcl, the Tcl library itself defined a function main , but that lacks flexibility of embedding style and having a function main in a library (particularly a shared library) causes problems on many systems. Having main in the Tcl library would also make it hard to use Tcl in C++ programs, since C++ programs must have special C++ main functions. Normally each shell application contains a small main function that does nothing but invoke Tcl_Main . Tcl_Main then does all the work of creating and running a tclsh -like application. Tcl_Main is not provided by the public interface of Tcl\\'s stub library. Programs that call Tcl_Main must be linked against the standard Tcl library. If the standard Tcl library is a dll (so, not a static .lib/.a) , then the program must be linked against the stub library as well. Extensions (stub-enabled or not) are not intended to call Tcl_Main . Tcl_Main is not thread-safe. It should only be called by a single main thread of a multi-threaded application. This restriction is not a problem with normal use described above. Tcl_Main and therefore all applications based upon it, like tclsh , use Tcl_GetStdChannel to initialize the standard channels to their default values. See Tcl_StandardChannels for more information. Tcl_Main supports two modes of operation, depending on whether the filename and encoding of a startup script has been established. The routines Tcl_SetStartupScript and Tcl_GetStartupScript are the tools for controlling this configuration of Tcl_Main . Tcl_SetStartupScript registers the value path as the name of the file for Tcl_Main to evaluate as its startup script. The value encoding is Tcl\\'s name for the encoding used to store the text in that file. A value of NULL for encoding is a signal to use the system encoding. A value of NULL for path erases any existing registration so that Tcl_Main will not evaluate any startup script. Tcl_GetStartupScript queries the registered file name and encoding set by the most recent Tcl_SetStartupScript call in the same thread. The stored file name is returned, and the stored encoding name is written to space pointed to by encodingPtr , when that is not NULL. The file name and encoding values managed by the routines Tcl_SetStartupScript and Tcl_GetStartupScript are stored per-thread. Although the storage and retrieval functions of these routines work in any thread, only those calls in the same main thread as Tcl_Main can have any influence on it. The caller of Tcl_Main may call Tcl_SetStartupScript first to establish its desired startup script. If Tcl_Main finds that no such startup script has been established, it consults the first few arguments in argv . If they match ? -encoding name ? fileName , where fileName does not begin with the character - , then fileName is taken to be the name of a file containing a startup script , and name is taken to be the name of the encoding of the contents of that file. Tcl_Main then calls Tcl_SetStartupScript with these values. Tcl_Main then defines in its main interpreter the Tcl variables argc , argv , argv0 , and tcl_interactive , as described in the documentation for tclsh . When it has finished its own initialization, but before it processes commands, Tcl_Main calls the procedure given by the appInitProc argument. This procedure provides a for the application to perform its own initialization of the interpreter created by Tcl_Main , such as defining application-specific commands. The application initialization routine might also call Tcl_SetStartupScript to (re-)set the file and encoding to be used as a startup script. The procedure must have an interface that matches the type Tcl_AppInitProc : typedef int Tcl_AppInitProc ( Tcl_Interp * interp ); AppInitProc is almost always a pointer to Tcl_AppInit ; for more details on this procedure, see the documentation for Tcl_AppInit . When the appInitProc is finished, Tcl_Main calls Tcl_GetStartupScript to determine what startup script has been requested, if any. If a startup script has been provided, Tcl_Main attempts to evaluate it. Otherwise, interactive mode begins with examination of the variable tcl_rcFileName in the main interpreter. If that variable exists and holds the name of a readable file, the contents of that file are evaluated in the main interpreter. Then interactive operations begin, with prompts and command evaluation results written to the standard output channel, and commands read from the standard input channel and then evaluated. The prompts written to the standard output channel may be customized by defining the Tcl variables tcl_prompt1 and tcl_prompt2 as described in the documentation for tclsh . The prompts and command evaluation results are written to the standard output channel only if the Tcl variable tcl_interactive in the main interpreter holds a non-zero integer value. Tcl_SetMainLoop allows setting an event loop procedure to be run. This allows, for example, Tk to be dynamically loaded and set its event loop. The event loop will run following the startup script. If you are in interactive mode, setting the main loop procedure will cause the prompt to become fileevent based and then the loop procedure is called. When the loop procedure returns in interactive mode, interactive operation will continue. The main loop procedure must have an interface that matches the type Tcl_MainLoopProc : typedef void Tcl_MainLoopProc (void); Tcl_Main does not return. Normally a program based on Tcl_Main will terminate when the exit command is evaluated. In interactive mode, if an EOF or channel error is encountered on the standard input channel, then Tcl_Main itself will evaluate the exit command after the main loop procedure (if any) returns. In non-interactive mode, after Tcl_Main evaluates the startup script, and the main loop procedure (if any) returns, Tcl_Main will also evaluate the exit command. Tcl_Main can not be used in stub-enabled extensions. The difference between Tcl_MainEx and Tcl_MainExW is that the arguments are passed as characters or wide characters. When used in stub-enabled embedders, the stubs table must be first initialized using one of Tcl_InitSubsystems , Tcl_SetPanicProc , Tcl_FindExecutable or TclZipfs_AppHook .","title":"DESCRIPTION"},{"location":"Tcl_Main/#reference-count-management","text":"Tcl_SetStartupScript takes a value (or NULL) for its path argument, and will increment the reference count of it. Tcl_GetStartupScript returns a value with reference count at least 1, or NULL. It\\'s encodingPtr is also used (if non-NULL) to return a value with a reference count at least 1, or NULL. In both cases, the owner of the values is the current thread.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"Tcl_Main/#see-also","text":"tclsh(1), Tcl_GetStdChannel(3), Tcl_StandardChannels(3), Tcl_AppInit(3), exit(n), encoding(n)","title":"SEE ALSO"},{"location":"Tcl_Main/#keywords","text":"application-specific initialization, command-line arguments, main program","title":"KEYWORDS"},{"location":"Thread/","text":"NAME Tcl_ConditionNotify, Tcl_ConditionWait, Tcl_ConditionFinalize, Tcl_GetThreadData, Tcl_MutexLock, Tcl_MutexUnlock, Tcl_MutexFinalize, Tcl_CreateThread, Tcl_JoinThread - Tcl thread support SYNOPSIS #include <tcl.h> void Tcl_ConditionNotify(condPtr) void Tcl_ConditionWait(condPtr, mutexPtr, timePtr) void Tcl_ConditionFinalize(condPtr) Void * Tcl_GetThreadData(keyPtr, size) void Tcl_MutexLock(mutexPtr) void Tcl_MutexUnlock(mutexPtr) void Tcl_MutexFinalize(mutexPtr) int Tcl_CreateThread(idPtr, proc, clientData, stackSize, flags) int Tcl_JoinThread(id, result) ARGUMENTS A condition variable, which must be associated with a mutex lock. A recursive mutex lock. A time limit on the condition wait. NULL to wait forever. Note that a polling value of 0 seconds does not make much sense. This identifies a block of thread local storage. The key should be static and process-wide, yet each thread will end up associating a different block of storage with this key. The size of the thread local storage block. This amount of data is allocated and initialized to zero the first time each thread calls Tcl_GetThreadData . The referred storage will contain the id of the newly created thread as returned by the operating system. Id of the thread waited upon. This procedure will act as the main() of the newly created thread. The specified clientData will be its sole argument. Arbitrary information. Passed as sole argument to the proc . The size of the stack given to the new thread. Bitmask containing flags allowing the caller to modify behavior of the new thread. The referred storage is used to place the exit code of the thread waited upon into it. INTRODUCTION Beginning with the 8.1 release, the Tcl core is thread safe, which allows you to incorporate Tcl into multithreaded applications without customizing the Tcl core. Starting with the 8.6 release, Tcl multithreading support is on by default. To disable Tcl multithreading support, you must include the -\u2006-disable-threads option to configure when you configure and compile your Tcl core. An important constraint of the Tcl threads implementation is that only the thread that created a Tcl interpreter can use that interpreter. In other words, multiple threads can not access the same Tcl interpreter. (However, a single thread can safely create and use multiple interpreters.) DESCRIPTION Tcl provides Tcl_CreateThread for creating threads. The caller can determine the size of the stack given to the new thread and modify the behavior through the supplied flags . The value TCL_THREAD_STACK_DEFAULT for the stackSize indicates that the default size as specified by the operating system is to be used for the new thread. As for the flags, currently only the values TCL_THREAD_NOFLAGS and TCL_THREAD_JOINABLE are defined. The first of them invokes the default behavior with no special settings. Using the second value marks the new thread as joinable . This means that another thread can wait for the such marked thread to exit and join it. Restrictions: On some UNIX systems the pthread-library does not contain the functionality to specify the stack size of a thread. The specified value for the stack size is ignored on these systems. Windows currently does not support joinable threads. This flag value is therefore ignored on this platform. Tcl provides the Tcl_ExitThread and Tcl_FinalizeThread functions for terminating threads and invoking optional per-thread exit handlers. See the Tcl_Exit page for more information on these procedures. The Tcl_JoinThread function is provided to allow threads to wait upon the exit of another thread, which must have been marked as joinable through usage of the TCL_THREAD_JOINABLE -flag during its creation via Tcl_CreateThread . Trying to wait for the exit of a non-joinable thread or a thread which is already waited upon will result in an error. Waiting for a joinable thread which already exited is possible, the system will retain the necessary information until after the call to Tcl_JoinThread . This means that not calling Tcl_JoinThread for a joinable thread will cause a memory leak. The Tcl_GetThreadData call returns a pointer to a block of thread-private data. Its argument is a key that is shared by all threads and a size for the block of storage. The storage is automatically allocated and initialized to all zeros the first time each thread asks for it. The storage is automatically deallocated by Tcl_FinalizeThread . SYNCHRONIZATION AND COMMUNICATION Tcl provides Tcl_ThreadQueueEvent and Tcl_ThreadAlert for handling event queuing in multithreaded applications. See the Notifier manual page for more information on these procedures. A mutex is a lock that is used to serialize all threads through a piece of code by calling Tcl_MutexLock and Tcl_MutexUnlock . If one thread holds a mutex, any other thread calling Tcl_MutexLock will block until Tcl_MutexUnlock is called. A mutex can be destroyed after its use by calling Tcl_MutexFinalize . Mutexes are reentrant: they can be locked several times from the same thread. However there must be exactly one call to Tcl_MutexUnlock for each call to Tcl_MutexLock in order for a thread to release a mutex completely. The Tcl_MutexLock , Tcl_MutexUnlock and Tcl_MutexFinalize procedures are defined as empty macros if not compiling with threads enabled. For declaration of mutexes the TCL_DECLARE_MUTEX macro should be used. This macro assures correct mutex handling even when the core is compiled without threads enabled. A condition variable is used as a signaling mechanism: a thread can lock a mutex and then wait on a condition variable with Tcl_ConditionWait . This atomically releases the mutex lock and blocks the waiting thread until another thread calls Tcl_ConditionNotify . The caller of Tcl_ConditionNotify should have the associated mutex held by previously calling Tcl_MutexLock , but this is not enforced. Notifying the condition variable unblocks all threads waiting on the condition variable, but they do not proceed until the mutex is released with Tcl_MutexUnlock . The implementation of Tcl_ConditionWait automatically locks the mutex before returning. The caller of Tcl_ConditionWait should be prepared for spurious notifications by calling Tcl_ConditionWait within a while loop that tests some invariant. A condition variable can be destroyed after its use by calling Tcl_ConditionFinalize . The Tcl_ConditionNotify , Tcl_ConditionWait and Tcl_ConditionFinalize procedures are defined as empty macros if not compiling with threads enabled. INITIALIZATION All of these synchronization objects are self-initializing. They are implemented as opaque pointers that should be NULL upon first use. The mutexes and condition variables are either cleaned up by process exit handlers (if living that long) or explicitly by calls to Tcl_MutexFinalize or Tcl_ConditionFinalize . Thread local storage is reclaimed during Tcl_FinalizeThread . SCRIPT-LEVEL ACCESS TO THREADS Tcl provides no built-in commands for scripts to use to create, manage, or join threads, nor any script-level access to mutex or condition variables. It provides such facilities only via C interfaces, and leaves it up to packages to expose these matters to the script level. One such package is the Thread package. EXAMPLE To create a thread with portable code, its implementation function should be declared as follows: static Tcl_ThreadCreateProc MyThreadImplFunc; It should then be defined like this example, which just counts up to a given value and then finishes. static Tcl_ThreadCreateType MyThreadImplFunc( void *clientData) { int i, limit = (int) clientData; for (i=0 ; i\\<limit ; i++) { /* doing nothing at all here */ } TCL_THREAD_CREATE_RETURN ; } To create the above thread, make it execute, and wait for it to finish, we would do this: int limit = 1000000000; void *limitData = (void*)((intptr_t) limit); Tcl_ThreadId id; /* holds identity of thread created */ int result; if ( Tcl_CreateThread (&id, MyThreadImplFunc, limitData, TCL_THREAD_STACK_DEFAULT , TCL_THREAD_JOINABLE ) != TCL_OK) { /* Thread did not create correctly */ return; } /* Do something else for a while here */ if ( Tcl_JoinThread (id, &result) != TCL_OK) { /* Thread did not finish properly */ return; } /* All cleaned up nicely */ SEE ALSO Tcl_GetCurrentThread(3), Tcl_ThreadQueueEvent(3), Tcl_ThreadAlert(3), Tcl_ExitThread(3), Tcl_FinalizeThread(3), Tcl_CreateThreadExitHandler(3), Tcl_DeleteThreadExitHandler(3), Thread KEYWORDS thread, mutex, condition variable, thread local storage","title":"NAME"},{"location":"Thread/#name","text":"Tcl_ConditionNotify, Tcl_ConditionWait, Tcl_ConditionFinalize, Tcl_GetThreadData, Tcl_MutexLock, Tcl_MutexUnlock, Tcl_MutexFinalize, Tcl_CreateThread, Tcl_JoinThread - Tcl thread support","title":"NAME"},{"location":"Thread/#synopsis","text":"#include <tcl.h> void Tcl_ConditionNotify(condPtr) void Tcl_ConditionWait(condPtr, mutexPtr, timePtr) void Tcl_ConditionFinalize(condPtr) Void * Tcl_GetThreadData(keyPtr, size) void Tcl_MutexLock(mutexPtr) void Tcl_MutexUnlock(mutexPtr) void Tcl_MutexFinalize(mutexPtr) int Tcl_CreateThread(idPtr, proc, clientData, stackSize, flags) int Tcl_JoinThread(id, result)","title":"SYNOPSIS"},{"location":"Thread/#arguments","text":"A condition variable, which must be associated with a mutex lock. A recursive mutex lock. A time limit on the condition wait. NULL to wait forever. Note that a polling value of 0 seconds does not make much sense. This identifies a block of thread local storage. The key should be static and process-wide, yet each thread will end up associating a different block of storage with this key. The size of the thread local storage block. This amount of data is allocated and initialized to zero the first time each thread calls Tcl_GetThreadData . The referred storage will contain the id of the newly created thread as returned by the operating system. Id of the thread waited upon. This procedure will act as the main() of the newly created thread. The specified clientData will be its sole argument. Arbitrary information. Passed as sole argument to the proc . The size of the stack given to the new thread. Bitmask containing flags allowing the caller to modify behavior of the new thread. The referred storage is used to place the exit code of the thread waited upon into it.","title":"ARGUMENTS"},{"location":"Thread/#introduction","text":"Beginning with the 8.1 release, the Tcl core is thread safe, which allows you to incorporate Tcl into multithreaded applications without customizing the Tcl core. Starting with the 8.6 release, Tcl multithreading support is on by default. To disable Tcl multithreading support, you must include the -\u2006-disable-threads option to configure when you configure and compile your Tcl core. An important constraint of the Tcl threads implementation is that only the thread that created a Tcl interpreter can use that interpreter. In other words, multiple threads can not access the same Tcl interpreter. (However, a single thread can safely create and use multiple interpreters.)","title":"INTRODUCTION"},{"location":"Thread/#description","text":"Tcl provides Tcl_CreateThread for creating threads. The caller can determine the size of the stack given to the new thread and modify the behavior through the supplied flags . The value TCL_THREAD_STACK_DEFAULT for the stackSize indicates that the default size as specified by the operating system is to be used for the new thread. As for the flags, currently only the values TCL_THREAD_NOFLAGS and TCL_THREAD_JOINABLE are defined. The first of them invokes the default behavior with no special settings. Using the second value marks the new thread as joinable . This means that another thread can wait for the such marked thread to exit and join it. Restrictions: On some UNIX systems the pthread-library does not contain the functionality to specify the stack size of a thread. The specified value for the stack size is ignored on these systems. Windows currently does not support joinable threads. This flag value is therefore ignored on this platform. Tcl provides the Tcl_ExitThread and Tcl_FinalizeThread functions for terminating threads and invoking optional per-thread exit handlers. See the Tcl_Exit page for more information on these procedures. The Tcl_JoinThread function is provided to allow threads to wait upon the exit of another thread, which must have been marked as joinable through usage of the TCL_THREAD_JOINABLE -flag during its creation via Tcl_CreateThread . Trying to wait for the exit of a non-joinable thread or a thread which is already waited upon will result in an error. Waiting for a joinable thread which already exited is possible, the system will retain the necessary information until after the call to Tcl_JoinThread . This means that not calling Tcl_JoinThread for a joinable thread will cause a memory leak. The Tcl_GetThreadData call returns a pointer to a block of thread-private data. Its argument is a key that is shared by all threads and a size for the block of storage. The storage is automatically allocated and initialized to all zeros the first time each thread asks for it. The storage is automatically deallocated by Tcl_FinalizeThread .","title":"DESCRIPTION"},{"location":"Thread/#synchronization-and-communication","text":"Tcl provides Tcl_ThreadQueueEvent and Tcl_ThreadAlert for handling event queuing in multithreaded applications. See the Notifier manual page for more information on these procedures. A mutex is a lock that is used to serialize all threads through a piece of code by calling Tcl_MutexLock and Tcl_MutexUnlock . If one thread holds a mutex, any other thread calling Tcl_MutexLock will block until Tcl_MutexUnlock is called. A mutex can be destroyed after its use by calling Tcl_MutexFinalize . Mutexes are reentrant: they can be locked several times from the same thread. However there must be exactly one call to Tcl_MutexUnlock for each call to Tcl_MutexLock in order for a thread to release a mutex completely. The Tcl_MutexLock , Tcl_MutexUnlock and Tcl_MutexFinalize procedures are defined as empty macros if not compiling with threads enabled. For declaration of mutexes the TCL_DECLARE_MUTEX macro should be used. This macro assures correct mutex handling even when the core is compiled without threads enabled. A condition variable is used as a signaling mechanism: a thread can lock a mutex and then wait on a condition variable with Tcl_ConditionWait . This atomically releases the mutex lock and blocks the waiting thread until another thread calls Tcl_ConditionNotify . The caller of Tcl_ConditionNotify should have the associated mutex held by previously calling Tcl_MutexLock , but this is not enforced. Notifying the condition variable unblocks all threads waiting on the condition variable, but they do not proceed until the mutex is released with Tcl_MutexUnlock . The implementation of Tcl_ConditionWait automatically locks the mutex before returning. The caller of Tcl_ConditionWait should be prepared for spurious notifications by calling Tcl_ConditionWait within a while loop that tests some invariant. A condition variable can be destroyed after its use by calling Tcl_ConditionFinalize . The Tcl_ConditionNotify , Tcl_ConditionWait and Tcl_ConditionFinalize procedures are defined as empty macros if not compiling with threads enabled.","title":"SYNCHRONIZATION AND COMMUNICATION"},{"location":"Thread/#initialization","text":"All of these synchronization objects are self-initializing. They are implemented as opaque pointers that should be NULL upon first use. The mutexes and condition variables are either cleaned up by process exit handlers (if living that long) or explicitly by calls to Tcl_MutexFinalize or Tcl_ConditionFinalize . Thread local storage is reclaimed during Tcl_FinalizeThread .","title":"INITIALIZATION"},{"location":"Thread/#script-level-access-to-threads","text":"Tcl provides no built-in commands for scripts to use to create, manage, or join threads, nor any script-level access to mutex or condition variables. It provides such facilities only via C interfaces, and leaves it up to packages to expose these matters to the script level. One such package is the Thread package.","title":"SCRIPT-LEVEL ACCESS TO THREADS"},{"location":"Thread/#example","text":"To create a thread with portable code, its implementation function should be declared as follows: static Tcl_ThreadCreateProc MyThreadImplFunc; It should then be defined like this example, which just counts up to a given value and then finishes. static Tcl_ThreadCreateType MyThreadImplFunc( void *clientData) { int i, limit = (int) clientData; for (i=0 ; i\\<limit ; i++) { /* doing nothing at all here */ } TCL_THREAD_CREATE_RETURN ; } To create the above thread, make it execute, and wait for it to finish, we would do this: int limit = 1000000000; void *limitData = (void*)((intptr_t) limit); Tcl_ThreadId id; /* holds identity of thread created */ int result; if ( Tcl_CreateThread (&id, MyThreadImplFunc, limitData, TCL_THREAD_STACK_DEFAULT , TCL_THREAD_JOINABLE ) != TCL_OK) { /* Thread did not create correctly */ return; } /* Do something else for a while here */ if ( Tcl_JoinThread (id, &result) != TCL_OK) { /* Thread did not finish properly */ return; } /* All cleaned up nicely */","title":"EXAMPLE"},{"location":"Thread/#see-also","text":"Tcl_GetCurrentThread(3), Tcl_ThreadQueueEvent(3), Tcl_ThreadAlert(3), Tcl_ExitThread(3), Tcl_FinalizeThread(3), Tcl_CreateThreadExitHandler(3), Tcl_DeleteThreadExitHandler(3), Thread","title":"SEE ALSO"},{"location":"Thread/#keywords","text":"thread, mutex, condition variable, thread local storage","title":"KEYWORDS"},{"location":"ToUpper/","text":"NAME Tcl_UniCharToUpper, Tcl_UniCharToLower, Tcl_UniCharToTitle, Tcl_UtfToUpper, Tcl_UtfToLower, Tcl_UtfToTitle - routines for manipulating the case of Unicode characters and UTF-8 strings SYNOPSIS #include <tcl.h> int Tcl_UniCharToUpper(ch) int Tcl_UniCharToLower(ch) int Tcl_UniCharToTitle(ch) Tcl_Size Tcl_UtfToUpper(str) Tcl_Size Tcl_UtfToLower(str) Tcl_Size Tcl_UtfToTitle(str) ARGUMENTS The Unicode character to be converted. Pointer to UTF-8 string to be converted in place. DESCRIPTION The first three routines convert the case of individual Unicode characters: If ch represents a lower-case character, Tcl_UniCharToUpper returns the corresponding upper-case character. If no upper-case character is defined, it returns the character unchanged. If ch represents an upper-case character, Tcl_UniCharToLower returns the corresponding lower-case character. If no lower-case character is defined, it returns the character unchanged. If ch represents a lower-case character, Tcl_UniCharToTitle returns the corresponding title-case character. If no title-case character is defined, it returns the corresponding upper-case character. If no upper-case character is defined, it returns the character unchanged. Title-case is defined for a small number of characters that have a different appearance when they are at the beginning of a capitalized word. The next three routines convert the case of UTF-8 strings in place in memory: Tcl_UtfToUpper changes every UTF-8 character in str to upper-case. Because changing the case of a character may change its size, the byte offset of each character in the resulting string may differ from its original location. Tcl_UtfToUpper writes a null byte at the end of the converted string. Tcl_UtfToUpper returns the new length of the string in bytes. This new length is guaranteed to be no longer than the original string length. Tcl_UtfToLower is the same as Tcl_UtfToUpper except it turns each character in the string into its lower-case equivalent. Tcl_UtfToTitle is the same as Tcl_UtfToUpper except it turns the first character in the string into its title-case equivalent and all following characters into their lower-case equivalents. KEYWORDS utf, unicode, toupper, tolower, totitle, case","title":"NAME"},{"location":"ToUpper/#name","text":"Tcl_UniCharToUpper, Tcl_UniCharToLower, Tcl_UniCharToTitle, Tcl_UtfToUpper, Tcl_UtfToLower, Tcl_UtfToTitle - routines for manipulating the case of Unicode characters and UTF-8 strings","title":"NAME"},{"location":"ToUpper/#synopsis","text":"#include <tcl.h> int Tcl_UniCharToUpper(ch) int Tcl_UniCharToLower(ch) int Tcl_UniCharToTitle(ch) Tcl_Size Tcl_UtfToUpper(str) Tcl_Size Tcl_UtfToLower(str) Tcl_Size Tcl_UtfToTitle(str)","title":"SYNOPSIS"},{"location":"ToUpper/#arguments","text":"The Unicode character to be converted. Pointer to UTF-8 string to be converted in place.","title":"ARGUMENTS"},{"location":"ToUpper/#description","text":"The first three routines convert the case of individual Unicode characters: If ch represents a lower-case character, Tcl_UniCharToUpper returns the corresponding upper-case character. If no upper-case character is defined, it returns the character unchanged. If ch represents an upper-case character, Tcl_UniCharToLower returns the corresponding lower-case character. If no lower-case character is defined, it returns the character unchanged. If ch represents a lower-case character, Tcl_UniCharToTitle returns the corresponding title-case character. If no title-case character is defined, it returns the corresponding upper-case character. If no upper-case character is defined, it returns the character unchanged. Title-case is defined for a small number of characters that have a different appearance when they are at the beginning of a capitalized word. The next three routines convert the case of UTF-8 strings in place in memory: Tcl_UtfToUpper changes every UTF-8 character in str to upper-case. Because changing the case of a character may change its size, the byte offset of each character in the resulting string may differ from its original location. Tcl_UtfToUpper writes a null byte at the end of the converted string. Tcl_UtfToUpper returns the new length of the string in bytes. This new length is guaranteed to be no longer than the original string length. Tcl_UtfToLower is the same as Tcl_UtfToUpper except it turns each character in the string into its lower-case equivalent. Tcl_UtfToTitle is the same as Tcl_UtfToUpper except it turns the first character in the string into its title-case equivalent and all following characters into their lower-case equivalents.","title":"DESCRIPTION"},{"location":"ToUpper/#keywords","text":"utf, unicode, toupper, tolower, totitle, case","title":"KEYWORDS"},{"location":"TraceCmd/","text":"NAME Tcl_CommandTraceInfo, Tcl_TraceCommand, Tcl_UntraceCommand - monitor renames and deletes of a command SYNOPSIS #include <tcl.h> void * Tcl_CommandTraceInfo(interp, cmdName, flags, proc, prevClientData) int Tcl_TraceCommand(interp, cmdName, flags, proc, clientData) void Tcl_UntraceCommand(interp, cmdName, flags, proc, clientData) ARGUMENTS Interpreter containing the command. Name of command. OR\\'ed collection of the values TCL_TRACE_RENAME and TCL_TRACE_DELETE . Procedure to call when specified operations occur to cmdName . Arbitrary argument to pass to proc . If non-NULL, gives last value returned by Tcl_CommandTraceInfo , so this call will return information about next trace. If NULL, this call will return information about first trace. DESCRIPTION Tcl_TraceCommand allows a C procedure to monitor operations performed on a Tcl command, so that the C procedure is invoked whenever the command is renamed or deleted. If the trace is created successfully then Tcl_TraceCommand returns TCL_OK . If an error occurred (e.g. cmdName specifies a non-existent command) then TCL_ERROR is returned and an error message is left in the interpreter\\'s result. The flags argument to Tcl_TraceCommand indicates when the trace procedure is to be invoked. It consists of an OR\\'ed combination of any of the following values: TCL_TRACE_RENAME : Invoke proc whenever the command is renamed. TCL_TRACE_DELETE : Invoke proc when the command is deleted. Whenever one of the specified operations occurs to the command, proc will be invoked. It should have arguments and result that match the type Tcl_CommandTraceProc : typedef void Tcl_CommandTraceProc ( void * clientData , Tcl_Interp * interp , const char * oldName , const char * newName , int flags ); The clientData and interp parameters will have the same values as those passed to Tcl_TraceCommand when the trace was created. clientData typically points to an application-specific data structure that describes what to do when proc is invoked. OldName gives the name of the command being renamed, and newName gives the name that the command is being renamed to (or NULL when the command is being deleted.) Flags is an OR\\'ed combination of bits potentially providing several pieces of information. One of the bits TCL_TRACE_RENAME and TCL_TRACE_DELETE will be set in flags to indicate which operation is being performed on the command. The bit TCL_TRACE_DESTROYED will be set in flags if the trace is about to be destroyed; this information may be useful to proc so that it can clean up its own internal data structures (see the section TCL_TRACE_DESTROYED below for more details). Because the deletion of commands can take place as part of the deletion of the interp that contains them, proc must be careful about checking what the passed in interp value can be called upon to do. The routine Tcl_InterpDeleted is an important tool for this. When Tcl_InterpDeleted returns 1, proc will not be able to invoke any scripts in interp . The function of proc in that circumstance is limited to the cleanup of its own data structures. Tcl_UntraceCommand may be used to remove a trace. If the command specified by interp , cmdName , and flags has a trace set with flags , proc , and clientData , then the corresponding trace is removed. If no such trace exists, then the call to Tcl_UntraceCommand has no effect. The same bits are valid for flags as for calls to Tcl_TraceCommand . Tcl_CommandTraceInfo may be used to retrieve information about traces set on a given command. The return value from Tcl_CommandTraceInfo is the clientData associated with a particular trace. The trace must be on the command specified by the interp , cmdName , and flags arguments (note that currently the flags are ignored; flags should be set to 0 for future compatibility) and its trace procedure must the same as the proc argument. If the prevClientData argument is NULL then the return value corresponds to the first (most recently created) matching trace, or NULL if there are no matching traces. If the prevClientData argument is not NULL, then it should be the return value from a previous call to Tcl_CommandTraceInfo . In this case, the new return value will correspond to the next matching trace after the one whose clientData matches prevClientData , or NULL if no trace matches prevClientData or if there are no more matching traces after it. This mechanism makes it possible to step through all of the traces for a given command that have the same proc . CALLING COMMANDS DURING TRACES During rename traces, the command being renamed is visible with both names simultaneously, and the command still exists during delete traces, unless the interp that contains it is being deleted. However, there is no mechanism for signaling that an error occurred in a trace procedure, so great care should be taken that errors do not get silently lost. MULTIPLE TRACES It is possible for multiple traces to exist on the same command. When this happens, all of the trace procedures will be invoked on each access, in order from most-recently-created to least-recently-created. Attempts to delete the command during a delete trace will fail silently, since the command is already scheduled for deletion anyway. If the command being renamed is renamed by one of its rename traces, that renaming takes precedence over the one that triggered the trace and the collection of traces will not be reexecuted; if several traces rename the command, the last renaming takes precedence. TCL_TRACE_DESTROYED FLAG In a delete callback to proc , the TCL_TRACE_DESTROYED bit is set in flags . KEYWORDS clientData, trace, command","title":"NAME"},{"location":"TraceCmd/#name","text":"Tcl_CommandTraceInfo, Tcl_TraceCommand, Tcl_UntraceCommand - monitor renames and deletes of a command","title":"NAME"},{"location":"TraceCmd/#synopsis","text":"#include <tcl.h> void * Tcl_CommandTraceInfo(interp, cmdName, flags, proc, prevClientData) int Tcl_TraceCommand(interp, cmdName, flags, proc, clientData) void Tcl_UntraceCommand(interp, cmdName, flags, proc, clientData)","title":"SYNOPSIS"},{"location":"TraceCmd/#arguments","text":"Interpreter containing the command. Name of command. OR\\'ed collection of the values TCL_TRACE_RENAME and TCL_TRACE_DELETE . Procedure to call when specified operations occur to cmdName . Arbitrary argument to pass to proc . If non-NULL, gives last value returned by Tcl_CommandTraceInfo , so this call will return information about next trace. If NULL, this call will return information about first trace.","title":"ARGUMENTS"},{"location":"TraceCmd/#description","text":"Tcl_TraceCommand allows a C procedure to monitor operations performed on a Tcl command, so that the C procedure is invoked whenever the command is renamed or deleted. If the trace is created successfully then Tcl_TraceCommand returns TCL_OK . If an error occurred (e.g. cmdName specifies a non-existent command) then TCL_ERROR is returned and an error message is left in the interpreter\\'s result. The flags argument to Tcl_TraceCommand indicates when the trace procedure is to be invoked. It consists of an OR\\'ed combination of any of the following values: TCL_TRACE_RENAME : Invoke proc whenever the command is renamed. TCL_TRACE_DELETE : Invoke proc when the command is deleted. Whenever one of the specified operations occurs to the command, proc will be invoked. It should have arguments and result that match the type Tcl_CommandTraceProc : typedef void Tcl_CommandTraceProc ( void * clientData , Tcl_Interp * interp , const char * oldName , const char * newName , int flags ); The clientData and interp parameters will have the same values as those passed to Tcl_TraceCommand when the trace was created. clientData typically points to an application-specific data structure that describes what to do when proc is invoked. OldName gives the name of the command being renamed, and newName gives the name that the command is being renamed to (or NULL when the command is being deleted.) Flags is an OR\\'ed combination of bits potentially providing several pieces of information. One of the bits TCL_TRACE_RENAME and TCL_TRACE_DELETE will be set in flags to indicate which operation is being performed on the command. The bit TCL_TRACE_DESTROYED will be set in flags if the trace is about to be destroyed; this information may be useful to proc so that it can clean up its own internal data structures (see the section TCL_TRACE_DESTROYED below for more details). Because the deletion of commands can take place as part of the deletion of the interp that contains them, proc must be careful about checking what the passed in interp value can be called upon to do. The routine Tcl_InterpDeleted is an important tool for this. When Tcl_InterpDeleted returns 1, proc will not be able to invoke any scripts in interp . The function of proc in that circumstance is limited to the cleanup of its own data structures. Tcl_UntraceCommand may be used to remove a trace. If the command specified by interp , cmdName , and flags has a trace set with flags , proc , and clientData , then the corresponding trace is removed. If no such trace exists, then the call to Tcl_UntraceCommand has no effect. The same bits are valid for flags as for calls to Tcl_TraceCommand . Tcl_CommandTraceInfo may be used to retrieve information about traces set on a given command. The return value from Tcl_CommandTraceInfo is the clientData associated with a particular trace. The trace must be on the command specified by the interp , cmdName , and flags arguments (note that currently the flags are ignored; flags should be set to 0 for future compatibility) and its trace procedure must the same as the proc argument. If the prevClientData argument is NULL then the return value corresponds to the first (most recently created) matching trace, or NULL if there are no matching traces. If the prevClientData argument is not NULL, then it should be the return value from a previous call to Tcl_CommandTraceInfo . In this case, the new return value will correspond to the next matching trace after the one whose clientData matches prevClientData , or NULL if no trace matches prevClientData or if there are no more matching traces after it. This mechanism makes it possible to step through all of the traces for a given command that have the same proc .","title":"DESCRIPTION"},{"location":"TraceCmd/#calling-commands-during-traces","text":"During rename traces, the command being renamed is visible with both names simultaneously, and the command still exists during delete traces, unless the interp that contains it is being deleted. However, there is no mechanism for signaling that an error occurred in a trace procedure, so great care should be taken that errors do not get silently lost.","title":"CALLING COMMANDS DURING TRACES"},{"location":"TraceCmd/#multiple-traces","text":"It is possible for multiple traces to exist on the same command. When this happens, all of the trace procedures will be invoked on each access, in order from most-recently-created to least-recently-created. Attempts to delete the command during a delete trace will fail silently, since the command is already scheduled for deletion anyway. If the command being renamed is renamed by one of its rename traces, that renaming takes precedence over the one that triggered the trace and the collection of traces will not be reexecuted; if several traces rename the command, the last renaming takes precedence.","title":"MULTIPLE TRACES"},{"location":"TraceCmd/#tcl_trace_destroyed-flag","text":"In a delete callback to proc , the TCL_TRACE_DESTROYED bit is set in flags .","title":"TCL_TRACE_DESTROYED FLAG"},{"location":"TraceCmd/#keywords","text":"clientData, trace, command","title":"KEYWORDS"},{"location":"TraceVar/","text":"NAME Tcl_TraceVar, Tcl_TraceVar2, Tcl_UntraceVar, Tcl_UntraceVar2, Tcl_VarTraceInfo, Tcl_VarTraceInfo2 - monitor accesses to a variable SYNOPSIS #include <tcl.h> int Tcl_TraceVar(interp, varName, flags, proc, clientData) int Tcl_TraceVar2(interp, name1, name2, flags, proc, clientData) Tcl_UntraceVar(interp, varName, flags, proc, clientData) Tcl_UntraceVar2(interp, name1, name2, flags, proc, clientData) void * Tcl_VarTraceInfo(interp, varName, flags, proc, prevClientData) void * Tcl_VarTraceInfo2(interp, name1, name2, flags, proc, prevClientData) ARGUMENTS Interpreter containing variable. Name of variable. May refer to a scalar variable, to an array variable with no index, or to an array variable with a parenthesized index. OR-ed combination of the values TCL_TRACE_READS , TCL_TRACE_WRITES , TCL_TRACE_UNSETS , TCL_TRACE_ARRAY , TCL_GLOBAL_ONLY , TCL_NAMESPACE_ONLY , TCL_TRACE_RESULT_DYNAMIC and TCL_TRACE_RESULT_OBJECT . Not all flags are used by all procedures. See below for more information. Procedure to invoke whenever one of the traced operations occurs. Arbitrary one-word value to pass to proc . Name of scalar or array variable (without array index). For a trace on an element of an array, gives the index of the element. For traces on scalar variables or on whole arrays, is NULL. If non-NULL, gives last value returned by Tcl_VarTraceInfo or Tcl_VarTraceInfo2 , so this call will return information about next trace. If NULL, this call will return information about first trace. DESCRIPTION Tcl_TraceVar allows a C procedure to monitor and control access to a Tcl variable, so that the C procedure is invoked whenever the variable is read or written or unset. If the trace is created successfully then Tcl_TraceVar returns TCL_OK . If an error occurred (e.g. varName specifies an element of an array, but the actual variable is not an array) then TCL_ERROR is returned and an error message is left in the interpreter\\'s result. The flags argument to Tcl_TraceVar indicates when the trace procedure is to be invoked and provides information for setting up the trace. It consists of an OR-ed combination of any of the following values: TCL_GLOBAL_ONLY : Normally, the variable will be looked up at the current level of procedure call; if this bit is set then the variable will be looked up at global level, ignoring any active procedures. TCL_NAMESPACE_ONLY : Normally, the variable will be looked up at the current level of procedure call; if this bit is set then the variable will be looked up in the current namespace, ignoring any active procedures. TCL_TRACE_READS : Invoke proc whenever an attempt is made to read the variable. TCL_TRACE_WRITES : Invoke proc whenever an attempt is made to modify the variable. TCL_TRACE_UNSETS : Invoke proc whenever the variable is unset. A variable may be unset either explicitly by an unset command, or implicitly when a procedure returns (its local variables are automatically unset) or when the interpreter or namespace is deleted (all variables are automatically unset). TCL_TRACE_ARRAY : Invoke proc whenever the array command is invoked. This gives the trace procedure a chance to update the array before array names or array get is called. Note that this is called before an array set, but that will trigger write traces. TCL_TRACE_RESULT_DYNAMIC : The result of invoking the proc is a dynamically allocated string that will be released by the Tcl library via a call to Tcl_Free . Must not be specified at the same time as TCL_TRACE_RESULT_OBJECT . TCL_TRACE_RESULT_OBJECT : The result of invoking the proc is a Tcl_Obj* (cast to a char*) with a reference count of at least one. The ownership of that reference will be transferred to the Tcl core for release (when the core has finished with it) via a call to Tcl_DecrRefCount . Must not be specified at the same time as TCL_TRACE_RESULT_DYNAMIC . Whenever one of the specified operations occurs on the variable, proc will be invoked. It should have arguments and result that match the type Tcl_VarTraceProc : typedef char * Tcl_VarTraceProc ( void * clientData , Tcl_Interp * interp , const char * name1 , const char * name2 , int flags ); The clientData and interp parameters will have the same values as those passed to Tcl_TraceVar when the trace was created. clientData typically points to an application-specific data structure that describes what to do when proc is invoked. Name1 and name2 give the name of the variable that triggered the callback in the normal two-part form (see the description of Tcl_TraceVar2 below for details). In case name1 is an alias to an array element (created through facilities such as upvar ), name2 holds the index of the array element, rather than NULL. Flags is an OR-ed combination of bits providing several pieces of information. One of the bits TCL_TRACE_READS , TCL_TRACE_WRITES , TCL_TRACE_ARRAY , or TCL_TRACE_UNSETS will be set in flags to indicate which operation is being performed on the variable. The bit TCL_GLOBAL_ONLY will be set whenever the variable being accessed is a global one not accessible from the current level of procedure call: the trace procedure will need to pass this flag back to variable-related procedures like Tcl_GetVar if it attempts to access the variable. The bit TCL_NAMESPACE_ONLY will be set whenever the variable being accessed is a namespace one not accessible from the current level of procedure call: the trace procedure will need to pass this flag back to variable-related procedures like Tcl_GetVar if it attempts to access the variable. The bit TCL_TRACE_DESTROYED will be set in flags if the trace is about to be destroyed; this information may be useful to proc so that it can clean up its own internal data structures (see the section TCL_TRACE_DESTROYED below for more details). The trace procedure\\'s return value should normally be NULL; see ERROR RETURNS below for information on other possibilities. Tcl_UntraceVar may be used to remove a trace. If the variable specified by interp , varName , and flags has a trace set with flags , proc , and clientData , then the corresponding trace is removed. If no such trace exists, then the call to Tcl_UntraceVar has no effect. The same bits are valid for flags as for calls to Tcl_TraceVar . Tcl_VarTraceInfo may be used to retrieve information about traces set on a given variable. The return value from Tcl_VarTraceInfo is the clientData associated with a particular trace. The trace must be on the variable specified by the interp , varName , and flags arguments (only the TCL_GLOBAL_ONLY and TCL_NAMESPACE_ONLY bits from flags is used; other bits are ignored) and its trace procedure must the same as the proc argument. If the prevClientData argument is NULL then the return value corresponds to the first (most recently created) matching trace, or NULL if there are no matching traces. If the prevClientData argument is not NULL, then it should be the return value from a previous call to Tcl_VarTraceInfo . In this case, the new return value will correspond to the next matching trace after the one whose clientData matches prevClientData , or NULL if no trace matches prevClientData or if there are no more matching traces after it. This mechanism makes it possible to step through all of the traces for a given variable that have the same proc . TWO-PART NAMES The procedures Tcl_TraceVar2 , Tcl_UntraceVar2 , and Tcl_VarTraceInfo2 are identical to Tcl_TraceVar , Tcl_UntraceVar , and Tcl_VarTraceInfo , respectively, except that the name of the variable consists of two parts. Name1 gives the name of a scalar variable or array, and name2 gives the name of an element within an array. When name2 is NULL, name1 may contain both an array and an element name: if the name contains an open parenthesis and ends with a close parenthesis, then the value between the parentheses is treated as an element name (which can have any string value) and the characters before the first open parenthesis are treated as the name of an array variable. If name2 is NULL and name1 does not refer to an array element it means that either the variable is a scalar or the trace is to be set on the entire array rather than an individual element (see WHOLE-ARRAY TRACES below for more information). ACCESSING VARIABLES DURING TRACES During read, write, and array traces, the trace procedure can read, write, or unset the traced variable using Tcl_GetVar2 , Tcl_SetVar2 , and other procedures. While proc is executing, traces are temporarily disabled for the variable, so that calls to Tcl_GetVar2 and Tcl_SetVar2 will not cause proc or other trace procedures to be invoked again. Disabling only occurs for the variable whose trace procedure is active; accesses to other variables will still be traced. However, if a variable is unset during a read or write trace then unset traces will be invoked. During unset traces the variable has already been completely expunged. It is possible for the trace procedure to read or write the variable, but this will be a new version of the variable. Traces are not disabled during unset traces as they are for read and write traces, but existing traces have been removed from the variable before any trace procedures are invoked. If new traces are set by unset trace procedures, these traces will be invoked on accesses to the variable by the trace procedures. CALLBACK TIMING When read tracing has been specified for a variable, the trace procedure will be invoked whenever the variable\\'s value is read. This includes set Tcl commands, \\$ -notation in Tcl commands, and invocations of the Tcl_GetVar and Tcl_GetVar2 procedures. Proc is invoked just before the variable\\'s value is returned. It may modify the value of the variable to affect what is returned by the traced access. If it unsets the variable then the access will return an error just as if the variable never existed. When write tracing has been specified for a variable, the trace procedure will be invoked whenever the variable\\'s value is modified. This includes set commands, commands that modify variables as side effects (such as catch and scan ), and calls to the Tcl_SetVar and Tcl_SetVar2 procedures). Proc will be invoked after the variable\\'s value has been modified, but before the new value of the variable has been returned. It may modify the value of the variable to override the change and to determine the value actually returned by the traced access. If it deletes the variable then the traced access will return an empty string. When array tracing has been specified, the trace procedure will be invoked at the beginning of the array command implementation, before any of the operations like get, set, or names have been invoked. The trace procedure can modify the array elements with Tcl_SetVar and Tcl_SetVar2 . When unset tracing has been specified, the trace procedure will be invoked whenever the variable is destroyed. The traces will be called after the variable has been completely unset. WHOLE-ARRAY TRACES If a call to Tcl_TraceVar or Tcl_TraceVar2 specifies the name of an array variable without an index into the array, then the trace will be set on the array as a whole. This means that proc will be invoked whenever any element of the array is accessed in the ways specified by flags . When an array is unset, a whole-array trace will be invoked just once, with name1 equal to the name of the array and name2 NULL; it will not be invoked once for each element. MULTIPLE TRACES It is possible for multiple traces to exist on the same variable. When this happens, all of the trace procedures will be invoked on each access, in order from most-recently-created to least-recently-created. When there exist whole-array traces for an array as well as traces on individual elements, the whole-array traces are invoked before the individual-element traces. If a read or write trace unsets the variable then all of the unset traces will be invoked but the remainder of the read and write traces will be skipped. ERROR RETURNS Under normal conditions trace procedures should return NULL, indicating successful completion. If proc returns a non-NULL value it signifies that an error occurred. The return value must be a pointer to a static character string containing an error message, unless ( exactly one of) the TCL_TRACE_RESULT_DYNAMIC and TCL_TRACE_RESULT_OBJECT flags is set, which specify that the result is either a dynamic string (to be released with Tcl_Free ) or a Tcl_Obj* (cast to char* and to be released with Tcl_DecrRefCount ) containing the error message. If a trace procedure returns an error, no further traces are invoked for the access and the traced access aborts with the given message. Trace procedures can use this facility to make variables read-only, for example (but note that the value of the variable will already have been modified before the trace procedure is called, so the trace procedure will have to restore the correct value). The return value from proc is only used during read and write tracing. During unset traces, the return value is ignored and all relevant trace procedures will always be invoked. RESTRICTIONS Because operations on variables may take place as part of the deletion of the interp that contains them, proc must be careful about checking what the interp parameter can be used to do. The routine Tcl_InterpDeleted is an important tool for this. When Tcl_InterpDeleted returns 1, proc will not be able to invoke any scripts in interp . You may encounter old code using a deprecated flag value TCL_INTERP_DESTROYED to signal this condition, but Tcl 9 no longer supports this. Any supported code must be converted to stop using it. A trace procedure can be called at any time, even when there are partially formed results stored in the interpreter. If the trace procedure does anything that could damage this result (such as calling Tcl_Eval ) then it must use the Tcl_SaveInterpState and related routines to save and restore the original state of the interpreter before it returns. UNDEFINED VARIABLES It is legal to set a trace on an undefined variable. The variable will still appear to be undefined until the first time its value is set. If an undefined variable is traced and then unset, the unset will fail with an error but the trace procedure will still be invoked. TCL_TRACE_DESTROYED FLAG In an unset callback to proc , the TCL_TRACE_DESTROYED bit is set in flags if the trace is being removed as part of the deletion. Traces on a variable are always removed whenever the variable is deleted; the only time TCL_TRACE_DESTROYED is not set is for a whole-array trace invoked when only a single element of an array is unset. REFERENCE COUNT MANAGEMENT When a proc callback is invoked, and that callback was installed with the TCL_TRACE_RESULT_OBJECT flag, the result of the callback is a Tcl_Obj reference when there is an error. The result will have its reference count decremented once when no longer needed, or may have additional references made to it (e.g., by setting it as the interpreter result with Tcl_SetObjResult ). BUGS Array traces are not yet integrated with the Tcl info exists command, nor is there Tcl-level access to array traces. SEE ALSO trace(n) KEYWORDS clientData, trace, variable","title":"NAME"},{"location":"TraceVar/#name","text":"Tcl_TraceVar, Tcl_TraceVar2, Tcl_UntraceVar, Tcl_UntraceVar2, Tcl_VarTraceInfo, Tcl_VarTraceInfo2 - monitor accesses to a variable","title":"NAME"},{"location":"TraceVar/#synopsis","text":"#include <tcl.h> int Tcl_TraceVar(interp, varName, flags, proc, clientData) int Tcl_TraceVar2(interp, name1, name2, flags, proc, clientData) Tcl_UntraceVar(interp, varName, flags, proc, clientData) Tcl_UntraceVar2(interp, name1, name2, flags, proc, clientData) void * Tcl_VarTraceInfo(interp, varName, flags, proc, prevClientData) void * Tcl_VarTraceInfo2(interp, name1, name2, flags, proc, prevClientData)","title":"SYNOPSIS"},{"location":"TraceVar/#arguments","text":"Interpreter containing variable. Name of variable. May refer to a scalar variable, to an array variable with no index, or to an array variable with a parenthesized index. OR-ed combination of the values TCL_TRACE_READS , TCL_TRACE_WRITES , TCL_TRACE_UNSETS , TCL_TRACE_ARRAY , TCL_GLOBAL_ONLY , TCL_NAMESPACE_ONLY , TCL_TRACE_RESULT_DYNAMIC and TCL_TRACE_RESULT_OBJECT . Not all flags are used by all procedures. See below for more information. Procedure to invoke whenever one of the traced operations occurs. Arbitrary one-word value to pass to proc . Name of scalar or array variable (without array index). For a trace on an element of an array, gives the index of the element. For traces on scalar variables or on whole arrays, is NULL. If non-NULL, gives last value returned by Tcl_VarTraceInfo or Tcl_VarTraceInfo2 , so this call will return information about next trace. If NULL, this call will return information about first trace.","title":"ARGUMENTS"},{"location":"TraceVar/#description","text":"Tcl_TraceVar allows a C procedure to monitor and control access to a Tcl variable, so that the C procedure is invoked whenever the variable is read or written or unset. If the trace is created successfully then Tcl_TraceVar returns TCL_OK . If an error occurred (e.g. varName specifies an element of an array, but the actual variable is not an array) then TCL_ERROR is returned and an error message is left in the interpreter\\'s result. The flags argument to Tcl_TraceVar indicates when the trace procedure is to be invoked and provides information for setting up the trace. It consists of an OR-ed combination of any of the following values: TCL_GLOBAL_ONLY : Normally, the variable will be looked up at the current level of procedure call; if this bit is set then the variable will be looked up at global level, ignoring any active procedures. TCL_NAMESPACE_ONLY : Normally, the variable will be looked up at the current level of procedure call; if this bit is set then the variable will be looked up in the current namespace, ignoring any active procedures. TCL_TRACE_READS : Invoke proc whenever an attempt is made to read the variable. TCL_TRACE_WRITES : Invoke proc whenever an attempt is made to modify the variable. TCL_TRACE_UNSETS : Invoke proc whenever the variable is unset. A variable may be unset either explicitly by an unset command, or implicitly when a procedure returns (its local variables are automatically unset) or when the interpreter or namespace is deleted (all variables are automatically unset). TCL_TRACE_ARRAY : Invoke proc whenever the array command is invoked. This gives the trace procedure a chance to update the array before array names or array get is called. Note that this is called before an array set, but that will trigger write traces. TCL_TRACE_RESULT_DYNAMIC : The result of invoking the proc is a dynamically allocated string that will be released by the Tcl library via a call to Tcl_Free . Must not be specified at the same time as TCL_TRACE_RESULT_OBJECT . TCL_TRACE_RESULT_OBJECT : The result of invoking the proc is a Tcl_Obj* (cast to a char*) with a reference count of at least one. The ownership of that reference will be transferred to the Tcl core for release (when the core has finished with it) via a call to Tcl_DecrRefCount . Must not be specified at the same time as TCL_TRACE_RESULT_DYNAMIC . Whenever one of the specified operations occurs on the variable, proc will be invoked. It should have arguments and result that match the type Tcl_VarTraceProc : typedef char * Tcl_VarTraceProc ( void * clientData , Tcl_Interp * interp , const char * name1 , const char * name2 , int flags ); The clientData and interp parameters will have the same values as those passed to Tcl_TraceVar when the trace was created. clientData typically points to an application-specific data structure that describes what to do when proc is invoked. Name1 and name2 give the name of the variable that triggered the callback in the normal two-part form (see the description of Tcl_TraceVar2 below for details). In case name1 is an alias to an array element (created through facilities such as upvar ), name2 holds the index of the array element, rather than NULL. Flags is an OR-ed combination of bits providing several pieces of information. One of the bits TCL_TRACE_READS , TCL_TRACE_WRITES , TCL_TRACE_ARRAY , or TCL_TRACE_UNSETS will be set in flags to indicate which operation is being performed on the variable. The bit TCL_GLOBAL_ONLY will be set whenever the variable being accessed is a global one not accessible from the current level of procedure call: the trace procedure will need to pass this flag back to variable-related procedures like Tcl_GetVar if it attempts to access the variable. The bit TCL_NAMESPACE_ONLY will be set whenever the variable being accessed is a namespace one not accessible from the current level of procedure call: the trace procedure will need to pass this flag back to variable-related procedures like Tcl_GetVar if it attempts to access the variable. The bit TCL_TRACE_DESTROYED will be set in flags if the trace is about to be destroyed; this information may be useful to proc so that it can clean up its own internal data structures (see the section TCL_TRACE_DESTROYED below for more details). The trace procedure\\'s return value should normally be NULL; see ERROR RETURNS below for information on other possibilities. Tcl_UntraceVar may be used to remove a trace. If the variable specified by interp , varName , and flags has a trace set with flags , proc , and clientData , then the corresponding trace is removed. If no such trace exists, then the call to Tcl_UntraceVar has no effect. The same bits are valid for flags as for calls to Tcl_TraceVar . Tcl_VarTraceInfo may be used to retrieve information about traces set on a given variable. The return value from Tcl_VarTraceInfo is the clientData associated with a particular trace. The trace must be on the variable specified by the interp , varName , and flags arguments (only the TCL_GLOBAL_ONLY and TCL_NAMESPACE_ONLY bits from flags is used; other bits are ignored) and its trace procedure must the same as the proc argument. If the prevClientData argument is NULL then the return value corresponds to the first (most recently created) matching trace, or NULL if there are no matching traces. If the prevClientData argument is not NULL, then it should be the return value from a previous call to Tcl_VarTraceInfo . In this case, the new return value will correspond to the next matching trace after the one whose clientData matches prevClientData , or NULL if no trace matches prevClientData or if there are no more matching traces after it. This mechanism makes it possible to step through all of the traces for a given variable that have the same proc .","title":"DESCRIPTION"},{"location":"TraceVar/#two-part-names","text":"The procedures Tcl_TraceVar2 , Tcl_UntraceVar2 , and Tcl_VarTraceInfo2 are identical to Tcl_TraceVar , Tcl_UntraceVar , and Tcl_VarTraceInfo , respectively, except that the name of the variable consists of two parts. Name1 gives the name of a scalar variable or array, and name2 gives the name of an element within an array. When name2 is NULL, name1 may contain both an array and an element name: if the name contains an open parenthesis and ends with a close parenthesis, then the value between the parentheses is treated as an element name (which can have any string value) and the characters before the first open parenthesis are treated as the name of an array variable. If name2 is NULL and name1 does not refer to an array element it means that either the variable is a scalar or the trace is to be set on the entire array rather than an individual element (see WHOLE-ARRAY TRACES below for more information).","title":"TWO-PART NAMES"},{"location":"TraceVar/#accessing-variables-during-traces","text":"During read, write, and array traces, the trace procedure can read, write, or unset the traced variable using Tcl_GetVar2 , Tcl_SetVar2 , and other procedures. While proc is executing, traces are temporarily disabled for the variable, so that calls to Tcl_GetVar2 and Tcl_SetVar2 will not cause proc or other trace procedures to be invoked again. Disabling only occurs for the variable whose trace procedure is active; accesses to other variables will still be traced. However, if a variable is unset during a read or write trace then unset traces will be invoked. During unset traces the variable has already been completely expunged. It is possible for the trace procedure to read or write the variable, but this will be a new version of the variable. Traces are not disabled during unset traces as they are for read and write traces, but existing traces have been removed from the variable before any trace procedures are invoked. If new traces are set by unset trace procedures, these traces will be invoked on accesses to the variable by the trace procedures.","title":"ACCESSING VARIABLES DURING TRACES"},{"location":"TraceVar/#callback-timing","text":"When read tracing has been specified for a variable, the trace procedure will be invoked whenever the variable\\'s value is read. This includes set Tcl commands, \\$ -notation in Tcl commands, and invocations of the Tcl_GetVar and Tcl_GetVar2 procedures. Proc is invoked just before the variable\\'s value is returned. It may modify the value of the variable to affect what is returned by the traced access. If it unsets the variable then the access will return an error just as if the variable never existed. When write tracing has been specified for a variable, the trace procedure will be invoked whenever the variable\\'s value is modified. This includes set commands, commands that modify variables as side effects (such as catch and scan ), and calls to the Tcl_SetVar and Tcl_SetVar2 procedures). Proc will be invoked after the variable\\'s value has been modified, but before the new value of the variable has been returned. It may modify the value of the variable to override the change and to determine the value actually returned by the traced access. If it deletes the variable then the traced access will return an empty string. When array tracing has been specified, the trace procedure will be invoked at the beginning of the array command implementation, before any of the operations like get, set, or names have been invoked. The trace procedure can modify the array elements with Tcl_SetVar and Tcl_SetVar2 . When unset tracing has been specified, the trace procedure will be invoked whenever the variable is destroyed. The traces will be called after the variable has been completely unset.","title":"CALLBACK TIMING"},{"location":"TraceVar/#whole-array-traces","text":"If a call to Tcl_TraceVar or Tcl_TraceVar2 specifies the name of an array variable without an index into the array, then the trace will be set on the array as a whole. This means that proc will be invoked whenever any element of the array is accessed in the ways specified by flags . When an array is unset, a whole-array trace will be invoked just once, with name1 equal to the name of the array and name2 NULL; it will not be invoked once for each element.","title":"WHOLE-ARRAY TRACES"},{"location":"TraceVar/#multiple-traces","text":"It is possible for multiple traces to exist on the same variable. When this happens, all of the trace procedures will be invoked on each access, in order from most-recently-created to least-recently-created. When there exist whole-array traces for an array as well as traces on individual elements, the whole-array traces are invoked before the individual-element traces. If a read or write trace unsets the variable then all of the unset traces will be invoked but the remainder of the read and write traces will be skipped.","title":"MULTIPLE TRACES"},{"location":"TraceVar/#error-returns","text":"Under normal conditions trace procedures should return NULL, indicating successful completion. If proc returns a non-NULL value it signifies that an error occurred. The return value must be a pointer to a static character string containing an error message, unless ( exactly one of) the TCL_TRACE_RESULT_DYNAMIC and TCL_TRACE_RESULT_OBJECT flags is set, which specify that the result is either a dynamic string (to be released with Tcl_Free ) or a Tcl_Obj* (cast to char* and to be released with Tcl_DecrRefCount ) containing the error message. If a trace procedure returns an error, no further traces are invoked for the access and the traced access aborts with the given message. Trace procedures can use this facility to make variables read-only, for example (but note that the value of the variable will already have been modified before the trace procedure is called, so the trace procedure will have to restore the correct value). The return value from proc is only used during read and write tracing. During unset traces, the return value is ignored and all relevant trace procedures will always be invoked.","title":"ERROR RETURNS"},{"location":"TraceVar/#restrictions","text":"Because operations on variables may take place as part of the deletion of the interp that contains them, proc must be careful about checking what the interp parameter can be used to do. The routine Tcl_InterpDeleted is an important tool for this. When Tcl_InterpDeleted returns 1, proc will not be able to invoke any scripts in interp . You may encounter old code using a deprecated flag value TCL_INTERP_DESTROYED to signal this condition, but Tcl 9 no longer supports this. Any supported code must be converted to stop using it. A trace procedure can be called at any time, even when there are partially formed results stored in the interpreter. If the trace procedure does anything that could damage this result (such as calling Tcl_Eval ) then it must use the Tcl_SaveInterpState and related routines to save and restore the original state of the interpreter before it returns.","title":"RESTRICTIONS"},{"location":"TraceVar/#undefined-variables","text":"It is legal to set a trace on an undefined variable. The variable will still appear to be undefined until the first time its value is set. If an undefined variable is traced and then unset, the unset will fail with an error but the trace procedure will still be invoked.","title":"UNDEFINED VARIABLES"},{"location":"TraceVar/#tcl_trace_destroyed-flag","text":"In an unset callback to proc , the TCL_TRACE_DESTROYED bit is set in flags if the trace is being removed as part of the deletion. Traces on a variable are always removed whenever the variable is deleted; the only time TCL_TRACE_DESTROYED is not set is for a whole-array trace invoked when only a single element of an array is unset.","title":"TCL_TRACE_DESTROYED FLAG"},{"location":"TraceVar/#reference-count-management","text":"When a proc callback is invoked, and that callback was installed with the TCL_TRACE_RESULT_OBJECT flag, the result of the callback is a Tcl_Obj reference when there is an error. The result will have its reference count decremented once when no longer needed, or may have additional references made to it (e.g., by setting it as the interpreter result with Tcl_SetObjResult ).","title":"REFERENCE COUNT MANAGEMENT"},{"location":"TraceVar/#bugs","text":"Array traces are not yet integrated with the Tcl info exists command, nor is there Tcl-level access to array traces.","title":"BUGS"},{"location":"TraceVar/#see-also","text":"trace(n)","title":"SEE ALSO"},{"location":"TraceVar/#keywords","text":"clientData, trace, variable","title":"KEYWORDS"},{"location":"Translate/","text":"NAME Tcl_TranslateFileName - convert file name to native form SYNOPSIS #include <tcl.h> char * Tcl_TranslateFileName(interp, name, bufferPtr) ARGUMENTS Interpreter in which to report an error, if any. File name If needed, this dynamic string is used to store the new file name. At the time of the call it should be uninitialized or free. The caller must eventually call Tcl_DStringFree to free up anything stored here. DESCRIPTION This utility procedure translates a file name to a platform-specific form which, after being converted to the appropriate encoding, is suitable for passing to the local operating system. In particular, it converts network names into native form. However, with the advent of the newer Tcl_FSGetNormalizedPath and Tcl_FSGetNativePath , there is no longer any need to use this procedure. In particular, Tcl_FSGetNativePath performs all the necessary translation and encoding conversion, is virtual-filesystem aware, and caches the native result for faster repeated calls. Finally Tcl_FSGetNativePath does not require you to free anything afterwards. If Tcl_TranslateFileName has to translate the name then it uses the dynamic string at *bufferPtr to hold the new string it generates. After Tcl_TranslateFileName returns a non-NULL result, the caller must eventually invoke Tcl_DStringFree to free any information placed in *bufferPtr . The caller need not know whether or not Tcl_TranslateFileName actually used the string; Tcl_TranslateFileName initializes *bufferPtr even if it does not use it, so the call to Tcl_DStringFree will be safe in either case. If an error occurs (e.g. because there was no user by the given name) then NULL is returned and an error message will be left in the interpreter\\'s result. When an error occurs, Tcl_TranslateFileName frees the dynamic string itself so that the caller need not call Tcl_DStringFree . The caller is responsible for making sure that the interpreter\\'s result has its default empty value when Tcl_TranslateFileName is invoked. SEE ALSO filename(n) KEYWORDS file name, home directory, translate, user","title":"NAME"},{"location":"Translate/#name","text":"Tcl_TranslateFileName - convert file name to native form","title":"NAME"},{"location":"Translate/#synopsis","text":"#include <tcl.h> char * Tcl_TranslateFileName(interp, name, bufferPtr)","title":"SYNOPSIS"},{"location":"Translate/#arguments","text":"Interpreter in which to report an error, if any. File name If needed, this dynamic string is used to store the new file name. At the time of the call it should be uninitialized or free. The caller must eventually call Tcl_DStringFree to free up anything stored here.","title":"ARGUMENTS"},{"location":"Translate/#description","text":"This utility procedure translates a file name to a platform-specific form which, after being converted to the appropriate encoding, is suitable for passing to the local operating system. In particular, it converts network names into native form. However, with the advent of the newer Tcl_FSGetNormalizedPath and Tcl_FSGetNativePath , there is no longer any need to use this procedure. In particular, Tcl_FSGetNativePath performs all the necessary translation and encoding conversion, is virtual-filesystem aware, and caches the native result for faster repeated calls. Finally Tcl_FSGetNativePath does not require you to free anything afterwards. If Tcl_TranslateFileName has to translate the name then it uses the dynamic string at *bufferPtr to hold the new string it generates. After Tcl_TranslateFileName returns a non-NULL result, the caller must eventually invoke Tcl_DStringFree to free any information placed in *bufferPtr . The caller need not know whether or not Tcl_TranslateFileName actually used the string; Tcl_TranslateFileName initializes *bufferPtr even if it does not use it, so the call to Tcl_DStringFree will be safe in either case. If an error occurs (e.g. because there was no user by the given name) then NULL is returned and an error message will be left in the interpreter\\'s result. When an error occurs, Tcl_TranslateFileName frees the dynamic string itself so that the caller need not call Tcl_DStringFree . The caller is responsible for making sure that the interpreter\\'s result has its default empty value when Tcl_TranslateFileName is invoked.","title":"DESCRIPTION"},{"location":"Translate/#see-also","text":"filename(n)","title":"SEE ALSO"},{"location":"Translate/#keywords","text":"file name, home directory, translate, user","title":"KEYWORDS"},{"location":"UniCharIsAlpha/","text":"NAME Tcl_UniCharIsAlnum, Tcl_UniCharIsAlpha, Tcl_UniCharIsControl, Tcl_UniCharIsDigit, Tcl_UniCharIsGraph, Tcl_UniCharIsLower, Tcl_UniCharIsPrint, Tcl_UniCharIsPunct, Tcl_UniCharIsSpace, Tcl_UniCharIsUpper, Tcl_UniCharIsUnicode, Tcl_UniCharIsWordChar - routines for classification of Tcl_UniChar characters SYNOPSIS #include <tcl.h> int Tcl_UniCharIsAlnum(ch) int Tcl_UniCharIsAlpha(ch) int Tcl_UniCharIsControl(ch) int Tcl_UniCharIsDigit(ch) int Tcl_UniCharIsGraph(ch) int Tcl_UniCharIsLower(ch) int Tcl_UniCharIsPrint(ch) int Tcl_UniCharIsPunct(ch) int Tcl_UniCharIsSpace(ch) int Tcl_UniCharIsUpper(ch) int Tcl_UniCharIsUnicode(ch) int Tcl_UniCharIsWordChar(ch) ARGUMENTS The Unicode character to be examined. DESCRIPTION All of the routines described examine Unicode characters and return a boolean value. A non-zero return value means that the character does belong to the character class associated with the called routine. The rest of this document just describes the character classes associated with the various routines. CHARACTER CLASSES Tcl_UniCharIsAlnum tests if the character is an alphanumeric Unicode character. Tcl_UniCharIsAlpha tests if the character is an alphabetic Unicode character. Tcl_UniCharIsControl tests if the character is a Unicode control character. Tcl_UniCharIsDigit tests if the character is a numeric Unicode character. Tcl_UniCharIsGraph tests if the character is any Unicode print character except space. Tcl_UniCharIsLower tests if the character is a lowercase Unicode character. Tcl_UniCharIsPrint tests if the character is a Unicode print character. Tcl_UniCharIsPunct tests if the character is a Unicode punctuation character. Tcl_UniCharIsSpace tests if the character is a whitespace Unicode character. Tcl_UniCharIsUpper tests if the character is an uppercase Unicode character. Tcl_UniCharIsUnicode tests if the character is a Unicode character, not being a surrogate or noncharacter. Tcl_UniCharIsWordChar tests if the character is alphanumeric or a connector punctuation mark. KEYWORDS unicode, classification","title":"NAME"},{"location":"UniCharIsAlpha/#name","text":"Tcl_UniCharIsAlnum, Tcl_UniCharIsAlpha, Tcl_UniCharIsControl, Tcl_UniCharIsDigit, Tcl_UniCharIsGraph, Tcl_UniCharIsLower, Tcl_UniCharIsPrint, Tcl_UniCharIsPunct, Tcl_UniCharIsSpace, Tcl_UniCharIsUpper, Tcl_UniCharIsUnicode, Tcl_UniCharIsWordChar - routines for classification of Tcl_UniChar characters","title":"NAME"},{"location":"UniCharIsAlpha/#synopsis","text":"#include <tcl.h> int Tcl_UniCharIsAlnum(ch) int Tcl_UniCharIsAlpha(ch) int Tcl_UniCharIsControl(ch) int Tcl_UniCharIsDigit(ch) int Tcl_UniCharIsGraph(ch) int Tcl_UniCharIsLower(ch) int Tcl_UniCharIsPrint(ch) int Tcl_UniCharIsPunct(ch) int Tcl_UniCharIsSpace(ch) int Tcl_UniCharIsUpper(ch) int Tcl_UniCharIsUnicode(ch) int Tcl_UniCharIsWordChar(ch)","title":"SYNOPSIS"},{"location":"UniCharIsAlpha/#arguments","text":"The Unicode character to be examined.","title":"ARGUMENTS"},{"location":"UniCharIsAlpha/#description","text":"All of the routines described examine Unicode characters and return a boolean value. A non-zero return value means that the character does belong to the character class associated with the called routine. The rest of this document just describes the character classes associated with the various routines.","title":"DESCRIPTION"},{"location":"UniCharIsAlpha/#character-classes","text":"Tcl_UniCharIsAlnum tests if the character is an alphanumeric Unicode character. Tcl_UniCharIsAlpha tests if the character is an alphabetic Unicode character. Tcl_UniCharIsControl tests if the character is a Unicode control character. Tcl_UniCharIsDigit tests if the character is a numeric Unicode character. Tcl_UniCharIsGraph tests if the character is any Unicode print character except space. Tcl_UniCharIsLower tests if the character is a lowercase Unicode character. Tcl_UniCharIsPrint tests if the character is a Unicode print character. Tcl_UniCharIsPunct tests if the character is a Unicode punctuation character. Tcl_UniCharIsSpace tests if the character is a whitespace Unicode character. Tcl_UniCharIsUpper tests if the character is an uppercase Unicode character. Tcl_UniCharIsUnicode tests if the character is a Unicode character, not being a surrogate or noncharacter. Tcl_UniCharIsWordChar tests if the character is alphanumeric or a connector punctuation mark.","title":"CHARACTER CLASSES"},{"location":"UniCharIsAlpha/#keywords","text":"unicode, classification","title":"KEYWORDS"},{"location":"UpVar/","text":"NAME upvar - Create link to variable in a different stack frame SYNOPSIS upvar ? level ? otherVar myVar ? otherVar myVar ...? DESCRIPTION This command arranges for one or more local variables in the current procedure to refer to variables in an enclosing procedure call or to global variables. Level may have any of the forms permitted for the uplevel command, and may be omitted (it defaults to 1 ). For each otherVar argument, upvar makes the variable by that name in the procedure frame given by level (or at global level, if level is #0 ) accessible in the current procedure by the name given in the corresponding myVar argument. The variable named by otherVar need not exist at the time of the call; it will be created the first time myVar is referenced, just like an ordinary variable. There must not exist a variable by the name myVar at the time upvar is invoked. MyVar is always treated as the name of a variable, not an array element. An error is returned if the name looks like an array element, such as a(b) . OtherVar may refer to a scalar variable, an array, or an array element. Upvar returns an empty string. The upvar command simplifies the implementation of call-by-name procedure calling and also makes it easier to build new control constructs as Tcl procedures. For example, consider the following procedure: proc add2 name { upvar \\$name x set x [expr {\\$x + 2}] } If add2 is invoked with an argument giving the name of a variable, it adds two to the value of that variable. Although add2 could have been implemented using uplevel instead of upvar , upvar makes it simpler for add2 to access the variable in the caller\\'s procedure frame. namespace eval is another way (besides procedure calls) that the Tcl naming context can change. It adds a call frame to the stack to represent the namespace context. This means each namespace eval command counts as another call level for uplevel and upvar commands. For example, info level 1 will return a list describing a command that is either the outermost procedure call or the outermost namespace eval command. Also, uplevel #0 evaluates a script at top-level in the outermost namespace (the global namespace). If an upvar variable is unset (e.g. x in add2 above), the unset operation affects the variable it is linked to, not the upvar variable. There is no way to unset an upvar variable except by exiting the procedure in which it is defined. However, it is possible to retarget an upvar variable by executing another upvar command. TRACES AND UPVAR Upvar interacts with traces in a straightforward but possibly unexpected manner. If a variable trace is defined on otherVar , that trace will be triggered by actions involving myVar . However, the trace procedure will be passed the name of myVar , rather than the name of otherVar . Thus, the output of the following code will be rather than proc traceproc { name index op } { puts \\$name } proc setByUpvar { name value } { upvar \\$name localVar set localVar \\$value } set originalVar 1 trace variable originalVar w traceproc setByUpvar originalVar 2 If otherVar refers to an element of an array, then the element name is passed as the second argument to the trace procedure. This may be important information in case of traces set on an entire array. EXAMPLE A decr command that works like incr except it subtracts the value from the variable instead of adding it: proc decr {varName {decrement 1}} { upvar 1 \\$varName var incr var [expr {-\\$decrement}] } SEE ALSO global(n), namespace(n), uplevel(n), variable(n) KEYWORDS context, frame, global, level, namespace, procedure, upvar, variable","title":"NAME"},{"location":"UpVar/#name","text":"upvar - Create link to variable in a different stack frame","title":"NAME"},{"location":"UpVar/#synopsis","text":"upvar ? level ? otherVar myVar ? otherVar myVar ...?","title":"SYNOPSIS"},{"location":"UpVar/#description","text":"This command arranges for one or more local variables in the current procedure to refer to variables in an enclosing procedure call or to global variables. Level may have any of the forms permitted for the uplevel command, and may be omitted (it defaults to 1 ). For each otherVar argument, upvar makes the variable by that name in the procedure frame given by level (or at global level, if level is #0 ) accessible in the current procedure by the name given in the corresponding myVar argument. The variable named by otherVar need not exist at the time of the call; it will be created the first time myVar is referenced, just like an ordinary variable. There must not exist a variable by the name myVar at the time upvar is invoked. MyVar is always treated as the name of a variable, not an array element. An error is returned if the name looks like an array element, such as a(b) . OtherVar may refer to a scalar variable, an array, or an array element. Upvar returns an empty string. The upvar command simplifies the implementation of call-by-name procedure calling and also makes it easier to build new control constructs as Tcl procedures. For example, consider the following procedure: proc add2 name { upvar \\$name x set x [expr {\\$x + 2}] } If add2 is invoked with an argument giving the name of a variable, it adds two to the value of that variable. Although add2 could have been implemented using uplevel instead of upvar , upvar makes it simpler for add2 to access the variable in the caller\\'s procedure frame. namespace eval is another way (besides procedure calls) that the Tcl naming context can change. It adds a call frame to the stack to represent the namespace context. This means each namespace eval command counts as another call level for uplevel and upvar commands. For example, info level 1 will return a list describing a command that is either the outermost procedure call or the outermost namespace eval command. Also, uplevel #0 evaluates a script at top-level in the outermost namespace (the global namespace). If an upvar variable is unset (e.g. x in add2 above), the unset operation affects the variable it is linked to, not the upvar variable. There is no way to unset an upvar variable except by exiting the procedure in which it is defined. However, it is possible to retarget an upvar variable by executing another upvar command.","title":"DESCRIPTION"},{"location":"UpVar/#traces-and-upvar","text":"Upvar interacts with traces in a straightforward but possibly unexpected manner. If a variable trace is defined on otherVar , that trace will be triggered by actions involving myVar . However, the trace procedure will be passed the name of myVar , rather than the name of otherVar . Thus, the output of the following code will be rather than proc traceproc { name index op } { puts \\$name } proc setByUpvar { name value } { upvar \\$name localVar set localVar \\$value } set originalVar 1 trace variable originalVar w traceproc setByUpvar originalVar 2 If otherVar refers to an element of an array, then the element name is passed as the second argument to the trace procedure. This may be important information in case of traces set on an entire array.","title":"TRACES AND UPVAR"},{"location":"UpVar/#example","text":"A decr command that works like incr except it subtracts the value from the variable instead of adding it: proc decr {varName {decrement 1}} { upvar 1 \\$varName var incr var [expr {-\\$decrement}] }","title":"EXAMPLE"},{"location":"UpVar/#see-also","text":"global(n), namespace(n), uplevel(n), variable(n)","title":"SEE ALSO"},{"location":"UpVar/#keywords","text":"context, frame, global, level, namespace, procedure, upvar, variable","title":"KEYWORDS"},{"location":"Utf/","text":"NAME Tcl_UniChar, Tcl_UniCharToUtf, Tcl_UtfToUniChar, Tcl_UtfToChar16, Tcl_UtfToWChar, Tcl_UniCharToUtfDString, Tcl_UtfToUniCharDString, Tcl_Char16ToUtfDString, Tcl_UtfToWCharDString, Tcl_UtfToChar16DString, Tcl_WCharLen, Tcl_Char16Len, Tcl_UniCharLen, Tcl_UniCharNcmp, Tcl_UniCharNcasecmp, Tcl_UniCharCaseMatch, Tcl_UtfNcmp, Tcl_UtfNcasecmp, Tcl_UtfCharComplete, Tcl_NumUtfChars, Tcl_UtfFindFirst, Tcl_UtfFindLast, Tcl_UtfNext, Tcl_UtfPrev, Tcl_UniCharAtIndex, Tcl_UtfAtIndex, Tcl_UtfBackslash - routines for manipulating UTF-8 strings SYNOPSIS #include <tcl.h> typedef ... Tcl_UniChar; Tcl_Size Tcl_UniCharToUtf(ch, buf) Tcl_Size Tcl_UtfToUniChar(src, chPtr) Tcl_Size Tcl_UtfToChar16(src, uPtr) Tcl_Size Tcl_UtfToWChar(src, wPtr) char * Tcl_UniCharToUtfDString(uniStr, uniLength, dsPtr) char * Tcl_Char16ToUtfDString(uStr, uniLength, dsPtr) char * Tcl_WCharToUtfDString(wStr, uniLength, dsPtr) Tcl_UniChar * Tcl_UtfToUniCharDString(src, length, dsPtr) unsigned short * Tcl_UtfToChar16DString(src, length, dsPtr) wchar_t * Tcl_UtfToWCharDString(src, length, dsPtr) int Tcl_Char16Len(uniStr) int Tcl_WCharLen(uniStr) int Tcl_UniCharLen(uniStr) int Tcl_UniCharNcmp(ucs, uct, uniLength) int Tcl_UniCharNcasecmp(ucs, uct, uniLength) int Tcl_UniCharCaseMatch(uniStr, uniPattern, nocase) int Tcl_UtfNcmp(cs, ct, length) int Tcl_UtfNcasecmp(cs, ct, length) int Tcl_UtfCharComplete(src, length) int Tcl_NumUtfChars(src, length) const char * Tcl_UtfFindFirst(src, ch) const char * Tcl_UtfFindLast(src, ch) const char * Tcl_UtfNext(src) const char * Tcl_UtfPrev(src, start) int Tcl_UniCharAtIndex(src, index) const char * Tcl_UtfAtIndex(src, index) Tcl_Size Tcl_UtfBackslash(src, readPtr, dst) ARGUMENTS Buffer in which the UTF-8 representation of the Tcl_UniChar is stored. At most 4 bytes are stored in the buffer. The Unicode character to be converted or examined. Filled with the Tcl_UniChar represented by the head of the UTF-8 string. Filled with the utf-16 represented by the head of the UTF-8 string. Filled with the wchar_t represented by the head of the UTF-8 string. Pointer to a UTF-8 string. Pointer to a UTF-8 string. Pointer to a UTF-8 string. A null-terminated Unicode string. A null-terminated Unicode string. A null-terminated Unicode string. A null-terminated Unicode string. A null-terminated UTF-16 string. A null-terminated wchar_t string. A null-terminated utf-16 string. A null-terminated utf-16 string. A null-terminated utf-16 string. The length of the UTF-8 string in bytes (not UTF-8 characters). If negative, all bytes up to the first null byte are used. The length of the Unicode string in characters. A pointer to a previously initialized Tcl_DString . Pointer to the beginning of a UTF-8 string. The index of a character (not byte) in the UTF-8 string. If non-NULL, filled with the number of bytes in the backslash sequence, including the backslash character. Buffer in which the bytes represented by the backslash sequence are stored. At most 4 bytes are stored in the buffer. Specifies whether the match should be done case-sensitive (0) or case-insensitive (1). DESCRIPTION These routines convert between UTF-8 strings and Unicode/Utf-16 characters. A UTF-8 character is a Unicode character represented as a varying-length sequence of up to 4 bytes. A multibyte UTF-8 sequence consists of a lead byte followed by some number of trail bytes. TCL_UTF_MAX is the maximum number of bytes that Tcl_UtfToUniChar can consume in a single call. Tcl_UniCharToUtf stores the character ch as a UTF-8 string in starting at buf . The return value is the number of bytes stored in buf . The character ch can be or\\'ed with the value TCL_COMBINE to enable special behavior, compatible with Tcl 8.x. Then, if ch is a high surrogate (range U+D800 - U+DBFF), the return value will be 1 and a single byte in the range 0xF0 - 0xF4 will be stored. If ch is a low surrogate (range U+DC00 - U+DFFF), an attempt is made to combine the result with the earlier produced bytes, resulting in a 4-byte UTF-8 byte sequence. Tcl_UtfToUniChar reads one UTF-8 character starting at src and stores it as a Tcl_UniChar in *chPtr . The return value is the number of bytes read from src . The caller must ensure that the source buffer is long enough such that this routine does not run off the end and dereference non-existent or random memory; if the source buffer is known to be null-terminated, this will not happen. If the input is a byte in the range 0x80 - 0x9F, Tcl_UtfToUniChar assumes the cp1252 encoding, stores the corresponding Tcl_UniChar in *chPtr and returns 1. If the input is otherwise not in proper UTF-8 format, Tcl_UtfToUniChar will store the first byte of src in *chPtr as a Tcl_UniChar between 0x00A0 and 0x00FF and return 1. Tcl_UniCharToUtfDString converts the given Unicode string to UTF-8, storing the result in a previously initialized Tcl_DString . The return value is a pointer to the UTF-8 representation of the Unicode string. Storage for the return value is appended to the end of the Tcl_DString . Tcl_UtfToUniCharDString converts the given UTF-8 string to Unicode, storing the result in the previously initialized Tcl_DString . In the argument length , you may either specify the length of the given UTF-8 string in bytes or in which case Tcl_UtfToUniCharDString uses strlen to calculate the length. The return value is a pointer to the Unicode representation of the UTF-8 string. Storage for the return value is appended to the end of the Tcl_DString . The Unicode string is terminated with a Unicode null character. Tcl_Char16Len corresponds to strlen for UTF-16 characters. It accepts a null-terminated Unicode string and returns the number of Unicode characters (not bytes) in that string. Tcl_WCharLen corresponds to strlen for wchar_t characters. It accepts a null-terminated Unicode string and returns the number of Unicode characters (not bytes) in that string. Tcl_UniCharLen corresponds to strlen for Unicode characters. It accepts a null-terminated Unicode string and returns the number of Unicode characters (not bytes) in that string. Tcl_UniCharNcmp and Tcl_UniCharNcasecmp correspond to strncmp and strncasecmp , respectively, for Unicode characters. They accept two null-terminated Unicode strings and the number of characters to compare. Both strings are assumed to be at least uniLength characters long. Tcl_UniCharNcmp compares the two strings character-by-character according to the Unicode character ordering. It returns an integer greater than, equal to, or less than 0 if the first string is greater than, equal to, or less than the second string respectively. Tcl_UniCharNcasecmp is the Unicode case insensitive version. Tcl_UniCharCaseMatch is the Unicode equivalent to Tcl_StringCaseMatch . It accepts a null-terminated Unicode string, a Unicode pattern, and a boolean value specifying whether the match should be case sensitive and returns whether the string matches the pattern. Tcl_UtfNcmp corresponds to strncmp for UTF-8 strings. It accepts two null-terminated UTF-8 strings and the number of characters to compare. (Both strings are assumed to be at least length characters long.) Tcl_UtfNcmp compares the two strings character-by-character according to the Unicode character ordering. It returns an integer greater than, equal to, or less than 0 if the first string is greater than, equal to, or less than the second string respectively. Tcl_UtfNcasecmp corresponds to strncasecmp for UTF-8 strings. It is similar to Tcl_UtfNcmp except comparisons ignore differences in case when comparing upper, lower or title case characters. Tcl_UtfCharComplete returns 1 if the source UTF-8 string src of length bytes is long enough to be decoded by Tcl_UtfToUniChar / Tcl_UtfNext , or 0 otherwise. This function does not guarantee that the UTF-8 string is properly formed. This routine is used by procedures that are operating on a byte at a time and need to know if a full Unicode character has been seen. Tcl_NumUtfChars corresponds to strlen for UTF-8 strings. It returns the number of Tcl_UniChars that are represented by the UTF-8 string src . The length of the source string is length bytes. If the length is negative, all bytes up to the first null byte are used. Tcl_UtfFindFirst corresponds to strchr for UTF-8 strings. It returns a pointer to the first occurrence of the Unicode character ch in the null-terminated UTF-8 string src . The null terminator is considered part of the UTF-8 string. Tcl_UtfFindLast corresponds to strrchr for UTF-8 strings. It returns a pointer to the last occurrence of the Unicode character ch in the null-terminated UTF-8 string src . The null terminator is considered part of the UTF-8 string. Given src , a pointer to some location in a UTF-8 string, Tcl_UtfNext returns a pointer to the next UTF-8 character in the string. The caller must not ask for the next character after the last character in the string if the string is not terminated by a null character. Tcl_UtfCharComplete can be used in that case to make sure enough bytes are available before calling Tcl_UtfNext . Tcl_UtfPrev is used to step backward through but not beyond the UTF-8 string that begins at start . If the UTF-8 string is made up entirely of complete and well-formed characters, and src points to the lead byte of one of those characters (or to the location one byte past the end of the string), then repeated calls of Tcl_UtfPrev will return pointers to the lead bytes of each character in the string, one character at a time, terminating when it returns start . When the conditions of completeness and well-formedness may not be satisfied, a more precise description of the function of Tcl_UtfPrev is necessary. It always returns a pointer greater than or equal to start ; that is, always a pointer to a location in the string. It always returns a pointer to a byte that begins a character when scanning for characters beginning from start . When src is greater than start , it always returns a pointer less than src and greater than or equal to ( src - 4). The character that begins at the returned pointer is the first one that either includes the byte src[-1] , or might include it if the right trail bytes are present at src and greater. Tcl_UtfPrev never reads the byte src[0] nor the byte start[-1] nor the byte src[-5] . Tcl_UniCharAtIndex corresponds to a C string array dereference or the Pascal Ord() function. It returns the Unicode character represented at the specified character (not byte) index in the UTF-8 string src . The source string must contain at least index characters. If index is negative or index points to the second half of a surrogate pair, it returns -1. Tcl_UtfAtIndex returns a pointer to the specified character (not byte) index in the UTF-8 string src . The source string must contain at least index characters. This is equivalent to calling Tcl_UtfToUniChar index times. If index is negative, the return pointer points to the first character in the source string. Tcl_UtfBackslash is a utility procedure used by several of the Tcl commands. It parses a backslash sequence and stores the properly formed UTF-8 character represented by the backslash sequence in the output buffer dst . At most 4 bytes are stored in the buffer. Tcl_UtfBackslash modifies *readPtr to contain the number of bytes in the backslash sequence, including the backslash character. The return value is the number of bytes stored in the output buffer. See the Tcl manual entry for information on the valid backslash sequences. All of the sequences described in the Tcl manual entry are supported by Tcl_UtfBackslash . KEYWORDS utf, unicode, backslash","title":"NAME"},{"location":"Utf/#name","text":"Tcl_UniChar, Tcl_UniCharToUtf, Tcl_UtfToUniChar, Tcl_UtfToChar16, Tcl_UtfToWChar, Tcl_UniCharToUtfDString, Tcl_UtfToUniCharDString, Tcl_Char16ToUtfDString, Tcl_UtfToWCharDString, Tcl_UtfToChar16DString, Tcl_WCharLen, Tcl_Char16Len, Tcl_UniCharLen, Tcl_UniCharNcmp, Tcl_UniCharNcasecmp, Tcl_UniCharCaseMatch, Tcl_UtfNcmp, Tcl_UtfNcasecmp, Tcl_UtfCharComplete, Tcl_NumUtfChars, Tcl_UtfFindFirst, Tcl_UtfFindLast, Tcl_UtfNext, Tcl_UtfPrev, Tcl_UniCharAtIndex, Tcl_UtfAtIndex, Tcl_UtfBackslash - routines for manipulating UTF-8 strings","title":"NAME"},{"location":"Utf/#synopsis","text":"#include <tcl.h> typedef ... Tcl_UniChar; Tcl_Size Tcl_UniCharToUtf(ch, buf) Tcl_Size Tcl_UtfToUniChar(src, chPtr) Tcl_Size Tcl_UtfToChar16(src, uPtr) Tcl_Size Tcl_UtfToWChar(src, wPtr) char * Tcl_UniCharToUtfDString(uniStr, uniLength, dsPtr) char * Tcl_Char16ToUtfDString(uStr, uniLength, dsPtr) char * Tcl_WCharToUtfDString(wStr, uniLength, dsPtr) Tcl_UniChar * Tcl_UtfToUniCharDString(src, length, dsPtr) unsigned short * Tcl_UtfToChar16DString(src, length, dsPtr) wchar_t * Tcl_UtfToWCharDString(src, length, dsPtr) int Tcl_Char16Len(uniStr) int Tcl_WCharLen(uniStr) int Tcl_UniCharLen(uniStr) int Tcl_UniCharNcmp(ucs, uct, uniLength) int Tcl_UniCharNcasecmp(ucs, uct, uniLength) int Tcl_UniCharCaseMatch(uniStr, uniPattern, nocase) int Tcl_UtfNcmp(cs, ct, length) int Tcl_UtfNcasecmp(cs, ct, length) int Tcl_UtfCharComplete(src, length) int Tcl_NumUtfChars(src, length) const char * Tcl_UtfFindFirst(src, ch) const char * Tcl_UtfFindLast(src, ch) const char * Tcl_UtfNext(src) const char * Tcl_UtfPrev(src, start) int Tcl_UniCharAtIndex(src, index) const char * Tcl_UtfAtIndex(src, index) Tcl_Size Tcl_UtfBackslash(src, readPtr, dst)","title":"SYNOPSIS"},{"location":"Utf/#arguments","text":"Buffer in which the UTF-8 representation of the Tcl_UniChar is stored. At most 4 bytes are stored in the buffer. The Unicode character to be converted or examined. Filled with the Tcl_UniChar represented by the head of the UTF-8 string. Filled with the utf-16 represented by the head of the UTF-8 string. Filled with the wchar_t represented by the head of the UTF-8 string. Pointer to a UTF-8 string. Pointer to a UTF-8 string. Pointer to a UTF-8 string. A null-terminated Unicode string. A null-terminated Unicode string. A null-terminated Unicode string. A null-terminated Unicode string. A null-terminated UTF-16 string. A null-terminated wchar_t string. A null-terminated utf-16 string. A null-terminated utf-16 string. A null-terminated utf-16 string. The length of the UTF-8 string in bytes (not UTF-8 characters). If negative, all bytes up to the first null byte are used. The length of the Unicode string in characters. A pointer to a previously initialized Tcl_DString . Pointer to the beginning of a UTF-8 string. The index of a character (not byte) in the UTF-8 string. If non-NULL, filled with the number of bytes in the backslash sequence, including the backslash character. Buffer in which the bytes represented by the backslash sequence are stored. At most 4 bytes are stored in the buffer. Specifies whether the match should be done case-sensitive (0) or case-insensitive (1).","title":"ARGUMENTS"},{"location":"Utf/#description","text":"These routines convert between UTF-8 strings and Unicode/Utf-16 characters. A UTF-8 character is a Unicode character represented as a varying-length sequence of up to 4 bytes. A multibyte UTF-8 sequence consists of a lead byte followed by some number of trail bytes. TCL_UTF_MAX is the maximum number of bytes that Tcl_UtfToUniChar can consume in a single call. Tcl_UniCharToUtf stores the character ch as a UTF-8 string in starting at buf . The return value is the number of bytes stored in buf . The character ch can be or\\'ed with the value TCL_COMBINE to enable special behavior, compatible with Tcl 8.x. Then, if ch is a high surrogate (range U+D800 - U+DBFF), the return value will be 1 and a single byte in the range 0xF0 - 0xF4 will be stored. If ch is a low surrogate (range U+DC00 - U+DFFF), an attempt is made to combine the result with the earlier produced bytes, resulting in a 4-byte UTF-8 byte sequence. Tcl_UtfToUniChar reads one UTF-8 character starting at src and stores it as a Tcl_UniChar in *chPtr . The return value is the number of bytes read from src . The caller must ensure that the source buffer is long enough such that this routine does not run off the end and dereference non-existent or random memory; if the source buffer is known to be null-terminated, this will not happen. If the input is a byte in the range 0x80 - 0x9F, Tcl_UtfToUniChar assumes the cp1252 encoding, stores the corresponding Tcl_UniChar in *chPtr and returns 1. If the input is otherwise not in proper UTF-8 format, Tcl_UtfToUniChar will store the first byte of src in *chPtr as a Tcl_UniChar between 0x00A0 and 0x00FF and return 1. Tcl_UniCharToUtfDString converts the given Unicode string to UTF-8, storing the result in a previously initialized Tcl_DString . The return value is a pointer to the UTF-8 representation of the Unicode string. Storage for the return value is appended to the end of the Tcl_DString . Tcl_UtfToUniCharDString converts the given UTF-8 string to Unicode, storing the result in the previously initialized Tcl_DString . In the argument length , you may either specify the length of the given UTF-8 string in bytes or in which case Tcl_UtfToUniCharDString uses strlen to calculate the length. The return value is a pointer to the Unicode representation of the UTF-8 string. Storage for the return value is appended to the end of the Tcl_DString . The Unicode string is terminated with a Unicode null character. Tcl_Char16Len corresponds to strlen for UTF-16 characters. It accepts a null-terminated Unicode string and returns the number of Unicode characters (not bytes) in that string. Tcl_WCharLen corresponds to strlen for wchar_t characters. It accepts a null-terminated Unicode string and returns the number of Unicode characters (not bytes) in that string. Tcl_UniCharLen corresponds to strlen for Unicode characters. It accepts a null-terminated Unicode string and returns the number of Unicode characters (not bytes) in that string. Tcl_UniCharNcmp and Tcl_UniCharNcasecmp correspond to strncmp and strncasecmp , respectively, for Unicode characters. They accept two null-terminated Unicode strings and the number of characters to compare. Both strings are assumed to be at least uniLength characters long. Tcl_UniCharNcmp compares the two strings character-by-character according to the Unicode character ordering. It returns an integer greater than, equal to, or less than 0 if the first string is greater than, equal to, or less than the second string respectively. Tcl_UniCharNcasecmp is the Unicode case insensitive version. Tcl_UniCharCaseMatch is the Unicode equivalent to Tcl_StringCaseMatch . It accepts a null-terminated Unicode string, a Unicode pattern, and a boolean value specifying whether the match should be case sensitive and returns whether the string matches the pattern. Tcl_UtfNcmp corresponds to strncmp for UTF-8 strings. It accepts two null-terminated UTF-8 strings and the number of characters to compare. (Both strings are assumed to be at least length characters long.) Tcl_UtfNcmp compares the two strings character-by-character according to the Unicode character ordering. It returns an integer greater than, equal to, or less than 0 if the first string is greater than, equal to, or less than the second string respectively. Tcl_UtfNcasecmp corresponds to strncasecmp for UTF-8 strings. It is similar to Tcl_UtfNcmp except comparisons ignore differences in case when comparing upper, lower or title case characters. Tcl_UtfCharComplete returns 1 if the source UTF-8 string src of length bytes is long enough to be decoded by Tcl_UtfToUniChar / Tcl_UtfNext , or 0 otherwise. This function does not guarantee that the UTF-8 string is properly formed. This routine is used by procedures that are operating on a byte at a time and need to know if a full Unicode character has been seen. Tcl_NumUtfChars corresponds to strlen for UTF-8 strings. It returns the number of Tcl_UniChars that are represented by the UTF-8 string src . The length of the source string is length bytes. If the length is negative, all bytes up to the first null byte are used. Tcl_UtfFindFirst corresponds to strchr for UTF-8 strings. It returns a pointer to the first occurrence of the Unicode character ch in the null-terminated UTF-8 string src . The null terminator is considered part of the UTF-8 string. Tcl_UtfFindLast corresponds to strrchr for UTF-8 strings. It returns a pointer to the last occurrence of the Unicode character ch in the null-terminated UTF-8 string src . The null terminator is considered part of the UTF-8 string. Given src , a pointer to some location in a UTF-8 string, Tcl_UtfNext returns a pointer to the next UTF-8 character in the string. The caller must not ask for the next character after the last character in the string if the string is not terminated by a null character. Tcl_UtfCharComplete can be used in that case to make sure enough bytes are available before calling Tcl_UtfNext . Tcl_UtfPrev is used to step backward through but not beyond the UTF-8 string that begins at start . If the UTF-8 string is made up entirely of complete and well-formed characters, and src points to the lead byte of one of those characters (or to the location one byte past the end of the string), then repeated calls of Tcl_UtfPrev will return pointers to the lead bytes of each character in the string, one character at a time, terminating when it returns start . When the conditions of completeness and well-formedness may not be satisfied, a more precise description of the function of Tcl_UtfPrev is necessary. It always returns a pointer greater than or equal to start ; that is, always a pointer to a location in the string. It always returns a pointer to a byte that begins a character when scanning for characters beginning from start . When src is greater than start , it always returns a pointer less than src and greater than or equal to ( src - 4). The character that begins at the returned pointer is the first one that either includes the byte src[-1] , or might include it if the right trail bytes are present at src and greater. Tcl_UtfPrev never reads the byte src[0] nor the byte start[-1] nor the byte src[-5] . Tcl_UniCharAtIndex corresponds to a C string array dereference or the Pascal Ord() function. It returns the Unicode character represented at the specified character (not byte) index in the UTF-8 string src . The source string must contain at least index characters. If index is negative or index points to the second half of a surrogate pair, it returns -1. Tcl_UtfAtIndex returns a pointer to the specified character (not byte) index in the UTF-8 string src . The source string must contain at least index characters. This is equivalent to calling Tcl_UtfToUniChar index times. If index is negative, the return pointer points to the first character in the source string. Tcl_UtfBackslash is a utility procedure used by several of the Tcl commands. It parses a backslash sequence and stores the properly formed UTF-8 character represented by the backslash sequence in the output buffer dst . At most 4 bytes are stored in the buffer. Tcl_UtfBackslash modifies *readPtr to contain the number of bytes in the backslash sequence, including the backslash character. The return value is the number of bytes stored in the output buffer. See the Tcl manual entry for information on the valid backslash sequences. All of the sequences described in the Tcl manual entry are supported by Tcl_UtfBackslash .","title":"DESCRIPTION"},{"location":"Utf/#keywords","text":"utf, unicode, backslash","title":"KEYWORDS"},{"location":"WrongNumArgs/","text":"NAME Tcl_WrongNumArgs - generate standard error message for wrong number of arguments SYNOPSIS #include <tcl.h> Tcl_WrongNumArgs(interp, objc, objv, message) ARGUMENTS Interpreter in which error will be reported: error message gets stored in its result value. Number of leading arguments from objv to include in error message. Arguments to command that had the wrong number of arguments. Additional error information to print after leading arguments from objv . This typically gives the acceptable syntax of the command. This argument may be NULL. DESCRIPTION Tcl_WrongNumArgs is a utility procedure that is invoked by command procedures when they discover that they have received the wrong number of arguments. Tcl_WrongNumArgs generates a standard error message and stores it in the result value of interp . The message includes the objc initial elements of objv plus message . For example, if objv consists of the values foo and bar , objc is 1, and message is then interp \\'s result value will be set to the following string: wrong # args: should be \\\"foo fileName count\\\" If objc is 2, the result will be set to the following string: wrong # args: should be \\\"foo bar fileName count\\\" Objc is usually 1, but may be 2 or more for commands like string and the Tk widget commands, which use the first argument as a subcommand. Some of the values in the objv array may be abbreviations for a subcommand. The command Tcl_GetIndexFromObj will convert the abbreviated string value into an indexObject . If an error occurs in the parsing of the subcommand we would like to use the full subcommand name rather than the abbreviation. If the Tcl_WrongNumArgs command finds any indexObjects in the objv array it will use the full subcommand name in the error message instead of the abbreviated name that was originally passed in. Using the above example, let us assume that bar is actually an abbreviation for barfly and the value is now an indexObject because it was passed to Tcl_GetIndexFromObj . In this case the error message would be: wrong # args: should be \\\"foo barfly fileName count\\\" REFERENCE COUNT MANAGEMENT The objv argument to Tcl_WrongNumArgs should be the exact arguments passed to the command or method implementation function that is calling Tcl_WrongNumArgs . As such, all values referenced in it should have reference counts greater than zero; this is usually a non-issue. SEE ALSO Tcl_GetIndexFromObj(3) KEYWORDS command, error message, wrong number of arguments","title":"NAME"},{"location":"WrongNumArgs/#name","text":"Tcl_WrongNumArgs - generate standard error message for wrong number of arguments","title":"NAME"},{"location":"WrongNumArgs/#synopsis","text":"#include <tcl.h> Tcl_WrongNumArgs(interp, objc, objv, message)","title":"SYNOPSIS"},{"location":"WrongNumArgs/#arguments","text":"Interpreter in which error will be reported: error message gets stored in its result value. Number of leading arguments from objv to include in error message. Arguments to command that had the wrong number of arguments. Additional error information to print after leading arguments from objv . This typically gives the acceptable syntax of the command. This argument may be NULL.","title":"ARGUMENTS"},{"location":"WrongNumArgs/#description","text":"Tcl_WrongNumArgs is a utility procedure that is invoked by command procedures when they discover that they have received the wrong number of arguments. Tcl_WrongNumArgs generates a standard error message and stores it in the result value of interp . The message includes the objc initial elements of objv plus message . For example, if objv consists of the values foo and bar , objc is 1, and message is then interp \\'s result value will be set to the following string: wrong # args: should be \\\"foo fileName count\\\" If objc is 2, the result will be set to the following string: wrong # args: should be \\\"foo bar fileName count\\\" Objc is usually 1, but may be 2 or more for commands like string and the Tk widget commands, which use the first argument as a subcommand. Some of the values in the objv array may be abbreviations for a subcommand. The command Tcl_GetIndexFromObj will convert the abbreviated string value into an indexObject . If an error occurs in the parsing of the subcommand we would like to use the full subcommand name rather than the abbreviation. If the Tcl_WrongNumArgs command finds any indexObjects in the objv array it will use the full subcommand name in the error message instead of the abbreviated name that was originally passed in. Using the above example, let us assume that bar is actually an abbreviation for barfly and the value is now an indexObject because it was passed to Tcl_GetIndexFromObj . In this case the error message would be: wrong # args: should be \\\"foo barfly fileName count\\\"","title":"DESCRIPTION"},{"location":"WrongNumArgs/#reference-count-management","text":"The objv argument to Tcl_WrongNumArgs should be the exact arguments passed to the command or method implementation function that is calling Tcl_WrongNumArgs . As such, all values referenced in it should have reference counts greater than zero; this is usually a non-issue.","title":"REFERENCE COUNT MANAGEMENT"},{"location":"WrongNumArgs/#see-also","text":"Tcl_GetIndexFromObj(3)","title":"SEE ALSO"},{"location":"WrongNumArgs/#keywords","text":"command, error message, wrong number of arguments","title":"KEYWORDS"},{"location":"about/","text":"","title":"About"},{"location":"abstract/","text":"NAME oo::abstract - a class that does not allow direct instances of itself SYNOPSIS package require tcl::oo oo::abstract method ?arg ...? CLASS HIERARCHY oo::object \u2192 oo::class \u2192 oo::abstract DESCRIPTION Abstract classes are classes that can contain definitions, but which cannot be directly manufactured; they are intended to only ever be inherited from and instantiated indirectly. The characteristic methods of oo::class ( create and new ) are not exported by an instance of oo::abstract . Note that oo::abstract is not itself an instance of oo::abstract . CONSTRUCTOR The oo::abstract class does not define an explicit constructor; this means that it is effectively the same as the constructor of the oo::class class. DESTRUCTOR The oo::abstract class does not define an explicit destructor; destroying an instance of it is just like destroying an ordinary class (and will destroy all its subclasses). EXPORTED METHODS The oo::abstract class defines no new exported methods. NON-EXPORTED METHODS The oo::abstract class explicitly states that create , createWithNamespace , and new are unexported. EXAMPLES This example defines a simple class hierarchy and creates a new instance of it. It then invokes a method of the object before destroying the hierarchy and showing that the destruction is transitive. oo::abstract create fruit { method eat {} { puts \\\"yummy!\\\" } } oo::class create banana { superclass fruit method peel {} { puts \\\"skin now off\\\" } } set b [banana new ] \\$b peel \u2192 prints \\'skin now off\\' \\$b eat \u2192 prints \\'yummy!\\' set f [fruit new] \u2192 error \\'unknown method \\\"new\\\"...\\' SEE ALSO oo::define(n), oo::object(n) KEYWORDS abstract class, class, metaclass, object","title":"NAME"},{"location":"abstract/#name","text":"oo::abstract - a class that does not allow direct instances of itself","title":"NAME"},{"location":"abstract/#synopsis","text":"package require tcl::oo oo::abstract method ?arg ...?","title":"SYNOPSIS"},{"location":"abstract/#class-hierarchy","text":"oo::object \u2192 oo::class \u2192 oo::abstract","title":"CLASS HIERARCHY"},{"location":"abstract/#description","text":"Abstract classes are classes that can contain definitions, but which cannot be directly manufactured; they are intended to only ever be inherited from and instantiated indirectly. The characteristic methods of oo::class ( create and new ) are not exported by an instance of oo::abstract . Note that oo::abstract is not itself an instance of oo::abstract .","title":"DESCRIPTION"},{"location":"abstract/#constructor","text":"The oo::abstract class does not define an explicit constructor; this means that it is effectively the same as the constructor of the oo::class class.","title":"CONSTRUCTOR"},{"location":"abstract/#destructor","text":"The oo::abstract class does not define an explicit destructor; destroying an instance of it is just like destroying an ordinary class (and will destroy all its subclasses).","title":"DESTRUCTOR"},{"location":"abstract/#exported-methods","text":"The oo::abstract class defines no new exported methods.","title":"EXPORTED METHODS"},{"location":"abstract/#non-exported-methods","text":"The oo::abstract class explicitly states that create , createWithNamespace , and new are unexported.","title":"NON-EXPORTED METHODS"},{"location":"abstract/#examples","text":"This example defines a simple class hierarchy and creates a new instance of it. It then invokes a method of the object before destroying the hierarchy and showing that the destruction is transitive. oo::abstract create fruit { method eat {} { puts \\\"yummy!\\\" } } oo::class create banana { superclass fruit method peel {} { puts \\\"skin now off\\\" } } set b [banana new ] \\$b peel \u2192 prints \\'skin now off\\' \\$b eat \u2192 prints \\'yummy!\\' set f [fruit new] \u2192 error \\'unknown method \\\"new\\\"...\\'","title":"EXAMPLES"},{"location":"abstract/#see-also","text":"oo::define(n), oo::object(n)","title":"SEE ALSO"},{"location":"abstract/#keywords","text":"abstract class, class, metaclass, object","title":"KEYWORDS"},{"location":"after/","text":"NAME after - Execute a command after a time delay SYNOPSIS after ms after ms ? script script script ... ? after cancel id after cancel script script script ... after idle ? script script script ... ? after info ? id ? DESCRIPTION This command is used to delay execution of the program or to execute a command in background sometime in the future. It has several forms, depending on the first argument to the command: after ms : Ms must be an integer giving a time in milliseconds. A negative number is treated as 0. The command sleeps for ms milliseconds and then returns. While the command is sleeping the application does not respond to events. after ms ? script script script ... ? : In this form the command returns immediately, but it arranges for a Tcl command to be executed ms milliseconds later as an event handler. The command will be executed exactly once, at the given time. The delayed command is formed by concatenating all the script arguments in the same fashion as the concat command. The command will be executed at global level (outside the context of any Tcl procedure). If an error occurs while executing the delayed command then the background error will be reported by the command registered with interp bgerror . The after command returns an identifier that can be used to cancel the delayed command using after cancel . A ms value of 0 (or negative) queues the event immediately with priority over other event types (if not installed withn an event proc, which will wait for next round of events). after cancel id : Cancels the execution of a delayed command that was previously scheduled. Id indicates which command should be canceled; it must have been the return value from a previous after command. If the command given by id has already been executed then the after cancel command has no effect. after cancel script script ... : This command also cancels the execution of a delayed command. The script arguments are concatenated together with space separators (just as in the concat command). If there is a pending command that matches the string, it is canceled and will never be executed; if no such command is currently pending then the after cancel command has no effect. after idle script ? script script ... ? : Concatenates the script arguments together with space separators (just as in the concat command), and arranges for the resulting script to be evaluated later as an idle callback. The script will be run exactly once, the next time the event loop is entered and there are no events to process. The command returns an identifier that can be used to cancel the delayed command using after cancel . If an error occurs while executing the script then the background error will be reported by the command registered with interp bgerror . after info ? id ? : This command returns information about existing event handlers. If no id argument is supplied, the command returns a list of the identifiers for all existing event handlers created by the after command for this interpreter. If id is supplied, it specifies an existing handler; id must have been the return value from some previous call to after and it must not have triggered yet or been canceled. In this case the command returns a list with two elements. The first element of the list is the script associated with id , and the second element is either idle or timer to indicate what kind of event handler it is. The after ms and after idle forms of the command assume that the application is event driven: the delayed commands will not be executed unless the application enters the event loop. In applications that are not normally event-driven, such as tclsh , the event loop can be entered with the vwait and update commands. EXAMPLES This defines a command to make Tcl do nothing at all for N seconds: proc sleep {N} { after [expr {int(\\$N * 1000)}] } This arranges for the command wake_up to be run in eight hours (providing the event loop is active at that time): after [expr {1000 * 60 * 60 * 8}] wake_up The following command can be used to do long-running calculations (as represented here by ::my_calc::one_step , which is assumed to return a boolean indicating whether another step should be performed) in a step-by-step fashion, though the calculation itself needs to be arranged so it can work step-wise. This technique is extra careful to ensure that the event loop is not starved by the rescheduling of processing steps (arranging for the next step to be done using an already-triggered timer event only when the event queue has been drained) and is useful when you want to ensure that a Tk GUI remains responsive during a slow task. proc doOneStep {} { if {[::my_calc::one_step]} { after idle [list after 0 doOneStep] } } doOneStep SEE ALSO concat(n), interp(n), update(n), vwait(n) KEYWORDS cancel, delay, idle callback, sleep, time","title":"NAME"},{"location":"after/#name","text":"after - Execute a command after a time delay","title":"NAME"},{"location":"after/#synopsis","text":"after ms after ms ? script script script ... ? after cancel id after cancel script script script ... after idle ? script script script ... ? after info ? id ?","title":"SYNOPSIS"},{"location":"after/#description","text":"This command is used to delay execution of the program or to execute a command in background sometime in the future. It has several forms, depending on the first argument to the command: after ms : Ms must be an integer giving a time in milliseconds. A negative number is treated as 0. The command sleeps for ms milliseconds and then returns. While the command is sleeping the application does not respond to events. after ms ? script script script ... ? : In this form the command returns immediately, but it arranges for a Tcl command to be executed ms milliseconds later as an event handler. The command will be executed exactly once, at the given time. The delayed command is formed by concatenating all the script arguments in the same fashion as the concat command. The command will be executed at global level (outside the context of any Tcl procedure). If an error occurs while executing the delayed command then the background error will be reported by the command registered with interp bgerror . The after command returns an identifier that can be used to cancel the delayed command using after cancel . A ms value of 0 (or negative) queues the event immediately with priority over other event types (if not installed withn an event proc, which will wait for next round of events). after cancel id : Cancels the execution of a delayed command that was previously scheduled. Id indicates which command should be canceled; it must have been the return value from a previous after command. If the command given by id has already been executed then the after cancel command has no effect. after cancel script script ... : This command also cancels the execution of a delayed command. The script arguments are concatenated together with space separators (just as in the concat command). If there is a pending command that matches the string, it is canceled and will never be executed; if no such command is currently pending then the after cancel command has no effect. after idle script ? script script ... ? : Concatenates the script arguments together with space separators (just as in the concat command), and arranges for the resulting script to be evaluated later as an idle callback. The script will be run exactly once, the next time the event loop is entered and there are no events to process. The command returns an identifier that can be used to cancel the delayed command using after cancel . If an error occurs while executing the script then the background error will be reported by the command registered with interp bgerror . after info ? id ? : This command returns information about existing event handlers. If no id argument is supplied, the command returns a list of the identifiers for all existing event handlers created by the after command for this interpreter. If id is supplied, it specifies an existing handler; id must have been the return value from some previous call to after and it must not have triggered yet or been canceled. In this case the command returns a list with two elements. The first element of the list is the script associated with id , and the second element is either idle or timer to indicate what kind of event handler it is. The after ms and after idle forms of the command assume that the application is event driven: the delayed commands will not be executed unless the application enters the event loop. In applications that are not normally event-driven, such as tclsh , the event loop can be entered with the vwait and update commands.","title":"DESCRIPTION"},{"location":"after/#examples","text":"This defines a command to make Tcl do nothing at all for N seconds: proc sleep {N} { after [expr {int(\\$N * 1000)}] } This arranges for the command wake_up to be run in eight hours (providing the event loop is active at that time): after [expr {1000 * 60 * 60 * 8}] wake_up The following command can be used to do long-running calculations (as represented here by ::my_calc::one_step , which is assumed to return a boolean indicating whether another step should be performed) in a step-by-step fashion, though the calculation itself needs to be arranged so it can work step-wise. This technique is extra careful to ensure that the event loop is not starved by the rescheduling of processing steps (arranging for the next step to be done using an already-triggered timer event only when the event queue has been drained) and is useful when you want to ensure that a Tk GUI remains responsive during a slow task. proc doOneStep {} { if {[::my_calc::one_step]} { after idle [list after 0 doOneStep] } } doOneStep","title":"EXAMPLES"},{"location":"after/#see-also","text":"concat(n), interp(n), update(n), vwait(n)","title":"SEE ALSO"},{"location":"after/#keywords","text":"cancel, delay, idle callback, sleep, time","title":"KEYWORDS"},{"location":"append/","text":"NAME append - Append to variable SYNOPSIS append varName ? value value value ... ? DESCRIPTION Append all of the value arguments to the current value of variable varName . If varName does not exist, it is given a value equal to the concatenation of all the value arguments. If varName indicate an element that does not exist of an array that has a default value set, the concatenation of the default value and all the value arguments will be stored in the array element. The result of this command is the new value stored in variable varName . This command provides an efficient way to build up long variables incrementally. For example, is much more efficient than if \\$a is long. EXAMPLE Building a string of comma-separated numbers piecemeal using a loop. set var 0 for {set i 1} {\\$i\\<=10} {incr i} { append var \\\",\\\" \\$i } puts \\$var # Prints 0,1,2,3,4,5,6,7,8,9,10 SEE ALSO concat(n), lappend(n) KEYWORDS append, variable","title":"NAME"},{"location":"append/#name","text":"append - Append to variable","title":"NAME"},{"location":"append/#synopsis","text":"append varName ? value value value ... ?","title":"SYNOPSIS"},{"location":"append/#description","text":"Append all of the value arguments to the current value of variable varName . If varName does not exist, it is given a value equal to the concatenation of all the value arguments. If varName indicate an element that does not exist of an array that has a default value set, the concatenation of the default value and all the value arguments will be stored in the array element. The result of this command is the new value stored in variable varName . This command provides an efficient way to build up long variables incrementally. For example, is much more efficient than if \\$a is long.","title":"DESCRIPTION"},{"location":"append/#example","text":"Building a string of comma-separated numbers piecemeal using a loop. set var 0 for {set i 1} {\\$i\\<=10} {incr i} { append var \\\",\\\" \\$i } puts \\$var # Prints 0,1,2,3,4,5,6,7,8,9,10","title":"EXAMPLE"},{"location":"append/#see-also","text":"concat(n), lappend(n)","title":"SEE ALSO"},{"location":"append/#keywords","text":"append, variable","title":"KEYWORDS"},{"location":"apply/","text":"NAME apply - Apply an anonymous function SYNOPSIS apply func ? arg1 arg2 ... ? DESCRIPTION The command apply applies the function func to the arguments arg1 arg2 ... and returns the result. The function func is a two element list {args body} or a three element list {args body namespace} (as if the list command had been used). The first element args specifies the formal arguments to func . The specification of the formal arguments args is shared with the proc command, and is described in detail in the corresponding manual page. The contents of body are executed by the Tcl interpreter after the local variables corresponding to the formal arguments are given the values of the actual parameters arg1 arg2 ... . When body is being executed, variable names normally refer to local variables, which are created automatically when referenced and deleted when apply returns. One local variable is automatically created for each of the function\\'s arguments. Global variables can only be accessed by invoking the global command or the upvar command. Namespace variables can only be accessed by invoking the variable command or the upvar command. The invocation of apply adds a call frame to Tcl\\'s evaluation stack (the stack of frames accessed via uplevel ). The execution of body proceeds in this call frame, in the namespace given by namespace or in the global namespace if none was specified. If given, namespace is interpreted relative to the global namespace even if its name does not start with The semantics of apply can also be described by: proc apply {fun args} { set len [llength \\$fun] if {(\\$len \\< 2) || (\\$len > 3)} { error \\\"can\\'t interpret \\\\\"\\$fun\\\\\" as anonymous function\\\" } lassign \\$fun argList body ns set name ::\\$ns::[getGloballyUniqueName] set body0 { rename [lindex [info level 0] 0] {} } proc \\$name \\$argList \\${body0}\\$body set code [catch {uplevel 1 \\$name \\$args} res opt] return -options \\$opt \\$res } EXAMPLES This shows how to make a simple general command that applies a transformation to each element of a list. proc map {lambda list} { set result {} foreach item \\$list { lappend result [ apply \\$lambda \\$item] } return \\$result } map {x {return [string length \\$x]:\\$x}} {a bb ccc dddd} \u2192 1:a 2:bb 3:ccc 4:dddd map {x {expr {\\$x**2 + 3*\\$x - 2}}} {-4 -3 -2 -1 0 1 2 3 4} \u2192 2 -2 -4 -4 -2 2 8 16 26 The apply command is also useful for defining callbacks for use in the trace command: set vbl \\\"123abc\\\" trace add variable vbl write { apply {{v1 v2 op} { upvar 1 \\$v1 v puts \\\"updated variable to \\\\\"\\$v\\\\\"\\\" }}} set vbl 123 set vbl abc SEE ALSO proc(n), uplevel(n) KEYWORDS anonymous function, argument, lambda, procedure,","title":"NAME"},{"location":"apply/#name","text":"apply - Apply an anonymous function","title":"NAME"},{"location":"apply/#synopsis","text":"apply func ? arg1 arg2 ... ?","title":"SYNOPSIS"},{"location":"apply/#description","text":"The command apply applies the function func to the arguments arg1 arg2 ... and returns the result. The function func is a two element list {args body} or a three element list {args body namespace} (as if the list command had been used). The first element args specifies the formal arguments to func . The specification of the formal arguments args is shared with the proc command, and is described in detail in the corresponding manual page. The contents of body are executed by the Tcl interpreter after the local variables corresponding to the formal arguments are given the values of the actual parameters arg1 arg2 ... . When body is being executed, variable names normally refer to local variables, which are created automatically when referenced and deleted when apply returns. One local variable is automatically created for each of the function\\'s arguments. Global variables can only be accessed by invoking the global command or the upvar command. Namespace variables can only be accessed by invoking the variable command or the upvar command. The invocation of apply adds a call frame to Tcl\\'s evaluation stack (the stack of frames accessed via uplevel ). The execution of body proceeds in this call frame, in the namespace given by namespace or in the global namespace if none was specified. If given, namespace is interpreted relative to the global namespace even if its name does not start with The semantics of apply can also be described by: proc apply {fun args} { set len [llength \\$fun] if {(\\$len \\< 2) || (\\$len > 3)} { error \\\"can\\'t interpret \\\\\"\\$fun\\\\\" as anonymous function\\\" } lassign \\$fun argList body ns set name ::\\$ns::[getGloballyUniqueName] set body0 { rename [lindex [info level 0] 0] {} } proc \\$name \\$argList \\${body0}\\$body set code [catch {uplevel 1 \\$name \\$args} res opt] return -options \\$opt \\$res }","title":"DESCRIPTION"},{"location":"apply/#examples","text":"This shows how to make a simple general command that applies a transformation to each element of a list. proc map {lambda list} { set result {} foreach item \\$list { lappend result [ apply \\$lambda \\$item] } return \\$result } map {x {return [string length \\$x]:\\$x}} {a bb ccc dddd} \u2192 1:a 2:bb 3:ccc 4:dddd map {x {expr {\\$x**2 + 3*\\$x - 2}}} {-4 -3 -2 -1 0 1 2 3 4} \u2192 2 -2 -4 -4 -2 2 8 16 26 The apply command is also useful for defining callbacks for use in the trace command: set vbl \\\"123abc\\\" trace add variable vbl write { apply {{v1 v2 op} { upvar 1 \\$v1 v puts \\\"updated variable to \\\\\"\\$v\\\\\"\\\" }}} set vbl 123 set vbl abc","title":"EXAMPLES"},{"location":"apply/#see-also","text":"proc(n), uplevel(n)","title":"SEE ALSO"},{"location":"apply/#keywords","text":"anonymous function, argument, lambda, procedure,","title":"KEYWORDS"},{"location":"array/","text":"NAME array - Manipulate array variables SYNOPSIS array option arrayName ? arg arg ... ? DESCRIPTION This command performs one of several operations on the variable given by arrayName . Unless otherwise specified for individual commands below, arrayName must be the name of an existing array variable. The option argument determines what action is carried out by the command. The legal options (which may be abbreviated) are: array anymore arrayName searchId : Returns 1 if there are any more elements left to be processed in an array search, 0 if all elements have already been returned. SearchId indicates which search on arrayName to check, and must have been the return value from a previous invocation of array startsearch . This option is particularly useful if an array has an element with an empty name, since the return value from array nextelement will not indicate whether the search has been completed. array default subcommand arrayName args... : Manages the default value of the array. Arrays initially have no default value, but this command allows you to set one; the default value will be returned when reading from an element of the array arrayName if the read would otherwise result in an error. Note that this may cause the append , dict , incr and lappend commands to change their behavior in relation to non-existing array elements. The subcommand argument controls what exact operation will be performed on the default value of arrayName . Supported subcommand s are: array default exists arrayName : This returns a boolean value indicating whether a default value has been set for the array arrayName . Returns a false value if arrayName does not exist. Raises an error if arrayName is an existing variable that is not an array. array default get arrayName : This returns the current default value for the array arrayName . Raises an error if arrayName is an existing variable that is not an array, or if arrayName is an array without a default value. array default set arrayName value : This sets the default value for the array arrayName to value . Returns the empty string. Raises an error if arrayName is an existing variable that is not an array, or if arrayName is an illegal name for an array. If arrayName does not currently exist, it is created as an empty array as well as having its default value set. array default unset arrayName : This removes the default value for the array arrayName and returns the empty string. Does nothing if arrayName does not have a default value. Raises an error if arrayName is an existing variable that is not an array. array donesearch arrayName searchId : This command terminates an array search and destroys all the state associated with that search. SearchId indicates which search on arrayName to destroy, and must have been the return value from a previous invocation of array startsearch . Returns an empty string. array exists arrayName : Returns 1 if arrayName is an array variable, 0 if there is no variable by that name or if it is a scalar variable. array for { keyVariable valueVariable } arrayName body : The first argument is a two element list of variable names for the key and value of each entry in the array. The second argument is the array name to iterate over. The third argument is the body to execute for each key and value returned. The ordering of the returned keys is undefined. If an array element is deleted or a new array element is inserted during the array for process, the command will terminate with an error. array get arrayName ? pattern ? : Returns a list containing pairs of elements. The first element in each pair is the name of an element in arrayName and the second element of each pair is the value of the array element. The order of the pairs is undefined. If pattern is not specified, then all of the elements of the array are included in the result. If pattern is specified, then only those elements whose names match pattern (using the matching rules of string match ) are included. If arrayName is not the name of an array variable, or if the array contains no elements, then an empty list is returned. If traces on the array modify the list of elements, the elements returned are those that exist both before and after the call to array get . array names arrayName ? mode ? ? pattern ? : Returns a list containing the names of all of the elements in the array that match pattern . Mode may be one of -exact , -glob , or -regexp . If specified, mode designates which matching rules to use to match pattern against the names of the elements in the array. If not specified, mode defaults to -glob . See the documentation for string match for information on glob style matching, and the documentation for regexp for information on regexp matching. If pattern is omitted then the command returns all of the element names in the array. If there are no (matching) elements in the array, or if arrayName is not the name of an array variable, then an empty string is returned. array nextelement arrayName searchId : Returns the name of the next element in arrayName , or an empty string if all elements of arrayName have already been returned in this search. The searchId argument identifies the search, and must have been the return value of an array startsearch command. Warning: if elements are added to or deleted from the array, then all searches are automatically terminated just as if array donesearch had been invoked; this will cause array nextelement operations to fail for those searches. array set arrayName list : Sets the values of one or more elements in arrayName . list must have a form like that returned by array get , consisting of an even number of elements. Each odd-numbered element in list is treated as an element name within arrayName , and the following element in list is used as a new value for that array element. If the variable arrayName does not already exist and list is empty, arrayName is created with an empty array value. array size arrayName : Returns a decimal string giving the number of elements in the array. If arrayName is not the name of an array then 0 is returned. array startsearch arrayName : This command initializes an element-by-element search through the array given by arrayName , such that invocations of the array nextelement command will return the names of the individual elements in the array. When the search has been completed, the array donesearch command should be invoked. The return value is a search identifier that must be used in array nextelement and array donesearch commands; it allows multiple searches to be underway simultaneously for the same array. It is currently more efficient and easier to use either the array get or array names , together with foreach , to iterate over all but very large arrays. See the examples below for how to do this. array statistics arrayName : Returns statistics about the distribution of data within the hashtable that represents the array. This information includes the number of entries in the table, the number of buckets, and the utilization of the buckets. array unset arrayName ? pattern ? : Unsets all of the elements in the array that match pattern (using the matching rules of string match ). If arrayName is not the name of an array variable or there are no matching elements in the array, no error will be raised. If pattern is omitted and arrayName is an array variable, then the command unsets the entire array. The command always returns an empty string. EXAMPLES array set colorcount { red 1 green 5 blue 4 white 9 } foreach {color count} [ array get colorcount] { puts \\\"Color: \\$color Count: \\$count\\\" } \u2192 Color: blue Count: 4 Color: white Count: 9 Color: green Count: 5 Color: red Count: 1 foreach color [ array names colorcount] { puts \\\"Color: \\$color Count: \\$colorcount(\\$color)\\\" } \u2192 Color: blue Count: 4 Color: white Count: 9 Color: green Count: 5 Color: red Count: 1 foreach color [lsort [ array names colorcount]] { puts \\\"Color: \\$color Count: \\$colorcount(\\$color)\\\" } \u2192 Color: blue Count: 4 Color: green Count: 5 Color: red Count: 1 Color: white Count: 9 array statistics colorcount \u2192 4 entries in table, 4 buckets number of buckets with 0 entries: 1 number of buckets with 1 entries: 2 number of buckets with 2 entries: 1 number of buckets with 3 entries: 0 number of buckets with 4 entries: 0 number of buckets with 5 entries: 0 number of buckets with 6 entries: 0 number of buckets with 7 entries: 0 number of buckets with 8 entries: 0 number of buckets with 9 entries: 0 number of buckets with 10 or more entries: 0 average search distance for entry: 1.2 SEE ALSO list(n), string(n), variable(n), trace(n), foreach(n) KEYWORDS array, element names, search","title":"NAME"},{"location":"array/#name","text":"array - Manipulate array variables","title":"NAME"},{"location":"array/#synopsis","text":"array option arrayName ? arg arg ... ?","title":"SYNOPSIS"},{"location":"array/#description","text":"This command performs one of several operations on the variable given by arrayName . Unless otherwise specified for individual commands below, arrayName must be the name of an existing array variable. The option argument determines what action is carried out by the command. The legal options (which may be abbreviated) are: array anymore arrayName searchId : Returns 1 if there are any more elements left to be processed in an array search, 0 if all elements have already been returned. SearchId indicates which search on arrayName to check, and must have been the return value from a previous invocation of array startsearch . This option is particularly useful if an array has an element with an empty name, since the return value from array nextelement will not indicate whether the search has been completed. array default subcommand arrayName args... : Manages the default value of the array. Arrays initially have no default value, but this command allows you to set one; the default value will be returned when reading from an element of the array arrayName if the read would otherwise result in an error. Note that this may cause the append , dict , incr and lappend commands to change their behavior in relation to non-existing array elements. The subcommand argument controls what exact operation will be performed on the default value of arrayName . Supported subcommand s are: array default exists arrayName : This returns a boolean value indicating whether a default value has been set for the array arrayName . Returns a false value if arrayName does not exist. Raises an error if arrayName is an existing variable that is not an array. array default get arrayName : This returns the current default value for the array arrayName . Raises an error if arrayName is an existing variable that is not an array, or if arrayName is an array without a default value. array default set arrayName value : This sets the default value for the array arrayName to value . Returns the empty string. Raises an error if arrayName is an existing variable that is not an array, or if arrayName is an illegal name for an array. If arrayName does not currently exist, it is created as an empty array as well as having its default value set. array default unset arrayName : This removes the default value for the array arrayName and returns the empty string. Does nothing if arrayName does not have a default value. Raises an error if arrayName is an existing variable that is not an array. array donesearch arrayName searchId : This command terminates an array search and destroys all the state associated with that search. SearchId indicates which search on arrayName to destroy, and must have been the return value from a previous invocation of array startsearch . Returns an empty string. array exists arrayName : Returns 1 if arrayName is an array variable, 0 if there is no variable by that name or if it is a scalar variable. array for { keyVariable valueVariable } arrayName body : The first argument is a two element list of variable names for the key and value of each entry in the array. The second argument is the array name to iterate over. The third argument is the body to execute for each key and value returned. The ordering of the returned keys is undefined. If an array element is deleted or a new array element is inserted during the array for process, the command will terminate with an error. array get arrayName ? pattern ? : Returns a list containing pairs of elements. The first element in each pair is the name of an element in arrayName and the second element of each pair is the value of the array element. The order of the pairs is undefined. If pattern is not specified, then all of the elements of the array are included in the result. If pattern is specified, then only those elements whose names match pattern (using the matching rules of string match ) are included. If arrayName is not the name of an array variable, or if the array contains no elements, then an empty list is returned. If traces on the array modify the list of elements, the elements returned are those that exist both before and after the call to array get . array names arrayName ? mode ? ? pattern ? : Returns a list containing the names of all of the elements in the array that match pattern . Mode may be one of -exact , -glob , or -regexp . If specified, mode designates which matching rules to use to match pattern against the names of the elements in the array. If not specified, mode defaults to -glob . See the documentation for string match for information on glob style matching, and the documentation for regexp for information on regexp matching. If pattern is omitted then the command returns all of the element names in the array. If there are no (matching) elements in the array, or if arrayName is not the name of an array variable, then an empty string is returned. array nextelement arrayName searchId : Returns the name of the next element in arrayName , or an empty string if all elements of arrayName have already been returned in this search. The searchId argument identifies the search, and must have been the return value of an array startsearch command. Warning: if elements are added to or deleted from the array, then all searches are automatically terminated just as if array donesearch had been invoked; this will cause array nextelement operations to fail for those searches. array set arrayName list : Sets the values of one or more elements in arrayName . list must have a form like that returned by array get , consisting of an even number of elements. Each odd-numbered element in list is treated as an element name within arrayName , and the following element in list is used as a new value for that array element. If the variable arrayName does not already exist and list is empty, arrayName is created with an empty array value. array size arrayName : Returns a decimal string giving the number of elements in the array. If arrayName is not the name of an array then 0 is returned. array startsearch arrayName : This command initializes an element-by-element search through the array given by arrayName , such that invocations of the array nextelement command will return the names of the individual elements in the array. When the search has been completed, the array donesearch command should be invoked. The return value is a search identifier that must be used in array nextelement and array donesearch commands; it allows multiple searches to be underway simultaneously for the same array. It is currently more efficient and easier to use either the array get or array names , together with foreach , to iterate over all but very large arrays. See the examples below for how to do this. array statistics arrayName : Returns statistics about the distribution of data within the hashtable that represents the array. This information includes the number of entries in the table, the number of buckets, and the utilization of the buckets. array unset arrayName ? pattern ? : Unsets all of the elements in the array that match pattern (using the matching rules of string match ). If arrayName is not the name of an array variable or there are no matching elements in the array, no error will be raised. If pattern is omitted and arrayName is an array variable, then the command unsets the entire array. The command always returns an empty string.","title":"DESCRIPTION"},{"location":"array/#examples","text":"array set colorcount { red 1 green 5 blue 4 white 9 } foreach {color count} [ array get colorcount] { puts \\\"Color: \\$color Count: \\$count\\\" } \u2192 Color: blue Count: 4 Color: white Count: 9 Color: green Count: 5 Color: red Count: 1 foreach color [ array names colorcount] { puts \\\"Color: \\$color Count: \\$colorcount(\\$color)\\\" } \u2192 Color: blue Count: 4 Color: white Count: 9 Color: green Count: 5 Color: red Count: 1 foreach color [lsort [ array names colorcount]] { puts \\\"Color: \\$color Count: \\$colorcount(\\$color)\\\" } \u2192 Color: blue Count: 4 Color: green Count: 5 Color: red Count: 1 Color: white Count: 9 array statistics colorcount \u2192 4 entries in table, 4 buckets number of buckets with 0 entries: 1 number of buckets with 1 entries: 2 number of buckets with 2 entries: 1 number of buckets with 3 entries: 0 number of buckets with 4 entries: 0 number of buckets with 5 entries: 0 number of buckets with 6 entries: 0 number of buckets with 7 entries: 0 number of buckets with 8 entries: 0 number of buckets with 9 entries: 0 number of buckets with 10 or more entries: 0 average search distance for entry: 1.2","title":"EXAMPLES"},{"location":"array/#see-also","text":"list(n), string(n), variable(n), trace(n), foreach(n)","title":"SEE ALSO"},{"location":"array/#keywords","text":"array, element names, search","title":"KEYWORDS"},{"location":"bgerror/","text":"NAME bgerror - Command invoked to process background errors SYNOPSIS bgerror message DESCRIPTION Release 8.5 of Tcl supports the interp bgerror command, which allows applications to register in an interpreter the command that will handle background errors in that interpreter. In older releases of Tcl, this level of control was not available, and applications could control the handling of background errors only by creating a command with the particular command name bgerror in the global namespace of an interpreter. The following documentation describes the interface requirements of the bgerror command an application might define to retain compatibility with pre-8.5 releases of Tcl. Applications intending to support only Tcl releases 8.5 and later should simply make use of interp bgerror . The bgerror command does not exist as built-in part of Tcl. Instead, individual applications or users can define a bgerror command (e.g. as a Tcl procedure) if they wish to handle background errors. A background error is one that occurs in an event handler or some other command that did not originate with the application. For example, if an error occurs while executing a command specified with the after command, then it is a background error. For a non-background error, the error can simply be returned up through nested Tcl command evaluations until it reaches the top-level code in the application; then the application can report the error in whatever way it wishes. When a background error occurs, the unwinding ends in the Tcl library and there is no obvious way for Tcl to report the error. When Tcl detects a background error, it saves information about the error and invokes a handler command registered by interp bgerror later as an idle event handler. The default handler command in turn calls the bgerror command . Before invoking bgerror , Tcl restores the errorInfo and errorCode variables to their values at the time the error occurred, then it invokes bgerror with the error message as its only argument. Tcl assumes that the application has implemented the bgerror command, and that the command will report the error in a way that makes sense for the application. Tcl will ignore any result returned by the bgerror command as long as no error is generated. If another Tcl error occurs within the bgerror command (for example, because no bgerror command has been defined) then Tcl reports the error itself by writing a message to stderr. If several background errors accumulate before bgerror is invoked to process them, bgerror will be invoked once for each error, in the order they occurred. However, if bgerror returns with a break exception, then any remaining errors are skipped without calling bgerror . If you are writing code that will be used by others as part of a package or other kind of library, consider avoiding bgerror . The reason for this is that the application programmer may also want to define a bgerror , or use other code that does and thus will have trouble integrating your code. EXAMPLE This bgerror procedure appends errors to a file, with a timestamp. proc bgerror {message} { set timestamp [clock format [clock seconds]] set fl [open mylog.txt {WRONLY CREAT APPEND}] puts \\$fl \\\"\\$timestamp: bgerror in \\$::argv \\'\\$message\\'\\\" close \\$fl } SEE ALSO after(n), errorCode(n), errorInfo(n), interp(n) KEYWORDS background error, reporting","title":"NAME"},{"location":"bgerror/#name","text":"bgerror - Command invoked to process background errors","title":"NAME"},{"location":"bgerror/#synopsis","text":"bgerror message","title":"SYNOPSIS"},{"location":"bgerror/#description","text":"Release 8.5 of Tcl supports the interp bgerror command, which allows applications to register in an interpreter the command that will handle background errors in that interpreter. In older releases of Tcl, this level of control was not available, and applications could control the handling of background errors only by creating a command with the particular command name bgerror in the global namespace of an interpreter. The following documentation describes the interface requirements of the bgerror command an application might define to retain compatibility with pre-8.5 releases of Tcl. Applications intending to support only Tcl releases 8.5 and later should simply make use of interp bgerror . The bgerror command does not exist as built-in part of Tcl. Instead, individual applications or users can define a bgerror command (e.g. as a Tcl procedure) if they wish to handle background errors. A background error is one that occurs in an event handler or some other command that did not originate with the application. For example, if an error occurs while executing a command specified with the after command, then it is a background error. For a non-background error, the error can simply be returned up through nested Tcl command evaluations until it reaches the top-level code in the application; then the application can report the error in whatever way it wishes. When a background error occurs, the unwinding ends in the Tcl library and there is no obvious way for Tcl to report the error. When Tcl detects a background error, it saves information about the error and invokes a handler command registered by interp bgerror later as an idle event handler. The default handler command in turn calls the bgerror command . Before invoking bgerror , Tcl restores the errorInfo and errorCode variables to their values at the time the error occurred, then it invokes bgerror with the error message as its only argument. Tcl assumes that the application has implemented the bgerror command, and that the command will report the error in a way that makes sense for the application. Tcl will ignore any result returned by the bgerror command as long as no error is generated. If another Tcl error occurs within the bgerror command (for example, because no bgerror command has been defined) then Tcl reports the error itself by writing a message to stderr. If several background errors accumulate before bgerror is invoked to process them, bgerror will be invoked once for each error, in the order they occurred. However, if bgerror returns with a break exception, then any remaining errors are skipped without calling bgerror . If you are writing code that will be used by others as part of a package or other kind of library, consider avoiding bgerror . The reason for this is that the application programmer may also want to define a bgerror , or use other code that does and thus will have trouble integrating your code.","title":"DESCRIPTION"},{"location":"bgerror/#example","text":"This bgerror procedure appends errors to a file, with a timestamp. proc bgerror {message} { set timestamp [clock format [clock seconds]] set fl [open mylog.txt {WRONLY CREAT APPEND}] puts \\$fl \\\"\\$timestamp: bgerror in \\$::argv \\'\\$message\\'\\\" close \\$fl }","title":"EXAMPLE"},{"location":"bgerror/#see-also","text":"after(n), errorCode(n), errorInfo(n), interp(n)","title":"SEE ALSO"},{"location":"bgerror/#keywords","text":"background error, reporting","title":"KEYWORDS"},{"location":"binary/","text":"NAME binary - Insert and extract fields from binary strings SYNOPSIS binary decode format ? -option value ... ? data \\ binary encode format ? -option value ... ? data \\ binary format formatString ? arg arg ... ?\\ binary scan string formatString ? varName varName ... ? DESCRIPTION This command provides facilities for manipulating binary data. The subcommand binary format creates a binary string from normal Tcl values. For example, given the values 16 and 22, on a 32-bit architecture, it might produce an 8-byte binary string consisting of two 4-byte integers, one for each of the numbers. The subcommand binary scan , does the opposite: it extracts data from a binary string and returns it as ordinary Tcl string values. The binary encode and binary decode subcommands convert binary data to or from string encodings such as base64 (used in MIME messages for example). Note that other operations on binary data, such as taking a subsequence of it, getting its length, or reinterpreting it as a string in some encoding, are done by other Tcl commands (respectively string range , string length and encoding convertfrom in the example cases). A binary string in Tcl is merely one where all the characters it contains are in the range \\u0000-\\u00FF. BINARY ENCODE AND DECODE When encoding binary data as a readable string, the starting binary data is passed to the binary encode command, together with the name of the encoding to use and any encoding-specific options desired. Data which has been encoded can be converted back to binary form using binary decode . The binary encode command raises an error if the data argument is not binary data. The following formats and options are supported. base64 : The base64 binary encoding is commonly used in mail messages and XML documents, and uses mostly upper and lower case letters and digits. It has the distinction of being able to be rewrapped arbitrarily without losing information. During encoding, the following options are supported: **-maxlen ***length* : Indicates that the output should be split into lines of no more than *length* characters. By default, lines are not split. **-wrapchar ***character* : Indicates that, when lines are split because of the **-maxlen** option, *character* should be used to separate lines. By default, this is a newline character, During decoding, the following options are supported: **-strict** : Instructs the decoder to throw an error if it encounters any characters that are not strictly part of the encoding itself. Otherwise it ignores them. RFC 2045 calls for base64 decoders to be non-strict. hex : The hex binary encoding converts each byte to a pair of hexadecimal digits that represent the byte value as a hexadecimal integer. When encoding, lower characters are used. When decoding, upper and lower characters are accepted. No options are supported during encoding. During decoding, the following options are supported: **-strict** : Instructs the decoder to throw an error if it encounters whitespace characters. Otherwise it ignores them. uuencode : The uuencode binary encoding used to be common for transfer of data between Unix systems and on USENET, but is less common these days, having been largely superseded by the base64 binary encoding. During encoding, the following options are supported (though changing them may produce files that other implementations of decoders cannot process): **-maxlen ***length* : Indicates the maximum number of characters to produce for each encoded line. The valid range is 5 to 85. Line lengths outside that range cannot be accommodated by the encoding format. The default value is 61. **-wrapchar ***character* : Indicates the character(s) to use to mark the end of each encoded line. Acceptable values are a sequence of zero or more characters from the set { \\\\x09 (TAB), \\\\x0B (VT), \\\\x0C (FF), \\\\x0D (CR) } followed by zero or one newline \\\\x0A (LF). Any other values are rejected because they would generate encoded text that could not be decoded. The default value is a single newline. During decoding, the following options are supported: **-strict** : Instructs the decoder to throw an error if it encounters anything outside of the standard encoding format. Without this option, the decoder tolerates some deviations, mostly to forgive reflows of lines between the encoder and decoder. Note that neither the encoder nor the decoder handle the header and footer of the uuencode format. BINARY FORMAT The binary format command generates a binary string whose layout is specified by the formatString and whose contents come from the additional arguments. The resulting binary value is returned. The formatString consists of a sequence of zero or more field specifiers separated by zero or more spaces. Each field specifier is a single type character followed by an optional flag character followed by an optional numeric count . Most field specifiers consume one argument to obtain the value to be formatted. The type character specifies how the value is to be formatted. The count typically indicates how many items of the specified type are taken from the value. If present, the count is a non-negative decimal integer or which normally indicates that all of the items in the value are to be used. If the number of arguments does not match the number of fields in the format string that consume arguments, then an error is generated. The flag character is ignored for binary format . Here is a small example to clarify the relation between the field specifiers and the arguments: binary format d3d {1.0 2.0 3.0 4.0} 0.1 The first argument is a list of four numbers, but because of the count of 3 for the associated field specifier, only the first three will be used. The second argument is associated with the second field specifier. The resulting binary string contains the four numbers 1.0, 2.0, 3.0 and 0.1. Each type-count pair moves an imaginary cursor through the binary data, storing bytes at the current position and advancing the cursor to just after the last byte stored. The cursor is initially at position 0 at the beginning of the data. The type may be any one of the following characters: a. Stores a byte string of length count in the output string. Every character is taken as modulo 256 (i.e. the low byte of every character is used, and the high byte discarded) so when storing character strings not wholly expressible using the characters \\u0000-\\u00ff, the encoding convertto command should be used first to change the string into an external representation if this truncation is not desired (i.e. if the characters are not part of the ISO 8859-1 character set.) If arg has fewer than count bytes, then additional zero bytes are used to pad out the field. If arg is longer than the specified length, the extra characters will be ignored. If count is then all of the bytes in arg will be formatted. If count is omitted, then one character will be formatted. For example, the command: binary format a7a*a alpha bravo charlie will return a binary string equivalent to: alpha\\000\\000bravoc the command: binary format a* [encoding convertto utf-8 \\u20ac] will return a binary string equivalent to: \\342\\202\\254 (which is the UTF-8 byte sequence for a Euro-currency character), and the command: binary format a* [encoding convertto iso8859-15 \\u20ac] will return a binary string equivalent to: \\244 (which is the ISO 8859-15 byte sequence for a Euro-currency character). Contrast these last two with: binary format a* \\u20ac which returns a binary string equivalent to: \\254 (i.e. \\xac ) by truncating the high-bits of the character, and which is probably not what is desired. A. This form is the same as a except that spaces are used for padding instead of nulls. For example, **binary format** A6A\\*A alpha bravo charlie will return **alpha bravoc** <!-- --> b. Stores a string of count binary digits in low-to-high order within each byte in the output binary string. Arg must contain a sequence of 1 and 0 characters. The resulting bytes are emitted in first to last order with the bits being formatted in low-to-high order within each byte. If arg has fewer than count digits, then zeros will be used for the remaining bits. If arg has more than the specified number of digits, the extra digits will be ignored. If count is then all of the digits in arg will be formatted. If count is omitted, then one digit will be formatted. If the number of bits formatted does not end at a byte boundary, the remaining bits of the last byte will be zeros. For example, binary format b5b* 11100 111000011010 will return a binary string equivalent to: \\x07\\x87\\x05 B. This form is the same as b except that the bits are stored in high-to-low order within each byte. For example, **binary format** B5B\\* 11100 111000011010 will return a binary string equivalent to: **\\\\xe0\\\\xe1\\\\xa0** C. Stores a string of count hexadecimal digits in high-to-low within each byte in the output binary string. Arg must contain a sequence of characters in the set The resulting bytes are emitted in first to last order with the hex digits being formatted in high-to-low order within each byte. If arg has fewer than count digits, then zeros will be used for the remaining digits. If arg has more than the specified number of digits, the extra digits will be ignored. If count is then all of the digits in arg will be formatted. If count is omitted, then one digit will be formatted. If the number of digits formatted does not end at a byte boundary, the remaining bits of the last byte will be zeros. For example, binary format H3H*H2 ab DEF 987 will return a binary string equivalent to: \\xab\\x00\\xde\\xf0\\x98 h. This form is the same as H except that the digits are stored in low-to-high order within each byte. This is seldom required. For example, **binary format** h3h\\*h2 AB def 987 will return a binary string equivalent to: **\\\\xba\\\\x00\\\\xed\\\\x0f\\\\x89** i. Stores one or more 8-bit integer values in the output string. If no count is specified, then arg must consist of an integer value. If count is specified, arg must consist of a list containing at least that many integers. The low-order 8 bits of each integer are stored as a one-byte value at the cursor position. If count is then all of the integers in the list are formatted. If the number of elements in the list is greater than count , then the extra elements are ignored. For example, binary format c3cc* {3 -3 128 1} 260 {2 5} will return a binary string equivalent to: \\x03\\xfd\\x80\\x04\\x02\\x05 whereas: binary format c {2 5} will generate an error. s. This form is the same as c except that it stores one or more 16-bit integers in little-endian byte order in the output string. The low-order 16-bits of each integer are stored as a two-byte value at the cursor position with the least significant byte stored first. For example, **binary format** s3 {3 -3 258 1} will return a binary string equivalent to: **\\\\x03\\\\x00\\\\xfd\\\\xff\\\\x02\\\\x01** <!-- --> S. This form is the same as s except that it stores one or more 16-bit integers in big-endian byte order in the output string. For example, **binary format** S3 {3 -3 258 1} will return a binary string equivalent to: **\\\\x00\\\\x03\\\\xff\\\\xfd\\\\x01\\\\x02** <!-- --> t. This form (mnemonically tiny ) is the same as s and S except that it stores the 16-bit integers in the output string in the native byte order of the machine where the Tcl script is running. To determine what the native byte order of the machine is, refer to the byteOrder element of the tcl_platform array. <!-- --> i. This form is the same as c except that it stores one or more 32-bit integers in little-endian byte order in the output string. The low-order 32-bits of each integer are stored as a four-byte value at the cursor position with the least significant byte stored first. For example, **binary format** i3 {3 -3 65536 1} will return a binary string equivalent to: **\\\\x03\\\\x00\\\\x00\\\\x00\\\\xfd\\\\xff\\\\xff\\\\xff\\\\x00\\\\x00\\\\x01\\\\x00** <!-- --> I. This form is the same as i except that it stores one or more one or more 32-bit integers in big-endian byte order in the output string. For example, **binary format** I3 {3 -3 65536 1} will return a binary string equivalent to: **\\\\x00\\\\x00\\\\x00\\\\x03\\\\xff\\\\xff\\\\xff\\\\xfd\\\\x00\\\\x01\\\\x00\\\\x00** <!-- --> n. This form (mnemonically number or normal ) is the same as i and I except that it stores the 32-bit integers in the output string in the native byte order of the machine where the Tcl script is running. To determine what the native byte order of the machine is, refer to the byteOrder element of the tcl_platform array. o. This form is the same as c except that it stores one or more 64-bit integers in little-endian byte order in the output string. The low-order 64-bits of each integer are stored as an eight-byte value at the cursor position with the least significant byte stored first. For example, **binary format** w 7810179016327718216 will return the binary string **HelloTcl**. <!-- --> W. This form is the same as w except that it stores one or more one or more 64-bit integers in big-endian byte order in the output string. For example, **binary format** Wc 4785469626960341345 110 will return the binary string **BigEndian** <!-- --> m. This form (mnemonically the mirror of w ) is the same as w and W except that it stores the 64-bit integers in the output string in the native byte order of the machine where the Tcl script is running. To determine what the native byte order of the machine is, refer to the byteOrder element of the tcl_platform array. n. This form is the same as c except that it stores one or more one or more single-precision floating point numbers in the machine\\'s native representation in the output string. This representation is not portable across architectures, so it should not be used to communicate floating point numbers across the network. The size of a floating point number may vary across architectures, so the number of bytes that are generated may vary. If the value overflows the machine\\'s native representation, then the value of FLT_MAX as defined by the system will be used instead. Because Tcl uses double-precision floating point numbers internally, there may be some loss of precision in the conversion to single-precision. For example, on a Windows system running on an Intel Pentium processor, **binary format** f2 {1.6 3.4} will return a binary string equivalent to: **\\\\xcd\\\\xcc\\\\xcc\\\\x3f\\\\x9a\\\\x99\\\\x59\\\\x40** o. This form (mnemonically real ) is the same as f except that it stores the single-precision floating point numbers in little-endian order. This conversion only produces meaningful output when used on machines which use the IEEE floating point representation (very common, but not universal.) <!-- --> R. This form is the same as r except that it stores the single-precision floating point numbers in big-endian order. <!-- --> d. This form is the same as f except that it stores one or more one or more double-precision floating point numbers in the machine\\'s native representation in the output string. For example, on a Windows system running on an Intel Pentium processor, **binary format** d1 {1.6} will return a binary string equivalent to: **\\\\x9a\\\\x99\\\\x99\\\\x99\\\\x99\\\\x99\\\\xf9\\\\x3f** e. This form (mnemonically the mirror of d ) is the same as d except that it stores the double-precision floating point numbers in little-endian order. This conversion only produces meaningful output when used on machines which use the IEEE floating point representation (very common, but not universal.) <!-- --> Q. This form is the same as q except that it stores the double-precision floating point numbers in big-endian order. <!-- --> x. Stores count null bytes in the output string. If count is not specified, stores one null byte. If count is generates an error. This type does not consume an argument. For example, binary format a3xa3x2a3 abc def ghi will return a binary string equivalent to: abc\\000def\\000\\000ghi X. Moves the cursor back count bytes in the output string. If count is or is larger than the current cursor position, then the cursor is positioned at location 0 so that the next byte stored will be the first byte in the result string. If count is omitted then the cursor is moved back one byte. This type does not consume an argument. For example, binary format a3X*a3X2a3 abc def ghi will return dghi . Moves the cursor to the absolute location in the output string specified by count . Position 0 refers to the first byte in the output string. If count refers to a position beyond the last byte stored so far, then null bytes will be placed in the uninitialized locations and the cursor will be placed at the specified location. If count is then the cursor is moved to the current end of the output string. If count is omitted, then an error will be generated. This type does not consume an argument. For example, binary format a5@2a1@*a3@10a1 abcde f ghi j will return abfdeghi\\000\\000j BINARY SCAN The binary scan command parses fields from a binary string, returning the number of conversions performed. String gives the input bytes to be parsed and formatString indicates how to parse it. An error is raised if string is anything other than a valid binary data value. Each varName gives the name of a variable; when a field is scanned from string the result is assigned to the corresponding variable. As with binary format , the formatString consists of a sequence of zero or more field specifiers separated by zero or more spaces. Each field specifier is a single type character followed by an optional flag character followed by an optional numeric count . Most field specifiers consume one argument to obtain the variable into which the scanned values should be placed. The type character specifies how the binary data is to be interpreted. The count typically indicates how many items of the specified type are taken from the data. If present, the count is a non-negative decimal integer or which normally indicates that all of the remaining items in the data are to be used. If there are not enough bytes left after the current cursor position to satisfy the current field specifier, then the corresponding variable is left untouched and binary scan returns immediately with the number of variables that were set. If there are not enough arguments for all of the fields in the format string that consume arguments, then an error is generated. The flag character may be given to cause some types to be read as unsigned values. The flag is accepted for all field types but is ignored for non-integer fields. A similar example as with binary format should explain the relation between field specifiers and arguments in case of the binary scan subcommand: binary scan \\$bytes s3s first second This command (provided the binary string in the variable bytes is long enough) assigns a list of three integers to the variable first and assigns a single value to the variable second . If bytes contains fewer than 8 bytes (i.e. four 2-byte integers), no assignment to second will be made, and if bytes contains fewer than 6 bytes (i.e. three 2-byte integers), no assignment to first will be made. Hence: puts [ binary scan abcdefg s3s first second] puts \\$first puts \\$second will print (assuming neither variable is set previously): 1 25185 25699 26213 can\\'t read \\\"second\\\": no such variable It is important to note that the c , s , and S (and i and I on 64bit systems) will be scanned into long data size values. In doing this, values that have their high bit set (0x80 for chars, 0x8000 for shorts, 0x80000000 for ints), will be sign extended. Thus the following will occur: set signShort [ binary format s1 0x8000] binary scan \\$signShort s1 val; # val == 0xFFFF8000 If you require unsigned values you can include the flag character following the field type. For example, to read an unsigned short value: set signShort [ binary format s1 0x8000] binary scan \\$signShort su1 val; # val == 0x00008000 Each type-count pair moves an imaginary cursor through the binary data, reading bytes from the current position. The cursor is initially at position 0 at the beginning of the data. The type may be any one of the following characters: a. The data is a byte string of length count . If count is then all of the remaining bytes in string will be scanned into the variable. If count is omitted, then one byte will be scanned. All bytes scanned will be interpreted as being characters in the range \\u0000-\\u00ff so the encoding convertfrom command will be needed if the string is not a binary string or a string encoded in ISO 8859-1. For example, binary scan abcde\\000fghi a6a10 var1 var2 will return 1 with the string equivalent to abcde\\000 stored in var1 and var2 left unmodified, and binary scan \\342\\202\\254 a* var1 set var2 [encoding convertfrom utf-8 \\$var1] will store a Euro-currency character in var2 . A. This form is the same as a , except trailing blanks and nulls are stripped from the scanned value before it is stored in the variable. For example, **binary scan** \\\"abc efghi \\\\000\\\" A\\* var1 will return **1** with **abc efghi** stored in *var1*. <!-- --> b. The data is turned into a string of count binary digits in low-to-high order represented as a sequence of and characters. The data bytes are scanned in first to last order with the bits being taken in low-to-high order within each byte. Any extra bits in the last byte are ignored. If count is then all of the remaining bits in string will be scanned. If count is omitted, then one bit will be scanned. For example, binary scan \\x07\\x87\\x05 b5b* var1 var2 will return 2 with 11100 stored in var1 and 1110000110100000 stored in var2 . B. This form is the same as b , except the bits are taken in high-to-low order within each byte. For example, **binary scan** \\\\x70\\\\x87\\\\x05 B5B\\* var1 var2 will return **2** with **01110** stored in *var1* and **1000011100000101** stored in *var2*. C. This form is similar to A , except that it scans the data from start and terminates at the first null (C string semantics). For example, **binary scan** \\\"abc\\\\000efghi\\\" C\\* var1 will return **1** with **abc** stored in *var1*. D. The data is turned into a string of count hexadecimal digits in high-to-low order represented as a sequence of characters in the set The data bytes are scanned in first to last order with the hex digits being taken in high-to-low order within each byte. Any extra bits in the last byte are ignored. If count is then all of the remaining hex digits in string will be scanned. If count is omitted, then one hex digit will be scanned. For example, binary scan \\x07\\xC6\\x05\\x1f\\x34 H3H* var1 var2 will return 2 with 07c stored in var1 and 051f34 stored in var2 . h. This form is the same as H , except the digits are taken in reverse (low-to-high) order within each byte. For example, **binary scan** \\\\x07\\\\x86\\\\x05\\\\x12\\\\x34 h3h\\* var1 var2 will return **2** with **706** stored in *var1* and **502143** stored in *var2*. Note that most code that wishes to parse the hexadecimal digits from multiple bytes in order should use the **H** format. i. The data is turned into count 8-bit signed integers and stored in the corresponding variable as a list, or as unsigned if u is placed immediately after the c . If count is then all of the remaining bytes in string will be scanned. If count is omitted, then one 8-bit integer will be scanned. For example, binary scan \\x07\\x86\\x05 c2c* var1 var2 will return 2 with 7 -122 stored in var1 and 5 stored in var2 . Note that the integers returned are signed unless cu in place of c . s. The data is interpreted as count 16-bit signed integers represented in little-endian byte order, or as unsigned if u is placed immediately after the s . The integers are stored in the corresponding variable as a list. If count is then all of the remaining bytes in string will be scanned. If count is omitted, then one 16-bit integer will be scanned. For example, binary scan \\x05\\x00\\x07\\x00\\xf0\\xff s2s* var1 var2 will return 2 with 5 7 stored in var1 and -16 stored in var2 . Note that the integers returned are signed unless su is used in place of s . S. This form is the same as s except that the data is interpreted as count 16-bit integers represented in big-endian byte order. For example, **binary scan** \\\\x00\\\\x05\\\\x00\\\\x07\\\\xff\\\\xf0 S2S\\* var1 var2 will return **2** with **5 7** stored in *var1* and **-16** stored in *var2*. <!-- --> t. The data is interpreted as count 16-bit signed integers represented in the native byte order of the machine running the Tcl script, or as unsigned if u is placed immediately after the t . It is otherwise identical to s and S . To determine what the native byte order of the machine is, refer to the byteOrder element of the tcl_platform array. <!-- --> i. The data is interpreted as count 32-bit signed integers represented in little-endian byte order, or as unsigned if u is placed immediately after the i . The integers are stored in the corresponding variable as a list. If count is then all of the remaining bytes in string will be scanned. If count is omitted, then one 32-bit integer will be scanned. For example, set str \\x05\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\xf0\\xff\\xff\\xff binary scan \\$str i2i* var1 var2 will return 2 with 5 7 stored in var1 and -16 stored in var2 . Note that the integers returned are signed unless iu is used in place of i . I. This form is the same as I except that the data is interpreted as count 32-bit signed integers represented in big-endian byte order, or as unsigned if u is placed immediately after the I . For example, set str \\\\x00\\\\x00\\\\x00\\\\x05\\\\x00\\\\x00\\\\x00\\\\x07\\\\xff\\\\xff\\\\xff\\\\xf0 **binary scan** \\$str I2I\\* var1 var2 will return **2** with **5 7** stored in *var1* and **-16** stored in *var2*. <!-- --> n. The data is interpreted as count 32-bit signed integers represented in the native byte order of the machine running the Tcl script, or as unsigned if u is placed immediately after the n . It is otherwise identical to i and I . To determine what the native byte order of the machine is, refer to the byteOrder element of the tcl_platform array. o. The data is interpreted as count 64-bit signed integers represented in little-endian byte order, or as unsigned if u is placed immediately after the w . The integers are stored in the corresponding variable as a list. If count is then all of the remaining bytes in string will be scanned. If count is omitted, then one 64-bit integer will be scanned. For example, set str \\x05\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\xf0\\xff\\xff\\xff binary scan \\$str wi* var1 var2 will return 2 with 30064771077 stored in var1 and -16 stored in var2 . W. This form is the same as w except that the data is interpreted as count 64-bit signed integers represented in big-endian byte order, or as unsigned if u is placed immediately after the W . For example, set str \\\\x00\\\\x00\\\\x00\\\\x05\\\\x00\\\\x00\\\\x00\\\\x07\\\\xff\\\\xff\\\\xff\\\\xf0 **binary scan** \\$str WI\\* var1 var2 will return **2** with **21474836487** stored in *var1* and **-16** stored in *var2*. <!-- --> m. The data is interpreted as count 64-bit signed integers represented in the native byte order of the machine running the Tcl script, or as unsigned if u is placed immediately after the m . It is otherwise identical to w and W . To determine what the native byte order of the machine is, refer to the byteOrder element of the tcl_platform array. n. The data is interpreted as count single-precision floating point numbers in the machine\\'s native representation. The floating point numbers are stored in the corresponding variable as a list. If count is then all of the remaining bytes in string will be scanned. If count is omitted, then one single-precision floating point number will be scanned. The size of a floating point number may vary across architectures, so the number of bytes that are scanned may vary. If the data does not represent a valid floating point number, the resulting value is undefined and compiler dependent. For example, on a Windows system running on an Intel Pentium processor, binary scan \\x3f\\xcc\\xcc\\xcd f var1 will return 1 with 1.6000000238418579 stored in var1 . r. This form is the same as f except that the data is interpreted as count single-precision floating point number in little-endian order. This conversion is not portable to the minority of systems not using IEEE floating point representations. <!-- --> R. This form is the same as f except that the data is interpreted as count single-precision floating point number in big-endian order. This conversion is not portable to the minority of systems not using IEEE floating point representations. <!-- --> d. This form is the same as f except that the data is interpreted as count double-precision floating point numbers in the machine\\'s native representation. For example, on a Windows system running on an Intel Pentium processor, **binary scan** \\\\x9a\\\\x99\\\\x99\\\\x99\\\\x99\\\\x99\\\\xf9\\\\x3f d var1 will return **1** with **1.6000000000000001** stored in *var1*. e. This form is the same as d except that the data is interpreted as count double-precision floating point number in little-endian order. This conversion is not portable to the minority of systems not using IEEE floating point representations. <!-- --> Q. This form is the same as d except that the data is interpreted as count double-precision floating point number in big-endian order. This conversion is not portable to the minority of systems not using IEEE floating point representations. <!-- --> x. Moves the cursor forward count bytes in string . If count is or is larger than the number of bytes after the current cursor position, then the cursor is positioned after the last byte in string . If count is omitted, then the cursor is moved forward one byte. Note that this type does not consume an argument. For example, binary scan \\x01\\x02\\x03\\x04 x2H* var1 will return 1 with 0304 stored in var1 . X. Moves the cursor back count bytes in string . If count is or is larger than the current cursor position, then the cursor is positioned at location 0 so that the next byte scanned will be the first byte in string . If count is omitted then the cursor is moved back one byte. Note that this type does not consume an argument. For example, binary scan \\x01\\x02\\x03\\x04 c2XH* var1 var2 will return 2 with 1 2 stored in var1 and 020304 stored in var2 . Moves the cursor to the absolute location in the data string specified by count . Note that position 0 refers to the first byte in string . If count refers to a position beyond the end of string , then the cursor is positioned after the last byte. If count is omitted, then an error will be generated. For example, binary scan \\x01\\x02\\x03\\x04 c2@1H* var1 var2 will return 2 with 1 2 stored in var1 and 020304 stored in var2 . PORTABILITY ISSUES The r , R , q and Q conversions will only work reliably for transferring data between computers which are all using IEEE floating point representations. This is very common, but not universal. To transfer floating-point numbers portably between all architectures, use their textual representation (as produced by format ) instead. EXAMPLES This is a procedure to write a Tcl string to a binary-encoded channel as UTF-8 data preceded by a length word: proc writeString {channel string} { set data [encoding convertto utf-8 \\$string] puts -nonewline [ binary format Ia* \\ [string length \\$data] \\$data] } This procedure reads a string from a channel that was written by the previously presented writeString procedure: proc readString {channel} { if {![ binary scan [read \\$channel 4] I length]} { error \\\"missing length\\\" } set data [read \\$channel \\$length] return [encoding convertfrom utf-8 \\$data] } This converts the contents of a file (named in the variable filename ) to base64 and prints them: set f [open \\$filename rb] set data [read \\$f] close \\$f puts [ binary encode base64 -maxlen 64 \\$data] SEE ALSO encoding(n), format(n), scan(n), string(n), tcl_platform(n) KEYWORDS binary, format, scan","title":"NAME"},{"location":"binary/#name","text":"binary - Insert and extract fields from binary strings","title":"NAME"},{"location":"binary/#synopsis","text":"binary decode format ? -option value ... ? data \\ binary encode format ? -option value ... ? data \\ binary format formatString ? arg arg ... ?\\ binary scan string formatString ? varName varName ... ?","title":"SYNOPSIS"},{"location":"binary/#description","text":"This command provides facilities for manipulating binary data. The subcommand binary format creates a binary string from normal Tcl values. For example, given the values 16 and 22, on a 32-bit architecture, it might produce an 8-byte binary string consisting of two 4-byte integers, one for each of the numbers. The subcommand binary scan , does the opposite: it extracts data from a binary string and returns it as ordinary Tcl string values. The binary encode and binary decode subcommands convert binary data to or from string encodings such as base64 (used in MIME messages for example). Note that other operations on binary data, such as taking a subsequence of it, getting its length, or reinterpreting it as a string in some encoding, are done by other Tcl commands (respectively string range , string length and encoding convertfrom in the example cases). A binary string in Tcl is merely one where all the characters it contains are in the range \\u0000-\\u00FF.","title":"DESCRIPTION"},{"location":"binary/#binary-encode-and-decode","text":"When encoding binary data as a readable string, the starting binary data is passed to the binary encode command, together with the name of the encoding to use and any encoding-specific options desired. Data which has been encoded can be converted back to binary form using binary decode . The binary encode command raises an error if the data argument is not binary data. The following formats and options are supported. base64 : The base64 binary encoding is commonly used in mail messages and XML documents, and uses mostly upper and lower case letters and digits. It has the distinction of being able to be rewrapped arbitrarily without losing information. During encoding, the following options are supported: **-maxlen ***length* : Indicates that the output should be split into lines of no more than *length* characters. By default, lines are not split. **-wrapchar ***character* : Indicates that, when lines are split because of the **-maxlen** option, *character* should be used to separate lines. By default, this is a newline character, During decoding, the following options are supported: **-strict** : Instructs the decoder to throw an error if it encounters any characters that are not strictly part of the encoding itself. Otherwise it ignores them. RFC 2045 calls for base64 decoders to be non-strict. hex : The hex binary encoding converts each byte to a pair of hexadecimal digits that represent the byte value as a hexadecimal integer. When encoding, lower characters are used. When decoding, upper and lower characters are accepted. No options are supported during encoding. During decoding, the following options are supported: **-strict** : Instructs the decoder to throw an error if it encounters whitespace characters. Otherwise it ignores them. uuencode : The uuencode binary encoding used to be common for transfer of data between Unix systems and on USENET, but is less common these days, having been largely superseded by the base64 binary encoding. During encoding, the following options are supported (though changing them may produce files that other implementations of decoders cannot process): **-maxlen ***length* : Indicates the maximum number of characters to produce for each encoded line. The valid range is 5 to 85. Line lengths outside that range cannot be accommodated by the encoding format. The default value is 61. **-wrapchar ***character* : Indicates the character(s) to use to mark the end of each encoded line. Acceptable values are a sequence of zero or more characters from the set { \\\\x09 (TAB), \\\\x0B (VT), \\\\x0C (FF), \\\\x0D (CR) } followed by zero or one newline \\\\x0A (LF). Any other values are rejected because they would generate encoded text that could not be decoded. The default value is a single newline. During decoding, the following options are supported: **-strict** : Instructs the decoder to throw an error if it encounters anything outside of the standard encoding format. Without this option, the decoder tolerates some deviations, mostly to forgive reflows of lines between the encoder and decoder. Note that neither the encoder nor the decoder handle the header and footer of the uuencode format.","title":"BINARY ENCODE AND DECODE"},{"location":"binary/#binary-format","text":"The binary format command generates a binary string whose layout is specified by the formatString and whose contents come from the additional arguments. The resulting binary value is returned. The formatString consists of a sequence of zero or more field specifiers separated by zero or more spaces. Each field specifier is a single type character followed by an optional flag character followed by an optional numeric count . Most field specifiers consume one argument to obtain the value to be formatted. The type character specifies how the value is to be formatted. The count typically indicates how many items of the specified type are taken from the value. If present, the count is a non-negative decimal integer or which normally indicates that all of the items in the value are to be used. If the number of arguments does not match the number of fields in the format string that consume arguments, then an error is generated. The flag character is ignored for binary format . Here is a small example to clarify the relation between the field specifiers and the arguments: binary format d3d {1.0 2.0 3.0 4.0} 0.1 The first argument is a list of four numbers, but because of the count of 3 for the associated field specifier, only the first three will be used. The second argument is associated with the second field specifier. The resulting binary string contains the four numbers 1.0, 2.0, 3.0 and 0.1. Each type-count pair moves an imaginary cursor through the binary data, storing bytes at the current position and advancing the cursor to just after the last byte stored. The cursor is initially at position 0 at the beginning of the data. The type may be any one of the following characters: a. Stores a byte string of length count in the output string. Every character is taken as modulo 256 (i.e. the low byte of every character is used, and the high byte discarded) so when storing character strings not wholly expressible using the characters \\u0000-\\u00ff, the encoding convertto command should be used first to change the string into an external representation if this truncation is not desired (i.e. if the characters are not part of the ISO 8859-1 character set.) If arg has fewer than count bytes, then additional zero bytes are used to pad out the field. If arg is longer than the specified length, the extra characters will be ignored. If count is then all of the bytes in arg will be formatted. If count is omitted, then one character will be formatted. For example, the command: binary format a7a*a alpha bravo charlie will return a binary string equivalent to: alpha\\000\\000bravoc the command: binary format a* [encoding convertto utf-8 \\u20ac] will return a binary string equivalent to: \\342\\202\\254 (which is the UTF-8 byte sequence for a Euro-currency character), and the command: binary format a* [encoding convertto iso8859-15 \\u20ac] will return a binary string equivalent to: \\244 (which is the ISO 8859-15 byte sequence for a Euro-currency character). Contrast these last two with: binary format a* \\u20ac which returns a binary string equivalent to: \\254 (i.e. \\xac ) by truncating the high-bits of the character, and which is probably not what is desired. A. This form is the same as a except that spaces are used for padding instead of nulls. For example, **binary format** A6A\\*A alpha bravo charlie will return **alpha bravoc** <!-- --> b. Stores a string of count binary digits in low-to-high order within each byte in the output binary string. Arg must contain a sequence of 1 and 0 characters. The resulting bytes are emitted in first to last order with the bits being formatted in low-to-high order within each byte. If arg has fewer than count digits, then zeros will be used for the remaining bits. If arg has more than the specified number of digits, the extra digits will be ignored. If count is then all of the digits in arg will be formatted. If count is omitted, then one digit will be formatted. If the number of bits formatted does not end at a byte boundary, the remaining bits of the last byte will be zeros. For example, binary format b5b* 11100 111000011010 will return a binary string equivalent to: \\x07\\x87\\x05 B. This form is the same as b except that the bits are stored in high-to-low order within each byte. For example, **binary format** B5B\\* 11100 111000011010 will return a binary string equivalent to: **\\\\xe0\\\\xe1\\\\xa0** C. Stores a string of count hexadecimal digits in high-to-low within each byte in the output binary string. Arg must contain a sequence of characters in the set The resulting bytes are emitted in first to last order with the hex digits being formatted in high-to-low order within each byte. If arg has fewer than count digits, then zeros will be used for the remaining digits. If arg has more than the specified number of digits, the extra digits will be ignored. If count is then all of the digits in arg will be formatted. If count is omitted, then one digit will be formatted. If the number of digits formatted does not end at a byte boundary, the remaining bits of the last byte will be zeros. For example, binary format H3H*H2 ab DEF 987 will return a binary string equivalent to: \\xab\\x00\\xde\\xf0\\x98 h. This form is the same as H except that the digits are stored in low-to-high order within each byte. This is seldom required. For example, **binary format** h3h\\*h2 AB def 987 will return a binary string equivalent to: **\\\\xba\\\\x00\\\\xed\\\\x0f\\\\x89** i. Stores one or more 8-bit integer values in the output string. If no count is specified, then arg must consist of an integer value. If count is specified, arg must consist of a list containing at least that many integers. The low-order 8 bits of each integer are stored as a one-byte value at the cursor position. If count is then all of the integers in the list are formatted. If the number of elements in the list is greater than count , then the extra elements are ignored. For example, binary format c3cc* {3 -3 128 1} 260 {2 5} will return a binary string equivalent to: \\x03\\xfd\\x80\\x04\\x02\\x05 whereas: binary format c {2 5} will generate an error. s. This form is the same as c except that it stores one or more 16-bit integers in little-endian byte order in the output string. The low-order 16-bits of each integer are stored as a two-byte value at the cursor position with the least significant byte stored first. For example, **binary format** s3 {3 -3 258 1} will return a binary string equivalent to: **\\\\x03\\\\x00\\\\xfd\\\\xff\\\\x02\\\\x01** <!-- --> S. This form is the same as s except that it stores one or more 16-bit integers in big-endian byte order in the output string. For example, **binary format** S3 {3 -3 258 1} will return a binary string equivalent to: **\\\\x00\\\\x03\\\\xff\\\\xfd\\\\x01\\\\x02** <!-- --> t. This form (mnemonically tiny ) is the same as s and S except that it stores the 16-bit integers in the output string in the native byte order of the machine where the Tcl script is running. To determine what the native byte order of the machine is, refer to the byteOrder element of the tcl_platform array. <!-- --> i. This form is the same as c except that it stores one or more 32-bit integers in little-endian byte order in the output string. The low-order 32-bits of each integer are stored as a four-byte value at the cursor position with the least significant byte stored first. For example, **binary format** i3 {3 -3 65536 1} will return a binary string equivalent to: **\\\\x03\\\\x00\\\\x00\\\\x00\\\\xfd\\\\xff\\\\xff\\\\xff\\\\x00\\\\x00\\\\x01\\\\x00** <!-- --> I. This form is the same as i except that it stores one or more one or more 32-bit integers in big-endian byte order in the output string. For example, **binary format** I3 {3 -3 65536 1} will return a binary string equivalent to: **\\\\x00\\\\x00\\\\x00\\\\x03\\\\xff\\\\xff\\\\xff\\\\xfd\\\\x00\\\\x01\\\\x00\\\\x00** <!-- --> n. This form (mnemonically number or normal ) is the same as i and I except that it stores the 32-bit integers in the output string in the native byte order of the machine where the Tcl script is running. To determine what the native byte order of the machine is, refer to the byteOrder element of the tcl_platform array. o. This form is the same as c except that it stores one or more 64-bit integers in little-endian byte order in the output string. The low-order 64-bits of each integer are stored as an eight-byte value at the cursor position with the least significant byte stored first. For example, **binary format** w 7810179016327718216 will return the binary string **HelloTcl**. <!-- --> W. This form is the same as w except that it stores one or more one or more 64-bit integers in big-endian byte order in the output string. For example, **binary format** Wc 4785469626960341345 110 will return the binary string **BigEndian** <!-- --> m. This form (mnemonically the mirror of w ) is the same as w and W except that it stores the 64-bit integers in the output string in the native byte order of the machine where the Tcl script is running. To determine what the native byte order of the machine is, refer to the byteOrder element of the tcl_platform array. n. This form is the same as c except that it stores one or more one or more single-precision floating point numbers in the machine\\'s native representation in the output string. This representation is not portable across architectures, so it should not be used to communicate floating point numbers across the network. The size of a floating point number may vary across architectures, so the number of bytes that are generated may vary. If the value overflows the machine\\'s native representation, then the value of FLT_MAX as defined by the system will be used instead. Because Tcl uses double-precision floating point numbers internally, there may be some loss of precision in the conversion to single-precision. For example, on a Windows system running on an Intel Pentium processor, **binary format** f2 {1.6 3.4} will return a binary string equivalent to: **\\\\xcd\\\\xcc\\\\xcc\\\\x3f\\\\x9a\\\\x99\\\\x59\\\\x40** o. This form (mnemonically real ) is the same as f except that it stores the single-precision floating point numbers in little-endian order. This conversion only produces meaningful output when used on machines which use the IEEE floating point representation (very common, but not universal.) <!-- --> R. This form is the same as r except that it stores the single-precision floating point numbers in big-endian order. <!-- --> d. This form is the same as f except that it stores one or more one or more double-precision floating point numbers in the machine\\'s native representation in the output string. For example, on a Windows system running on an Intel Pentium processor, **binary format** d1 {1.6} will return a binary string equivalent to: **\\\\x9a\\\\x99\\\\x99\\\\x99\\\\x99\\\\x99\\\\xf9\\\\x3f** e. This form (mnemonically the mirror of d ) is the same as d except that it stores the double-precision floating point numbers in little-endian order. This conversion only produces meaningful output when used on machines which use the IEEE floating point representation (very common, but not universal.) <!-- --> Q. This form is the same as q except that it stores the double-precision floating point numbers in big-endian order. <!-- --> x. Stores count null bytes in the output string. If count is not specified, stores one null byte. If count is generates an error. This type does not consume an argument. For example, binary format a3xa3x2a3 abc def ghi will return a binary string equivalent to: abc\\000def\\000\\000ghi X. Moves the cursor back count bytes in the output string. If count is or is larger than the current cursor position, then the cursor is positioned at location 0 so that the next byte stored will be the first byte in the result string. If count is omitted then the cursor is moved back one byte. This type does not consume an argument. For example, binary format a3X*a3X2a3 abc def ghi will return dghi . Moves the cursor to the absolute location in the output string specified by count . Position 0 refers to the first byte in the output string. If count refers to a position beyond the last byte stored so far, then null bytes will be placed in the uninitialized locations and the cursor will be placed at the specified location. If count is then the cursor is moved to the current end of the output string. If count is omitted, then an error will be generated. This type does not consume an argument. For example, binary format a5@2a1@*a3@10a1 abcde f ghi j will return abfdeghi\\000\\000j","title":"BINARY FORMAT"},{"location":"binary/#binary-scan","text":"The binary scan command parses fields from a binary string, returning the number of conversions performed. String gives the input bytes to be parsed and formatString indicates how to parse it. An error is raised if string is anything other than a valid binary data value. Each varName gives the name of a variable; when a field is scanned from string the result is assigned to the corresponding variable. As with binary format , the formatString consists of a sequence of zero or more field specifiers separated by zero or more spaces. Each field specifier is a single type character followed by an optional flag character followed by an optional numeric count . Most field specifiers consume one argument to obtain the variable into which the scanned values should be placed. The type character specifies how the binary data is to be interpreted. The count typically indicates how many items of the specified type are taken from the data. If present, the count is a non-negative decimal integer or which normally indicates that all of the remaining items in the data are to be used. If there are not enough bytes left after the current cursor position to satisfy the current field specifier, then the corresponding variable is left untouched and binary scan returns immediately with the number of variables that were set. If there are not enough arguments for all of the fields in the format string that consume arguments, then an error is generated. The flag character may be given to cause some types to be read as unsigned values. The flag is accepted for all field types but is ignored for non-integer fields. A similar example as with binary format should explain the relation between field specifiers and arguments in case of the binary scan subcommand: binary scan \\$bytes s3s first second This command (provided the binary string in the variable bytes is long enough) assigns a list of three integers to the variable first and assigns a single value to the variable second . If bytes contains fewer than 8 bytes (i.e. four 2-byte integers), no assignment to second will be made, and if bytes contains fewer than 6 bytes (i.e. three 2-byte integers), no assignment to first will be made. Hence: puts [ binary scan abcdefg s3s first second] puts \\$first puts \\$second will print (assuming neither variable is set previously): 1 25185 25699 26213 can\\'t read \\\"second\\\": no such variable It is important to note that the c , s , and S (and i and I on 64bit systems) will be scanned into long data size values. In doing this, values that have their high bit set (0x80 for chars, 0x8000 for shorts, 0x80000000 for ints), will be sign extended. Thus the following will occur: set signShort [ binary format s1 0x8000] binary scan \\$signShort s1 val; # val == 0xFFFF8000 If you require unsigned values you can include the flag character following the field type. For example, to read an unsigned short value: set signShort [ binary format s1 0x8000] binary scan \\$signShort su1 val; # val == 0x00008000 Each type-count pair moves an imaginary cursor through the binary data, reading bytes from the current position. The cursor is initially at position 0 at the beginning of the data. The type may be any one of the following characters: a. The data is a byte string of length count . If count is then all of the remaining bytes in string will be scanned into the variable. If count is omitted, then one byte will be scanned. All bytes scanned will be interpreted as being characters in the range \\u0000-\\u00ff so the encoding convertfrom command will be needed if the string is not a binary string or a string encoded in ISO 8859-1. For example, binary scan abcde\\000fghi a6a10 var1 var2 will return 1 with the string equivalent to abcde\\000 stored in var1 and var2 left unmodified, and binary scan \\342\\202\\254 a* var1 set var2 [encoding convertfrom utf-8 \\$var1] will store a Euro-currency character in var2 . A. This form is the same as a , except trailing blanks and nulls are stripped from the scanned value before it is stored in the variable. For example, **binary scan** \\\"abc efghi \\\\000\\\" A\\* var1 will return **1** with **abc efghi** stored in *var1*. <!-- --> b. The data is turned into a string of count binary digits in low-to-high order represented as a sequence of and characters. The data bytes are scanned in first to last order with the bits being taken in low-to-high order within each byte. Any extra bits in the last byte are ignored. If count is then all of the remaining bits in string will be scanned. If count is omitted, then one bit will be scanned. For example, binary scan \\x07\\x87\\x05 b5b* var1 var2 will return 2 with 11100 stored in var1 and 1110000110100000 stored in var2 . B. This form is the same as b , except the bits are taken in high-to-low order within each byte. For example, **binary scan** \\\\x70\\\\x87\\\\x05 B5B\\* var1 var2 will return **2** with **01110** stored in *var1* and **1000011100000101** stored in *var2*. C. This form is similar to A , except that it scans the data from start and terminates at the first null (C string semantics). For example, **binary scan** \\\"abc\\\\000efghi\\\" C\\* var1 will return **1** with **abc** stored in *var1*. D. The data is turned into a string of count hexadecimal digits in high-to-low order represented as a sequence of characters in the set The data bytes are scanned in first to last order with the hex digits being taken in high-to-low order within each byte. Any extra bits in the last byte are ignored. If count is then all of the remaining hex digits in string will be scanned. If count is omitted, then one hex digit will be scanned. For example, binary scan \\x07\\xC6\\x05\\x1f\\x34 H3H* var1 var2 will return 2 with 07c stored in var1 and 051f34 stored in var2 . h. This form is the same as H , except the digits are taken in reverse (low-to-high) order within each byte. For example, **binary scan** \\\\x07\\\\x86\\\\x05\\\\x12\\\\x34 h3h\\* var1 var2 will return **2** with **706** stored in *var1* and **502143** stored in *var2*. Note that most code that wishes to parse the hexadecimal digits from multiple bytes in order should use the **H** format. i. The data is turned into count 8-bit signed integers and stored in the corresponding variable as a list, or as unsigned if u is placed immediately after the c . If count is then all of the remaining bytes in string will be scanned. If count is omitted, then one 8-bit integer will be scanned. For example, binary scan \\x07\\x86\\x05 c2c* var1 var2 will return 2 with 7 -122 stored in var1 and 5 stored in var2 . Note that the integers returned are signed unless cu in place of c . s. The data is interpreted as count 16-bit signed integers represented in little-endian byte order, or as unsigned if u is placed immediately after the s . The integers are stored in the corresponding variable as a list. If count is then all of the remaining bytes in string will be scanned. If count is omitted, then one 16-bit integer will be scanned. For example, binary scan \\x05\\x00\\x07\\x00\\xf0\\xff s2s* var1 var2 will return 2 with 5 7 stored in var1 and -16 stored in var2 . Note that the integers returned are signed unless su is used in place of s . S. This form is the same as s except that the data is interpreted as count 16-bit integers represented in big-endian byte order. For example, **binary scan** \\\\x00\\\\x05\\\\x00\\\\x07\\\\xff\\\\xf0 S2S\\* var1 var2 will return **2** with **5 7** stored in *var1* and **-16** stored in *var2*. <!-- --> t. The data is interpreted as count 16-bit signed integers represented in the native byte order of the machine running the Tcl script, or as unsigned if u is placed immediately after the t . It is otherwise identical to s and S . To determine what the native byte order of the machine is, refer to the byteOrder element of the tcl_platform array. <!-- --> i. The data is interpreted as count 32-bit signed integers represented in little-endian byte order, or as unsigned if u is placed immediately after the i . The integers are stored in the corresponding variable as a list. If count is then all of the remaining bytes in string will be scanned. If count is omitted, then one 32-bit integer will be scanned. For example, set str \\x05\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\xf0\\xff\\xff\\xff binary scan \\$str i2i* var1 var2 will return 2 with 5 7 stored in var1 and -16 stored in var2 . Note that the integers returned are signed unless iu is used in place of i . I. This form is the same as I except that the data is interpreted as count 32-bit signed integers represented in big-endian byte order, or as unsigned if u is placed immediately after the I . For example, set str \\\\x00\\\\x00\\\\x00\\\\x05\\\\x00\\\\x00\\\\x00\\\\x07\\\\xff\\\\xff\\\\xff\\\\xf0 **binary scan** \\$str I2I\\* var1 var2 will return **2** with **5 7** stored in *var1* and **-16** stored in *var2*. <!-- --> n. The data is interpreted as count 32-bit signed integers represented in the native byte order of the machine running the Tcl script, or as unsigned if u is placed immediately after the n . It is otherwise identical to i and I . To determine what the native byte order of the machine is, refer to the byteOrder element of the tcl_platform array. o. The data is interpreted as count 64-bit signed integers represented in little-endian byte order, or as unsigned if u is placed immediately after the w . The integers are stored in the corresponding variable as a list. If count is then all of the remaining bytes in string will be scanned. If count is omitted, then one 64-bit integer will be scanned. For example, set str \\x05\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\xf0\\xff\\xff\\xff binary scan \\$str wi* var1 var2 will return 2 with 30064771077 stored in var1 and -16 stored in var2 . W. This form is the same as w except that the data is interpreted as count 64-bit signed integers represented in big-endian byte order, or as unsigned if u is placed immediately after the W . For example, set str \\\\x00\\\\x00\\\\x00\\\\x05\\\\x00\\\\x00\\\\x00\\\\x07\\\\xff\\\\xff\\\\xff\\\\xf0 **binary scan** \\$str WI\\* var1 var2 will return **2** with **21474836487** stored in *var1* and **-16** stored in *var2*. <!-- --> m. The data is interpreted as count 64-bit signed integers represented in the native byte order of the machine running the Tcl script, or as unsigned if u is placed immediately after the m . It is otherwise identical to w and W . To determine what the native byte order of the machine is, refer to the byteOrder element of the tcl_platform array. n. The data is interpreted as count single-precision floating point numbers in the machine\\'s native representation. The floating point numbers are stored in the corresponding variable as a list. If count is then all of the remaining bytes in string will be scanned. If count is omitted, then one single-precision floating point number will be scanned. The size of a floating point number may vary across architectures, so the number of bytes that are scanned may vary. If the data does not represent a valid floating point number, the resulting value is undefined and compiler dependent. For example, on a Windows system running on an Intel Pentium processor, binary scan \\x3f\\xcc\\xcc\\xcd f var1 will return 1 with 1.6000000238418579 stored in var1 . r. This form is the same as f except that the data is interpreted as count single-precision floating point number in little-endian order. This conversion is not portable to the minority of systems not using IEEE floating point representations. <!-- --> R. This form is the same as f except that the data is interpreted as count single-precision floating point number in big-endian order. This conversion is not portable to the minority of systems not using IEEE floating point representations. <!-- --> d. This form is the same as f except that the data is interpreted as count double-precision floating point numbers in the machine\\'s native representation. For example, on a Windows system running on an Intel Pentium processor, **binary scan** \\\\x9a\\\\x99\\\\x99\\\\x99\\\\x99\\\\x99\\\\xf9\\\\x3f d var1 will return **1** with **1.6000000000000001** stored in *var1*. e. This form is the same as d except that the data is interpreted as count double-precision floating point number in little-endian order. This conversion is not portable to the minority of systems not using IEEE floating point representations. <!-- --> Q. This form is the same as d except that the data is interpreted as count double-precision floating point number in big-endian order. This conversion is not portable to the minority of systems not using IEEE floating point representations. <!-- --> x. Moves the cursor forward count bytes in string . If count is or is larger than the number of bytes after the current cursor position, then the cursor is positioned after the last byte in string . If count is omitted, then the cursor is moved forward one byte. Note that this type does not consume an argument. For example, binary scan \\x01\\x02\\x03\\x04 x2H* var1 will return 1 with 0304 stored in var1 . X. Moves the cursor back count bytes in string . If count is or is larger than the current cursor position, then the cursor is positioned at location 0 so that the next byte scanned will be the first byte in string . If count is omitted then the cursor is moved back one byte. Note that this type does not consume an argument. For example, binary scan \\x01\\x02\\x03\\x04 c2XH* var1 var2 will return 2 with 1 2 stored in var1 and 020304 stored in var2 . Moves the cursor to the absolute location in the data string specified by count . Note that position 0 refers to the first byte in string . If count refers to a position beyond the end of string , then the cursor is positioned after the last byte. If count is omitted, then an error will be generated. For example, binary scan \\x01\\x02\\x03\\x04 c2@1H* var1 var2 will return 2 with 1 2 stored in var1 and 020304 stored in var2 .","title":"BINARY SCAN"},{"location":"binary/#portability-issues","text":"The r , R , q and Q conversions will only work reliably for transferring data between computers which are all using IEEE floating point representations. This is very common, but not universal. To transfer floating-point numbers portably between all architectures, use their textual representation (as produced by format ) instead.","title":"PORTABILITY ISSUES"},{"location":"binary/#examples","text":"This is a procedure to write a Tcl string to a binary-encoded channel as UTF-8 data preceded by a length word: proc writeString {channel string} { set data [encoding convertto utf-8 \\$string] puts -nonewline [ binary format Ia* \\ [string length \\$data] \\$data] } This procedure reads a string from a channel that was written by the previously presented writeString procedure: proc readString {channel} { if {![ binary scan [read \\$channel 4] I length]} { error \\\"missing length\\\" } set data [read \\$channel \\$length] return [encoding convertfrom utf-8 \\$data] } This converts the contents of a file (named in the variable filename ) to base64 and prints them: set f [open \\$filename rb] set data [read \\$f] close \\$f puts [ binary encode base64 -maxlen 64 \\$data]","title":"EXAMPLES"},{"location":"binary/#see-also","text":"encoding(n), format(n), scan(n), string(n), tcl_platform(n)","title":"SEE ALSO"},{"location":"binary/#keywords","text":"binary, format, scan","title":"KEYWORDS"},{"location":"break/","text":"NAME break - Abort looping command SYNOPSIS break DESCRIPTION This command is typically invoked inside the body of a looping command such as for or foreach or while . It returns a 3 ( TCL_BREAK ) result code, which causes a break exception to occur. The exception causes the current script to be aborted out to the innermost containing loop command, which then aborts its execution and returns normally. Break exceptions are also handled in a few other situations, such as the catch command, Tk event bindings, and the outermost scripts of procedure bodies. EXAMPLE Print a line for each of the integers from 0 to 5: for {set x 0} {\\$x\\<10} {incr x} { if {\\$x > 5} { break } puts \\\"x is \\$x\\\" } SEE ALSO catch(n), continue(n), for(n), foreach(n), return(n), while(n) KEYWORDS abort, break, loop","title":"NAME"},{"location":"break/#name","text":"break - Abort looping command","title":"NAME"},{"location":"break/#synopsis","text":"break","title":"SYNOPSIS"},{"location":"break/#description","text":"This command is typically invoked inside the body of a looping command such as for or foreach or while . It returns a 3 ( TCL_BREAK ) result code, which causes a break exception to occur. The exception causes the current script to be aborted out to the innermost containing loop command, which then aborts its execution and returns normally. Break exceptions are also handled in a few other situations, such as the catch command, Tk event bindings, and the outermost scripts of procedure bodies.","title":"DESCRIPTION"},{"location":"break/#example","text":"Print a line for each of the integers from 0 to 5: for {set x 0} {\\$x\\<10} {incr x} { if {\\$x > 5} { break } puts \\\"x is \\$x\\\" }","title":"EXAMPLE"},{"location":"break/#see-also","text":"catch(n), continue(n), for(n), foreach(n), return(n), while(n)","title":"SEE ALSO"},{"location":"break/#keywords","text":"abort, break, loop","title":"KEYWORDS"},{"location":"callback/","text":"NAME callback, mymethod - generate callbacks to methods SYNOPSIS package require tcl::oo callback methodName ?arg ...? mymethod methodName ?arg ...? DESCRIPTION The callback command, also called mymethod for compatibility with the ooutil and snit packages of Tcllib, and which should only be used from within the context of a call to a method (i.e. inside a method, constructor or destructor body) is used to generate a script fragment that will invoke the method, methodName , on the current object (as reported by self ) when executed. Any additional arguments provided will be provided as leading arguments to the callback. The resulting script fragment shall be a proper list. Note that it is up to the caller to ensure that the current object is able to handle the call of methodName ; this command does not check that. methodName may refer to any exported or unexported method, but may not refer to a private method as those can only be invoked directly from within methods. If there is no such method present at the point when the callback is invoked, the standard unknown method handler will be called. EXAMPLE This is a simple echo server class. The callback command is used in two places, to arrange for the incoming socket connections to be handled by the Accept method, and to arrange for the incoming bytes on those connections to be handled by the Receive method. oo::class create EchoServer { variable server clients constructor {port} { set server [socket -server [ callback Accept] \\$port] set clients {} } destructor { chan close \\$server foreach client [dict keys \\$clients] { chan close \\$client } } method Accept {channel clientAddress clientPort} { dict set clients \\$channel [dict create \\ address \\$clientAddress port \\$clientPort] chan event \\$channel readable [ callback Receive \\$channel] } method Receive {channel} { if {[chan gets \\$channel line] >= 0} { my echo \\$channel \\$line } else { chan close \\$channel dict unset clients \\$channel } } method echo {channel line} { dict with clients \\$channel { chan puts \\$channel \\ [format {[%s:%d] %s} \\$address \\$port \\$line] } } } SEE ALSO chan(n), fileevent(n), my(n), self(n), socket(n), trace(n) KEYWORDS callback, object","title":"NAME"},{"location":"callback/#name","text":"callback, mymethod - generate callbacks to methods","title":"NAME"},{"location":"callback/#synopsis","text":"package require tcl::oo callback methodName ?arg ...? mymethod methodName ?arg ...?","title":"SYNOPSIS"},{"location":"callback/#description","text":"The callback command, also called mymethod for compatibility with the ooutil and snit packages of Tcllib, and which should only be used from within the context of a call to a method (i.e. inside a method, constructor or destructor body) is used to generate a script fragment that will invoke the method, methodName , on the current object (as reported by self ) when executed. Any additional arguments provided will be provided as leading arguments to the callback. The resulting script fragment shall be a proper list. Note that it is up to the caller to ensure that the current object is able to handle the call of methodName ; this command does not check that. methodName may refer to any exported or unexported method, but may not refer to a private method as those can only be invoked directly from within methods. If there is no such method present at the point when the callback is invoked, the standard unknown method handler will be called.","title":"DESCRIPTION"},{"location":"callback/#example","text":"This is a simple echo server class. The callback command is used in two places, to arrange for the incoming socket connections to be handled by the Accept method, and to arrange for the incoming bytes on those connections to be handled by the Receive method. oo::class create EchoServer { variable server clients constructor {port} { set server [socket -server [ callback Accept] \\$port] set clients {} } destructor { chan close \\$server foreach client [dict keys \\$clients] { chan close \\$client } } method Accept {channel clientAddress clientPort} { dict set clients \\$channel [dict create \\ address \\$clientAddress port \\$clientPort] chan event \\$channel readable [ callback Receive \\$channel] } method Receive {channel} { if {[chan gets \\$channel line] >= 0} { my echo \\$channel \\$line } else { chan close \\$channel dict unset clients \\$channel } } method echo {channel line} { dict with clients \\$channel { chan puts \\$channel \\ [format {[%s:%d] %s} \\$address \\$port \\$line] } } }","title":"EXAMPLE"},{"location":"callback/#see-also","text":"chan(n), fileevent(n), my(n), self(n), socket(n), trace(n)","title":"SEE ALSO"},{"location":"callback/#keywords","text":"callback, object","title":"KEYWORDS"},{"location":"catch/","text":"NAME catch - Evaluate script and trap exceptional returns SYNOPSIS catch script ? resultVarName ? ? optionsVarName ? DESCRIPTION The catch command may be used to prevent errors from aborting command interpretation. The catch command calls the Tcl interpreter recursively to execute script , and always returns without raising an error, regardless of any errors that might occur while executing script . If script raises an error, catch will return a non-zero integer value corresponding to the exceptional return code returned by evaluation of script . Tcl defines the normal return code from script evaluation to be zero (0), or TCL_OK . Tcl also defines four exceptional return codes: 1 ( TCL_ERROR ), 2 ( TCL_RETURN ), 3 ( TCL_BREAK ), and 4 ( TCL_CONTINUE ). Errors during evaluation of a script are indicated by a return code of TCL_ERROR . The other exceptional return codes are returned by the return , break , and continue commands and in other special situations as documented. Tcl packages can define new commands that return other integer values as return codes as well, and scripts that make use of the return -code command can also have return codes other than the five defined by Tcl. If the resultVarName argument is given, then the variable it names is set to the result of the script evaluation. When the return code from the script is 1 ( TCL_ERROR ), the value stored in resultVarName is an error message. When the return code from the script is 0 ( TCL_OK ), the value stored in resultVarName is the value returned from script . If the optionsVarName argument is given, then the variable it names is set to a dictionary of return options returned by evaluation of script . Tcl specifies two entries that are always defined in the dictionary: -code and -level . When the return code from evaluation of script is not TCL_RETURN , the value of the -level entry will be 0, and the value of the -code entry will be the same as the return code. Only when the return code is TCL_RETURN will the values of the -level and -code entries be something else, as further described in the documentation for the return command. When the return code from evaluation of script is TCL_ERROR , four additional entries are defined in the dictionary of return options stored in optionsVarName : -errorinfo , -errorcode , -errorline , and -errorstack . The value of the -errorinfo entry is a formatted stack trace containing more information about the context in which the error happened. The formatted stack trace is meant to be read by a person. The value of the -errorcode entry is additional information about the error stored as a list. The -errorcode value is meant to be further processed by programs, and may not be particularly readable by people. The value of the -errorline entry is an integer indicating which line of script was being evaluated when the error occurred. The value of the -errorstack entry is an even-sized list made of token-parameter pairs accumulated while unwinding the stack. The token may be in which case the parameter is a list made of the proc name and arguments at the corresponding level; or it may be in which case the parameter is the relative level (as in uplevel ) of the previous CALL . The salient differences with respect to -errorinfo are that: [1] : it is a machine-readable form that is amenable to processing with [ foreach {tok prm} ...], [2] : it contains the true (substituted) values passed to the functions, instead of the static text of the calling sites, and [3] : it is coarser-grained, with only one element per stack frame (like procs; no separate elements for foreach constructs for example). The values of the -errorinfo and -errorcode entries of the most recent error are also available as values of the global variables ::errorInfo and ::errorCode respectively. The value of the -errorstack entry surfaces as info errorstack . Tcl packages may provide commands that set other entries in the dictionary of return options, and the return command may be used by scripts to set return options in addition to those defined above. EXAMPLES The catch command may be used in an if to branch based on the success of a script. if { [ catch {open \\$someFile w} fid] } { puts stderr \\\"Could not open \\$someFile for writing\\n\\$fid\\\" exit 1 } There are more complex examples of catch usage in the documentation for the return command. SEE ALSO break(n), continue(n), dict(n), error(n), errorCode(n), errorInfo(n), info(n), return(n) KEYWORDS catch, error, exception","title":"NAME"},{"location":"catch/#name","text":"catch - Evaluate script and trap exceptional returns","title":"NAME"},{"location":"catch/#synopsis","text":"catch script ? resultVarName ? ? optionsVarName ?","title":"SYNOPSIS"},{"location":"catch/#description","text":"The catch command may be used to prevent errors from aborting command interpretation. The catch command calls the Tcl interpreter recursively to execute script , and always returns without raising an error, regardless of any errors that might occur while executing script . If script raises an error, catch will return a non-zero integer value corresponding to the exceptional return code returned by evaluation of script . Tcl defines the normal return code from script evaluation to be zero (0), or TCL_OK . Tcl also defines four exceptional return codes: 1 ( TCL_ERROR ), 2 ( TCL_RETURN ), 3 ( TCL_BREAK ), and 4 ( TCL_CONTINUE ). Errors during evaluation of a script are indicated by a return code of TCL_ERROR . The other exceptional return codes are returned by the return , break , and continue commands and in other special situations as documented. Tcl packages can define new commands that return other integer values as return codes as well, and scripts that make use of the return -code command can also have return codes other than the five defined by Tcl. If the resultVarName argument is given, then the variable it names is set to the result of the script evaluation. When the return code from the script is 1 ( TCL_ERROR ), the value stored in resultVarName is an error message. When the return code from the script is 0 ( TCL_OK ), the value stored in resultVarName is the value returned from script . If the optionsVarName argument is given, then the variable it names is set to a dictionary of return options returned by evaluation of script . Tcl specifies two entries that are always defined in the dictionary: -code and -level . When the return code from evaluation of script is not TCL_RETURN , the value of the -level entry will be 0, and the value of the -code entry will be the same as the return code. Only when the return code is TCL_RETURN will the values of the -level and -code entries be something else, as further described in the documentation for the return command. When the return code from evaluation of script is TCL_ERROR , four additional entries are defined in the dictionary of return options stored in optionsVarName : -errorinfo , -errorcode , -errorline , and -errorstack . The value of the -errorinfo entry is a formatted stack trace containing more information about the context in which the error happened. The formatted stack trace is meant to be read by a person. The value of the -errorcode entry is additional information about the error stored as a list. The -errorcode value is meant to be further processed by programs, and may not be particularly readable by people. The value of the -errorline entry is an integer indicating which line of script was being evaluated when the error occurred. The value of the -errorstack entry is an even-sized list made of token-parameter pairs accumulated while unwinding the stack. The token may be in which case the parameter is a list made of the proc name and arguments at the corresponding level; or it may be in which case the parameter is the relative level (as in uplevel ) of the previous CALL . The salient differences with respect to -errorinfo are that: [1] : it is a machine-readable form that is amenable to processing with [ foreach {tok prm} ...], [2] : it contains the true (substituted) values passed to the functions, instead of the static text of the calling sites, and [3] : it is coarser-grained, with only one element per stack frame (like procs; no separate elements for foreach constructs for example). The values of the -errorinfo and -errorcode entries of the most recent error are also available as values of the global variables ::errorInfo and ::errorCode respectively. The value of the -errorstack entry surfaces as info errorstack . Tcl packages may provide commands that set other entries in the dictionary of return options, and the return command may be used by scripts to set return options in addition to those defined above.","title":"DESCRIPTION"},{"location":"catch/#examples","text":"The catch command may be used in an if to branch based on the success of a script. if { [ catch {open \\$someFile w} fid] } { puts stderr \\\"Could not open \\$someFile for writing\\n\\$fid\\\" exit 1 } There are more complex examples of catch usage in the documentation for the return command.","title":"EXAMPLES"},{"location":"catch/#see-also","text":"break(n), continue(n), dict(n), error(n), errorCode(n), errorInfo(n), info(n), return(n)","title":"SEE ALSO"},{"location":"catch/#keywords","text":"catch, error, exception","title":"KEYWORDS"},{"location":"cd/","text":"NAME cd - Change working directory SYNOPSIS cd ? dirName ? DESCRIPTION Change the current working directory to dirName , or to the home directory (as specified in the HOME environment variable) if dirName is not given. Returns an empty string. Note that the current working directory is a per-process resource; the cd command changes the working directory for all interpreters and all threads. EXAMPLES Change to the home directory of the user fred : cd [file home fred] Change to the directory lib that is a sibling directory of the current one: cd ../lib SEE ALSO filename(n), glob(n), pwd(n) KEYWORDS working directory","title":"NAME"},{"location":"cd/#name","text":"cd - Change working directory","title":"NAME"},{"location":"cd/#synopsis","text":"cd ? dirName ?","title":"SYNOPSIS"},{"location":"cd/#description","text":"Change the current working directory to dirName , or to the home directory (as specified in the HOME environment variable) if dirName is not given. Returns an empty string. Note that the current working directory is a per-process resource; the cd command changes the working directory for all interpreters and all threads.","title":"DESCRIPTION"},{"location":"cd/#examples","text":"Change to the home directory of the user fred : cd [file home fred] Change to the directory lib that is a sibling directory of the current one: cd ../lib","title":"EXAMPLES"},{"location":"cd/#see-also","text":"filename(n), glob(n), pwd(n)","title":"SEE ALSO"},{"location":"cd/#keywords","text":"working directory","title":"KEYWORDS"},{"location":"chan/","text":"NAME chan - Reads, writes and manipulates channels. SYNOPSIS chan operation ? arg arg ... ? DESCRIPTION chan provides several operations for reading from, writing to, and otherwise manipulating channels, e.g. those created by open and socket , or the default channels stdin , stdout or stderr which correspond respectively to the standard input, output, and error streams of the process. Any unique abbreviation for operation is acceptable. Available operations are: chan blocked channelName : Returns 1 when the channel is in non-blocking mode and the last input operation on the channel failed because it would have otherwise caused the process to block, and 0 otherwise. Each Tcl channel is in blocking mode unless configured otherwise. chan close channelName ? direction ? : Closes and destroys the named channel, deleting any existing event handlers established for the channel, and returns the empty string. If direction is given, it is or or any unique abbreviation of those words, and only that side of the channel is closed. I.e. a read-write channel may become read-only or write-only. Closing a read-only channel for reading, or closing a write-only channel for writing is the same as simply closing the channel. It is an error to close a read-only channel for writing or to close a write-only channel for reading. When a channel is closed for writing, any buffered output on the channel is flushed. When a channel is closed for reading, any buffered input is discarded. When a channel is destroyed the underlying resource is closed and the channel is thereafter unavailable. chan close fully flushes any output before closing the write side of a channel unless it is non-blocking mode, where it returns immediately and the channel is flushed in the background before finally being closed. chan close may return an error if an error occurs while flushing output. If a process in a command pipeline created by open returns an error, chan close generates an error in the same manner as exec . Closing one side of a socket or command pipeline may lead to the shutdown() or close() of the underlying system resource, leading to a reaction from whatever is on the other side of the pipeline or socket. If the channel for a command pipeline is in blocking mode, chan close waits for the connected processes to complete. chan close only affects the current interpreter. If the channel is open in any other interpreter, its state is unchanged there. See interp for a description of channel sharing. When the last interpreter sharing a channel is destroyed, the channel is switched to blocking mode and fully flushed and then closed. chan configure channelName ? optionName ? ? value ? ? optionName value ?... : Configures or reports the configuration of channelName . If no *optionName* or *value* arguments are given, **chan configure** returns a dictionary of option names and values for the channel. If *optionName* is supplied without a *value*, **chan configure** returns the current value of the named option. If one or more pairs of *optionName* and *value* are supplied, **chan configure** sets each of the named options to the corresponding *value* and returns the empty string. The options described below are supported for all channels. Each type of channel may provide additional options. Those options are described in the relevant documentation. For example, additional options are documented for **socket**, and also for serial devices at **open**. **-blocking** *boolean* : If **-blocking** is set to **true**, which is the default, reading from or writing to the channel may cause the process to block indefinitely. Otherwise, operations such as **chan gets**, **chan read**, **chan puts**, **chan** flush, and **chan close** take care not to block. Non-blocking mode in generally requires that the event loop is entered, e.g. by calling **Tcl_DoOneEvent** or **vwait** or by using Tk, to give Tcl a chance to process events on the channel. **-buffering** *newValue* : If *newValue* is **full**, which is the default, output is buffered until the internal buffer is full or until **chan flush** is called. If *newValue* is **line**, output is flushed each time a end-of-line character is written. If *newValue* is **none**, output is flushed after every output operation. For **stdin**, **stdout**, and channels that connect to terminal-like devices, the default value is **line**. For **stderr** the default value is **none**. **-buffersize** *newSize* : *newSize*, an integer no greater than one million, is the size in bytes of any input or output buffers subsequently allocated for this channel. **-encoding** ?*name*? : Sets the encoding of the channel. *name* is either one of the names returned by **encoding names**, or . Input is converted from the encoding into Unicode, and output is converted from Unicode to the encoding. > **binary** is an alias for **iso8859-1**. This alone is not > sufficient for working with binary data. Use **-translation > binary** instead. > > The encoding of a new channel is the value of **encoding system**, > which returns the platform- and locale-dependent system encoding > used to interface with the operating system, **-eofchar** *char* : *char* signals the end of the data when it is encountered in the input. If *char* is the empty string, there is no special character that marks the end of the data. The default value is the empty string. The acceptable range is \\\\x01 - \\\\x7f. A value outside this range results in an error. **-profile** *profile* : Specifies the encoding profile to be used on the channel. The encoding transforms in use for the channel\\'s input and output will then be subject to the rules of that profile. Any failures will result in a channel error. See **PROFILES** in the **encoding(n)** documentation for details about encoding profiles. **-translation** *translation* : **-translation** **{***inTranslation outTranslation***}** : In Tcl a single line feed (\\\\n) represents the end of a line. However, at the destination the end of a line may be represented differently on different platforms, or even for different devices on the same platform. For example, under UNIX line feed is used in files and a carriage-return-linefeed sequence is normally used in network connections. Therefore, on input, e.g. with **chan gets** and **chan read**, each external end-of-line character is translated into a line feed. On output, e.g. with **chan puts**, each line feed is translated to the external end-of-line character. The default translation, **auto**, handles all the common cases, and **-translation** provides explicit control over the end-of-line character. Returns the input translation for a read-only channel, the output translation for a write-only channel, and both the input translation and the the output translation for a read-write channel. When two translations are given, they are the input and output translation, respectively. When only one translation is given for a read-write channel, it is the translation for both input and output. The following values are currently supported: **auto** : The default. For input each occurrence of a line feed (**lf**), carriage return (**cr**), or carriage return followed by a line feed (**crlf**) is translated into a line feed. For output, each line feed is translated into a platform-specific representation: For all Unix variants it is **lf**, and for all Windows variants it is **crlf**, except that for sockets on all platforms it is **crlf** for both input and output. **binary** : Like **lf**, no end-of-line translation is performed, but in addition, sets **-eofchar** to the empty string to disable it, sets **-encoding** to **iso8859-1**, and sets **-profile** to **strict** so the the channel is fully configured for binary input and output: Each byte read from the channel becomes the Unicode character having the same value as that byte, and each character written to the channel becomes a single byte in the output. This makes it possible to work seamlessly with binary data as long as each character in the data remains in the range of 0 to 255 so that there is no distinction between binary data and text. For example, A JPEG image can be read from a such a channel, manipulated, and then written back to such a channel. **cr** : The end of a line is represented in the external data by a single carriage return character. For input, each carriage return is translated to a line feed, and for output each line feed character is translated to a carriage return. **crlf** : The end of a line is represented in the external data by a carriage return character followed by a line feed. For input, each carriage-return-linefeed sequence is translated to a line feed. For output, each line feed is translated to a carriage-return-linefeed sequence. This translation is typically used for network connections, and also on Windows systems. **lf** : The end of a line in the external data is represented by a line feed so no translations occur during either input or output. This translation is typically used on UNIX platforms, chan copy inputChan outputChan ? -size size ? ? -command callback ? : Reads characters from inputChan and writes them to outputChan until all characters are copied, blocking until the copy is complete and returning the number of characters copied. Leverages internal buffers to avoid extra copies and to avoid buffering too much data in main memory when copying large files to slow destinations like network sockets. **-size** limits the number of characters copied. If **-command** is gviven, **chan copy** returns immediately, works in the background, and calls *callback* when the copy completes, providing as an additional argument the number of characters written to *outputChan*. If an error occurres during the background copy, another argument provides message for the error. *inputChan* and *outputChan* are automatically configured for non-blocking mode if needed. Background copying only works correctly if events are being processed, e.g. via **vwait** or Tk. During a background copy no other read operation may be performed on *inputChan*, and no write operation may be performed on *outputChan*. However, write operations may by performed on *inputChan* and read operations may be performed on *outputChan*, as exhibited by the bidirectional copy example below. If either *inputChan* or *outputChan* is closed while the copy is in progress, copying ceases and **no** callback is made. If *inputChan* is closed all data already queued is written to *outputChan*. There should be no event handler established for *inputChan* because it may become readable during a background copy. An attempt to read or write from within an event handler results result in the error, \\\"channel busy\\\". Any wrong-sided I/O attempted (by a **fileevent** handler or otherwise) results in a error. EXAMPLES : The first example transfers the contents of one channel exactly to another. Note that when copying one file to another, it is better to use **file copy** which also copies file metadata (e.g. the file access permissions) where possible. fconfigure \\$in -translation binary fconfigure \\$out -translation binary **fcopy** \\$in \\$out This second example shows how the callback gets passed the number of bytes transferred. It also uses vwait to put the application into the event loop. Of course, this simplified example could be done without the command callback. proc Cleanup {in out bytes {error {}}} { global total set total \\$bytes close \\$in close \\$out if {\\[string length \\$error\\] != 0} { \\# error occurred during the copy } } set in \\[open \\$file1\\] set out \\[socket \\$server \\$port\\] **fcopy** \\$in \\$out -command \\[list Cleanup \\$in \\$out\\] vwait total The third example copies in chunks and tests for end of file in the command callback. proc CopyMore {in out chunk bytes {error {}}} { global total done incr total \\$bytes if {(\\[string length \\$error\\] != 0) \\|\\| \\[eof \\$in\\]} { set done \\$total close \\$in close \\$out } else { **fcopy** \\$in \\$out -size \\$chunk \\\\ -command \\[list CopyMore \\$in \\$out \\$chunk\\] } } set in \\[open \\$file1\\] set out \\[socket \\$server \\$port\\] set chunk 1024 set total 0 **fcopy** \\$in \\$out -size \\$chunk \\\\ -command \\[list CopyMore \\$in \\$out \\$chunk\\] vwait done The fourth example starts an asynchronous, bidirectional fcopy between two sockets. Those could also be pipes from two \\[open \\\"\\|hal 9000\\\" r+\\] (though their conversation would remain secret to the script, since all four fileevent slots are busy). set flows 2 proc Done {dir args} { global flows done puts \\\"\\$dir is over.\\\" incr flows -1 if {\\$flows\\<=0} {set done 1} } **fcopy** \\$sok1 \\$sok2 -command \\[list Done UP\\] **fcopy** \\$sok2 \\$sok1 -command \\[list Done DOWN\\] vwait done chan create mode cmdPrefix : Creates a new channel, called a reflected channel, with cmdPrefix as its handler, and returns the name of the channel. cmdPrefix is the first words of a command that provides the interface for a refchan . **Imode** is a list of one or more of the strings or , indicating whether the channel is a read channel, a write channel, or both. It is an error if the handler does not support the chosen mode. The handler is called as needed from the global namespace at the top level, and command resolution happens there at the time of the call. If the handler is renamed or deleted any subsequent attempt to call it is an error, which may not be able to describe the failure. The handler is always called in the interpreter and thread it was created in, even if the channel was shared with or moved into a different interpreter in a different thread. This is achieved through event dispatch, so if the event loop is not entered, e.g. by calling **Tcl_DoOneEvent** or **vwait** or using Tk, the thread performing the channel operation *blocks* indefinitely, resulting in deadlock. One side of a channel may be in one thread while the other side is in a different thread, providing a stream-oriented bridge between the threads. This provides a method for regular stream communication between threads as an alternative to sending commands. When the interpreter the handler is in is deleted each channel associated with the handler is deleted as well, regardless of which interpreter or thread it is currently in or shared with. **chan create** is **safe** and is accessible to safe interpreters. The handler is always called in the safe interpreter it was created in. chan eof channelName : Returns 1 if the last read on the channel failed because the end of the data was already reached, and 0 otherwise. chan event channelName event ? script ? : Arranges for the given script, called a channel event hndler , to be called whenever the given event, one of or occurs on the given channel, replacing any script that was previously set. If script is the empty string the current handler is deleted. It is also deleted when the channel is closed. If script is omitted, either the existing script or the empty string is returned. The event loop must be entered, e.g. via vwait or update , or by using Tk, for handlers to be evaluated. script is evaluated at the global level in the interpreter it was established in. Any resulting error is handled in the background, i.e. via interp bgerror . In order to prevent an endless loop due to a buggy handler, the handler is deleted if script returns an error so that it is not evaluated again. Without an event handler, chan gets or chan read on a channel in blocking mode may block until data becomes available, become during which the thread is unable to perform other work or respond to events on other channels. This could cause the application to appear to . Channel event handlers allow events on the channel to direct channel handling so that the reader or writer can continue to perform other processing while waiting for a channel to become available and then handle channel operations when the channel is ready for the operation. A event occurs when there is data that can be read from the channel and also when there is an error on the channel. The handler must check for these conditions and handle them appropriately. For example, a handler that does not check whether the end of the data has been reached may be repeatedly evaluated in a busy loop until the channel is closed. A event occurs when at least one byte of data can be written, or if there is an error on the channel. A client socket opened in non-blocking mode becomes writable when it becomes connected or if the connection fails. Event-driven channel handling works best for channels in non-blocking mode. A channel in blocking mode blocks when chan puts writes more data than the channel can accept at the moment, and when chan gets or chan read requests more data than is currently available. When a channel blocks, the thread can not do any other processing or service any other events. A channel in non-blocking mode allows a thread to carry on with other work and get back to the channel at the right time. chan flush channelName : For a channel in blocking mode, flushes all buffered output to the destination, and then returns. For a channel in non-blocking mode, returns immediately while all buffered output is flushed in the background as soon as possible. chan gets channelName ? varName ? : Returns the next line from the channel, removing the trailing line feed, or if varName is given, assigns the line to that variable and returns the number of characters read. the line that was read, removing the trailing line feed, or returns the empty string if there is no data to return and the end of the file has been reached, or in non-blocking mode, if no complete line is currently available. If varName is given, assigns the line that was read to variable named varName and returns the number of characters that were read, or -1 if there no data available and the end of the channel was reached or the channel is in non-blocking mode. If the end of the channel is reached the data read so far is returned or assigned to *varName*. When *varName* is not given, **chan eof** may indicate that the empty string means that the end of the data has been reached, and **chan blocked** may indicate that that the empty string means there isn\\'t currently enough data do return the next line. chan names ? pattern ? : Returns a list of all channel names, or if pattern is given, only those names that match according to the rules of string match . chan pending mode channelName : Returns the number of bytes of input when mode is , or output when mode is , that are currently internally buffered for the channel. Useful in a readable event callback to impose limits on input line length to avoid a potential denial-of-service attack where an extremely long line exceeds the available memory to buffer it. Returns -1 if the channel was not opened for the mode in question. chan pipe : Creates a pipe, i.e. a readable channel and a writable channel, and returns the names of the readable channel and the writable channel. Data written to the writable channel can be read from the readable channel. Because the pipe is a real system-level pipe, it can be connected to other processes using redirection. For example, to redirect stderr from a subprocess into one channel, and stdout into another, exec with \\\"2>@\\\" and \\\">@\\\", each onto the writable side of a pipe, closing the writable side immediately thereafter so that EOF is signaled on the read side once the subprocess has closed its output, typically on exit. Due to buffering, data written to one side of a pipe might not immediately become available on the other side. Tcl\\'s own buffers can be configured via **chan configure -buffering**, but overall behaviour still depends on operating system buffers outside of Tcl\\'s control. Once the write side of the channel is closed, any data remaining in the buffers is flushed through to the read side. It may be useful to arrange for the connected process to flush at some point after writing to the channel or to have it use some system-provided mechanism to configure buffering. When two pipes are connected to the same process, one to send data to the process, and one to read data from the process, a deadlock may occur if the channels are in blocking mode: If reading, the channel may block waiting for data that can never come because buffers are only flushed on subsequent writes, and if writing, the channel may block while waiting for the buffers to become free, which can never happen because the reader can not read while the writer is blocking. To avoid this issue, either put the channels into non-blocking mode and use event handlers, or place the read channel and the write channel in separate interpreters in separate threads. chan pop channelName : Removes the topmost transformation handler from the channel if there is one, and closes the channel otherwise. The result is normally the empty string, but may be an error in some situations, e.g. when closing the underlying resource results in an error. chan postevent channelName eventSpec : For use by handlers established with chan create . Notifies Tcl that that one or more event(s) listed in eventSpec , each of which is either or , have occurred. For use only by handlers for a channel created by chan create . It is an error to post an event for any other channel. Since only the handler for a reflected channel channel should post events it is an error to post an event from any interpreter other than the interpreter that created the channel. It is an error to post an event that the channel has no interest in. See watch in the refchan documentation for more information chan postevent is available in safe interpreters, as any handler for a reflected channel would have been created, and will be evaluated in that interpreter as well. chan push channelName cmdPrefix : Adds a new transformation handler on top of the channel and returns a handle for the transformation. cmdPrefix is the first words of a command that provides the interface documented for transchan , and transforms data on the channel, It is an error if handler does not support the mode(s) the channel is in. chan puts ? -nonewline ? ? channelName ? string : Writes string and a line feed to the channel. If -nonewline is given, the trailing line feed is not written. The default channel is stdout . Each line feed in the output is translated according to the configuration of **-translation**. Because Tcl internally buffers output, characters written to a channel may not immediately be available at the destination. Tcl normally delays output until the buffer is full or the channel is closed. **chan flush** forces output in the direction of the destination. When the output for a channel in blocking mode fills up, **chan puts** blocks until space in the buffer is available again, but for a channel in non-blocking mode, it returns immediately and the data is written in the background as fast possible, constrained by the speed at which as the destination accepts it. Output to a channel in non-blocking mode only works properly when the application enters the event loop, giving Tcl a chance to find out that the destination is ready to accept more data. When a channel is in non-blocking mode, Tcl\\'s internal buffers can hold an arbitrary amount of data, possibly consuming a large amount of memory. To avoid wasting memory, channels in non-blocking mode should normally be handled using **chan event**, where the application only invokes **chan puts** after being recently notified through a file event handler that the channel is ready for more output data. chan read channelName ? numChars ? : chan read ? -nonewline ? channelName : Reads and returns the next numChars characters from the channel. If numChars is omitted, all available characters up to the end of the file are read, or if the channel is in non-blocking mode, all currently-available characters are read. If there is an error on the channel, reading ceases and an error is returned. If numChars is not given, -nonewline may be given, causing any any trailing line feed to be trimmed. If the channel is in non-blocking mode, fewer characters than requested may be returned. If the channel is configured to use a multi-byte encoding, bytes that do not form a complete character are retained in the buffers until enough bytes to complete the character accumulate, or the end of the data is reached. **-nonewline** is ignored if characters are returned before reaching the end of the file. Each end-of-line sequence according to the value of **-translation** is translated into a line feed. When reading from a serial port, most applications should configure the serial port channel to be in non-blocking mode, but not necessarily use an event handler since most serial ports are comparatively slow. It is entirely possible to get a **readable** event for each individual character. In blocking mode, **chan read** blocks forever when reading to the end of the data if there is no **chan configure -eofchar** configured for the channel. chan seek channelName offset ? origin ? : Sets the current position for the data in the channel to integer offset bytes relative to origin . A negative offset moves the current position backwards from the origin. origin is one of the following: **start** : The origin is the start of the data. This is the default. **current** : The origin is the current position. **end** : The origin is the end of the data. **Chan seek** flushes all buffered output even if the channel is in non-blocking mode, discards any buffered and unread input, and returns the empty string or an error if the channel does not support seeking. *offset* values are byte offsets, not character offsets. Unlike **chan** read, both **chan seek** and **chan tell** operate in terms of bytes, not characters, chan tell channelName : Returns the offset in bytes of the current position in the underlying data, or -1 if the channel does not suport seeking. The value can be passed to chan seek to set current position to that offset. chan truncate channelName ? length ? : Flushes the channel and truncates the data in the channel to length bytes, or to the current position in bytes if length is omitted. EXAMPLES In the following example a file is opened using the encoding CP1252, which is common on Windows, searches for a string, rewrites that part, and truncates the file two lines later. set f [open somefile.txt r+] chan configure \\$f -encoding cp1252 set offset 0 # Search for string \\\"FOOBAR\\\" in the file while {[ chan gets \\$f line] >= 0} { set idx [string first FOOBAR \\$line] if {\\$idx >= 0} { # Found it; rewrite line chan seek \\$f [expr {\\$offset + \\$idx}] chan puts -nonewline \\$f BARFOO # Skip to end of following line, and truncate chan gets \\$f chan gets \\$f chan truncate \\$f # Stop searching the file now break } # Save offset of start of next line for later set offset [ chan tell \\$f] } chan close \\$f A network server that echoes its input line-by-line without preventing servicing of other connections at the same time: # This is a very simple logger... proc log message { chan puts stdout \\$message } # This is called whenever a new client connects to the server proc connect {chan host port} { set clientName [format \\<%s:%d> \\$host \\$port] log \\\"connection from \\$clientName\\\" chan configure \\$chan -blocking 0 -buffering line chan event \\$chan readable [list echoLine \\$chan \\$clientName] } # This is called whenever either at least one byte of input # data is available, or the channel was closed by the client. proc echoLine {chan clientName} { chan gets \\$chan line if {[ chan eof \\$chan]} { log \\\"finishing connection from \\$clientName\\\" chan close \\$chan } elseif {![ chan blocked \\$chan]} { # Didn\\'t block waiting for end-of-line log \\\"\\$clientName - \\$line\\\" chan puts \\$chan \\$line } } # Create the server socket and enter the event-loop to wait # for incoming connections... socket -server connect 12345 vwait forever SEE ALSO close(n), eof(n), fblocked(n), fconfigure(n), fcopy(n), file(n), fileevent(n), flush(n), gets(n), open(n), puts(n), read(n), seek(n), socket(n), tell(n), refchan(n), transchan(n) KEYWORDS channel, input, output, events, offset","title":"NAME"},{"location":"chan/#name","text":"chan - Reads, writes and manipulates channels.","title":"NAME"},{"location":"chan/#synopsis","text":"chan operation ? arg arg ... ?","title":"SYNOPSIS"},{"location":"chan/#description","text":"chan provides several operations for reading from, writing to, and otherwise manipulating channels, e.g. those created by open and socket , or the default channels stdin , stdout or stderr which correspond respectively to the standard input, output, and error streams of the process. Any unique abbreviation for operation is acceptable. Available operations are: chan blocked channelName : Returns 1 when the channel is in non-blocking mode and the last input operation on the channel failed because it would have otherwise caused the process to block, and 0 otherwise. Each Tcl channel is in blocking mode unless configured otherwise. chan close channelName ? direction ? : Closes and destroys the named channel, deleting any existing event handlers established for the channel, and returns the empty string. If direction is given, it is or or any unique abbreviation of those words, and only that side of the channel is closed. I.e. a read-write channel may become read-only or write-only. Closing a read-only channel for reading, or closing a write-only channel for writing is the same as simply closing the channel. It is an error to close a read-only channel for writing or to close a write-only channel for reading. When a channel is closed for writing, any buffered output on the channel is flushed. When a channel is closed for reading, any buffered input is discarded. When a channel is destroyed the underlying resource is closed and the channel is thereafter unavailable. chan close fully flushes any output before closing the write side of a channel unless it is non-blocking mode, where it returns immediately and the channel is flushed in the background before finally being closed. chan close may return an error if an error occurs while flushing output. If a process in a command pipeline created by open returns an error, chan close generates an error in the same manner as exec . Closing one side of a socket or command pipeline may lead to the shutdown() or close() of the underlying system resource, leading to a reaction from whatever is on the other side of the pipeline or socket. If the channel for a command pipeline is in blocking mode, chan close waits for the connected processes to complete. chan close only affects the current interpreter. If the channel is open in any other interpreter, its state is unchanged there. See interp for a description of channel sharing. When the last interpreter sharing a channel is destroyed, the channel is switched to blocking mode and fully flushed and then closed. chan configure channelName ? optionName ? ? value ? ? optionName value ?... : Configures or reports the configuration of channelName . If no *optionName* or *value* arguments are given, **chan configure** returns a dictionary of option names and values for the channel. If *optionName* is supplied without a *value*, **chan configure** returns the current value of the named option. If one or more pairs of *optionName* and *value* are supplied, **chan configure** sets each of the named options to the corresponding *value* and returns the empty string. The options described below are supported for all channels. Each type of channel may provide additional options. Those options are described in the relevant documentation. For example, additional options are documented for **socket**, and also for serial devices at **open**. **-blocking** *boolean* : If **-blocking** is set to **true**, which is the default, reading from or writing to the channel may cause the process to block indefinitely. Otherwise, operations such as **chan gets**, **chan read**, **chan puts**, **chan** flush, and **chan close** take care not to block. Non-blocking mode in generally requires that the event loop is entered, e.g. by calling **Tcl_DoOneEvent** or **vwait** or by using Tk, to give Tcl a chance to process events on the channel. **-buffering** *newValue* : If *newValue* is **full**, which is the default, output is buffered until the internal buffer is full or until **chan flush** is called. If *newValue* is **line**, output is flushed each time a end-of-line character is written. If *newValue* is **none**, output is flushed after every output operation. For **stdin**, **stdout**, and channels that connect to terminal-like devices, the default value is **line**. For **stderr** the default value is **none**. **-buffersize** *newSize* : *newSize*, an integer no greater than one million, is the size in bytes of any input or output buffers subsequently allocated for this channel. **-encoding** ?*name*? : Sets the encoding of the channel. *name* is either one of the names returned by **encoding names**, or . Input is converted from the encoding into Unicode, and output is converted from Unicode to the encoding. > **binary** is an alias for **iso8859-1**. This alone is not > sufficient for working with binary data. Use **-translation > binary** instead. > > The encoding of a new channel is the value of **encoding system**, > which returns the platform- and locale-dependent system encoding > used to interface with the operating system, **-eofchar** *char* : *char* signals the end of the data when it is encountered in the input. If *char* is the empty string, there is no special character that marks the end of the data. The default value is the empty string. The acceptable range is \\\\x01 - \\\\x7f. A value outside this range results in an error. **-profile** *profile* : Specifies the encoding profile to be used on the channel. The encoding transforms in use for the channel\\'s input and output will then be subject to the rules of that profile. Any failures will result in a channel error. See **PROFILES** in the **encoding(n)** documentation for details about encoding profiles. **-translation** *translation* : **-translation** **{***inTranslation outTranslation***}** : In Tcl a single line feed (\\\\n) represents the end of a line. However, at the destination the end of a line may be represented differently on different platforms, or even for different devices on the same platform. For example, under UNIX line feed is used in files and a carriage-return-linefeed sequence is normally used in network connections. Therefore, on input, e.g. with **chan gets** and **chan read**, each external end-of-line character is translated into a line feed. On output, e.g. with **chan puts**, each line feed is translated to the external end-of-line character. The default translation, **auto**, handles all the common cases, and **-translation** provides explicit control over the end-of-line character. Returns the input translation for a read-only channel, the output translation for a write-only channel, and both the input translation and the the output translation for a read-write channel. When two translations are given, they are the input and output translation, respectively. When only one translation is given for a read-write channel, it is the translation for both input and output. The following values are currently supported: **auto** : The default. For input each occurrence of a line feed (**lf**), carriage return (**cr**), or carriage return followed by a line feed (**crlf**) is translated into a line feed. For output, each line feed is translated into a platform-specific representation: For all Unix variants it is **lf**, and for all Windows variants it is **crlf**, except that for sockets on all platforms it is **crlf** for both input and output. **binary** : Like **lf**, no end-of-line translation is performed, but in addition, sets **-eofchar** to the empty string to disable it, sets **-encoding** to **iso8859-1**, and sets **-profile** to **strict** so the the channel is fully configured for binary input and output: Each byte read from the channel becomes the Unicode character having the same value as that byte, and each character written to the channel becomes a single byte in the output. This makes it possible to work seamlessly with binary data as long as each character in the data remains in the range of 0 to 255 so that there is no distinction between binary data and text. For example, A JPEG image can be read from a such a channel, manipulated, and then written back to such a channel. **cr** : The end of a line is represented in the external data by a single carriage return character. For input, each carriage return is translated to a line feed, and for output each line feed character is translated to a carriage return. **crlf** : The end of a line is represented in the external data by a carriage return character followed by a line feed. For input, each carriage-return-linefeed sequence is translated to a line feed. For output, each line feed is translated to a carriage-return-linefeed sequence. This translation is typically used for network connections, and also on Windows systems. **lf** : The end of a line in the external data is represented by a line feed so no translations occur during either input or output. This translation is typically used on UNIX platforms, chan copy inputChan outputChan ? -size size ? ? -command callback ? : Reads characters from inputChan and writes them to outputChan until all characters are copied, blocking until the copy is complete and returning the number of characters copied. Leverages internal buffers to avoid extra copies and to avoid buffering too much data in main memory when copying large files to slow destinations like network sockets. **-size** limits the number of characters copied. If **-command** is gviven, **chan copy** returns immediately, works in the background, and calls *callback* when the copy completes, providing as an additional argument the number of characters written to *outputChan*. If an error occurres during the background copy, another argument provides message for the error. *inputChan* and *outputChan* are automatically configured for non-blocking mode if needed. Background copying only works correctly if events are being processed, e.g. via **vwait** or Tk. During a background copy no other read operation may be performed on *inputChan*, and no write operation may be performed on *outputChan*. However, write operations may by performed on *inputChan* and read operations may be performed on *outputChan*, as exhibited by the bidirectional copy example below. If either *inputChan* or *outputChan* is closed while the copy is in progress, copying ceases and **no** callback is made. If *inputChan* is closed all data already queued is written to *outputChan*. There should be no event handler established for *inputChan* because it may become readable during a background copy. An attempt to read or write from within an event handler results result in the error, \\\"channel busy\\\". Any wrong-sided I/O attempted (by a **fileevent** handler or otherwise) results in a error. EXAMPLES : The first example transfers the contents of one channel exactly to another. Note that when copying one file to another, it is better to use **file copy** which also copies file metadata (e.g. the file access permissions) where possible. fconfigure \\$in -translation binary fconfigure \\$out -translation binary **fcopy** \\$in \\$out This second example shows how the callback gets passed the number of bytes transferred. It also uses vwait to put the application into the event loop. Of course, this simplified example could be done without the command callback. proc Cleanup {in out bytes {error {}}} { global total set total \\$bytes close \\$in close \\$out if {\\[string length \\$error\\] != 0} { \\# error occurred during the copy } } set in \\[open \\$file1\\] set out \\[socket \\$server \\$port\\] **fcopy** \\$in \\$out -command \\[list Cleanup \\$in \\$out\\] vwait total The third example copies in chunks and tests for end of file in the command callback. proc CopyMore {in out chunk bytes {error {}}} { global total done incr total \\$bytes if {(\\[string length \\$error\\] != 0) \\|\\| \\[eof \\$in\\]} { set done \\$total close \\$in close \\$out } else { **fcopy** \\$in \\$out -size \\$chunk \\\\ -command \\[list CopyMore \\$in \\$out \\$chunk\\] } } set in \\[open \\$file1\\] set out \\[socket \\$server \\$port\\] set chunk 1024 set total 0 **fcopy** \\$in \\$out -size \\$chunk \\\\ -command \\[list CopyMore \\$in \\$out \\$chunk\\] vwait done The fourth example starts an asynchronous, bidirectional fcopy between two sockets. Those could also be pipes from two \\[open \\\"\\|hal 9000\\\" r+\\] (though their conversation would remain secret to the script, since all four fileevent slots are busy). set flows 2 proc Done {dir args} { global flows done puts \\\"\\$dir is over.\\\" incr flows -1 if {\\$flows\\<=0} {set done 1} } **fcopy** \\$sok1 \\$sok2 -command \\[list Done UP\\] **fcopy** \\$sok2 \\$sok1 -command \\[list Done DOWN\\] vwait done chan create mode cmdPrefix : Creates a new channel, called a reflected channel, with cmdPrefix as its handler, and returns the name of the channel. cmdPrefix is the first words of a command that provides the interface for a refchan . **Imode** is a list of one or more of the strings or , indicating whether the channel is a read channel, a write channel, or both. It is an error if the handler does not support the chosen mode. The handler is called as needed from the global namespace at the top level, and command resolution happens there at the time of the call. If the handler is renamed or deleted any subsequent attempt to call it is an error, which may not be able to describe the failure. The handler is always called in the interpreter and thread it was created in, even if the channel was shared with or moved into a different interpreter in a different thread. This is achieved through event dispatch, so if the event loop is not entered, e.g. by calling **Tcl_DoOneEvent** or **vwait** or using Tk, the thread performing the channel operation *blocks* indefinitely, resulting in deadlock. One side of a channel may be in one thread while the other side is in a different thread, providing a stream-oriented bridge between the threads. This provides a method for regular stream communication between threads as an alternative to sending commands. When the interpreter the handler is in is deleted each channel associated with the handler is deleted as well, regardless of which interpreter or thread it is currently in or shared with. **chan create** is **safe** and is accessible to safe interpreters. The handler is always called in the safe interpreter it was created in. chan eof channelName : Returns 1 if the last read on the channel failed because the end of the data was already reached, and 0 otherwise. chan event channelName event ? script ? : Arranges for the given script, called a channel event hndler , to be called whenever the given event, one of or occurs on the given channel, replacing any script that was previously set. If script is the empty string the current handler is deleted. It is also deleted when the channel is closed. If script is omitted, either the existing script or the empty string is returned. The event loop must be entered, e.g. via vwait or update , or by using Tk, for handlers to be evaluated. script is evaluated at the global level in the interpreter it was established in. Any resulting error is handled in the background, i.e. via interp bgerror . In order to prevent an endless loop due to a buggy handler, the handler is deleted if script returns an error so that it is not evaluated again. Without an event handler, chan gets or chan read on a channel in blocking mode may block until data becomes available, become during which the thread is unable to perform other work or respond to events on other channels. This could cause the application to appear to . Channel event handlers allow events on the channel to direct channel handling so that the reader or writer can continue to perform other processing while waiting for a channel to become available and then handle channel operations when the channel is ready for the operation. A event occurs when there is data that can be read from the channel and also when there is an error on the channel. The handler must check for these conditions and handle them appropriately. For example, a handler that does not check whether the end of the data has been reached may be repeatedly evaluated in a busy loop until the channel is closed. A event occurs when at least one byte of data can be written, or if there is an error on the channel. A client socket opened in non-blocking mode becomes writable when it becomes connected or if the connection fails. Event-driven channel handling works best for channels in non-blocking mode. A channel in blocking mode blocks when chan puts writes more data than the channel can accept at the moment, and when chan gets or chan read requests more data than is currently available. When a channel blocks, the thread can not do any other processing or service any other events. A channel in non-blocking mode allows a thread to carry on with other work and get back to the channel at the right time. chan flush channelName : For a channel in blocking mode, flushes all buffered output to the destination, and then returns. For a channel in non-blocking mode, returns immediately while all buffered output is flushed in the background as soon as possible. chan gets channelName ? varName ? : Returns the next line from the channel, removing the trailing line feed, or if varName is given, assigns the line to that variable and returns the number of characters read. the line that was read, removing the trailing line feed, or returns the empty string if there is no data to return and the end of the file has been reached, or in non-blocking mode, if no complete line is currently available. If varName is given, assigns the line that was read to variable named varName and returns the number of characters that were read, or -1 if there no data available and the end of the channel was reached or the channel is in non-blocking mode. If the end of the channel is reached the data read so far is returned or assigned to *varName*. When *varName* is not given, **chan eof** may indicate that the empty string means that the end of the data has been reached, and **chan blocked** may indicate that that the empty string means there isn\\'t currently enough data do return the next line. chan names ? pattern ? : Returns a list of all channel names, or if pattern is given, only those names that match according to the rules of string match . chan pending mode channelName : Returns the number of bytes of input when mode is , or output when mode is , that are currently internally buffered for the channel. Useful in a readable event callback to impose limits on input line length to avoid a potential denial-of-service attack where an extremely long line exceeds the available memory to buffer it. Returns -1 if the channel was not opened for the mode in question. chan pipe : Creates a pipe, i.e. a readable channel and a writable channel, and returns the names of the readable channel and the writable channel. Data written to the writable channel can be read from the readable channel. Because the pipe is a real system-level pipe, it can be connected to other processes using redirection. For example, to redirect stderr from a subprocess into one channel, and stdout into another, exec with \\\"2>@\\\" and \\\">@\\\", each onto the writable side of a pipe, closing the writable side immediately thereafter so that EOF is signaled on the read side once the subprocess has closed its output, typically on exit. Due to buffering, data written to one side of a pipe might not immediately become available on the other side. Tcl\\'s own buffers can be configured via **chan configure -buffering**, but overall behaviour still depends on operating system buffers outside of Tcl\\'s control. Once the write side of the channel is closed, any data remaining in the buffers is flushed through to the read side. It may be useful to arrange for the connected process to flush at some point after writing to the channel or to have it use some system-provided mechanism to configure buffering. When two pipes are connected to the same process, one to send data to the process, and one to read data from the process, a deadlock may occur if the channels are in blocking mode: If reading, the channel may block waiting for data that can never come because buffers are only flushed on subsequent writes, and if writing, the channel may block while waiting for the buffers to become free, which can never happen because the reader can not read while the writer is blocking. To avoid this issue, either put the channels into non-blocking mode and use event handlers, or place the read channel and the write channel in separate interpreters in separate threads. chan pop channelName : Removes the topmost transformation handler from the channel if there is one, and closes the channel otherwise. The result is normally the empty string, but may be an error in some situations, e.g. when closing the underlying resource results in an error. chan postevent channelName eventSpec : For use by handlers established with chan create . Notifies Tcl that that one or more event(s) listed in eventSpec , each of which is either or , have occurred. For use only by handlers for a channel created by chan create . It is an error to post an event for any other channel. Since only the handler for a reflected channel channel should post events it is an error to post an event from any interpreter other than the interpreter that created the channel. It is an error to post an event that the channel has no interest in. See watch in the refchan documentation for more information chan postevent is available in safe interpreters, as any handler for a reflected channel would have been created, and will be evaluated in that interpreter as well. chan push channelName cmdPrefix : Adds a new transformation handler on top of the channel and returns a handle for the transformation. cmdPrefix is the first words of a command that provides the interface documented for transchan , and transforms data on the channel, It is an error if handler does not support the mode(s) the channel is in. chan puts ? -nonewline ? ? channelName ? string : Writes string and a line feed to the channel. If -nonewline is given, the trailing line feed is not written. The default channel is stdout . Each line feed in the output is translated according to the configuration of **-translation**. Because Tcl internally buffers output, characters written to a channel may not immediately be available at the destination. Tcl normally delays output until the buffer is full or the channel is closed. **chan flush** forces output in the direction of the destination. When the output for a channel in blocking mode fills up, **chan puts** blocks until space in the buffer is available again, but for a channel in non-blocking mode, it returns immediately and the data is written in the background as fast possible, constrained by the speed at which as the destination accepts it. Output to a channel in non-blocking mode only works properly when the application enters the event loop, giving Tcl a chance to find out that the destination is ready to accept more data. When a channel is in non-blocking mode, Tcl\\'s internal buffers can hold an arbitrary amount of data, possibly consuming a large amount of memory. To avoid wasting memory, channels in non-blocking mode should normally be handled using **chan event**, where the application only invokes **chan puts** after being recently notified through a file event handler that the channel is ready for more output data. chan read channelName ? numChars ? : chan read ? -nonewline ? channelName : Reads and returns the next numChars characters from the channel. If numChars is omitted, all available characters up to the end of the file are read, or if the channel is in non-blocking mode, all currently-available characters are read. If there is an error on the channel, reading ceases and an error is returned. If numChars is not given, -nonewline may be given, causing any any trailing line feed to be trimmed. If the channel is in non-blocking mode, fewer characters than requested may be returned. If the channel is configured to use a multi-byte encoding, bytes that do not form a complete character are retained in the buffers until enough bytes to complete the character accumulate, or the end of the data is reached. **-nonewline** is ignored if characters are returned before reaching the end of the file. Each end-of-line sequence according to the value of **-translation** is translated into a line feed. When reading from a serial port, most applications should configure the serial port channel to be in non-blocking mode, but not necessarily use an event handler since most serial ports are comparatively slow. It is entirely possible to get a **readable** event for each individual character. In blocking mode, **chan read** blocks forever when reading to the end of the data if there is no **chan configure -eofchar** configured for the channel. chan seek channelName offset ? origin ? : Sets the current position for the data in the channel to integer offset bytes relative to origin . A negative offset moves the current position backwards from the origin. origin is one of the following: **start** : The origin is the start of the data. This is the default. **current** : The origin is the current position. **end** : The origin is the end of the data. **Chan seek** flushes all buffered output even if the channel is in non-blocking mode, discards any buffered and unread input, and returns the empty string or an error if the channel does not support seeking. *offset* values are byte offsets, not character offsets. Unlike **chan** read, both **chan seek** and **chan tell** operate in terms of bytes, not characters, chan tell channelName : Returns the offset in bytes of the current position in the underlying data, or -1 if the channel does not suport seeking. The value can be passed to chan seek to set current position to that offset. chan truncate channelName ? length ? : Flushes the channel and truncates the data in the channel to length bytes, or to the current position in bytes if length is omitted.","title":"DESCRIPTION"},{"location":"chan/#examples","text":"In the following example a file is opened using the encoding CP1252, which is common on Windows, searches for a string, rewrites that part, and truncates the file two lines later. set f [open somefile.txt r+] chan configure \\$f -encoding cp1252 set offset 0 # Search for string \\\"FOOBAR\\\" in the file while {[ chan gets \\$f line] >= 0} { set idx [string first FOOBAR \\$line] if {\\$idx >= 0} { # Found it; rewrite line chan seek \\$f [expr {\\$offset + \\$idx}] chan puts -nonewline \\$f BARFOO # Skip to end of following line, and truncate chan gets \\$f chan gets \\$f chan truncate \\$f # Stop searching the file now break } # Save offset of start of next line for later set offset [ chan tell \\$f] } chan close \\$f A network server that echoes its input line-by-line without preventing servicing of other connections at the same time: # This is a very simple logger... proc log message { chan puts stdout \\$message } # This is called whenever a new client connects to the server proc connect {chan host port} { set clientName [format \\<%s:%d> \\$host \\$port] log \\\"connection from \\$clientName\\\" chan configure \\$chan -blocking 0 -buffering line chan event \\$chan readable [list echoLine \\$chan \\$clientName] } # This is called whenever either at least one byte of input # data is available, or the channel was closed by the client. proc echoLine {chan clientName} { chan gets \\$chan line if {[ chan eof \\$chan]} { log \\\"finishing connection from \\$clientName\\\" chan close \\$chan } elseif {![ chan blocked \\$chan]} { # Didn\\'t block waiting for end-of-line log \\\"\\$clientName - \\$line\\\" chan puts \\$chan \\$line } } # Create the server socket and enter the event-loop to wait # for incoming connections... socket -server connect 12345 vwait forever","title":"EXAMPLES"},{"location":"chan/#see-also","text":"close(n), eof(n), fblocked(n), fconfigure(n), fcopy(n), file(n), fileevent(n), flush(n), gets(n), open(n), puts(n), read(n), seek(n), socket(n), tell(n), refchan(n), transchan(n)","title":"SEE ALSO"},{"location":"chan/#keywords","text":"channel, input, output, events, offset","title":"KEYWORDS"},{"location":"classvariable/","text":"NAME classvariable - create link from local variable to variable in class SYNOPSIS package require tcl::oo classvariable variableName ?...? DESCRIPTION The classvariable command is available within methods. It takes a series of one or more variable names and makes them available in the method\\'s scope; those variable names must not be qualified and must not refer to array elements. The originating scope for the variables is the namespace of the class that the method was defined by. In other words, the referenced variables are shared between all instances of that class. Note: This command is equivalent to the command typevariable provided by the snit package in tcllib for approximately the same purpose. If used in a method defined directly on a class instance (e.g., through the oo::objdefine method definition) this is very much like just using: namespace upvar [namespace current] \\$var \\$var for each variable listed to classvariable . EXAMPLE This class counts how many instances of it have been made. oo::class create Counted { initialise { variable count 0 } variable number constructor {} { classvariable count set number [incr count] } method report {} { classvariable count puts \\\"This is instance \\$number of \\$count\\\" } } set a [Counted new] set b [Counted new] \\$a report \u2192 This is instance 1 of 2 set c [Counted new] \\$b report \u2192 This is instance 2 of 3 \\$c report \u2192 This is instance 3 of 3 SEE ALSO global(n), namespace(n), oo::class(n), oo::define(n), upvar(n), variable(n) KEYWORDS class, class variable, variable","title":"NAME"},{"location":"classvariable/#name","text":"classvariable - create link from local variable to variable in class","title":"NAME"},{"location":"classvariable/#synopsis","text":"package require tcl::oo classvariable variableName ?...?","title":"SYNOPSIS"},{"location":"classvariable/#description","text":"The classvariable command is available within methods. It takes a series of one or more variable names and makes them available in the method\\'s scope; those variable names must not be qualified and must not refer to array elements. The originating scope for the variables is the namespace of the class that the method was defined by. In other words, the referenced variables are shared between all instances of that class. Note: This command is equivalent to the command typevariable provided by the snit package in tcllib for approximately the same purpose. If used in a method defined directly on a class instance (e.g., through the oo::objdefine method definition) this is very much like just using: namespace upvar [namespace current] \\$var \\$var for each variable listed to classvariable .","title":"DESCRIPTION"},{"location":"classvariable/#example","text":"This class counts how many instances of it have been made. oo::class create Counted { initialise { variable count 0 } variable number constructor {} { classvariable count set number [incr count] } method report {} { classvariable count puts \\\"This is instance \\$number of \\$count\\\" } } set a [Counted new] set b [Counted new] \\$a report \u2192 This is instance 1 of 2 set c [Counted new] \\$b report \u2192 This is instance 2 of 3 \\$c report \u2192 This is instance 3 of 3","title":"EXAMPLE"},{"location":"classvariable/#see-also","text":"global(n), namespace(n), oo::class(n), oo::define(n), upvar(n), variable(n)","title":"SEE ALSO"},{"location":"classvariable/#keywords","text":"class, class variable, variable","title":"KEYWORDS"},{"location":"clock/","text":"NAME clock - Obtain and manipulate dates and times SYNOPSIS package require Tcl 8.5- clock add timeVal ? count unit... ? ? -option value ? clock clicks ? -option ? clock format timeVal ? -option value ...? clock microseconds clock milliseconds clock scan inputString ? -option value ...? clock seconds DESCRIPTION The clock command performs several operations that obtain and manipulate values that represent times. The command supports several subcommands that determine what action is carried out by the command. clock add timeVal ? count unit... ? ? -option value ? : Adds a (possibly negative) offset to a time that is expressed as an integer number of seconds. See CLOCK ARITHMETIC for a full description. clock clicks ? -option ? : If no -option argument is supplied, returns a high-resolution time value as a system-dependent integer value. The unit of the value is system-dependent but should be the highest resolution clock available on the system such as a CPU cycle counter. See HIGH RESOLUTION TIMERS for a full description. If the *-option* argument is **-milliseconds**, then the command is synonymous with **clock milliseconds** (see below). This usage is obsolete, and **clock milliseconds** is to be considered the preferred way of obtaining a count of milliseconds. If the *-option* argument is **-microseconds**, then the command is synonymous with **clock microseconds** (see below). This usage is obsolete, and **clock microseconds** is to be considered the preferred way of obtaining a count of microseconds. clock format timeVal ? -option value ...? : Formats a time that is expressed as an integer number of seconds into a format intended for consumption by users or external programs. See FORMATTING TIMES for a full description. clock microseconds : Returns the current time as an integer number of microseconds. See HIGH RESOLUTION TIMERS for a full description. clock milliseconds : Returns the current time as an integer number of milliseconds. See HIGH RESOLUTION TIMERS for a full description. clock scan inputString ? -option value ...? : Scans a time that is expressed as a character string and produces an integer number of seconds. See SCANNING TIMES for a full description. clock seconds : Returns the current time as an integer number of seconds. PARAMETERS count : An integer representing a count of some unit of time. See CLOCK ARITHMETIC for the details. timeVal : An integer value passed to the clock command that represents an absolute time as a number of seconds from the epoch time of 1 January 1970, 00:00 UTC. Note that the count of seconds does not include any leap seconds; seconds are counted as if each UTC day has exactly 86400 seconds. Tcl responds to leap seconds by speeding or slowing its clock by a tiny fraction for some minutes until it is back in sync with UTC; its data model does not represent minutes that have 59 or 61 seconds. unit : One of the words, seconds , minutes , hours , days , weekdays , weeks , months , or years . Used in conjunction with count to identify an interval of time, for example, 3 seconds or 1 year . OPTIONS -base time : Specifies that any relative times present in a clock scan command are to be given relative to time . time must be expressed as a count of nominal seconds from the epoch time of 1 January 1970, 00:00 UTC. -format format : Specifies the desired output format for clock format or the expected input format for clock scan . The format string consists of any number of characters other than the per-cent sign interspersed with any number of format groups , which are two-character sequences beginning with the per-cent sign. The permissible format groups, and their interpretation, are described under FORMAT GROUPS . On clock format , the default format is %a %b %d %H:%M:%S %Z %Y On clock scan , the lack of a -format option indicates that a is requested; see FREE FORM SCAN for a description of what happens. -gmt boolean : If boolean is true, specifies that a time specified to clock add , clock format or clock scan should be processed in UTC. If boolean is false, the processing defaults to the local time zone. This usage is obsolete; the correct current usage is to specify the UTC time zone with or any of the equivalent ways to specify it. -locale localeName : Specifies that locale-dependent scanning and formatting (and date arithmetic for dates preceding the adoption of the Gregorian calendar) is to be done in the locale identified by localeName . The locale name may be any of the locales acceptable to the msgcat package, or it may be the special name system , which represents the current locale of the process, or the null string, which represents Tcl\\'s default locale. The effect of locale on scanning and formatting is discussed in the descriptions of the individual format groups under **FORMAT GROUPS**. The effect of locale on clock arithmetic is discussed under **CLOCK ARITHMETIC**. -timezone zoneName : Specifies that clock arithmetic, formatting, and scanning are to be done according to the rules for the time zone specified by zoneName . The permissible values, and their interpretation, are discussed under TIME ZONES . On subcommands that expect a -timezone argument, the default is to use the current time zone . The current time zone is determined, in order of preference, by: \\[1\\] : the environment variable **TCL_TZ**. \\[2\\] : the environment variable **TZ**. \\[3\\] : on Windows systems, the time zone settings from the Control Panel. If none of these is present, the C localtime and mktime functions are used to attempt to convert times between local and Greenwich. On 32-bit systems, this approach is likely to have bugs, particularly for times that lie outside the window (approximately the years 1902 to 2037) that can be represented in a 32-bit integer. CLOCK ARITHMETIC The clock add command performs clock arithmetic on a value (expressed as nominal seconds from the epoch time of 1 January 1970, 00:00 UTC) given as its first argument. The remaining arguments (other than the possible -timezone , -locale and -gmt options) are integers and keywords in alternation, where the keywords are chosen from seconds , minutes , hours , days , weekdays , weeks , months , or years . Addition of seconds, minutes and hours is fairly straightforward; the given time increment (times sixty for minutes, or 3600 for hours) is simply added to the timeVal given to the clock add command. The result is interpreted as a nominal number of seconds from the Epoch. Surprising results may be obtained when crossing a point at which a leap second is inserted or removed; the clock add command simply ignores leap seconds and therefore assumes that times come in sequence, 23:59:58, 23:59:59, 00:00:00. This assumption is handled by the fact that Tcl\\'s model of time reacts to leap seconds by speeding or slowing the clock by a miniscule amount until Tcl\\'s time is back in step with the world. The fact that adding and subtracting hours is defined in terms of absolute time means that it will add fixed amounts of time in time zones that observe summer time (Daylight Saving Time). For example, the following code sets the value of x to 04:00:00 because the clock has changed in the interval in question. set s [ clock scan {2004-10-30 05:00:00} \\ -format {%Y-%m-%d %H:%M:%S} \\ -timezone :America/New_York] set a [ clock add \\$s 24 hours -timezone :America/New_York] set x [ clock format \\$a \\ -format {%H:%M:%S} -timezone :America/New_York] Adding and subtracting days and weeks is accomplished by converting the given time to a calendar day and time of day in the appropriate time zone and locale. The requisite number of days (weeks are converted to days by multiplying by seven) is added to the calendar day, and the date and time are then converted back to a count of seconds from the epoch time. The weekdays keyword is similar to days , with the only difference that weekends - Saturdays and Sundays - are skipped. Adding and subtracting a given number of days across the point that the time changes at the start or end of summer time (Daylight Saving Time) results in the same local time on the day in question. For instance, the following code sets the value of x to 05:00:00 . set s [ clock scan {2004-10-30 05:00:00} \\ -format {%Y-%m-%d %H:%M:%S} \\ -timezone :America/New_York] set a [ clock add \\$s 1 day -timezone :America/New_York] set x [ clock format \\$a \\ -format {%H:%M:%S} -timezone :America/New_York] In cases of ambiguity, where the same local time happens twice on the same day, the earlier time is used. In cases where the conversion yields an impossible time (for instance, 02:30 during the Spring Daylight Saving Time change using US rules), the time is converted as if the clock had not changed. Thus, the following code will set the value of x to 03:30:00 . set s [ clock scan {2004-04-03 02:30:00} \\ -format {%Y-%m-%d %H:%M:%S} \\ -timezone :America/New_York] set a [ clock add \\$s 1 day -timezone :America/New_York] set x [ clock format \\$a \\ -format {%H:%M:%S} -timezone :America/New_York] Adding a given number of days or weeks works correctly across the conversion between the Julian and Gregorian calendars; the omitted days are skipped. The following code sets z to 1752-09-14 . set x [ clock scan 1752-09-02 -format %Y-%m-%d -locale en_US] set y [ clock add \\$x 1 day -locale en_US] set z [ clock format \\$y -format %Y-%m-%d -locale en_US] In the bizarre case that adding the given number of days yields a date that does not exist because it falls within the dropped days of the Julian-to-Gregorian conversion, the date is converted as if it was on the Julian calendar. Adding a number of months, or a number of years, is similar; it converts the given time to a calendar date and time of day. It then adds the requisite number of months or years, and reconverts the resulting date and time of day to an absolute time. If the resulting date is impossible because the month has too few days (for example, when adding 1 month to 31 January), the last day of the month is substituted. Thus, adding 1 month to 31 January will result in 28 February in a common year or 29 February in a leap year. The rules for handling anomalies relating to summer time and to the Gregorian calendar are the same when adding/subtracting months and years as they are when adding/subtracting days and weeks. If multiple count unit pairs are present on the command, they are evaluated consecutively, from left to right. HIGH RESOLUTION TIMERS Most of the subcommands supported by the clock command deal with times represented as a count of seconds from the epoch time, and this is the representation that clock seconds returns. There are three exceptions, which are all intended for use where higher-resolution times are required. clock milliseconds returns the count of milliseconds from the epoch time, and clock microseconds returns the count of microseconds from the epoch time. In addition, there is a clock clicks command that returns a platform-dependent high-resolution timer. Unlike clock seconds and clock milliseconds , the value of clock clicks is not guaranteed to be tied to any fixed epoch; it is simply intended to be the most precise interval timer available, and is intended only for relative timing studies such as benchmarks. FORMATTING TIMES The clock format command produces times for display to a user or writing to an external medium. The command accepts times that are expressed in seconds from the epoch time of 1 January 1970, 00:00 UTC, as returned by clock seconds , clock scan , clock add , file atime or file mtime . If a -format option is present, the following argument is a string that specifies how the date and time are to be formatted. The string consists of any number of characters other than the per-cent sign interspersed with any number of format groups , which are two-character sequences beginning with the per-cent sign. The permissible format groups, and their interpretation, are described under FORMAT GROUPS . If a -timezone option is present, the following argument is a string that specifies the time zone in which the date and time are to be formatted. As an alternative to the obsolete usage may be used. See TIME ZONES for the permissible variants for the time zone. If a -locale option is present, the following argument is a string that specifies the locale in which the time is to be formatted, in the same format that is used for the msgcat package. Note that the default, if -locale is not specified, is the root locale {} rather than the current locale. The current locale may be obtained by using -locale current . In addition, some platforms support a system locale that reflects the user\\'s current choices. For instance, on Windows, the format that the user has selected from dates and times in the Control Panel can be obtained by using the system locale. On platforms that do not define a user selection of date and time formats separate from LC_TIME , -locale system is synonymous with -locale current . SCANNING TIMES The clock scan command accepts times that are formatted as strings and converts them to counts of seconds from the epoch time of 1 January 1970, 00:00 UTC. It normally takes a -format option that is followed by a string describing the expected format of the input. (See FREE FORM SCAN for the effect of clock scan without such an argument.) The string consists of any number of characters other than the per-cent sign interspersed with any number of format groups , which are two-character sequences beginning with the per-cent sign. The permissible format groups, and their interpretation, are described under FORMAT GROUPS . If a -timezone option is present, the following argument is a string that specifies the time zone in which the date and time are to be interpreted. As an alternative to -timezone :UTC , the obsolete usage -gmt true may be used. See TIME ZONES for the permissible variants for the time zone. If a -locale option is present, the following argument is a string that specifies the locale in which the time is to be interpreted, in the same format that is used for the msgcat package. Note that the default, if -locale is not specified, is the root locale {} rather than the current locale. The current locale may be obtained by using -locale current . In addition, some platforms support a system locale that reflects the user\\'s current choices. For instance, on Windows, the format that the user has selected from dates and times in the Control Panel can be obtained by using the system locale. On platforms that do not define a user selection of date and time formats separate from LC_TIME , -locale system is synonymous with -locale current . If a -base option is present, the following argument is a time (expressed in seconds from the epoch time) that is used as a base time for interpreting relative times. If no -base option is present, the base time is the current time. Scanning of times in fixed format works by determining three things: the date, the time of day, and the time zone. These three are then combined into a point in time, which is returned as the number of seconds from the epoch. Before scanning begins, the format string is preprocessed to replace %c , %Ec , %x , %Ex , %X . %Ex , %r , %R , %T , %D , %EY and %+ format groups with counterparts that are appropriate to the current locale and contain none of the above groups. For instance, %D will (in the en_US locale) be replaced with %m/%d/%Y . The date is determined according to the fields that are present in the preprocessed format string. In order of preference: [1] : If the string contains a %s format group, representing seconds from the epoch, that group is used to determine the date. [2] : If the string contains a %J format group, representing the Julian Day Number, that group is used to determine the date. [3] : If the string contains a complete set of format groups specifying century, year, month, and day of month; century, year, and day of year; or ISO8601 fiscal year, week of year, and day of week; those groups are combined and used to determine the date. If more than one complete set is present, the one at the rightmost position in the string is used. [4] : If the string lacks a century but contains a set of format groups specifying year of century, month and day of month; year of century and day of year; or two-digit ISO8601 fiscal year, week of year, and day of week; those groups are combined and used to determine the date. If more than one complete set is present, the one at the rightmost position in the string is used. The year is presumed to lie in the range 1938 to 2037 inclusive. [5] : If the string entirely lacks any specification for the year (or contains the year only on the locale\\'s alternative calendar) and contains a set of format groups specifying month and day of month, day of year, or week of year and day of week, those groups are combined and used to determine the date. If more than one complete set is present, the one at the rightmost position in the string is used. The year is determined by interpreting the base time in the given time zone. [6] : If the string contains none of the above sets, but has a day of the month or day of the week, the day of the month or day of the week are used to determine the date by interpreting the base time in the given time zone and returning the given day of the current week or month. (The week runs from Monday to Sunday, ISO8601-fashion.) If both day of month and day of week are present, the day of the month takes priority. [7] : If none of the above rules results in a usable date, the date of the base time in the given time zone is used. The time is also determined according to the fields that are present in the preprocessed format string. In order of preference: [1] : If the string contains a %s format group, representing seconds from the epoch, that group determines the time of day. [2] : If the string contains either an hour on the 24-hour clock or an hour on the 12-hour clock plus an AM/PM indicator, that hour determines the hour of the day. If the string further contains a group specifying the minute of the hour, that group combines with the hour. If the string further contains a group specifying the second of the minute, that group combines with the hour and minute. [3] : If the string contains neither a %s format group nor a group specifying the hour of the day, then midnight ( 00:00 , the start of the given date) is used. The time zone is determined by either the -timezone or -gmt options, or by using the current time zone. If a format string lacks a %z or %Z format group, it is possible for the time to be ambiguous because it appears twice in the same day, once without and once with Daylight Saving Time. If this situation occurs, the first occurrence of the time is chosen. (For this reason, it is wise to have the input string contain the time zone when converting local times. This caveat does not apply to UTC times.) If the interpretation of the groups yields an impossible time because a field is out of range, enough of that field\\'s unit will be added to or subtracted from the time to bring it in range. Thus, if attempting to scan or format day 0 of the month, one day will be subtracted from day 1 of the month, yielding the last day of the previous month. If the interpretation of the groups yields an impossible time because a Daylight Saving Time change skips over that time, or an ambiguous time because a Daylight Saving Time change skips back so that the clock observes the given time twice, and no time zone specifier ( %z or %Z ) is present in the format, the time is interpreted as if the clock had not changed. FORMAT GROUPS The following format groups are recognized by the clock scan and clock format commands. %a : On output, produces an abbreviation ( e.g., Mon ) for the day of the week in the given locale. On input, matches the name of the day of the week in the given locale (in either abbreviated or full form, or any unique prefix of either form). %A : On output, produces the full name ( e.g., Monday ) of the day of the week in the given locale. On input, matches the name of the day of the week in the given locale (in either abbreviated or full form, or any unique prefix of either form). %b : On output, produces an abbreviation ( e.g., Jan ) for the name of the month in the given locale. On input, matches the name of the month in the given locale (in either abbreviated or full form, or any unique prefix of either form). %B : On output, produces the full name ( e.g., January ) of the month in the given locale. On input, matches the name of the month in the given locale (in either abbreviated or full form, or any unique prefix of either form). %c : On output, produces a localized representation of date and time of day; the localized representation is expected to use the Gregorian calendar. On input, matches whatever %c produces. %C : On output, produces the number of the century in Indo-Arabic numerals. On input, matches one or two digits, possibly with leading whitespace, that are expected to be the number of the century. %d : On output, produces the number of the day of the month, as two decimal digits. On input, matches one or two digits, possibly with leading whitespace, that are expected to be the number of the day of the month. %D : This format group is synonymous with %m/%d/%Y . It should be used only in exchanging data within the en_US locale, since other locales typically do not use this order for the fields of the date. %e : On output, produces the number of the day of the month, as one or two decimal digits (with a leading blank for one-digit dates). On input, matches one or two digits, possibly with leading whitespace, that are expected to be the number of the day of the month. %Ec : On output, produces a locale-dependent representation of the date and time of day in the locale\\'s alternative calendar. On input, matches whatever %Ec produces. The locale\\'s alternative calendar need not be the Gregorian calendar. %EC : On output, produces a locale-dependent name of an era in the locale\\'s alternative calendar. On input, matches the name of the era or any unique prefix. %EE : On output, produces the string B.C.E. or C.E. , or a string of the same meaning in the locale, to indicate whether %Y refers to years before or after Year 1 of the Common Era. On input, accepts the string B.C.E. , B.C. , C.E. , A.D. , or the abbreviation appropriate to the current locale, and uses it to fix whether %Y refers to years before or after Year 1 of the Common Era. %Ex : On output, produces a locale-dependent representation of the date in the locale\\'s alternative calendar. On input, matches whatever %Ex produces. The locale\\'s alternative calendar need not be the Gregorian calendar. %EX : On output, produces a locale-dependent representation of the time of day in the locale\\'s alternative numerals. On input, matches whatever %EX produces. %Ey : On output, produces a locale-dependent number of the year of the era in the locale\\'s alternative calendar and numerals. On input, matches such a number. %EY : On output, produces a representation of the year in the locale\\'s alternative calendar and numerals. On input, matches what %EY produces. Often synonymous with %EC%Ey . %g : On output, produces a two-digit year number suitable for use with the week-based ISO8601 calendar; that is, the year number corresponds to the week number produced by %V . On input, accepts such a two-digit year number, possibly with leading whitespace. %G : On output, produces a four-digit year number suitable for use with the week-based ISO8601 calendar; that is, the year number corresponds to the week number produced by %V . On input, accepts such a four-digit year number, possibly with leading whitespace. %h : This format group is synonymous with %b . %H : On output, produces a two-digit number giving the hour of the day (00-23) on a 24-hour clock. On input, accepts such a number. %I : On output, produces a two-digit number giving the hour of the day (12-11) on a 12-hour clock. On input, accepts such a number. %j : On output, produces a three-digit number giving the day of the year (001-366). On input, accepts such a number. %J : On output, produces a string of digits giving the Julian Day Number. On input, accepts a string of digits and interprets it as a Julian Day Number. The Julian Day Number is a count of the number of calendar days that have elapsed since 1 January, 4713 BCE of the proleptic Julian calendar. The epoch time of 1 January 1970 corresponds to Julian Day Number 2440588. %k : On output, produces a one- or two-digit number giving the hour of the day (0-23) on a 24-hour clock. On input, accepts such a number. %l : On output, produces a one- or two-digit number giving the hour of the day (12-11) on a 12-hour clock. On input, accepts such a number. %m : On output, produces the number of the month (01-12) with exactly two digits. On input, accepts two digits and interprets them as the number of the month. %M : On output, produces the number of the minute of the hour (00-59) with exactly two digits. On input, accepts two digits and interprets them as the number of the minute of the hour. %N : On output, produces the number of the month (1-12) with one or two digits, and a leading blank for one-digit dates. On input, accepts one or two digits, possibly with leading whitespace, and interprets them as the number of the month. %Od , %Oe , %OH , %OI , %Ok , %Ol , %Om , %OM , %OS , %Ou , %Ow , %Oy : All of these format groups are synonymous with their counterparts without the except that the string is produced and parsed in the locale-dependent alternative numerals. %p : On output, produces an indicator for the part of the day, AM or PM , appropriate to the given locale. If the script of the given locale supports multiple letterforms, lowercase is preferred. On input, matches the representation AM or PM in the given locale, in either case. %P : On output, produces an indicator for the part of the day, am or pm , appropriate to the given locale. If the script of the given locale supports multiple letterforms, uppercase is preferred. On input, matches the representation AM or PM in the given locale, in either case. %Q : This format group is reserved for internal use within the Tcl library. %r : On output, produces a locale-dependent time of day representation on a 12-hour clock. On input, accepts whatever %r produces. %R : On output, the time in 24-hour notation (%H:%M). For a version including the seconds, see %T below. On input, accepts whatever %R produces. %s : On output, simply formats the timeVal argument as a decimal integer and inserts it into the output string. On input, accepts a decimal integer and uses is as the time value without any further processing. Since %s uniquely determines a point in time, it overrides all other input formats. %S : On output, produces a two-digit number of the second of the minute (00-59). On input, accepts two digits and uses them as the second of the minute. %t : On output, produces a TAB character. On input, matches a TAB character. %T : Synonymous with %H:%M:%S . %u : On output, produces the number of the day of the week ( 1 \u2192Monday, 7 \u2192Sunday). On input, accepts a single digit and interprets it as the day of the week. Sunday may be either 0 or 7 . %U : On output, produces the ordinal number of the week of the year (00-53). The first Sunday of the year is the first day of week 01. On input accepts two digits which are otherwise ignored. This format group is never used in determining an input date. This interpretation of the week of the year was once common in US banking but is now largely obsolete. See %V for the ISO8601 week number. %V : On output, produces the number of the ISO8601 week as a two digit number (01-53). Week 01 is the week containing January 4; or the first week of the year containing at least 4 days; or the week containing the first Thursday of the year (the three statements are equivalent). Each week begins on a Monday. On input, accepts the ISO8601 week number. %w : On output, produces the ordinal number of the day of the week (Sunday==0; Saturday==6). On input, accepts a single digit and interprets it as the day of the week; Sunday may be represented as either 0 or 7. Note that %w is not the ISO8601 weekday number, which is produced and accepted by %u . %W : On output, produces a week number (00-53) within the year; week 01 begins on the first Monday of the year. On input, accepts two digits, which are otherwise ignored. This format group is never used in determining an input date. It is not the ISO8601 week number; that week is produced and accepted by %V . %x : On output, produces the date in a locale-dependent representation. On input, accepts whatever %x produces and is used to determine calendar date. %X : On output, produces the time of day in a locale-dependent representation. On input, accepts whatever %X produces and is used to determine time of day. %y : On output, produces the two-digit year of the century. On input, accepts two digits, and is used to determine calendar date. The date is presumed to lie between 1938 and 2037 inclusive. Note that %y does not yield a year appropriate for use with the ISO8601 week number %V ; programs should use %g for that purpose. %Y : On output, produces the four-digit calendar year. On input, accepts four digits and may be used to determine calendar date. Note that %Y does not yield a year appropriate for use with the ISO8601 week number %V ; programs should use %G for that purpose. %z : On output, produces the current time zone, expressed in hours and minutes east (+hhmm) or west (-hhmm) of Greenwich. On input, accepts a time zone specifier (see TIME ZONES below) that will be used to determine the time zone. %Z : On output, produces the current time zone\\'s name, possibly translated to the given locale. On input, accepts a time zone specifier (see TIME ZONES below) that will be used to determine the time zone. This option should, in general, be used on input only when parsing RFC822 dates. Other uses are fraught with ambiguity; for instance, the string BST may represent British Summer Time or Brazilian Standard Time. It is recommended that date/time strings for use by computers use numeric time zones instead. %% : On output, produces a literal character. On input, matches a literal character. %+ : Synonymous with TIME ZONES When the clock command is processing a local time, it has several possible sources for the time zone to use. In order of preference, they are: [1] : A time zone specified inside a string being parsed and matched by a %z or %Z format group. [2] : A time zone specified with the -timezone option to the clock command (or, equivalently, by -gmt 1 ). [3] : A time zone specified in an environment variable TCL_TZ . [4] : A time zone specified in an environment variable TZ . [5] : The local time zone from the Control Panel on Windows systems. [6] : The C library\\'s idea of the local time zone, as defined by the mktime and localtime functions. In case [1] only, the string is tested to see if it is one of the strings: gmt ut utc bst wet wat at nft nst ndt ast adt est edt cst cdt mst mdt pst pdt yst ydt hst hdt cat ahst nt idlw cet cest met mewt mest swt sst eet eest bt it zp4 zp5 ist zp6 wast wadt jt cct jst cast cadt east eadt gst nzt nzst nzdt idle If it is a string in the above list, it designates a known time zone, and is interpreted as such. For time zones in case [1] that do not match any of the above strings, and always for cases [2]-[6], the following rules apply. If the time zone begins with a colon, it is one of a standardized list of names like :America/New_York that give the rules for various locales. A complete list of the location names is too lengthy to be listed here. On most Tcl installations, the definitions of the locations are to be found in named files in the directory On some Unix systems, these files are omitted, and the definitions are instead obtained from system files in or As a special case, the name :localtime refers to the local time zone as defined by the C library. A time zone string consisting of a plus or minus sign followed by four or six decimal digits is interpreted as an offset in hours, minutes, and seconds (if six digits are present) from UTC. The plus sign denotes a sign east of Greenwich; the minus sign one west of Greenwich. A time zone string conforming to the Posix specification of the TZ environment variable will be recognized. The specification may be found at https://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html . If the Posix time zone string contains a DST (Daylight Savings Time) part, but doesn\\'t contain a rule stating when DST starts or ends, then default rules are used. For Timezones with an offset between 0 and +12, the current European/Russian rules are used, otherwise the current US rules are used. In Europe (offset +0 to +2) the switch to summertime is done each last Sunday in March at 1:00 GMT, and the switch back is each last Sunday in October at 2:00 GMT. In Russia (offset +3 to +12), the switch dates are the same, only the switch to summertime is at 2:00 local time, and the switch back is at 3:00 local time in all time zones. The US switch to summertime takes place each second Sunday in March at 2:00 local time, and the switch back is each first Sunday in November at 3:00 local time. These default rules mean that in all European, Russian and US (or compatible) time zones, DST calculations will be correct for dates in 2007 and later, unless in the future the rules change again. Any other time zone string is processed by prefixing a colon and attempting to use it as a location name, as above. LOCALIZATION Developers wishing to localize the date and time formatting and parsing are referred to https://tip.tcl-lang.org/173 for a specification. FREE FORM SCAN If the clock scan command is invoked without a -format option, then it requests a free-form scan. This form of scan is deprecated. The reason for the deprecation is that there are too many ambiguities. (Does the string represent a year, a time of day, or a quantity?) No set of rules for interpreting free-form dates and times has been found to give unsurprising results in all cases. If free-form scan is used, only the -base and -gmt options are accepted. The -timezone and -locale options will result in an error if -format is not supplied. For the benefit of users who need to understand legacy code that uses free-form scan, the documentation for how free-form scan interprets a string is included here: If only a time is specified, the current date is assumed. If the inputString does not contain a time zone mnemonic, the local time zone is assumed, unless the -gmt argument is true, in which case the clock value is calculated assuming that the specified time is relative to Greenwich Mean Time. -gmt , if specified, affects only the computed time value; it does not impact the interpretation of -base . If the -base flag is specified, the next argument should contain an integer clock value. Only the date in this value is used, not the time. This is useful for determining the time on a specific day or doing other date-relative conversions. The inputString argument consists of zero or more specifications of the following form: time : A time of day, which is of the form: or If no meridian is specified, hh is interpreted on a 24-hour clock. date : A specific month and day with optional year. The acceptable formats are and The default year is the current year. If the year is less than 100, we treat the years 00-68 as 2000-2068 and the years 69-99 as 1969-1999. Not all platforms can represent the years 38-70, so an error may result if these years are used. ISO 8601 point-in-time : An ISO 8601 point-in-time specification, such as where T is the literal or Note that only these four formats are accepted. The command does not accept the full range of point-in-time specifications specified in ISO8601. Other formats can be recognized by giving an explicit -format option to the clock scan command. relative time : A specification relative to the current time. The format is number unit. Acceptable units are year , fortnight , month , week , day , hour , minute (or min ), and second (or sec ). The unit can be specified as a singular or plural, as in 3 weeks . These modifiers may also be specified: tomorrow , yesterday , today , now , last , this , next , ago . The actual date is calculated according to the following steps. First, any absolute date and/or time is processed and converted. Using that time as the base, day-of-week specifications are added. Next, relative specifications are used. If a date or day is specified, and no absolute or relative time is given, midnight is used. Finally, a correction is applied so that the correct hour of the day is produced after allowing for daylight savings time differences and the correct date is given when going from the end of a long month to a short month. SEE ALSO msgcat(n) KEYWORDS clock, date, time COPYRIGHT Copyright \u00a9 2004 Kevin B. Kenny \\<kennykb@acm.org>. All rights reserved.","title":"NAME"},{"location":"clock/#name","text":"clock - Obtain and manipulate dates and times","title":"NAME"},{"location":"clock/#synopsis","text":"package require Tcl 8.5- clock add timeVal ? count unit... ? ? -option value ? clock clicks ? -option ? clock format timeVal ? -option value ...? clock microseconds clock milliseconds clock scan inputString ? -option value ...? clock seconds","title":"SYNOPSIS"},{"location":"clock/#description","text":"The clock command performs several operations that obtain and manipulate values that represent times. The command supports several subcommands that determine what action is carried out by the command. clock add timeVal ? count unit... ? ? -option value ? : Adds a (possibly negative) offset to a time that is expressed as an integer number of seconds. See CLOCK ARITHMETIC for a full description. clock clicks ? -option ? : If no -option argument is supplied, returns a high-resolution time value as a system-dependent integer value. The unit of the value is system-dependent but should be the highest resolution clock available on the system such as a CPU cycle counter. See HIGH RESOLUTION TIMERS for a full description. If the *-option* argument is **-milliseconds**, then the command is synonymous with **clock milliseconds** (see below). This usage is obsolete, and **clock milliseconds** is to be considered the preferred way of obtaining a count of milliseconds. If the *-option* argument is **-microseconds**, then the command is synonymous with **clock microseconds** (see below). This usage is obsolete, and **clock microseconds** is to be considered the preferred way of obtaining a count of microseconds. clock format timeVal ? -option value ...? : Formats a time that is expressed as an integer number of seconds into a format intended for consumption by users or external programs. See FORMATTING TIMES for a full description. clock microseconds : Returns the current time as an integer number of microseconds. See HIGH RESOLUTION TIMERS for a full description. clock milliseconds : Returns the current time as an integer number of milliseconds. See HIGH RESOLUTION TIMERS for a full description. clock scan inputString ? -option value ...? : Scans a time that is expressed as a character string and produces an integer number of seconds. See SCANNING TIMES for a full description. clock seconds : Returns the current time as an integer number of seconds.","title":"DESCRIPTION"},{"location":"clock/#parameters","text":"count : An integer representing a count of some unit of time. See CLOCK ARITHMETIC for the details. timeVal : An integer value passed to the clock command that represents an absolute time as a number of seconds from the epoch time of 1 January 1970, 00:00 UTC. Note that the count of seconds does not include any leap seconds; seconds are counted as if each UTC day has exactly 86400 seconds. Tcl responds to leap seconds by speeding or slowing its clock by a tiny fraction for some minutes until it is back in sync with UTC; its data model does not represent minutes that have 59 or 61 seconds. unit : One of the words, seconds , minutes , hours , days , weekdays , weeks , months , or years . Used in conjunction with count to identify an interval of time, for example, 3 seconds or 1 year .","title":"PARAMETERS"},{"location":"clock/#options","text":"-base time : Specifies that any relative times present in a clock scan command are to be given relative to time . time must be expressed as a count of nominal seconds from the epoch time of 1 January 1970, 00:00 UTC. -format format : Specifies the desired output format for clock format or the expected input format for clock scan . The format string consists of any number of characters other than the per-cent sign interspersed with any number of format groups , which are two-character sequences beginning with the per-cent sign. The permissible format groups, and their interpretation, are described under FORMAT GROUPS . On clock format , the default format is %a %b %d %H:%M:%S %Z %Y On clock scan , the lack of a -format option indicates that a is requested; see FREE FORM SCAN for a description of what happens. -gmt boolean : If boolean is true, specifies that a time specified to clock add , clock format or clock scan should be processed in UTC. If boolean is false, the processing defaults to the local time zone. This usage is obsolete; the correct current usage is to specify the UTC time zone with or any of the equivalent ways to specify it. -locale localeName : Specifies that locale-dependent scanning and formatting (and date arithmetic for dates preceding the adoption of the Gregorian calendar) is to be done in the locale identified by localeName . The locale name may be any of the locales acceptable to the msgcat package, or it may be the special name system , which represents the current locale of the process, or the null string, which represents Tcl\\'s default locale. The effect of locale on scanning and formatting is discussed in the descriptions of the individual format groups under **FORMAT GROUPS**. The effect of locale on clock arithmetic is discussed under **CLOCK ARITHMETIC**. -timezone zoneName : Specifies that clock arithmetic, formatting, and scanning are to be done according to the rules for the time zone specified by zoneName . The permissible values, and their interpretation, are discussed under TIME ZONES . On subcommands that expect a -timezone argument, the default is to use the current time zone . The current time zone is determined, in order of preference, by: \\[1\\] : the environment variable **TCL_TZ**. \\[2\\] : the environment variable **TZ**. \\[3\\] : on Windows systems, the time zone settings from the Control Panel. If none of these is present, the C localtime and mktime functions are used to attempt to convert times between local and Greenwich. On 32-bit systems, this approach is likely to have bugs, particularly for times that lie outside the window (approximately the years 1902 to 2037) that can be represented in a 32-bit integer.","title":"OPTIONS"},{"location":"clock/#clock-arithmetic","text":"The clock add command performs clock arithmetic on a value (expressed as nominal seconds from the epoch time of 1 January 1970, 00:00 UTC) given as its first argument. The remaining arguments (other than the possible -timezone , -locale and -gmt options) are integers and keywords in alternation, where the keywords are chosen from seconds , minutes , hours , days , weekdays , weeks , months , or years . Addition of seconds, minutes and hours is fairly straightforward; the given time increment (times sixty for minutes, or 3600 for hours) is simply added to the timeVal given to the clock add command. The result is interpreted as a nominal number of seconds from the Epoch. Surprising results may be obtained when crossing a point at which a leap second is inserted or removed; the clock add command simply ignores leap seconds and therefore assumes that times come in sequence, 23:59:58, 23:59:59, 00:00:00. This assumption is handled by the fact that Tcl\\'s model of time reacts to leap seconds by speeding or slowing the clock by a miniscule amount until Tcl\\'s time is back in step with the world. The fact that adding and subtracting hours is defined in terms of absolute time means that it will add fixed amounts of time in time zones that observe summer time (Daylight Saving Time). For example, the following code sets the value of x to 04:00:00 because the clock has changed in the interval in question. set s [ clock scan {2004-10-30 05:00:00} \\ -format {%Y-%m-%d %H:%M:%S} \\ -timezone :America/New_York] set a [ clock add \\$s 24 hours -timezone :America/New_York] set x [ clock format \\$a \\ -format {%H:%M:%S} -timezone :America/New_York] Adding and subtracting days and weeks is accomplished by converting the given time to a calendar day and time of day in the appropriate time zone and locale. The requisite number of days (weeks are converted to days by multiplying by seven) is added to the calendar day, and the date and time are then converted back to a count of seconds from the epoch time. The weekdays keyword is similar to days , with the only difference that weekends - Saturdays and Sundays - are skipped. Adding and subtracting a given number of days across the point that the time changes at the start or end of summer time (Daylight Saving Time) results in the same local time on the day in question. For instance, the following code sets the value of x to 05:00:00 . set s [ clock scan {2004-10-30 05:00:00} \\ -format {%Y-%m-%d %H:%M:%S} \\ -timezone :America/New_York] set a [ clock add \\$s 1 day -timezone :America/New_York] set x [ clock format \\$a \\ -format {%H:%M:%S} -timezone :America/New_York] In cases of ambiguity, where the same local time happens twice on the same day, the earlier time is used. In cases where the conversion yields an impossible time (for instance, 02:30 during the Spring Daylight Saving Time change using US rules), the time is converted as if the clock had not changed. Thus, the following code will set the value of x to 03:30:00 . set s [ clock scan {2004-04-03 02:30:00} \\ -format {%Y-%m-%d %H:%M:%S} \\ -timezone :America/New_York] set a [ clock add \\$s 1 day -timezone :America/New_York] set x [ clock format \\$a \\ -format {%H:%M:%S} -timezone :America/New_York] Adding a given number of days or weeks works correctly across the conversion between the Julian and Gregorian calendars; the omitted days are skipped. The following code sets z to 1752-09-14 . set x [ clock scan 1752-09-02 -format %Y-%m-%d -locale en_US] set y [ clock add \\$x 1 day -locale en_US] set z [ clock format \\$y -format %Y-%m-%d -locale en_US] In the bizarre case that adding the given number of days yields a date that does not exist because it falls within the dropped days of the Julian-to-Gregorian conversion, the date is converted as if it was on the Julian calendar. Adding a number of months, or a number of years, is similar; it converts the given time to a calendar date and time of day. It then adds the requisite number of months or years, and reconverts the resulting date and time of day to an absolute time. If the resulting date is impossible because the month has too few days (for example, when adding 1 month to 31 January), the last day of the month is substituted. Thus, adding 1 month to 31 January will result in 28 February in a common year or 29 February in a leap year. The rules for handling anomalies relating to summer time and to the Gregorian calendar are the same when adding/subtracting months and years as they are when adding/subtracting days and weeks. If multiple count unit pairs are present on the command, they are evaluated consecutively, from left to right.","title":"CLOCK ARITHMETIC"},{"location":"clock/#high-resolution-timers","text":"Most of the subcommands supported by the clock command deal with times represented as a count of seconds from the epoch time, and this is the representation that clock seconds returns. There are three exceptions, which are all intended for use where higher-resolution times are required. clock milliseconds returns the count of milliseconds from the epoch time, and clock microseconds returns the count of microseconds from the epoch time. In addition, there is a clock clicks command that returns a platform-dependent high-resolution timer. Unlike clock seconds and clock milliseconds , the value of clock clicks is not guaranteed to be tied to any fixed epoch; it is simply intended to be the most precise interval timer available, and is intended only for relative timing studies such as benchmarks.","title":"HIGH RESOLUTION TIMERS"},{"location":"clock/#formatting-times","text":"The clock format command produces times for display to a user or writing to an external medium. The command accepts times that are expressed in seconds from the epoch time of 1 January 1970, 00:00 UTC, as returned by clock seconds , clock scan , clock add , file atime or file mtime . If a -format option is present, the following argument is a string that specifies how the date and time are to be formatted. The string consists of any number of characters other than the per-cent sign interspersed with any number of format groups , which are two-character sequences beginning with the per-cent sign. The permissible format groups, and their interpretation, are described under FORMAT GROUPS . If a -timezone option is present, the following argument is a string that specifies the time zone in which the date and time are to be formatted. As an alternative to the obsolete usage may be used. See TIME ZONES for the permissible variants for the time zone. If a -locale option is present, the following argument is a string that specifies the locale in which the time is to be formatted, in the same format that is used for the msgcat package. Note that the default, if -locale is not specified, is the root locale {} rather than the current locale. The current locale may be obtained by using -locale current . In addition, some platforms support a system locale that reflects the user\\'s current choices. For instance, on Windows, the format that the user has selected from dates and times in the Control Panel can be obtained by using the system locale. On platforms that do not define a user selection of date and time formats separate from LC_TIME , -locale system is synonymous with -locale current .","title":"FORMATTING TIMES"},{"location":"clock/#scanning-times","text":"The clock scan command accepts times that are formatted as strings and converts them to counts of seconds from the epoch time of 1 January 1970, 00:00 UTC. It normally takes a -format option that is followed by a string describing the expected format of the input. (See FREE FORM SCAN for the effect of clock scan without such an argument.) The string consists of any number of characters other than the per-cent sign interspersed with any number of format groups , which are two-character sequences beginning with the per-cent sign. The permissible format groups, and their interpretation, are described under FORMAT GROUPS . If a -timezone option is present, the following argument is a string that specifies the time zone in which the date and time are to be interpreted. As an alternative to -timezone :UTC , the obsolete usage -gmt true may be used. See TIME ZONES for the permissible variants for the time zone. If a -locale option is present, the following argument is a string that specifies the locale in which the time is to be interpreted, in the same format that is used for the msgcat package. Note that the default, if -locale is not specified, is the root locale {} rather than the current locale. The current locale may be obtained by using -locale current . In addition, some platforms support a system locale that reflects the user\\'s current choices. For instance, on Windows, the format that the user has selected from dates and times in the Control Panel can be obtained by using the system locale. On platforms that do not define a user selection of date and time formats separate from LC_TIME , -locale system is synonymous with -locale current . If a -base option is present, the following argument is a time (expressed in seconds from the epoch time) that is used as a base time for interpreting relative times. If no -base option is present, the base time is the current time. Scanning of times in fixed format works by determining three things: the date, the time of day, and the time zone. These three are then combined into a point in time, which is returned as the number of seconds from the epoch. Before scanning begins, the format string is preprocessed to replace %c , %Ec , %x , %Ex , %X . %Ex , %r , %R , %T , %D , %EY and %+ format groups with counterparts that are appropriate to the current locale and contain none of the above groups. For instance, %D will (in the en_US locale) be replaced with %m/%d/%Y . The date is determined according to the fields that are present in the preprocessed format string. In order of preference: [1] : If the string contains a %s format group, representing seconds from the epoch, that group is used to determine the date. [2] : If the string contains a %J format group, representing the Julian Day Number, that group is used to determine the date. [3] : If the string contains a complete set of format groups specifying century, year, month, and day of month; century, year, and day of year; or ISO8601 fiscal year, week of year, and day of week; those groups are combined and used to determine the date. If more than one complete set is present, the one at the rightmost position in the string is used. [4] : If the string lacks a century but contains a set of format groups specifying year of century, month and day of month; year of century and day of year; or two-digit ISO8601 fiscal year, week of year, and day of week; those groups are combined and used to determine the date. If more than one complete set is present, the one at the rightmost position in the string is used. The year is presumed to lie in the range 1938 to 2037 inclusive. [5] : If the string entirely lacks any specification for the year (or contains the year only on the locale\\'s alternative calendar) and contains a set of format groups specifying month and day of month, day of year, or week of year and day of week, those groups are combined and used to determine the date. If more than one complete set is present, the one at the rightmost position in the string is used. The year is determined by interpreting the base time in the given time zone. [6] : If the string contains none of the above sets, but has a day of the month or day of the week, the day of the month or day of the week are used to determine the date by interpreting the base time in the given time zone and returning the given day of the current week or month. (The week runs from Monday to Sunday, ISO8601-fashion.) If both day of month and day of week are present, the day of the month takes priority. [7] : If none of the above rules results in a usable date, the date of the base time in the given time zone is used. The time is also determined according to the fields that are present in the preprocessed format string. In order of preference: [1] : If the string contains a %s format group, representing seconds from the epoch, that group determines the time of day. [2] : If the string contains either an hour on the 24-hour clock or an hour on the 12-hour clock plus an AM/PM indicator, that hour determines the hour of the day. If the string further contains a group specifying the minute of the hour, that group combines with the hour. If the string further contains a group specifying the second of the minute, that group combines with the hour and minute. [3] : If the string contains neither a %s format group nor a group specifying the hour of the day, then midnight ( 00:00 , the start of the given date) is used. The time zone is determined by either the -timezone or -gmt options, or by using the current time zone. If a format string lacks a %z or %Z format group, it is possible for the time to be ambiguous because it appears twice in the same day, once without and once with Daylight Saving Time. If this situation occurs, the first occurrence of the time is chosen. (For this reason, it is wise to have the input string contain the time zone when converting local times. This caveat does not apply to UTC times.) If the interpretation of the groups yields an impossible time because a field is out of range, enough of that field\\'s unit will be added to or subtracted from the time to bring it in range. Thus, if attempting to scan or format day 0 of the month, one day will be subtracted from day 1 of the month, yielding the last day of the previous month. If the interpretation of the groups yields an impossible time because a Daylight Saving Time change skips over that time, or an ambiguous time because a Daylight Saving Time change skips back so that the clock observes the given time twice, and no time zone specifier ( %z or %Z ) is present in the format, the time is interpreted as if the clock had not changed.","title":"SCANNING TIMES"},{"location":"clock/#format-groups","text":"The following format groups are recognized by the clock scan and clock format commands. %a : On output, produces an abbreviation ( e.g., Mon ) for the day of the week in the given locale. On input, matches the name of the day of the week in the given locale (in either abbreviated or full form, or any unique prefix of either form). %A : On output, produces the full name ( e.g., Monday ) of the day of the week in the given locale. On input, matches the name of the day of the week in the given locale (in either abbreviated or full form, or any unique prefix of either form). %b : On output, produces an abbreviation ( e.g., Jan ) for the name of the month in the given locale. On input, matches the name of the month in the given locale (in either abbreviated or full form, or any unique prefix of either form). %B : On output, produces the full name ( e.g., January ) of the month in the given locale. On input, matches the name of the month in the given locale (in either abbreviated or full form, or any unique prefix of either form). %c : On output, produces a localized representation of date and time of day; the localized representation is expected to use the Gregorian calendar. On input, matches whatever %c produces. %C : On output, produces the number of the century in Indo-Arabic numerals. On input, matches one or two digits, possibly with leading whitespace, that are expected to be the number of the century. %d : On output, produces the number of the day of the month, as two decimal digits. On input, matches one or two digits, possibly with leading whitespace, that are expected to be the number of the day of the month. %D : This format group is synonymous with %m/%d/%Y . It should be used only in exchanging data within the en_US locale, since other locales typically do not use this order for the fields of the date. %e : On output, produces the number of the day of the month, as one or two decimal digits (with a leading blank for one-digit dates). On input, matches one or two digits, possibly with leading whitespace, that are expected to be the number of the day of the month. %Ec : On output, produces a locale-dependent representation of the date and time of day in the locale\\'s alternative calendar. On input, matches whatever %Ec produces. The locale\\'s alternative calendar need not be the Gregorian calendar. %EC : On output, produces a locale-dependent name of an era in the locale\\'s alternative calendar. On input, matches the name of the era or any unique prefix. %EE : On output, produces the string B.C.E. or C.E. , or a string of the same meaning in the locale, to indicate whether %Y refers to years before or after Year 1 of the Common Era. On input, accepts the string B.C.E. , B.C. , C.E. , A.D. , or the abbreviation appropriate to the current locale, and uses it to fix whether %Y refers to years before or after Year 1 of the Common Era. %Ex : On output, produces a locale-dependent representation of the date in the locale\\'s alternative calendar. On input, matches whatever %Ex produces. The locale\\'s alternative calendar need not be the Gregorian calendar. %EX : On output, produces a locale-dependent representation of the time of day in the locale\\'s alternative numerals. On input, matches whatever %EX produces. %Ey : On output, produces a locale-dependent number of the year of the era in the locale\\'s alternative calendar and numerals. On input, matches such a number. %EY : On output, produces a representation of the year in the locale\\'s alternative calendar and numerals. On input, matches what %EY produces. Often synonymous with %EC%Ey . %g : On output, produces a two-digit year number suitable for use with the week-based ISO8601 calendar; that is, the year number corresponds to the week number produced by %V . On input, accepts such a two-digit year number, possibly with leading whitespace. %G : On output, produces a four-digit year number suitable for use with the week-based ISO8601 calendar; that is, the year number corresponds to the week number produced by %V . On input, accepts such a four-digit year number, possibly with leading whitespace. %h : This format group is synonymous with %b . %H : On output, produces a two-digit number giving the hour of the day (00-23) on a 24-hour clock. On input, accepts such a number. %I : On output, produces a two-digit number giving the hour of the day (12-11) on a 12-hour clock. On input, accepts such a number. %j : On output, produces a three-digit number giving the day of the year (001-366). On input, accepts such a number. %J : On output, produces a string of digits giving the Julian Day Number. On input, accepts a string of digits and interprets it as a Julian Day Number. The Julian Day Number is a count of the number of calendar days that have elapsed since 1 January, 4713 BCE of the proleptic Julian calendar. The epoch time of 1 January 1970 corresponds to Julian Day Number 2440588. %k : On output, produces a one- or two-digit number giving the hour of the day (0-23) on a 24-hour clock. On input, accepts such a number. %l : On output, produces a one- or two-digit number giving the hour of the day (12-11) on a 12-hour clock. On input, accepts such a number. %m : On output, produces the number of the month (01-12) with exactly two digits. On input, accepts two digits and interprets them as the number of the month. %M : On output, produces the number of the minute of the hour (00-59) with exactly two digits. On input, accepts two digits and interprets them as the number of the minute of the hour. %N : On output, produces the number of the month (1-12) with one or two digits, and a leading blank for one-digit dates. On input, accepts one or two digits, possibly with leading whitespace, and interprets them as the number of the month. %Od , %Oe , %OH , %OI , %Ok , %Ol , %Om , %OM , %OS , %Ou , %Ow , %Oy : All of these format groups are synonymous with their counterparts without the except that the string is produced and parsed in the locale-dependent alternative numerals. %p : On output, produces an indicator for the part of the day, AM or PM , appropriate to the given locale. If the script of the given locale supports multiple letterforms, lowercase is preferred. On input, matches the representation AM or PM in the given locale, in either case. %P : On output, produces an indicator for the part of the day, am or pm , appropriate to the given locale. If the script of the given locale supports multiple letterforms, uppercase is preferred. On input, matches the representation AM or PM in the given locale, in either case. %Q : This format group is reserved for internal use within the Tcl library. %r : On output, produces a locale-dependent time of day representation on a 12-hour clock. On input, accepts whatever %r produces. %R : On output, the time in 24-hour notation (%H:%M). For a version including the seconds, see %T below. On input, accepts whatever %R produces. %s : On output, simply formats the timeVal argument as a decimal integer and inserts it into the output string. On input, accepts a decimal integer and uses is as the time value without any further processing. Since %s uniquely determines a point in time, it overrides all other input formats. %S : On output, produces a two-digit number of the second of the minute (00-59). On input, accepts two digits and uses them as the second of the minute. %t : On output, produces a TAB character. On input, matches a TAB character. %T : Synonymous with %H:%M:%S . %u : On output, produces the number of the day of the week ( 1 \u2192Monday, 7 \u2192Sunday). On input, accepts a single digit and interprets it as the day of the week. Sunday may be either 0 or 7 . %U : On output, produces the ordinal number of the week of the year (00-53). The first Sunday of the year is the first day of week 01. On input accepts two digits which are otherwise ignored. This format group is never used in determining an input date. This interpretation of the week of the year was once common in US banking but is now largely obsolete. See %V for the ISO8601 week number. %V : On output, produces the number of the ISO8601 week as a two digit number (01-53). Week 01 is the week containing January 4; or the first week of the year containing at least 4 days; or the week containing the first Thursday of the year (the three statements are equivalent). Each week begins on a Monday. On input, accepts the ISO8601 week number. %w : On output, produces the ordinal number of the day of the week (Sunday==0; Saturday==6). On input, accepts a single digit and interprets it as the day of the week; Sunday may be represented as either 0 or 7. Note that %w is not the ISO8601 weekday number, which is produced and accepted by %u . %W : On output, produces a week number (00-53) within the year; week 01 begins on the first Monday of the year. On input, accepts two digits, which are otherwise ignored. This format group is never used in determining an input date. It is not the ISO8601 week number; that week is produced and accepted by %V . %x : On output, produces the date in a locale-dependent representation. On input, accepts whatever %x produces and is used to determine calendar date. %X : On output, produces the time of day in a locale-dependent representation. On input, accepts whatever %X produces and is used to determine time of day. %y : On output, produces the two-digit year of the century. On input, accepts two digits, and is used to determine calendar date. The date is presumed to lie between 1938 and 2037 inclusive. Note that %y does not yield a year appropriate for use with the ISO8601 week number %V ; programs should use %g for that purpose. %Y : On output, produces the four-digit calendar year. On input, accepts four digits and may be used to determine calendar date. Note that %Y does not yield a year appropriate for use with the ISO8601 week number %V ; programs should use %G for that purpose. %z : On output, produces the current time zone, expressed in hours and minutes east (+hhmm) or west (-hhmm) of Greenwich. On input, accepts a time zone specifier (see TIME ZONES below) that will be used to determine the time zone. %Z : On output, produces the current time zone\\'s name, possibly translated to the given locale. On input, accepts a time zone specifier (see TIME ZONES below) that will be used to determine the time zone. This option should, in general, be used on input only when parsing RFC822 dates. Other uses are fraught with ambiguity; for instance, the string BST may represent British Summer Time or Brazilian Standard Time. It is recommended that date/time strings for use by computers use numeric time zones instead. %% : On output, produces a literal character. On input, matches a literal character. %+ : Synonymous with","title":"FORMAT GROUPS"},{"location":"clock/#time-zones","text":"When the clock command is processing a local time, it has several possible sources for the time zone to use. In order of preference, they are: [1] : A time zone specified inside a string being parsed and matched by a %z or %Z format group. [2] : A time zone specified with the -timezone option to the clock command (or, equivalently, by -gmt 1 ). [3] : A time zone specified in an environment variable TCL_TZ . [4] : A time zone specified in an environment variable TZ . [5] : The local time zone from the Control Panel on Windows systems. [6] : The C library\\'s idea of the local time zone, as defined by the mktime and localtime functions. In case [1] only, the string is tested to see if it is one of the strings: gmt ut utc bst wet wat at nft nst ndt ast adt est edt cst cdt mst mdt pst pdt yst ydt hst hdt cat ahst nt idlw cet cest met mewt mest swt sst eet eest bt it zp4 zp5 ist zp6 wast wadt jt cct jst cast cadt east eadt gst nzt nzst nzdt idle If it is a string in the above list, it designates a known time zone, and is interpreted as such. For time zones in case [1] that do not match any of the above strings, and always for cases [2]-[6], the following rules apply. If the time zone begins with a colon, it is one of a standardized list of names like :America/New_York that give the rules for various locales. A complete list of the location names is too lengthy to be listed here. On most Tcl installations, the definitions of the locations are to be found in named files in the directory On some Unix systems, these files are omitted, and the definitions are instead obtained from system files in or As a special case, the name :localtime refers to the local time zone as defined by the C library. A time zone string consisting of a plus or minus sign followed by four or six decimal digits is interpreted as an offset in hours, minutes, and seconds (if six digits are present) from UTC. The plus sign denotes a sign east of Greenwich; the minus sign one west of Greenwich. A time zone string conforming to the Posix specification of the TZ environment variable will be recognized. The specification may be found at https://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html . If the Posix time zone string contains a DST (Daylight Savings Time) part, but doesn\\'t contain a rule stating when DST starts or ends, then default rules are used. For Timezones with an offset between 0 and +12, the current European/Russian rules are used, otherwise the current US rules are used. In Europe (offset +0 to +2) the switch to summertime is done each last Sunday in March at 1:00 GMT, and the switch back is each last Sunday in October at 2:00 GMT. In Russia (offset +3 to +12), the switch dates are the same, only the switch to summertime is at 2:00 local time, and the switch back is at 3:00 local time in all time zones. The US switch to summertime takes place each second Sunday in March at 2:00 local time, and the switch back is each first Sunday in November at 3:00 local time. These default rules mean that in all European, Russian and US (or compatible) time zones, DST calculations will be correct for dates in 2007 and later, unless in the future the rules change again. Any other time zone string is processed by prefixing a colon and attempting to use it as a location name, as above.","title":"TIME ZONES"},{"location":"clock/#localization","text":"Developers wishing to localize the date and time formatting and parsing are referred to https://tip.tcl-lang.org/173 for a specification.","title":"LOCALIZATION"},{"location":"clock/#free-form-scan","text":"If the clock scan command is invoked without a -format option, then it requests a free-form scan. This form of scan is deprecated. The reason for the deprecation is that there are too many ambiguities. (Does the string represent a year, a time of day, or a quantity?) No set of rules for interpreting free-form dates and times has been found to give unsurprising results in all cases. If free-form scan is used, only the -base and -gmt options are accepted. The -timezone and -locale options will result in an error if -format is not supplied. For the benefit of users who need to understand legacy code that uses free-form scan, the documentation for how free-form scan interprets a string is included here: If only a time is specified, the current date is assumed. If the inputString does not contain a time zone mnemonic, the local time zone is assumed, unless the -gmt argument is true, in which case the clock value is calculated assuming that the specified time is relative to Greenwich Mean Time. -gmt , if specified, affects only the computed time value; it does not impact the interpretation of -base . If the -base flag is specified, the next argument should contain an integer clock value. Only the date in this value is used, not the time. This is useful for determining the time on a specific day or doing other date-relative conversions. The inputString argument consists of zero or more specifications of the following form: time : A time of day, which is of the form: or If no meridian is specified, hh is interpreted on a 24-hour clock. date : A specific month and day with optional year. The acceptable formats are and The default year is the current year. If the year is less than 100, we treat the years 00-68 as 2000-2068 and the years 69-99 as 1969-1999. Not all platforms can represent the years 38-70, so an error may result if these years are used. ISO 8601 point-in-time : An ISO 8601 point-in-time specification, such as where T is the literal or Note that only these four formats are accepted. The command does not accept the full range of point-in-time specifications specified in ISO8601. Other formats can be recognized by giving an explicit -format option to the clock scan command. relative time : A specification relative to the current time. The format is number unit. Acceptable units are year , fortnight , month , week , day , hour , minute (or min ), and second (or sec ). The unit can be specified as a singular or plural, as in 3 weeks . These modifiers may also be specified: tomorrow , yesterday , today , now , last , this , next , ago . The actual date is calculated according to the following steps. First, any absolute date and/or time is processed and converted. Using that time as the base, day-of-week specifications are added. Next, relative specifications are used. If a date or day is specified, and no absolute or relative time is given, midnight is used. Finally, a correction is applied so that the correct hour of the day is produced after allowing for daylight savings time differences and the correct date is given when going from the end of a long month to a short month.","title":"FREE FORM SCAN"},{"location":"clock/#see-also","text":"msgcat(n)","title":"SEE ALSO"},{"location":"clock/#keywords","text":"clock, date, time","title":"KEYWORDS"},{"location":"clock/#copyright","text":"Copyright \u00a9 2004 Kevin B. Kenny \\<kennykb@acm.org>. All rights reserved.","title":"COPYRIGHT"},{"location":"close/","text":"NAME close - Close an open channel SYNOPSIS close channelId ?r(ead)|w(rite)? DESCRIPTION Closes or half-closes the channel given by channelId . ChannelId must be an identifier for an open channel such as a Tcl standard channel ( stdin , stdout , or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. The single-argument form is a simple all buffered output is flushed to the channel\\'s output device, any buffered input is discarded, the underlying file or device is closed, and channelId becomes unavailable for use. If the channel is blocking, the command does not return until all output is flushed. If the channel is nonblocking and there is unflushed output, the channel remains open and the command returns immediately; output will be flushed in the background and the channel will be closed when all the flushing is complete. If channelId is a blocking channel for a command pipeline then close waits for the child processes to complete. If the channel is shared between interpreters, then close makes channelId unavailable in the invoking interpreter but has no other effect until all of the sharing interpreters have closed the channel. When the last interpreter in which the channel is registered invokes close , the cleanup actions described above occur. See the interp command for a description of channel sharing. Channels are automatically closed when an interpreter is destroyed and when the process exits. From 8.6 on (TIP#398), nonblocking channels are no longer switched to blocking mode when exiting; this guarantees a timely exit even when the peer or a communication channel is stalled. To ensure proper flushing of stalled nonblocking channels on exit, one must now either (a) actively switch them back to blocking or (b) use the environment variable TCL_FLUSH_NONBLOCKING_ON_EXIT, which when set and not equal to \\\"0\\\" restores the previous behavior. The command returns an empty string, and may generate an error if an error occurs while flushing output. If a command in a command pipeline created with open returns an error, close generates an error (similar to the exec command.) The two-argument form is a given a bidirectional channel like a socket or command pipeline and a (possibly abbreviated) direction, it closes only the sub-stream going in that direction. This means a shutdown() on a socket, and a close() of one end of a pipe for a command pipeline. Then, the Tcl-level channel data structure is either kept or freed depending on whether the other direction is still open. A single-argument close on an already half-closed bidirectional channel is defined to just A half-close on an already closed half, or on a wrong-sided unidirectional channel, raises an error. In the case of a command pipeline, the child-reaping duty falls upon the shoulders of the last close or half-close, which is thus allowed to report an abnormal exit error. Currently only sockets and command pipelines support half-close. A future extension will allow reflected and stacked channels to do so. EXAMPLE This illustrates how you can use Tcl to ensure that files get closed even when errors happen by combining catch , close and return : proc withOpenFile {filename channelVar script} { upvar 1 \\$channelVar chan set chan [open \\$filename] catch { uplevel 1 \\$script } result options close \\$chan return -options \\$options \\$result } SEE ALSO file(n), open(n), socket(n), eof(n), Tcl_StandardChannels(3) KEYWORDS blocking, channel, close, nonblocking, half-close","title":"NAME"},{"location":"close/#name","text":"close - Close an open channel","title":"NAME"},{"location":"close/#synopsis","text":"close channelId ?r(ead)|w(rite)?","title":"SYNOPSIS"},{"location":"close/#description","text":"Closes or half-closes the channel given by channelId . ChannelId must be an identifier for an open channel such as a Tcl standard channel ( stdin , stdout , or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. The single-argument form is a simple all buffered output is flushed to the channel\\'s output device, any buffered input is discarded, the underlying file or device is closed, and channelId becomes unavailable for use. If the channel is blocking, the command does not return until all output is flushed. If the channel is nonblocking and there is unflushed output, the channel remains open and the command returns immediately; output will be flushed in the background and the channel will be closed when all the flushing is complete. If channelId is a blocking channel for a command pipeline then close waits for the child processes to complete. If the channel is shared between interpreters, then close makes channelId unavailable in the invoking interpreter but has no other effect until all of the sharing interpreters have closed the channel. When the last interpreter in which the channel is registered invokes close , the cleanup actions described above occur. See the interp command for a description of channel sharing. Channels are automatically closed when an interpreter is destroyed and when the process exits. From 8.6 on (TIP#398), nonblocking channels are no longer switched to blocking mode when exiting; this guarantees a timely exit even when the peer or a communication channel is stalled. To ensure proper flushing of stalled nonblocking channels on exit, one must now either (a) actively switch them back to blocking or (b) use the environment variable TCL_FLUSH_NONBLOCKING_ON_EXIT, which when set and not equal to \\\"0\\\" restores the previous behavior. The command returns an empty string, and may generate an error if an error occurs while flushing output. If a command in a command pipeline created with open returns an error, close generates an error (similar to the exec command.) The two-argument form is a given a bidirectional channel like a socket or command pipeline and a (possibly abbreviated) direction, it closes only the sub-stream going in that direction. This means a shutdown() on a socket, and a close() of one end of a pipe for a command pipeline. Then, the Tcl-level channel data structure is either kept or freed depending on whether the other direction is still open. A single-argument close on an already half-closed bidirectional channel is defined to just A half-close on an already closed half, or on a wrong-sided unidirectional channel, raises an error. In the case of a command pipeline, the child-reaping duty falls upon the shoulders of the last close or half-close, which is thus allowed to report an abnormal exit error. Currently only sockets and command pipelines support half-close. A future extension will allow reflected and stacked channels to do so.","title":"DESCRIPTION"},{"location":"close/#example","text":"This illustrates how you can use Tcl to ensure that files get closed even when errors happen by combining catch , close and return : proc withOpenFile {filename channelVar script} { upvar 1 \\$channelVar chan set chan [open \\$filename] catch { uplevel 1 \\$script } result options close \\$chan return -options \\$options \\$result }","title":"EXAMPLE"},{"location":"close/#see-also","text":"file(n), open(n), socket(n), eof(n), Tcl_StandardChannels(3)","title":"SEE ALSO"},{"location":"close/#keywords","text":"blocking, channel, close, nonblocking, half-close","title":"KEYWORDS"},{"location":"continue/","text":"NAME continue - Skip to the next iteration of a loop SYNOPSIS continue DESCRIPTION This command is typically invoked inside the body of a looping command such as for or foreach or while . It returns a 4 ( TCL_CONTINUE ) result code, which causes a continue exception to occur. The exception causes the current script to be aborted out to the innermost containing loop command, which then continues with the next iteration of the loop. Continue exceptions are also handled in a few other situations, such as the catch command and the outermost scripts of procedure bodies. EXAMPLE Print a line for each of the integers from 0 to 10 except 5: for {set x 0} {\\$x\\<10} {incr x} { if {\\$x == 5} { continue } puts \\\"x is \\$x\\\" } SEE ALSO break(n), for(n), foreach(n), return(n), while(n) KEYWORDS continue, iteration, loop","title":"NAME"},{"location":"continue/#name","text":"continue - Skip to the next iteration of a loop","title":"NAME"},{"location":"continue/#synopsis","text":"continue","title":"SYNOPSIS"},{"location":"continue/#description","text":"This command is typically invoked inside the body of a looping command such as for or foreach or while . It returns a 4 ( TCL_CONTINUE ) result code, which causes a continue exception to occur. The exception causes the current script to be aborted out to the innermost containing loop command, which then continues with the next iteration of the loop. Continue exceptions are also handled in a few other situations, such as the catch command and the outermost scripts of procedure bodies.","title":"DESCRIPTION"},{"location":"continue/#example","text":"Print a line for each of the integers from 0 to 10 except 5: for {set x 0} {\\$x\\<10} {incr x} { if {\\$x == 5} { continue } puts \\\"x is \\$x\\\" }","title":"EXAMPLE"},{"location":"continue/#see-also","text":"break(n), for(n), foreach(n), return(n), while(n)","title":"SEE ALSO"},{"location":"continue/#keywords","text":"continue, iteration, loop","title":"KEYWORDS"},{"location":"cookiejar/","text":"NAME cookiejar - Implementation of the Tcl http package cookie jar protocol SYNOPSIS package require cookiejar ?0.1? ::http::cookiejar configure ?optionName? ?optionValue? ::http::cookiejar create name ?filename? ::http::cookiejar new ?filename? cookiejar destroy cookiejar forceLoadDomainData cookiejar getCookies protocol host path cookiejar storeCookie options cookiejar lookup ?host? ?key? DESCRIPTION The cookiejar package provides an implementation of the http package\\'s cookie jar protocol using an SQLite database. It provides one main command, ::http::cookiejar , which is a TclOO class that should be instantiated to create a cookie jar that manages a particular HTTP session. The database management policy can be controlled at the package level by the configure method on the ::http::cookiejar class object: ::http::cookiejar configure ? optionName ? ? optionValue ? : If neither optionName nor optionValue are supplied, this returns a copy of the configuration as a Tcl dictionary. If just optionName is supplied, just the value of the named option is returned. If both optionName and optionValue are given, the named option is changed to be the given value. Supported options are: **-domainfile ***filename* : A file (defaulting to within the cookiejar package) with a description of the list of top-level domains (e.g., **.com** or **.co.jp**). Such domains *must not* accept cookies set upon them. Note that the list of such domains is both security-sensitive and *not* constant and should be periodically refetched. Cookie jars maintain their own cache of the domain list. **-domainlist ***url* : A URL to fetch the list of top-level domains (e.g., **.com** or **.co.jp**) from. Such domains *must not* accept cookies set upon them. Note that the list of such domains is both security-sensitive and *not* constant and should be periodically refetched. Cookie jars maintain their own cache of the domain list. **-domainrefresh ***intervalMilliseconds* : The number of milliseconds between checks of the *-domainlist* for new domains. **-loglevel ***level* : The logging level of this package. The logging level must be (in order of decreasing verbosity) one of **debug**, **info**, **warn**, or **error**. **-offline ***flag* : Allows the cookie managment engine to be placed into offline mode. In offline mode, the list of domains is read immediately from the file configured in the **-domainfile** option, and the **-domainlist** option is not used; it also makes the **-domainrefresh** option be effectively ignored. **-purgeold ***intervalMilliseconds* : The number of milliseconds between checks of the database for expired cookies; expired cookies are deleted. **-retain ***cookieCount* : The maximum number of cookies to retain in the database. **-vacuumtrigger ***deletionCount* : A count of the number of persistent cookie deletions to go between vacuuming the database. Cookie jar instances may be made with any of the standard TclOO instance creation methods ( create or new ). ::http::cookiejar new ? filename ? : If a filename argument is provided, it is the name of a file containing an SQLite database that will contain the persistent cookies maintained by the cookie jar; the database will be created if the file does not already exist. If filename is not supplied, the database will be held entirely within memory, which effectively forces all cookies within it to be session cookies. INSTANCE METHODS The following methods are supported on the instances: cookiejar destroy : This is the standard TclOO destruction method. It does not delete the SQLite database if it is written to disk. Callers are responsible for ensuring that the cookie jar is not in use by the http package at the time of destruction. cookiejar forceLoadDomainData : This method causes the cookie jar to immediately load (and cache) the domain list data. The domain list will be loaded from the -domainlist configured a the package level if that is enabled, and otherwise will be obtained from the -domainfile configured at the package level. cookiejar getCookies protocol host path : This method obtains the cookies for a particular HTTP request. This implements the http cookie jar protocol. cookiejar policyAllow operation domain path : This method is called by the storeCookie method to get a decision on whether to allow operation to be performed for the domain and path . This is checked immediately before the database is updated but after the built-in security checks are done, and should return a boolean value; if the value is false, the operation is rejected and the database is not modified. The supported operation s are: **delete** : The *domain* is seeking to delete a cookie. **session** : The *domain* is seeking to create or update a session cookie. **set** : The *domain* is seeking to create or update a persistent cookie (with a defined lifetime). The default implementation of this method just returns true, but subclasses of this class may impose their own rules. cookiejar storeCookie options : This method stores a single cookie from a particular HTTP response. Cookies that fail security checks are ignored. This implements the http cookie jar protocol. cookiejar lookup ? host ? ? key ? : This method looks a cookie by exact host (or domain) matching. If neither host nor key are supplied, the list of hosts for which a cookie is stored is returned. If just host (which may be a hostname or a domain name) is supplied, the list of cookie keys stored for that host is returned. If both host and key are supplied, the value for that key is returned; it is an error if no such host or key match exactly. EXAMPLES The simplest way of using a cookie jar is to just permanently configure it at the start of the application. package require http package require cookiejar set cookiedb [file join [file home] cookiejar] http::configure -cookiejar [ http::cookiejar new \\$cookiedb] # No further explicit steps are required to use cookies set tok [http::geturl http://core.tcl-lang.org/] To only allow a particular domain to use cookies, perhaps because you only want to enable a particular host to create and manipulate sessions, create a subclass that imposes that policy. package require http package require cookiejar oo::class create MyCookieJar { superclass http::cookiejar method policyAllow {operation domain path} { return [expr {\\$domain eq \\\"my.example.com\\\"}] } } set cookiedb [file join [file home] cookiejar] http::configure -cookiejar [MyCookieJar new \\$cookiedb] # No further explicit steps are required to use cookies set tok [http::geturl http://core.tcl-lang.org/] SEE ALSO http(n), oo::class(n), sqlite3(n) KEYWORDS cookie, internet, security policy, www","title":"NAME"},{"location":"cookiejar/#name","text":"cookiejar - Implementation of the Tcl http package cookie jar protocol","title":"NAME"},{"location":"cookiejar/#synopsis","text":"package require cookiejar ?0.1? ::http::cookiejar configure ?optionName? ?optionValue? ::http::cookiejar create name ?filename? ::http::cookiejar new ?filename? cookiejar destroy cookiejar forceLoadDomainData cookiejar getCookies protocol host path cookiejar storeCookie options cookiejar lookup ?host? ?key?","title":"SYNOPSIS"},{"location":"cookiejar/#description","text":"The cookiejar package provides an implementation of the http package\\'s cookie jar protocol using an SQLite database. It provides one main command, ::http::cookiejar , which is a TclOO class that should be instantiated to create a cookie jar that manages a particular HTTP session. The database management policy can be controlled at the package level by the configure method on the ::http::cookiejar class object: ::http::cookiejar configure ? optionName ? ? optionValue ? : If neither optionName nor optionValue are supplied, this returns a copy of the configuration as a Tcl dictionary. If just optionName is supplied, just the value of the named option is returned. If both optionName and optionValue are given, the named option is changed to be the given value. Supported options are: **-domainfile ***filename* : A file (defaulting to within the cookiejar package) with a description of the list of top-level domains (e.g., **.com** or **.co.jp**). Such domains *must not* accept cookies set upon them. Note that the list of such domains is both security-sensitive and *not* constant and should be periodically refetched. Cookie jars maintain their own cache of the domain list. **-domainlist ***url* : A URL to fetch the list of top-level domains (e.g., **.com** or **.co.jp**) from. Such domains *must not* accept cookies set upon them. Note that the list of such domains is both security-sensitive and *not* constant and should be periodically refetched. Cookie jars maintain their own cache of the domain list. **-domainrefresh ***intervalMilliseconds* : The number of milliseconds between checks of the *-domainlist* for new domains. **-loglevel ***level* : The logging level of this package. The logging level must be (in order of decreasing verbosity) one of **debug**, **info**, **warn**, or **error**. **-offline ***flag* : Allows the cookie managment engine to be placed into offline mode. In offline mode, the list of domains is read immediately from the file configured in the **-domainfile** option, and the **-domainlist** option is not used; it also makes the **-domainrefresh** option be effectively ignored. **-purgeold ***intervalMilliseconds* : The number of milliseconds between checks of the database for expired cookies; expired cookies are deleted. **-retain ***cookieCount* : The maximum number of cookies to retain in the database. **-vacuumtrigger ***deletionCount* : A count of the number of persistent cookie deletions to go between vacuuming the database. Cookie jar instances may be made with any of the standard TclOO instance creation methods ( create or new ). ::http::cookiejar new ? filename ? : If a filename argument is provided, it is the name of a file containing an SQLite database that will contain the persistent cookies maintained by the cookie jar; the database will be created if the file does not already exist. If filename is not supplied, the database will be held entirely within memory, which effectively forces all cookies within it to be session cookies.","title":"DESCRIPTION"},{"location":"cookiejar/#instance-methods","text":"The following methods are supported on the instances: cookiejar destroy : This is the standard TclOO destruction method. It does not delete the SQLite database if it is written to disk. Callers are responsible for ensuring that the cookie jar is not in use by the http package at the time of destruction. cookiejar forceLoadDomainData : This method causes the cookie jar to immediately load (and cache) the domain list data. The domain list will be loaded from the -domainlist configured a the package level if that is enabled, and otherwise will be obtained from the -domainfile configured at the package level. cookiejar getCookies protocol host path : This method obtains the cookies for a particular HTTP request. This implements the http cookie jar protocol. cookiejar policyAllow operation domain path : This method is called by the storeCookie method to get a decision on whether to allow operation to be performed for the domain and path . This is checked immediately before the database is updated but after the built-in security checks are done, and should return a boolean value; if the value is false, the operation is rejected and the database is not modified. The supported operation s are: **delete** : The *domain* is seeking to delete a cookie. **session** : The *domain* is seeking to create or update a session cookie. **set** : The *domain* is seeking to create or update a persistent cookie (with a defined lifetime). The default implementation of this method just returns true, but subclasses of this class may impose their own rules. cookiejar storeCookie options : This method stores a single cookie from a particular HTTP response. Cookies that fail security checks are ignored. This implements the http cookie jar protocol. cookiejar lookup ? host ? ? key ? : This method looks a cookie by exact host (or domain) matching. If neither host nor key are supplied, the list of hosts for which a cookie is stored is returned. If just host (which may be a hostname or a domain name) is supplied, the list of cookie keys stored for that host is returned. If both host and key are supplied, the value for that key is returned; it is an error if no such host or key match exactly.","title":"INSTANCE METHODS"},{"location":"cookiejar/#examples","text":"The simplest way of using a cookie jar is to just permanently configure it at the start of the application. package require http package require cookiejar set cookiedb [file join [file home] cookiejar] http::configure -cookiejar [ http::cookiejar new \\$cookiedb] # No further explicit steps are required to use cookies set tok [http::geturl http://core.tcl-lang.org/] To only allow a particular domain to use cookies, perhaps because you only want to enable a particular host to create and manipulate sessions, create a subclass that imposes that policy. package require http package require cookiejar oo::class create MyCookieJar { superclass http::cookiejar method policyAllow {operation domain path} { return [expr {\\$domain eq \\\"my.example.com\\\"}] } } set cookiedb [file join [file home] cookiejar] http::configure -cookiejar [MyCookieJar new \\$cookiedb] # No further explicit steps are required to use cookies set tok [http::geturl http://core.tcl-lang.org/]","title":"EXAMPLES"},{"location":"cookiejar/#see-also","text":"http(n), oo::class(n), sqlite3(n)","title":"SEE ALSO"},{"location":"cookiejar/#keywords","text":"cookie, internet, security policy, www","title":"KEYWORDS"},{"location":"copy/","text":"NAME oo::copy - create copies of objects and classes SYNOPSIS package require tcl::oo oo::copy sourceObject ?targetObject? ?targetNamespace? DESCRIPTION The oo::copy command creates a copy of an object or class. It takes the name of the object or class to be copied, sourceObject , and optionally the name of the object or class to create, targetObject , which will be resolved relative to the current namespace if not an absolute qualified name and targetNamespace which is the name of the namespace that will hold the internal state of the object ( my command, etc.); it must not refer to an existing namespace. If either targetObject or targetNamespace is omitted or is given as the empty string, a new name is chosen. Names, unless specified, are chosen with the same algorithm used by the new method of oo::class . The copied object will be of the same class as the source object, and will have all its per-object methods copied. If it is a class, it will also have all the class methods in the class copied, but it will not have any of its instances copied. After the targetObject has been created and all definitions of its configuration (e.g., methods, filters, mixins) copied, the \\<cloned> method of targetObject will be invoked, to allow for customization of the created object such as installing related variable traces. The only argument given will be sourceObject . The default implementation of this method (in oo::object ) just copies the procedures and variables in the namespace of sourceObject to the namespace of targetObject . If this method call does not return a result that is successful (i.e., an error or other kind of exception) then the targetObject will be deleted and an error returned. The result of the oo::copy command will be the fully-qualified name of the new object or class. EXAMPLES This example creates an object, copies it, modifies the source object, and then demonstrates that the copied object is indeed a copy. oo::object create src oo::objdefine src method msg {} {puts foo} oo::copy src dst oo::objdefine src method msg {} {puts bar} src msg \u2192 prints \\\"bar\\\" dst msg \u2192 prints \\\"foo\\\" SEE ALSO oo::class(n), oo::define(n), oo::object(n) KEYWORDS clone, copy, duplication, object","title":"NAME"},{"location":"copy/#name","text":"oo::copy - create copies of objects and classes","title":"NAME"},{"location":"copy/#synopsis","text":"package require tcl::oo oo::copy sourceObject ?targetObject? ?targetNamespace?","title":"SYNOPSIS"},{"location":"copy/#description","text":"The oo::copy command creates a copy of an object or class. It takes the name of the object or class to be copied, sourceObject , and optionally the name of the object or class to create, targetObject , which will be resolved relative to the current namespace if not an absolute qualified name and targetNamespace which is the name of the namespace that will hold the internal state of the object ( my command, etc.); it must not refer to an existing namespace. If either targetObject or targetNamespace is omitted or is given as the empty string, a new name is chosen. Names, unless specified, are chosen with the same algorithm used by the new method of oo::class . The copied object will be of the same class as the source object, and will have all its per-object methods copied. If it is a class, it will also have all the class methods in the class copied, but it will not have any of its instances copied. After the targetObject has been created and all definitions of its configuration (e.g., methods, filters, mixins) copied, the \\<cloned> method of targetObject will be invoked, to allow for customization of the created object such as installing related variable traces. The only argument given will be sourceObject . The default implementation of this method (in oo::object ) just copies the procedures and variables in the namespace of sourceObject to the namespace of targetObject . If this method call does not return a result that is successful (i.e., an error or other kind of exception) then the targetObject will be deleted and an error returned. The result of the oo::copy command will be the fully-qualified name of the new object or class.","title":"DESCRIPTION"},{"location":"copy/#examples","text":"This example creates an object, copies it, modifies the source object, and then demonstrates that the copied object is indeed a copy. oo::object create src oo::objdefine src method msg {} {puts foo} oo::copy src dst oo::objdefine src method msg {} {puts bar} src msg \u2192 prints \\\"bar\\\" dst msg \u2192 prints \\\"foo\\\"","title":"EXAMPLES"},{"location":"copy/#see-also","text":"oo::class(n), oo::define(n), oo::object(n)","title":"SEE ALSO"},{"location":"copy/#keywords","text":"clone, copy, duplication, object","title":"KEYWORDS"},{"location":"coroutine/","text":"NAME coroutine, yield, yieldto, coroinject, coroprobe - Create and produce values from coroutines SYNOPSIS coroutine name command ?arg...? yield ?value? yieldto command ?arg...? name ?value...? coroinject coroName command ?arg...? coroprobe coroName command ?arg...? DESCRIPTION The coroutine command creates a new coroutine context (with associated command) named name and executes that context by calling command , passing in the other remaining arguments without further interpretation. Once command returns normally or with an exception (e.g., an error) the coroutine context name is deleted. Within the context, values may be generated as results by using the yield command; if no value is supplied, the empty string is used. When that is called, the context will suspend execution and the coroutine command will return the argument to yield . The execution of the context can then be resumed by calling the context command, optionally passing in the single value to use as the result of the yield call that caused the context to be suspended. If the coroutine context never yields and instead returns conventionally, the result of the coroutine command will be the result of the evaluation of the context. The coroutine may also suspend its execution by use of the yieldto command, which instead of returning, cedes execution to some command called command (resolved in the context of the coroutine) and to which any number of arguments may be passed. Since every coroutine has a context command, yieldto can be used to transfer control directly from one coroutine to another (this is only advisable if the two coroutines are expecting this to happen) but any command may be the target. If a coroutine is suspended by this mechanism, the coroutine processing can be resumed by calling the context command optionally passing in an arbitrary number of arguments. The return value of the yieldto call will be the list of arguments passed to the context command; it is up to the caller to decide what to do with those values. The recommended way of writing a version of yield that allows resumption with multiple arguments is by using yieldto and the return command, like this: proc yieldMultiple {value} { tailcall yieldto string cat \\$value } The coroutine can also be deleted by destroying the command name , and the name of the current coroutine can be retrieved by using info coroutine . If there are deletion traces on variables in the coroutine\\'s implementation, they will fire at the point when the coroutine is explicitly deleted (or, naturally, if the command returns conventionally). At the point when command is called, the current namespace will be the global namespace and there will be no stack frames above it (in the sense of upvar and uplevel ). However, which command to call will be determined in the namespace that the coroutine command was called from. A suspended coroutine (i.e., one that has yield ed or yieldto -d) may have its state inspected (or modified) at that point by using coroprobe to run a command at the point where the coroutine is at. The command takes the name of the coroutine to run the command in, coroName , and the name of a command (any any arguments it requires) to immediately run at that point. The result of that command is the result of the coroprobe command, and the gross state of the coroutine remains the same afterwards (i.e., the coroutine is still expecting the results of a yield or yieldto as before) though variables may have been changed. Similarly, the coroinject command may be used to place a command to be run inside a suspended coroutine (when it is resumed) to process arguments, with quite a bit of similarity to coroprobe . However, with coroinject there are several key differences: The coroutine is not immediately resumed after the injection has been done. A consequence of this is that multiple injections may be done before the coroutine is resumed. There injected commands are performed in reverse order of definition (that is, they are internally stored on a stack). An additional two arguments are appended to the list of arguments to be run (that is, the command and its args are extended by two elements). The first is the name of the command that suspended the coroutine ( yield or yieldto ), and the second is the argument (or list of arguments, in the case of yieldto ) that is the current resumption value. The result of the injected command is used as the result of the yield or yieldto that caused the coroutine to become suspended. Where there are multiple injected commands, the result of one becomes the resumption value processed by the next. The injection is a one-off. It is not retained once it has been executed. It may yield or yieldto as part of its execution. Note that running coroutines may be neither probed nor injected; the operations may only be applied to EXAMPLES This example shows a coroutine that will produce an infinite sequence of even values, and a loop that consumes the first ten of them. proc allNumbers {} { yield set i 0 while 1 { yield \\$i incr i 2 } } coroutine nextNumber allNumbers for {set i 0} {\\$i \\< 10} {incr i} { puts \\\"received [ nextNumber ]\\\" } rename nextNumber {} In this example, the coroutine acts to add up the arguments passed to it. coroutine accumulator apply {{} { set x 0 while 1 { incr x [ yield \\$x] } }} for {set i 0} {\\$i \\< 10} {incr i} { puts \\\"\\$i -> [ accumulator \\$i]\\\" } This example demonstrates the use of coroutines to implement the classic Sieve of Eratosthenes algorithm for finding prime numbers. Note the creation of coroutines inside a coroutine. proc filterByFactor {source n} { yield [info coroutine] while 1 { set x [ \\$source ] if {\\$x % \\$n} { yield \\$x } } } coroutine allNumbers apply {{} {while 1 { yield [incr x]}}} coroutine eratosthenes apply {c { yield while 1 { set n [ \\$c ] yield \\$n set c [ coroutine prime\\$n filterByFactor \\$c \\$n] } }} allNumbers for {set i 1} {\\$i \\<= 20} {incr i} { puts \\\"prime#\\$i = [ eratosthenes ]\\\" } This example shows how a value can be passed around a group of three coroutines that yield to each other: proc juggler {name target {value \\\"\\\"}} { if {\\$value eq \\\"\\\"} { set value [ yield [info coroutine]] } while {\\$value ne \\\"\\\"} { puts \\\"\\$name : \\$value\\\" set value [string range \\$value 0 end-1] lassign [ yieldto \\$target \\$value] value } } coroutine j1 juggler Larry [ coroutine j2 juggler Curly [ coroutine j3 juggler Moe j1]] \\\"Nyuck!Nyuck!Nyuck!\\\" This example shows a simple coroutine that collects non-empty values and returns a list of them when not given an argument. It also shows how we can look inside the coroutine to find out what it is doing, and how we can modify the input on a one-off basis. proc collectorImpl {} { set me [info coroutine] set accumulator {} for {set val [ yield \\$me]} {\\$val ne \\\"\\\"} {set val [ yield ]} { lappend accumulator \\$val } return \\$accumulator } coroutine collect collectorImpl collect 123 collect \\\"abc def\\\" collect 456 puts [ coroprobe collect set accumulator] # ==> 123 {abc def} 456 collect \\\"pqr\\\" coroinject collect apply {{type value} { puts \\\"Received \\'\\$value\\' at a \\$type in [info coroutine]\\\" return [string toupper \\$value] }} collect rst # ==> Received \\'rst\\' at a yield in ::collect collect xyz puts [ collect ] # ==> 123 {abc def} 456 pqr RST xyz This example shows a simple coroutine that collects non-empty values and returns a list of them when not given an argument. It also shows how we can look inside the coroutine to find out what it is doing. DETAILED SEMANTICS This example demonstrates that coroutines start from the global namespace, and that command resolution happens before the coroutine stack is created. proc report {where level} { # Where was the caller called from? set ns [uplevel 2 {namespace current}] yield \\\"made \\$where \\$level context=\\$ns name=[info coroutine]\\\" } proc example {} { report outer [info level] } namespace eval demo { proc example {} { report inner [info level] } proc makeExample {} { puts \\\"making from [info level]\\\" puts [ coroutine coroEg example] } makeExample } Which produces the output below. In particular, we can see that stack manipulation has occurred (comparing the levels from the first and second line) and that the parent level in the coroutine is the global namespace. We can also see that coroutine names are local to the current namespace if not qualified, and that coroutines may yield at depth (e.g., in called procedures). making from 2 made inner 1 context=:: name=::demo::coroEg SEE ALSO apply(n), info(n), proc(n), return(n) KEYWORDS coroutine, generator","title":"NAME"},{"location":"coroutine/#name","text":"coroutine, yield, yieldto, coroinject, coroprobe - Create and produce values from coroutines","title":"NAME"},{"location":"coroutine/#synopsis","text":"coroutine name command ?arg...? yield ?value? yieldto command ?arg...? name ?value...? coroinject coroName command ?arg...? coroprobe coroName command ?arg...?","title":"SYNOPSIS"},{"location":"coroutine/#description","text":"The coroutine command creates a new coroutine context (with associated command) named name and executes that context by calling command , passing in the other remaining arguments without further interpretation. Once command returns normally or with an exception (e.g., an error) the coroutine context name is deleted. Within the context, values may be generated as results by using the yield command; if no value is supplied, the empty string is used. When that is called, the context will suspend execution and the coroutine command will return the argument to yield . The execution of the context can then be resumed by calling the context command, optionally passing in the single value to use as the result of the yield call that caused the context to be suspended. If the coroutine context never yields and instead returns conventionally, the result of the coroutine command will be the result of the evaluation of the context. The coroutine may also suspend its execution by use of the yieldto command, which instead of returning, cedes execution to some command called command (resolved in the context of the coroutine) and to which any number of arguments may be passed. Since every coroutine has a context command, yieldto can be used to transfer control directly from one coroutine to another (this is only advisable if the two coroutines are expecting this to happen) but any command may be the target. If a coroutine is suspended by this mechanism, the coroutine processing can be resumed by calling the context command optionally passing in an arbitrary number of arguments. The return value of the yieldto call will be the list of arguments passed to the context command; it is up to the caller to decide what to do with those values. The recommended way of writing a version of yield that allows resumption with multiple arguments is by using yieldto and the return command, like this: proc yieldMultiple {value} { tailcall yieldto string cat \\$value } The coroutine can also be deleted by destroying the command name , and the name of the current coroutine can be retrieved by using info coroutine . If there are deletion traces on variables in the coroutine\\'s implementation, they will fire at the point when the coroutine is explicitly deleted (or, naturally, if the command returns conventionally). At the point when command is called, the current namespace will be the global namespace and there will be no stack frames above it (in the sense of upvar and uplevel ). However, which command to call will be determined in the namespace that the coroutine command was called from. A suspended coroutine (i.e., one that has yield ed or yieldto -d) may have its state inspected (or modified) at that point by using coroprobe to run a command at the point where the coroutine is at. The command takes the name of the coroutine to run the command in, coroName , and the name of a command (any any arguments it requires) to immediately run at that point. The result of that command is the result of the coroprobe command, and the gross state of the coroutine remains the same afterwards (i.e., the coroutine is still expecting the results of a yield or yieldto as before) though variables may have been changed. Similarly, the coroinject command may be used to place a command to be run inside a suspended coroutine (when it is resumed) to process arguments, with quite a bit of similarity to coroprobe . However, with coroinject there are several key differences: The coroutine is not immediately resumed after the injection has been done. A consequence of this is that multiple injections may be done before the coroutine is resumed. There injected commands are performed in reverse order of definition (that is, they are internally stored on a stack). An additional two arguments are appended to the list of arguments to be run (that is, the command and its args are extended by two elements). The first is the name of the command that suspended the coroutine ( yield or yieldto ), and the second is the argument (or list of arguments, in the case of yieldto ) that is the current resumption value. The result of the injected command is used as the result of the yield or yieldto that caused the coroutine to become suspended. Where there are multiple injected commands, the result of one becomes the resumption value processed by the next. The injection is a one-off. It is not retained once it has been executed. It may yield or yieldto as part of its execution. Note that running coroutines may be neither probed nor injected; the operations may only be applied to","title":"DESCRIPTION"},{"location":"coroutine/#examples","text":"This example shows a coroutine that will produce an infinite sequence of even values, and a loop that consumes the first ten of them. proc allNumbers {} { yield set i 0 while 1 { yield \\$i incr i 2 } } coroutine nextNumber allNumbers for {set i 0} {\\$i \\< 10} {incr i} { puts \\\"received [ nextNumber ]\\\" } rename nextNumber {} In this example, the coroutine acts to add up the arguments passed to it. coroutine accumulator apply {{} { set x 0 while 1 { incr x [ yield \\$x] } }} for {set i 0} {\\$i \\< 10} {incr i} { puts \\\"\\$i -> [ accumulator \\$i]\\\" } This example demonstrates the use of coroutines to implement the classic Sieve of Eratosthenes algorithm for finding prime numbers. Note the creation of coroutines inside a coroutine. proc filterByFactor {source n} { yield [info coroutine] while 1 { set x [ \\$source ] if {\\$x % \\$n} { yield \\$x } } } coroutine allNumbers apply {{} {while 1 { yield [incr x]}}} coroutine eratosthenes apply {c { yield while 1 { set n [ \\$c ] yield \\$n set c [ coroutine prime\\$n filterByFactor \\$c \\$n] } }} allNumbers for {set i 1} {\\$i \\<= 20} {incr i} { puts \\\"prime#\\$i = [ eratosthenes ]\\\" } This example shows how a value can be passed around a group of three coroutines that yield to each other: proc juggler {name target {value \\\"\\\"}} { if {\\$value eq \\\"\\\"} { set value [ yield [info coroutine]] } while {\\$value ne \\\"\\\"} { puts \\\"\\$name : \\$value\\\" set value [string range \\$value 0 end-1] lassign [ yieldto \\$target \\$value] value } } coroutine j1 juggler Larry [ coroutine j2 juggler Curly [ coroutine j3 juggler Moe j1]] \\\"Nyuck!Nyuck!Nyuck!\\\" This example shows a simple coroutine that collects non-empty values and returns a list of them when not given an argument. It also shows how we can look inside the coroutine to find out what it is doing, and how we can modify the input on a one-off basis. proc collectorImpl {} { set me [info coroutine] set accumulator {} for {set val [ yield \\$me]} {\\$val ne \\\"\\\"} {set val [ yield ]} { lappend accumulator \\$val } return \\$accumulator } coroutine collect collectorImpl collect 123 collect \\\"abc def\\\" collect 456 puts [ coroprobe collect set accumulator] # ==> 123 {abc def} 456 collect \\\"pqr\\\" coroinject collect apply {{type value} { puts \\\"Received \\'\\$value\\' at a \\$type in [info coroutine]\\\" return [string toupper \\$value] }} collect rst # ==> Received \\'rst\\' at a yield in ::collect collect xyz puts [ collect ] # ==> 123 {abc def} 456 pqr RST xyz This example shows a simple coroutine that collects non-empty values and returns a list of them when not given an argument. It also shows how we can look inside the coroutine to find out what it is doing.","title":"EXAMPLES"},{"location":"coroutine/#detailed-semantics","text":"This example demonstrates that coroutines start from the global namespace, and that command resolution happens before the coroutine stack is created. proc report {where level} { # Where was the caller called from? set ns [uplevel 2 {namespace current}] yield \\\"made \\$where \\$level context=\\$ns name=[info coroutine]\\\" } proc example {} { report outer [info level] } namespace eval demo { proc example {} { report inner [info level] } proc makeExample {} { puts \\\"making from [info level]\\\" puts [ coroutine coroEg example] } makeExample } Which produces the output below. In particular, we can see that stack manipulation has occurred (comparing the levels from the first and second line) and that the parent level in the coroutine is the global namespace. We can also see that coroutine names are local to the current namespace if not qualified, and that coroutines may yield at depth (e.g., in called procedures). making from 2 made inner 1 context=:: name=::demo::coroEg","title":"DETAILED SEMANTICS"},{"location":"coroutine/#see-also","text":"apply(n), info(n), proc(n), return(n)","title":"SEE ALSO"},{"location":"coroutine/#keywords","text":"coroutine, generator","title":"KEYWORDS"},{"location":"dde/","text":"NAME dde - Execute a Dynamic Data Exchange command SYNOPSIS package require dde 1.4 dde servername ? -force ? ? -handler proc ? ? -\u2006- ? ? topic ? dde execute ? -async ? ? -binary ? service topic data dde poke ? -binary ? service topic item data dde request ? -binary ? service topic item dde services service topic dde eval ? -async ? topic cmd ? arg arg ... ? DESCRIPTION This command allows an application to send Dynamic Data Exchange (DDE) command when running under Microsoft Windows. Dynamic Data Exchange is a mechanism where applications can exchange raw data. Each DDE transaction needs a service name and a topic . Both the service name and topic are application defined; Tcl uses the service name TclEval , while the topic name is the name of the interpreter given by dde servername . Other applications have their own service names and topics . For instance, Microsoft Excel has the service name Excel . DDE COMMANDS The following commands are a subset of the full Dynamic Data Exchange set of commands. dde servername ? -force ? ? -handler proc ? ? -\u2006- ? ? topic ? : dde servername registers the interpreter as a DDE server with the service name TclEval and the topic name specified by topic . If no topic is given, dde servername returns the name of the current topic or the empty string if it is not registered as a service. If the given topic name is already in use, then a suffix of the form or is appended to the name to make it unique. The command\\'s result will be the name actually used. The -force option is used to force registration of precisely the given topic name. The -handler option specifies a Tcl procedure that will be called to process calls to the dde server. If the package has been loaded into a safe interpreter then a -handler procedure must be defined. The procedure is called with all the arguments provided by the remote call. dde execute ? -async ? ? -binary ? service topic data : dde execute takes the data and sends it to the server indicated by service with the topic indicated by topic . Typically, service is the name of an application, and topic is a file to work on. The data field is given to the remote application. Typically, the application treats the data field as a script, and the script is run in the application. The -async option requests asynchronous invocation. The command returns an error message if the script did not run, unless the -async flag was used, in which case the command returns immediately with no error. Without the -binary option all data will be sent in unicode. For dde clients which don\\'t implement the CF_UNICODE clipboard format, this will automatically be translated to the system encoding. You can use the -binary option in combination with the result of encoding convertto to send data in any other encoding. dde poke ? -binary ? service topic item data : dde poke passes the data to the server indicated by service using the topic and item specified. Typically, service is the name of an application. topic is application specific but can be a command to the server or the name of a file to work on. The item is also application specific and is often not used, but it must always be non-null. The data field is given to the remote application. Without the -binary option all data will be sent in unicode. For dde clients which don\\'t implement the CF_UNICODE clipboard format, this will automatically be translated to the system encoding. You can use the -binary option in combination with the result of encoding convertto to send data in any other encoding. dde request ? -binary ? service topic item : dde request is typically used to get the value of something; the value of a cell in Microsoft Excel or the text of a selection in Microsoft Word. service is typically the name of an application, topic is typically the name of the file, and item is application-specific. The command returns the value of item as defined in the application. Normally this is interpreted to be a string with terminating null. If -binary is specified, the result is returned as a byte array. dde services service topic : dde services returns a list of service-topic pairs that currently exist on the machine. If service and topic are both empty strings ({}), then all service-topic pairs currently available on the system are returned. If service is empty and topic is not, then all services with the specified topic are returned. If service is non-empty and topic is, all topics for a given service are returned. If both are non-empty, if that service-topic pair currently exists, it is returned; otherwise, an empty string is returned. dde eval ? -async ? topic cmd ? arg arg ... ? : dde eval evaluates a command and its arguments using the interpreter specified by topic . The DDE service must be the TclEval service. The -async option requests asynchronous invocation. The command returns an error message if the script did not run, unless the -async flag was used, in which case the command returns immediately with no error. This command can be used to replace send on Windows. DDE AND TCL A Tcl interpreter always has a service name of TclEval . Each different interpreter of all running Tcl applications must be given a unique name specified by dde servername . Each interp is available as a DDE topic only if the dde servername command was used to set the name of the topic for each interp. So a dde services TclEval {} command will return a list of service-topic pairs, where each of the currently running interps will be a topic. When Tcl processes a dde execute command, the data for the execute is run as a script in the interp named by the topic of the dde execute command. When Tcl processes a dde request command, it returns the value of the variable given in the dde command in the context of the interp named by the dde topic. Tcl reserves the variable \\$TCLEVAL\\$EXECUTE\\$RESULT for internal use, and dde request commands for that variable will give unpredictable results. An external application which wishes to run a script in Tcl should have that script store its result in a variable, run the dde execute command, and then run dde request to get the value of the variable. When using DDE, be careful to ensure that the event queue is flushed using either update or vwait . This happens by default when using wish unless a blocking command is called (such as exec without adding the & to place the process in the background). If for any reason the event queue is not flushed, DDE commands may hang until the event queue is flushed. This can create a deadlock situation. EXAMPLE This asks Internet Explorer (which must already be running) to go to a particularly important website: package require dde dde execute -async iexplore WWW_OpenURL http://www.tcl-lang.org/ SEE ALSO tk(n), winfo(n), send(n) KEYWORDS application, dde, name, remote execution","title":"NAME"},{"location":"dde/#name","text":"dde - Execute a Dynamic Data Exchange command","title":"NAME"},{"location":"dde/#synopsis","text":"package require dde 1.4 dde servername ? -force ? ? -handler proc ? ? -\u2006- ? ? topic ? dde execute ? -async ? ? -binary ? service topic data dde poke ? -binary ? service topic item data dde request ? -binary ? service topic item dde services service topic dde eval ? -async ? topic cmd ? arg arg ... ?","title":"SYNOPSIS"},{"location":"dde/#description","text":"This command allows an application to send Dynamic Data Exchange (DDE) command when running under Microsoft Windows. Dynamic Data Exchange is a mechanism where applications can exchange raw data. Each DDE transaction needs a service name and a topic . Both the service name and topic are application defined; Tcl uses the service name TclEval , while the topic name is the name of the interpreter given by dde servername . Other applications have their own service names and topics . For instance, Microsoft Excel has the service name Excel .","title":"DESCRIPTION"},{"location":"dde/#dde-commands","text":"The following commands are a subset of the full Dynamic Data Exchange set of commands. dde servername ? -force ? ? -handler proc ? ? -\u2006- ? ? topic ? : dde servername registers the interpreter as a DDE server with the service name TclEval and the topic name specified by topic . If no topic is given, dde servername returns the name of the current topic or the empty string if it is not registered as a service. If the given topic name is already in use, then a suffix of the form or is appended to the name to make it unique. The command\\'s result will be the name actually used. The -force option is used to force registration of precisely the given topic name. The -handler option specifies a Tcl procedure that will be called to process calls to the dde server. If the package has been loaded into a safe interpreter then a -handler procedure must be defined. The procedure is called with all the arguments provided by the remote call. dde execute ? -async ? ? -binary ? service topic data : dde execute takes the data and sends it to the server indicated by service with the topic indicated by topic . Typically, service is the name of an application, and topic is a file to work on. The data field is given to the remote application. Typically, the application treats the data field as a script, and the script is run in the application. The -async option requests asynchronous invocation. The command returns an error message if the script did not run, unless the -async flag was used, in which case the command returns immediately with no error. Without the -binary option all data will be sent in unicode. For dde clients which don\\'t implement the CF_UNICODE clipboard format, this will automatically be translated to the system encoding. You can use the -binary option in combination with the result of encoding convertto to send data in any other encoding. dde poke ? -binary ? service topic item data : dde poke passes the data to the server indicated by service using the topic and item specified. Typically, service is the name of an application. topic is application specific but can be a command to the server or the name of a file to work on. The item is also application specific and is often not used, but it must always be non-null. The data field is given to the remote application. Without the -binary option all data will be sent in unicode. For dde clients which don\\'t implement the CF_UNICODE clipboard format, this will automatically be translated to the system encoding. You can use the -binary option in combination with the result of encoding convertto to send data in any other encoding. dde request ? -binary ? service topic item : dde request is typically used to get the value of something; the value of a cell in Microsoft Excel or the text of a selection in Microsoft Word. service is typically the name of an application, topic is typically the name of the file, and item is application-specific. The command returns the value of item as defined in the application. Normally this is interpreted to be a string with terminating null. If -binary is specified, the result is returned as a byte array. dde services service topic : dde services returns a list of service-topic pairs that currently exist on the machine. If service and topic are both empty strings ({}), then all service-topic pairs currently available on the system are returned. If service is empty and topic is not, then all services with the specified topic are returned. If service is non-empty and topic is, all topics for a given service are returned. If both are non-empty, if that service-topic pair currently exists, it is returned; otherwise, an empty string is returned. dde eval ? -async ? topic cmd ? arg arg ... ? : dde eval evaluates a command and its arguments using the interpreter specified by topic . The DDE service must be the TclEval service. The -async option requests asynchronous invocation. The command returns an error message if the script did not run, unless the -async flag was used, in which case the command returns immediately with no error. This command can be used to replace send on Windows.","title":"DDE COMMANDS"},{"location":"dde/#dde-and-tcl","text":"A Tcl interpreter always has a service name of TclEval . Each different interpreter of all running Tcl applications must be given a unique name specified by dde servername . Each interp is available as a DDE topic only if the dde servername command was used to set the name of the topic for each interp. So a dde services TclEval {} command will return a list of service-topic pairs, where each of the currently running interps will be a topic. When Tcl processes a dde execute command, the data for the execute is run as a script in the interp named by the topic of the dde execute command. When Tcl processes a dde request command, it returns the value of the variable given in the dde command in the context of the interp named by the dde topic. Tcl reserves the variable \\$TCLEVAL\\$EXECUTE\\$RESULT for internal use, and dde request commands for that variable will give unpredictable results. An external application which wishes to run a script in Tcl should have that script store its result in a variable, run the dde execute command, and then run dde request to get the value of the variable. When using DDE, be careful to ensure that the event queue is flushed using either update or vwait . This happens by default when using wish unless a blocking command is called (such as exec without adding the & to place the process in the background). If for any reason the event queue is not flushed, DDE commands may hang until the event queue is flushed. This can create a deadlock situation.","title":"DDE AND TCL"},{"location":"dde/#example","text":"This asks Internet Explorer (which must already be running) to go to a particularly important website: package require dde dde execute -async iexplore WWW_OpenURL http://www.tcl-lang.org/","title":"EXAMPLE"},{"location":"dde/#see-also","text":"tk(n), winfo(n), send(n)","title":"SEE ALSO"},{"location":"dde/#keywords","text":"application, dde, name, remote execution","title":"KEYWORDS"},{"location":"define/","text":"NAME oo::define, oo::objdefine - define and configure classes and objects SYNOPSIS package require tcl::oo oo::define class defScript oo::define class subcommand arg ?arg ...? oo::objdefine object defScript oo::objdefine object subcommand arg ?arg ...? DESCRIPTION The oo::define command is used to control the configuration of classes, and the oo::objdefine command is used to control the configuration of objects (including classes as instance objects), with the configuration being applied to the entity named in the class or the object argument. Configuring a class also updates the configuration of all subclasses of the class and all objects that are instances of that class or which mix it in (as modified by any per-instance configuration). The way in which the configuration is done is controlled by either the defScript argument or by the subcommand and following arg arguments; when the second is present, it is exactly as if all the arguments from subcommand onwards are made into a list and that list is used as the defScript argument. Note that the constructor for oo::class will call oo::define on the script argument that it is provided. This is a convenient way to create and define a class in one step. CONFIGURING CLASSES The following commands are supported in the defScript for oo::define , each of which may also be used in the subcommand form: classmethod name ? argList bodyScrip ? : This creates a class method, or (if argList and bodyScript are omitted) promotes an existing method on the class object to be a class method. The name , argList and bodyScript arguments are as in the method definition, below. Class methods can be called on either the class itself or on the instances of that class. When they are called, the current object (see the sel and my commands) is the class on which they are called or the class of the instance on which they are called, depending on whether they are called on the class or an instance of the class, respectively. If called on a subclass or instance of the subclass, the current object is the subclass. In a private definition context, the methods as invoked on classes are not private, but the methods as invoked on instances of classes are private. constructor argList bodyScript : This creates or updates the constructor for a class. The formal arguments to the constructor (defined using the same format as for the Tcl proc command) will be argList , and the body of the constructor will be bodyScript . When the body of the constructor is evaluated, the current namespace of the constructor will be a namespace that is unique to the object being constructed. Within the constructor, the next command should be used to call the superclasses\\' constructors. If bodyScript is the empty string, the constructor will be deleted. Classes do not need to have a constructor defined. If none is specified, the superclass\\'s constructor will be used instead. destructor bodyScript : This creates or updates the destructor for a class. Destructors take no arguments, and the body of the destructor will be bodyScript . The destructor is called when objects of the class are deleted, and when called will have the object\\'s unique namespace as the current namespace. Destructors should use the next command to call the superclasses\\' destructors. Note that destructors are not called in all situations (e.g. if the interpreter is destroyed). If bodyScript is the empty string, the destructor will be deleted. Note that errors during the evaluation of a destructor *are not returned* to the code that causes the destruction of an object. Instead, they are passed to the currently-defined **bgerror** handler. export name ? name ... ? : This arranges for each of the named methods, name , to be exported (i.e. usable outside an instance through the instance object\\'s command) by the class being defined. Note that the methods themselves may be actually defined by a superclass; subclass exports override superclass visibility, and may in turn be overridden by instances. forward name cmdName ? arg ... ? : This creates or updates a forwarded method called name . The method is defined be forwarded to the command called cmdName , with additional arguments, arg etc., added before those arguments specified by the caller of the method. The cmdName will always be resolved using the rules of the invoking objects\\' namespaces, i.e., when cmdName is not fully-qualified, the command will be searched for in each object\\'s namespace, using the instances\\' namespace\\'s path, or by looking in the global namespace. The method will be exported if name starts with a lower-case letter, and non-exported otherwise. If in a private definition context (see the **private** definition command, below), this command creates private forwarded methods. initialise script : initialize script : This evaluates script in a context which supports local variables and where the current namespace is the instance namespace of the class object itself. This is useful for setting up, e.g., class-scoped variables. method name ? option ? argList bodyScript : This creates or updates a method that is implemented as a procedure-like script. The name of the method is name , the formal arguments to the method (defined using the same format as for the Tcl proc command) will be argList , and the body of the method will be bodyScript . When the body of the method is evaluated, the current namespace of the method will be a namespace that is unique to the current object. The method will be exported if name starts with a lower-case letter, and non-exported otherwise; this behavior can be overridden via export and unexport or by specifying -export , -private or -unexport in the optional parameter option . If in a private definition context (see the private definition command, below) or if the -private flag is given for option , this command creates private procedure-like methods. private cmd arg... : private script : This evaluates the script (or the list of command and arguments given by cmd and arg s) in a context where the definitions made on the current class will be private definitions. The following class definition commands are affected by private : forward , method , self , and variable . Nesting private inside private has no cumulative effect; the innermost definition context is just a private definition context. All other definition commands have no difference in behavior when used in a private definition context. self subcommand arg ... : self script : self : This command is equivalent to calling oo::objdefine on the class being defined (see CONFIGURING OBJECTS below for a description of the supported values of subcommand ). It follows the same general pattern of argument handling as the oo::define and oo::objdefine commands, and operates identically to If no arguments at all are used, this gives the name of the class currently being configured. If in a private definition context (see the private definition command, below), the definitions on the class object will also be made in a private definition context. superclass ? -slotOperation ? ? className ... ? : This slot (see SLOTTED DEFINITIONS below) allows the alteration of the superclasses of the class being defined. Each className argument names one class that is to be a superclass of the defined class. Note that objects must not be changed from being classes to being non-classes or vice-versa, that an empty parent class is equivalent to oo::object , and that the parent classes of oo::object and oo::class may not be modified. By default, this slot works by replacement. unexport name ? name ... ? : This arranges for each of the named methods, name , to be not exported (i.e. not usable outside the instance through the instance object\\'s command, but instead just through the my command visible in each object\\'s context) by the class being defined. Note that the methods themselves may be actually defined by a superclass; subclass unexports override superclass visibility, and may be overridden by instance unexports. variable ? -slotOperation ? ? name ... ? : This slot (see SLOTTED DEFINITIONS below) arranges for each of the named variables to be automatically made available in the methods, constructor and destructor declared by the class being defined. Each variable name must not have any namespace separators and must not look like an array access. All variables will be actually present in the namespace of the instance object on which the method is executed. Note that the variable lists declared by a superclass or subclass are completely disjoint, as are variable lists declared by instances; the list of variable names is just for methods (and constructors and destructors) declared by this class. By default, this slot works by appending. If in a private definition context (see the **private** definition command, below), this slot manipulates the list of private variable bindings for this class. In a private variable binding, the name of the variable within the instance object is different to the name given in the definition; the name used in the definition is the name that you use to access the variable within the methods of this class, and the name of the variable in the instance namespace has a unique prefix that makes accidental use from other classes extremely unlikely. ADVANCED CLASS CONFIGURATION OPTIONS The following definitions are also supported, but are not required in simple programs: definitionnamespace ? kind ? namespaceName : This allows control over what namespace will be used by the oo::define and oo::objdefine commands to look up the definition commands they use. When any object has a definition operation applied to it, the class that it is an instance of (and its superclasses and mixins) is consulted for what definition namespace to use. oo::define gets the class definition namespace, and ::oo::objdefine gets the instance definition namespace, but both otherwise use the identical lookup operation. This sets the definition namespace of kind kind provided by the current class to namespaceName . The namespaceName must refer to a currently existing namespace, or must be the empty string (to stop the current class from having such a namespace connected). The kind , if supplied, must be either -class (the default) or -instance to specify the whether the namespace for use with oo::define or oo::objdefine respectively is being set. The class oo::object has its instance namespace locked to ::oo::objdefine , and the class oo::class has its class namespace locked to ::oo::define . A consequence of this is that effective use of this feature for classes requires the definition of a metaclass. deletemethod name ? name ... ? : This deletes each of the methods called name from a class. The methods must have previously existed in that class. Does not affect the superclasses of the class, nor does it affect the subclasses or instances of the class (except when they have a call chain through the class being modified) or the class object itself. filter ? -slotOperation ? ? methodName ... ? : This slot (see SLOTTED DEFINITIONS below) sets or updates the list of method names that are used to guard whether method call to instances of the class may be called and what the method\\'s results are. Each methodName names a single filtering method (which may be exposed or not exposed); it is not an error for a non-existent method to be named since they may be defined by subclasses. By default, this slot works by appending. mixin ? -slotOperation ? ? className ... ? : This slot (see SLOTTED DEFINITIONS below) sets or updates the list of additional classes that are to be mixed into all the instances of the class being defined. Each className argument names a single class that is to be mixed in. By default, this slot works by replacement. renamemethod fromName toName : This renames the method called fromName in a class to toName . The method must have previously existed in the class, and toName must not previously refer to a method in that class. Does not affect the superclasses of the class, nor does it affect the subclasses or instances of the class (except when they have a call chain through the class being modified), or the class object itself. Does not change the export status of the method; if it was exported before, it will be afterwards. CONFIGURING OBJECTS The following commands are supported in the defScript for oo::objdefine , each of which may also be used in the subcommand form: export name ? name ... ? : This arranges for each of the named methods, name , to be exported (i.e. usable outside the object through the object\\'s command) by the object being defined. Note that the methods themselves may be actually defined by a class or superclass; object exports override class visibility. forward name cmdName ? arg ... ? : This creates or updates a forwarded object method called name . The method is defined be forwarded to the command called cmdName , with additional arguments, arg etc., added before those arguments specified by the caller of the method. Forwarded methods should be deleted using the method subcommand. The method will be exported if name starts with a lower-case letter, and non-exported otherwise. If in a private definition context (see the **private** definition command, below), this command creates private forwarded methods. method name ? option ? argList bodyScript : This creates, updates or deletes an object method. The name of the method is name , the formal arguments to the method (defined using the same format as for the Tcl proc command) will be argList , and the body of the method will be bodyScript . When the body of the method is evaluated, the current namespace of the method will be a namespace that is unique to the object. The method will be exported if name starts with a lower-case letter, and non-exported otherwise; this can be overridden by specifying -export , -private or -unexport in the optional parameter option , or via the export and unexport definitions. If in a private definition context (see the private definition command, below) or if the -private flag is given for option , this command creates private procedure-like methods. mixin ? -slotOperation ? ? className ... ? : This slot (see SLOTTED DEFINITIONS below) sets or updates a per-object list of additional classes that are to be mixed into the object. Each argument, className , names a single class that is to be mixed in. By default, this slot works by replacement. private cmd arg... : private script : This evaluates the script (or the list of command and arguments given by cmd and arg s) in a context where the definitions made on the current object will be private definitions. The following class definition commands are affected by private : forward , method , and variable . Nesting private inside private has no cumulative effect; the innermost definition context is just a private definition context. All other definition commands have no difference in behavior when used in a private definition context. unexport name ? name ... ? : This arranges for each of the named methods, name , to be not exported (i.e. not usable outside the object through the object\\'s command, but instead just through the my command visible in the object\\'s context) by the object being defined. Note that the methods themselves may be actually defined by a class; instance unexports override class visibility. variable ? -slotOperation ? ? name ... ? : This slot (see SLOTTED DEFINITIONS below) arranges for each of the named variables to be automatically made available in the methods declared by the object being defined. Each variable name must not have any namespace separators and must not look like an array access. All variables will be actually present in the namespace of the object on which the method is executed. Note that the variable lists declared by the classes and mixins of which the object is an instance are completely disjoint; the list of variable names is just for methods declared by this object. By default, this slot works by appending. If in a private definition context (see the **private** definition command, below), this slot manipulates the list of private variable bindings for this object. In a private variable binding, the name of the variable within the instance object is different to the name given in the definition; the name used in the definition is the name that you use to access the variable within the methods of this instance object, and the name of the variable in the instance namespace has a unique prefix that makes accidental use from superclass methods extremely unlikely. ADVANCED OBJECT CONFIGURATION OPTIONS The following definitions are also supported, but are not required in simple programs: class className : This allows the class of an object to be changed after creation. Note that the class\\'s constructors are not called when this is done, and so the object may well be in an inconsistent state unless additional configuration work is done. deletemethod name ? name ... : This deletes each of the methods called name from an object. The methods must have previously existed in that object (e.g., because it was created through oo::objdefine method ). Does not affect the classes that the object is an instance of, or remove the exposure of those class-provided methods in the instance of that class. filter ? -slotOperation ? ? methodName ... ? : This slot (see SLOTTED DEFINITIONS below) sets or updates the list of method names that are used to guard whether a method call to the object may be called and what the method\\'s results are. Each methodName names a single filtering method (which may be exposed or not exposed); it is not an error for a non-existent method to be named. Note that the actual list of filters also depends on the filters set upon any classes that the object is an instance of. By default, this slot works by appending. renamemethod fromName toName : This renames the method called fromName in an object to toName . The method must have previously existed in the object, and toName must not previously refer to a method in that object. Does not affect the classes that the object is an instance of and cannot rename in an instance object the methods provided by those classes (though a oo::objdefine forward ed method may provide an equivalent capability). Does not change the export status of the method; if it was exported before, it will be afterwards. self : This gives the name of the object currently being configured. PRIVATE METHODS When a class or instance has a private method, that private method can only be invoked from within methods of that class or instance. Other callers of the object\\'s methods cannot invoke private methods, it is as if the private methods do not exist. However, a private method of a class can be invoked from the class\\'s methods when those methods are being used on another instance object; this means that a class can use them to coordinate behaviour between several instances of itself without interfering with how other classes (especially either subclasses or superclasses) interact. Private methods precede all mixed in classes in the method call order (as reported by self call ). SLOTTED DEFINITIONS Some of the configurable definitions of a class or object are slotted definitions. This means that the configuration is implemented by a slot object, that is an instance of the class oo::Slot , which manages a list of values (class names, variable names, etc.) that comprises the contents of the slot. The class defines five operations (as methods) that may be done on the slot: slot -append ? member ... ? : This appends the given member elements to the slot definition. slot -clear : This sets the slot definition to the empty list. slot -prepend ? member ... ? : This prepends the given member elements to the slot definition. slot -remove ? member ... ? : This removes the given member elements from the slot definition. slot -set ? member ... ? : This replaces the slot definition with the given member elements. A consequence of this is that any use of a slot\\'s default operation where the first member argument begins with a hyphen will be an error. One of the above operations should be used explicitly in those circumstances. SLOT IMPLEMENTATION Internally, slot objects also define a method --default-operation which is forwarded to the default operation of the slot (thus, for the class slot, this is forwarded to and these methods which provide the implementation interface: slot Get : Returns a list that is the current contents of the slot, but does not modify the slot. This method must always be called from a stack frame created by a call to oo::define or oo::objdefine . This method should not return an error unless it is called from outside a definition context or with the wrong number of arguments. The elements of the list should be fully resolved, if that is a meaningful concept to the slot. slot Resolve slotElement : Returns slotElement with a resolution operation applied to it, but does not modify the slot. For slots of simple strings, this is an operation that does nothing, whereas for slots of classes, this maps a class name to its fully-qualified class name. This method must always be called from a stack frame created by a call to oo::define or oo::objdefine . This method should not return an error unless it is called from outside a definition context or with the wrong number of arguments; unresolvable arguments should be returned as is (as not all slot operations strictly require that values are resolvable to work). Implementations should not enforce uniqueness and ordering constraints in this method; that is the responsibility of the Set method. slot Set elementList : Sets the contents of the slot to the list elementList and returns the empty string. This method must always be called from a stack frame created by a call to oo::define or oo::objdefine . This method may return an error if it rejects the change to the slot contents (e.g., because of invalid values) as well as if it is called from outside a definition context or with the wrong number of arguments. This method *may* reorder and filter the elements if this is necessary in order to satisfy the underlying constraints of the slot. (For example, slots of classes enforce a uniqueness constraint that places each element in the earliest location in the slot that it can.) The implementation of these methods is slot-dependent (and responsible for accessing the correct part of the class or object definition). Slots also have an unknown method handler to tie all these pieces together, and they hide their destroy method so that it is not invoked inadvertently. It is recommended that any user changes to the slot mechanism be restricted to defining new operations whose names start with a hyphen. Most slot operations will initially Resolve their argument list, combine it with the results of the Get method, and then Set the result. Some operations omit one or both of the first two steps; omitting the third would result in an idempotent read-only operation (but the standard mechanism for reading from slots is via info class and info object ). EXAMPLES This example demonstrates how to use both forms of the oo::define and oo::objdefine commands (they work in the same way), as well as illustrating four of their subcommands. oo::class create c c create o oo::define c method foo {} { puts \\\"world\\\" } oo::objdefine o { method bar {} { my Foo \\\"hello \\\" my foo } forward Foo ::puts -nonewline unexport foo } o bar \u2192 prints \\\"hello world\\\" o foo \u2192 error \\\"unknown method foo\\\" o Foo Bar \u2192 error \\\"unknown method Foo\\\" oo::objdefine o renamemethod bar lollipop o lollipop \u2192 prints \\\"hello world\\\" This example shows how additional classes can be mixed into an object. It also shows how mixin is a slot that supports appending: oo::object create inst inst m1 \u2192 error \\\"unknown method m1\\\" inst m2 \u2192 error \\\"unknown method m2\\\" oo::class create A { method m1 {} { puts \\\"red brick\\\" } } oo::objdefine inst { mixin A } inst m1 \u2192 prints \\\"red brick\\\" inst m2 \u2192 error \\\"unknown method m2\\\" oo::class create B { method m2 {} { puts \\\"blue brick\\\" } } oo::objdefine inst { mixin -append B } inst m1 \u2192 prints \\\"red brick\\\" inst m2 \u2192 prints \\\"blue brick\\\" This example shows how to create and use class variables. It is a class that counts how many instances of itself have been made. oo::class create Counted oo::define Counted { initialise { variable count 0 } variable number constructor {} { classvariable count set number [incr count] } method report {} { classvariable count puts \\\"This is instance \\$number of \\$count\\\" } } set a [Counted new] set b [Counted new] \\$a report \u2192 This is instance 1 of 2 set c [Counted new] \\$b report \u2192 This is instance 2 of 3 \\$c report \u2192 This is instance 3 of 3 This example demonstrates how to use class methods. (Note that the constructor for oo::class calls oo::define on the class.) oo::class create DBTable { classmethod find {description} { puts \\\"DB: locate row from [self] matching \\$description\\\" return [my new] } classmethod insert {description} { puts \\\"DB: create row in [self] matching \\$description\\\" return [my new] } method update {description} { puts \\\"DB: update row [self] with \\$description\\\" } method delete {} { puts \\\"DB: delete row [self]\\\" my destroy; # Just delete the object, not the DB row } } oo::class create Users { superclass DBTable } oo::class create Groups { superclass DBTable } set u1 [Users insert \\\"username=abc\\\"] \u2192 DB: create row from ::Users matching username=abc set u2 [Users insert \\\"username=def\\\"] \u2192 DB: create row from ::Users matching username=def \\$u2 update \\\"group=NULL\\\" \u2192 DB: update row ::oo::Obj124 with group=NULL \\$u1 delete \u2192 DB: delete row ::oo::Obj123 set g [Group find \\\"groupname=webadmins\\\"] \u2192 DB: locate row ::Group with groupname=webadmins \\$g update \\\"emailaddress=admins\\\" \u2192 DB: update row ::oo::Obj125 with emailaddress=admins This example shows how to make a custom definition for a class. Note that it explicitly includes delegation to the existing definition commands via namespace path . namespace eval myDefinitions { # Delegate to existing definitions where not overridden namespace path ::oo::define # A custom type of method proc exprmethod {name arguments body} { tailcall method \\$name \\$arguments [list expr \\$body] } # A custom way of building a constructor proc parameters args { uplevel 1 [list variable {*}\\$args] set body [join [lmap a \\$args { string map [list VAR \\$a] { set [my varname VAR] [expr {double(\\$VAR)}] } }] \\\";\\\"] tailcall constructor \\$args \\$body } } # Bind the namespace into a (very simple) metaclass for use oo::class create exprclass { superclass oo::class definitionnamespace myDefinitions } # Use the custom definitions exprclass create quadratic { parameters a b c exprmethod evaluate {x} { (\\$a * \\$x**2) + (\\$b * \\$x) + \\$c } } # Showing the resulting class and object in action quadratic create quad 1 2 3 for {set x 0} {\\$x \\<= 4} {incr x} { puts [format \\\"quad(%d) = %.2f\\\" \\$x [quad evaluate \\$x]] } \u2192 quad(0) = 3.00 \u2192 quad(1) = 6.00 \u2192 quad(2) = 11.00 \u2192 quad(3) = 18.00 \u2192 quad(4) = 27.00 SEE ALSO next(n), oo::class(n), oo::object(n) KEYWORDS class, definition, method, object, slot","title":"NAME"},{"location":"define/#name","text":"oo::define, oo::objdefine - define and configure classes and objects","title":"NAME"},{"location":"define/#synopsis","text":"package require tcl::oo oo::define class defScript oo::define class subcommand arg ?arg ...? oo::objdefine object defScript oo::objdefine object subcommand arg ?arg ...?","title":"SYNOPSIS"},{"location":"define/#description","text":"The oo::define command is used to control the configuration of classes, and the oo::objdefine command is used to control the configuration of objects (including classes as instance objects), with the configuration being applied to the entity named in the class or the object argument. Configuring a class also updates the configuration of all subclasses of the class and all objects that are instances of that class or which mix it in (as modified by any per-instance configuration). The way in which the configuration is done is controlled by either the defScript argument or by the subcommand and following arg arguments; when the second is present, it is exactly as if all the arguments from subcommand onwards are made into a list and that list is used as the defScript argument. Note that the constructor for oo::class will call oo::define on the script argument that it is provided. This is a convenient way to create and define a class in one step.","title":"DESCRIPTION"},{"location":"define/#configuring-classes","text":"The following commands are supported in the defScript for oo::define , each of which may also be used in the subcommand form: classmethod name ? argList bodyScrip ? : This creates a class method, or (if argList and bodyScript are omitted) promotes an existing method on the class object to be a class method. The name , argList and bodyScript arguments are as in the method definition, below. Class methods can be called on either the class itself or on the instances of that class. When they are called, the current object (see the sel and my commands) is the class on which they are called or the class of the instance on which they are called, depending on whether they are called on the class or an instance of the class, respectively. If called on a subclass or instance of the subclass, the current object is the subclass. In a private definition context, the methods as invoked on classes are not private, but the methods as invoked on instances of classes are private. constructor argList bodyScript : This creates or updates the constructor for a class. The formal arguments to the constructor (defined using the same format as for the Tcl proc command) will be argList , and the body of the constructor will be bodyScript . When the body of the constructor is evaluated, the current namespace of the constructor will be a namespace that is unique to the object being constructed. Within the constructor, the next command should be used to call the superclasses\\' constructors. If bodyScript is the empty string, the constructor will be deleted. Classes do not need to have a constructor defined. If none is specified, the superclass\\'s constructor will be used instead. destructor bodyScript : This creates or updates the destructor for a class. Destructors take no arguments, and the body of the destructor will be bodyScript . The destructor is called when objects of the class are deleted, and when called will have the object\\'s unique namespace as the current namespace. Destructors should use the next command to call the superclasses\\' destructors. Note that destructors are not called in all situations (e.g. if the interpreter is destroyed). If bodyScript is the empty string, the destructor will be deleted. Note that errors during the evaluation of a destructor *are not returned* to the code that causes the destruction of an object. Instead, they are passed to the currently-defined **bgerror** handler. export name ? name ... ? : This arranges for each of the named methods, name , to be exported (i.e. usable outside an instance through the instance object\\'s command) by the class being defined. Note that the methods themselves may be actually defined by a superclass; subclass exports override superclass visibility, and may in turn be overridden by instances. forward name cmdName ? arg ... ? : This creates or updates a forwarded method called name . The method is defined be forwarded to the command called cmdName , with additional arguments, arg etc., added before those arguments specified by the caller of the method. The cmdName will always be resolved using the rules of the invoking objects\\' namespaces, i.e., when cmdName is not fully-qualified, the command will be searched for in each object\\'s namespace, using the instances\\' namespace\\'s path, or by looking in the global namespace. The method will be exported if name starts with a lower-case letter, and non-exported otherwise. If in a private definition context (see the **private** definition command, below), this command creates private forwarded methods. initialise script : initialize script : This evaluates script in a context which supports local variables and where the current namespace is the instance namespace of the class object itself. This is useful for setting up, e.g., class-scoped variables. method name ? option ? argList bodyScript : This creates or updates a method that is implemented as a procedure-like script. The name of the method is name , the formal arguments to the method (defined using the same format as for the Tcl proc command) will be argList , and the body of the method will be bodyScript . When the body of the method is evaluated, the current namespace of the method will be a namespace that is unique to the current object. The method will be exported if name starts with a lower-case letter, and non-exported otherwise; this behavior can be overridden via export and unexport or by specifying -export , -private or -unexport in the optional parameter option . If in a private definition context (see the private definition command, below) or if the -private flag is given for option , this command creates private procedure-like methods. private cmd arg... : private script : This evaluates the script (or the list of command and arguments given by cmd and arg s) in a context where the definitions made on the current class will be private definitions. The following class definition commands are affected by private : forward , method , self , and variable . Nesting private inside private has no cumulative effect; the innermost definition context is just a private definition context. All other definition commands have no difference in behavior when used in a private definition context. self subcommand arg ... : self script : self : This command is equivalent to calling oo::objdefine on the class being defined (see CONFIGURING OBJECTS below for a description of the supported values of subcommand ). It follows the same general pattern of argument handling as the oo::define and oo::objdefine commands, and operates identically to If no arguments at all are used, this gives the name of the class currently being configured. If in a private definition context (see the private definition command, below), the definitions on the class object will also be made in a private definition context. superclass ? -slotOperation ? ? className ... ? : This slot (see SLOTTED DEFINITIONS below) allows the alteration of the superclasses of the class being defined. Each className argument names one class that is to be a superclass of the defined class. Note that objects must not be changed from being classes to being non-classes or vice-versa, that an empty parent class is equivalent to oo::object , and that the parent classes of oo::object and oo::class may not be modified. By default, this slot works by replacement. unexport name ? name ... ? : This arranges for each of the named methods, name , to be not exported (i.e. not usable outside the instance through the instance object\\'s command, but instead just through the my command visible in each object\\'s context) by the class being defined. Note that the methods themselves may be actually defined by a superclass; subclass unexports override superclass visibility, and may be overridden by instance unexports. variable ? -slotOperation ? ? name ... ? : This slot (see SLOTTED DEFINITIONS below) arranges for each of the named variables to be automatically made available in the methods, constructor and destructor declared by the class being defined. Each variable name must not have any namespace separators and must not look like an array access. All variables will be actually present in the namespace of the instance object on which the method is executed. Note that the variable lists declared by a superclass or subclass are completely disjoint, as are variable lists declared by instances; the list of variable names is just for methods (and constructors and destructors) declared by this class. By default, this slot works by appending. If in a private definition context (see the **private** definition command, below), this slot manipulates the list of private variable bindings for this class. In a private variable binding, the name of the variable within the instance object is different to the name given in the definition; the name used in the definition is the name that you use to access the variable within the methods of this class, and the name of the variable in the instance namespace has a unique prefix that makes accidental use from other classes extremely unlikely.","title":"CONFIGURING CLASSES"},{"location":"define/#advanced-class-configuration-options","text":"The following definitions are also supported, but are not required in simple programs: definitionnamespace ? kind ? namespaceName : This allows control over what namespace will be used by the oo::define and oo::objdefine commands to look up the definition commands they use. When any object has a definition operation applied to it, the class that it is an instance of (and its superclasses and mixins) is consulted for what definition namespace to use. oo::define gets the class definition namespace, and ::oo::objdefine gets the instance definition namespace, but both otherwise use the identical lookup operation. This sets the definition namespace of kind kind provided by the current class to namespaceName . The namespaceName must refer to a currently existing namespace, or must be the empty string (to stop the current class from having such a namespace connected). The kind , if supplied, must be either -class (the default) or -instance to specify the whether the namespace for use with oo::define or oo::objdefine respectively is being set. The class oo::object has its instance namespace locked to ::oo::objdefine , and the class oo::class has its class namespace locked to ::oo::define . A consequence of this is that effective use of this feature for classes requires the definition of a metaclass. deletemethod name ? name ... ? : This deletes each of the methods called name from a class. The methods must have previously existed in that class. Does not affect the superclasses of the class, nor does it affect the subclasses or instances of the class (except when they have a call chain through the class being modified) or the class object itself. filter ? -slotOperation ? ? methodName ... ? : This slot (see SLOTTED DEFINITIONS below) sets or updates the list of method names that are used to guard whether method call to instances of the class may be called and what the method\\'s results are. Each methodName names a single filtering method (which may be exposed or not exposed); it is not an error for a non-existent method to be named since they may be defined by subclasses. By default, this slot works by appending. mixin ? -slotOperation ? ? className ... ? : This slot (see SLOTTED DEFINITIONS below) sets or updates the list of additional classes that are to be mixed into all the instances of the class being defined. Each className argument names a single class that is to be mixed in. By default, this slot works by replacement. renamemethod fromName toName : This renames the method called fromName in a class to toName . The method must have previously existed in the class, and toName must not previously refer to a method in that class. Does not affect the superclasses of the class, nor does it affect the subclasses or instances of the class (except when they have a call chain through the class being modified), or the class object itself. Does not change the export status of the method; if it was exported before, it will be afterwards.","title":"ADVANCED CLASS CONFIGURATION OPTIONS"},{"location":"define/#configuring-objects","text":"The following commands are supported in the defScript for oo::objdefine , each of which may also be used in the subcommand form: export name ? name ... ? : This arranges for each of the named methods, name , to be exported (i.e. usable outside the object through the object\\'s command) by the object being defined. Note that the methods themselves may be actually defined by a class or superclass; object exports override class visibility. forward name cmdName ? arg ... ? : This creates or updates a forwarded object method called name . The method is defined be forwarded to the command called cmdName , with additional arguments, arg etc., added before those arguments specified by the caller of the method. Forwarded methods should be deleted using the method subcommand. The method will be exported if name starts with a lower-case letter, and non-exported otherwise. If in a private definition context (see the **private** definition command, below), this command creates private forwarded methods. method name ? option ? argList bodyScript : This creates, updates or deletes an object method. The name of the method is name , the formal arguments to the method (defined using the same format as for the Tcl proc command) will be argList , and the body of the method will be bodyScript . When the body of the method is evaluated, the current namespace of the method will be a namespace that is unique to the object. The method will be exported if name starts with a lower-case letter, and non-exported otherwise; this can be overridden by specifying -export , -private or -unexport in the optional parameter option , or via the export and unexport definitions. If in a private definition context (see the private definition command, below) or if the -private flag is given for option , this command creates private procedure-like methods. mixin ? -slotOperation ? ? className ... ? : This slot (see SLOTTED DEFINITIONS below) sets or updates a per-object list of additional classes that are to be mixed into the object. Each argument, className , names a single class that is to be mixed in. By default, this slot works by replacement. private cmd arg... : private script : This evaluates the script (or the list of command and arguments given by cmd and arg s) in a context where the definitions made on the current object will be private definitions. The following class definition commands are affected by private : forward , method , and variable . Nesting private inside private has no cumulative effect; the innermost definition context is just a private definition context. All other definition commands have no difference in behavior when used in a private definition context. unexport name ? name ... ? : This arranges for each of the named methods, name , to be not exported (i.e. not usable outside the object through the object\\'s command, but instead just through the my command visible in the object\\'s context) by the object being defined. Note that the methods themselves may be actually defined by a class; instance unexports override class visibility. variable ? -slotOperation ? ? name ... ? : This slot (see SLOTTED DEFINITIONS below) arranges for each of the named variables to be automatically made available in the methods declared by the object being defined. Each variable name must not have any namespace separators and must not look like an array access. All variables will be actually present in the namespace of the object on which the method is executed. Note that the variable lists declared by the classes and mixins of which the object is an instance are completely disjoint; the list of variable names is just for methods declared by this object. By default, this slot works by appending. If in a private definition context (see the **private** definition command, below), this slot manipulates the list of private variable bindings for this object. In a private variable binding, the name of the variable within the instance object is different to the name given in the definition; the name used in the definition is the name that you use to access the variable within the methods of this instance object, and the name of the variable in the instance namespace has a unique prefix that makes accidental use from superclass methods extremely unlikely.","title":"CONFIGURING OBJECTS"},{"location":"define/#advanced-object-configuration-options","text":"The following definitions are also supported, but are not required in simple programs: class className : This allows the class of an object to be changed after creation. Note that the class\\'s constructors are not called when this is done, and so the object may well be in an inconsistent state unless additional configuration work is done. deletemethod name ? name ... : This deletes each of the methods called name from an object. The methods must have previously existed in that object (e.g., because it was created through oo::objdefine method ). Does not affect the classes that the object is an instance of, or remove the exposure of those class-provided methods in the instance of that class. filter ? -slotOperation ? ? methodName ... ? : This slot (see SLOTTED DEFINITIONS below) sets or updates the list of method names that are used to guard whether a method call to the object may be called and what the method\\'s results are. Each methodName names a single filtering method (which may be exposed or not exposed); it is not an error for a non-existent method to be named. Note that the actual list of filters also depends on the filters set upon any classes that the object is an instance of. By default, this slot works by appending. renamemethod fromName toName : This renames the method called fromName in an object to toName . The method must have previously existed in the object, and toName must not previously refer to a method in that object. Does not affect the classes that the object is an instance of and cannot rename in an instance object the methods provided by those classes (though a oo::objdefine forward ed method may provide an equivalent capability). Does not change the export status of the method; if it was exported before, it will be afterwards. self : This gives the name of the object currently being configured.","title":"ADVANCED OBJECT CONFIGURATION OPTIONS"},{"location":"define/#private-methods","text":"When a class or instance has a private method, that private method can only be invoked from within methods of that class or instance. Other callers of the object\\'s methods cannot invoke private methods, it is as if the private methods do not exist. However, a private method of a class can be invoked from the class\\'s methods when those methods are being used on another instance object; this means that a class can use them to coordinate behaviour between several instances of itself without interfering with how other classes (especially either subclasses or superclasses) interact. Private methods precede all mixed in classes in the method call order (as reported by self call ).","title":"PRIVATE METHODS"},{"location":"define/#slotted-definitions","text":"Some of the configurable definitions of a class or object are slotted definitions. This means that the configuration is implemented by a slot object, that is an instance of the class oo::Slot , which manages a list of values (class names, variable names, etc.) that comprises the contents of the slot. The class defines five operations (as methods) that may be done on the slot: slot -append ? member ... ? : This appends the given member elements to the slot definition. slot -clear : This sets the slot definition to the empty list. slot -prepend ? member ... ? : This prepends the given member elements to the slot definition. slot -remove ? member ... ? : This removes the given member elements from the slot definition. slot -set ? member ... ? : This replaces the slot definition with the given member elements. A consequence of this is that any use of a slot\\'s default operation where the first member argument begins with a hyphen will be an error. One of the above operations should be used explicitly in those circumstances.","title":"SLOTTED DEFINITIONS"},{"location":"define/#slot-implementation","text":"Internally, slot objects also define a method --default-operation which is forwarded to the default operation of the slot (thus, for the class slot, this is forwarded to and these methods which provide the implementation interface: slot Get : Returns a list that is the current contents of the slot, but does not modify the slot. This method must always be called from a stack frame created by a call to oo::define or oo::objdefine . This method should not return an error unless it is called from outside a definition context or with the wrong number of arguments. The elements of the list should be fully resolved, if that is a meaningful concept to the slot. slot Resolve slotElement : Returns slotElement with a resolution operation applied to it, but does not modify the slot. For slots of simple strings, this is an operation that does nothing, whereas for slots of classes, this maps a class name to its fully-qualified class name. This method must always be called from a stack frame created by a call to oo::define or oo::objdefine . This method should not return an error unless it is called from outside a definition context or with the wrong number of arguments; unresolvable arguments should be returned as is (as not all slot operations strictly require that values are resolvable to work). Implementations should not enforce uniqueness and ordering constraints in this method; that is the responsibility of the Set method. slot Set elementList : Sets the contents of the slot to the list elementList and returns the empty string. This method must always be called from a stack frame created by a call to oo::define or oo::objdefine . This method may return an error if it rejects the change to the slot contents (e.g., because of invalid values) as well as if it is called from outside a definition context or with the wrong number of arguments. This method *may* reorder and filter the elements if this is necessary in order to satisfy the underlying constraints of the slot. (For example, slots of classes enforce a uniqueness constraint that places each element in the earliest location in the slot that it can.) The implementation of these methods is slot-dependent (and responsible for accessing the correct part of the class or object definition). Slots also have an unknown method handler to tie all these pieces together, and they hide their destroy method so that it is not invoked inadvertently. It is recommended that any user changes to the slot mechanism be restricted to defining new operations whose names start with a hyphen. Most slot operations will initially Resolve their argument list, combine it with the results of the Get method, and then Set the result. Some operations omit one or both of the first two steps; omitting the third would result in an idempotent read-only operation (but the standard mechanism for reading from slots is via info class and info object ).","title":"SLOT IMPLEMENTATION"},{"location":"define/#examples","text":"This example demonstrates how to use both forms of the oo::define and oo::objdefine commands (they work in the same way), as well as illustrating four of their subcommands. oo::class create c c create o oo::define c method foo {} { puts \\\"world\\\" } oo::objdefine o { method bar {} { my Foo \\\"hello \\\" my foo } forward Foo ::puts -nonewline unexport foo } o bar \u2192 prints \\\"hello world\\\" o foo \u2192 error \\\"unknown method foo\\\" o Foo Bar \u2192 error \\\"unknown method Foo\\\" oo::objdefine o renamemethod bar lollipop o lollipop \u2192 prints \\\"hello world\\\" This example shows how additional classes can be mixed into an object. It also shows how mixin is a slot that supports appending: oo::object create inst inst m1 \u2192 error \\\"unknown method m1\\\" inst m2 \u2192 error \\\"unknown method m2\\\" oo::class create A { method m1 {} { puts \\\"red brick\\\" } } oo::objdefine inst { mixin A } inst m1 \u2192 prints \\\"red brick\\\" inst m2 \u2192 error \\\"unknown method m2\\\" oo::class create B { method m2 {} { puts \\\"blue brick\\\" } } oo::objdefine inst { mixin -append B } inst m1 \u2192 prints \\\"red brick\\\" inst m2 \u2192 prints \\\"blue brick\\\" This example shows how to create and use class variables. It is a class that counts how many instances of itself have been made. oo::class create Counted oo::define Counted { initialise { variable count 0 } variable number constructor {} { classvariable count set number [incr count] } method report {} { classvariable count puts \\\"This is instance \\$number of \\$count\\\" } } set a [Counted new] set b [Counted new] \\$a report \u2192 This is instance 1 of 2 set c [Counted new] \\$b report \u2192 This is instance 2 of 3 \\$c report \u2192 This is instance 3 of 3 This example demonstrates how to use class methods. (Note that the constructor for oo::class calls oo::define on the class.) oo::class create DBTable { classmethod find {description} { puts \\\"DB: locate row from [self] matching \\$description\\\" return [my new] } classmethod insert {description} { puts \\\"DB: create row in [self] matching \\$description\\\" return [my new] } method update {description} { puts \\\"DB: update row [self] with \\$description\\\" } method delete {} { puts \\\"DB: delete row [self]\\\" my destroy; # Just delete the object, not the DB row } } oo::class create Users { superclass DBTable } oo::class create Groups { superclass DBTable } set u1 [Users insert \\\"username=abc\\\"] \u2192 DB: create row from ::Users matching username=abc set u2 [Users insert \\\"username=def\\\"] \u2192 DB: create row from ::Users matching username=def \\$u2 update \\\"group=NULL\\\" \u2192 DB: update row ::oo::Obj124 with group=NULL \\$u1 delete \u2192 DB: delete row ::oo::Obj123 set g [Group find \\\"groupname=webadmins\\\"] \u2192 DB: locate row ::Group with groupname=webadmins \\$g update \\\"emailaddress=admins\\\" \u2192 DB: update row ::oo::Obj125 with emailaddress=admins This example shows how to make a custom definition for a class. Note that it explicitly includes delegation to the existing definition commands via namespace path . namespace eval myDefinitions { # Delegate to existing definitions where not overridden namespace path ::oo::define # A custom type of method proc exprmethod {name arguments body} { tailcall method \\$name \\$arguments [list expr \\$body] } # A custom way of building a constructor proc parameters args { uplevel 1 [list variable {*}\\$args] set body [join [lmap a \\$args { string map [list VAR \\$a] { set [my varname VAR] [expr {double(\\$VAR)}] } }] \\\";\\\"] tailcall constructor \\$args \\$body } } # Bind the namespace into a (very simple) metaclass for use oo::class create exprclass { superclass oo::class definitionnamespace myDefinitions } # Use the custom definitions exprclass create quadratic { parameters a b c exprmethod evaluate {x} { (\\$a * \\$x**2) + (\\$b * \\$x) + \\$c } } # Showing the resulting class and object in action quadratic create quad 1 2 3 for {set x 0} {\\$x \\<= 4} {incr x} { puts [format \\\"quad(%d) = %.2f\\\" \\$x [quad evaluate \\$x]] } \u2192 quad(0) = 3.00 \u2192 quad(1) = 6.00 \u2192 quad(2) = 11.00 \u2192 quad(3) = 18.00 \u2192 quad(4) = 27.00","title":"EXAMPLES"},{"location":"define/#see-also","text":"next(n), oo::class(n), oo::object(n)","title":"SEE ALSO"},{"location":"define/#keywords","text":"class, definition, method, object, slot","title":"KEYWORDS"},{"location":"dict/","text":"NAME dict - Manipulate dictionaries SYNOPSIS dict option arg ? arg ... ? DESCRIPTION Performs one of several operations on dictionary values or variables containing dictionary values (see the DICTIONARY VALUES section below for a description), depending on option . The legal option s (which may be abbreviated) are: dict append dictionaryVariable key ? string ... ? : This appends the given string (or strings) to the value that the given key maps to in the dictionary value contained in the given variable, writing the resulting dictionary value back to that variable. Non-existent keys are treated as if they map to an empty string. The updated dictionary value is returned. If dictionaryVariable indicates an element that does not exist of an array that has a default value set, the default value and will be used as the value of the dictionary prior to the appending operation. dict create ? key value ... ? : Return a new dictionary that contains each of the key/value mappings listed as arguments (keys and values alternating, with each key being followed by its associated value.) dict exists dictionaryValue key ? key ... ? : This returns a boolean value indicating whether the given key (or path of keys through a set of nested dictionaries) exists in the given dictionary value. This returns a true value exactly when dict get on that path will succeed. dict filter dictionaryValue filterType arg ? arg ... ? : This takes a dictionary value and returns a new dictionary that contains just those key/value pairs that match the specified filter type (which may be abbreviated.) Supported filter types are: **dict filter ***dictionaryValue ***key** ?*globPattern \\...*? : The key rule only matches those key/value pairs whose keys match any of the given patterns (in the style of **string match**.) **dict filter ***dictionaryValue ***script {***keyVariable valueVariable***} ***script* : The script rule tests for matching by assigning the key to the *keyVariable* and the value to the *valueVariable*, and then evaluating the given script which should result in a boolean value (with the key/value pair only being included in the result of the **dict** filter when a true value is returned.) Note that the first argument after the rule selection word is a two-element list. If the *script* returns with a condition of **TCL_BREAK**, no further key/value pairs are considered for inclusion in the resulting dictionary, and a condition of **TCL_CONTINUE** is equivalent to a false result. The key/value pairs are tested in the order in which the keys were inserted into the dictionary. **dict filter ***dictionaryValue ***value **?*globPattern \\...*? : The value rule only matches those key/value pairs whose values match any of the given patterns (in the style of **string match**.) dict for { keyVariable valueVariable } dictionaryValue body : This command takes three arguments, the first a two-element list of variable names (for the key and value respectively of each mapping in the dictionary), the second the dictionary value to iterate across, and the third a script to be evaluated for each mapping with the key and value variables set appropriately (in the manner of foreach .) The result of the command is an empty string. If any evaluation of the body generates a TCL_BREAK result, no further pairs from the dictionary will be iterated over and the dict for command will terminate successfully immediately. If any evaluation of the body generates a TCL_CONTINUE result, this shall be treated exactly like a normal TCL_OK result. The order of iteration is the order in which the keys were inserted into the dictionary. dict get dictionaryValue ? key ... ? : Given a dictionary value (first argument) and a key (second argument), this will retrieve the value for that key. Where several keys are supplied, the behaviour of the command shall be as if the result of dict get \\$dictVal \\$key was passed as the first argument to dict get with the remaining arguments as second (and possibly subsequent) arguments. This facilitates lookups in nested dictionaries. For example, the following two commands are equivalent: dict get \\$dict foo bar spong dict get \\[dict get \\[dict get \\$dict foo\\] bar\\] spong If no keys are provided, **dict get** will return a list containing pairs of elements in a manner similar to **array get**. That is, the first element of each pair would be the key and the second element would be the value for that key. It is an error to attempt to retrieve a value for a key that is not present in the dictionary. dict getdef dictionaryValue ? key ... ? key default : dict getwithdefault dictionaryValue ? key ... ? key default : This behaves the same as dict get (with at least one key argument), returning the value that the key path maps to in the dictionary dictionaryValue , except that instead of producing an error because the key (or one of the key s on the key path) is absent, it returns the default argument instead. Note that there must always be at least one key provided, and that dict getdef and dict getwithdefault are aliases for each other. dict incr dictionaryVariable key ? increment ? : This adds the given increment value (an integer that defaults to 1 if not specified) to the value that the given key maps to in the dictionary value contained in the given variable, writing the resulting dictionary value back to that variable. Non-existent keys are treated as if they map to 0. It is an error to increment a value for an existing key if that value is not an integer. The updated dictionary value is returned. If dictionaryVariable indicates an element that does not exist of an array that has a default value set, the default value and will be used as the value of the dictionary prior to the incrementing operation. dict info dictionaryValue : This returns information (intended for display to people) about the given dictionary though the format of this data is dependent on the implementation of the dictionary. For dictionaries that are implemented by hash tables, it is expected that this will return the string produced by Tcl_HashStats , similar to array statistics . dict keys dictionaryValue ? globPattern ? : Return a list of all keys in the given dictionary value. If a pattern is supplied, only those keys that match it (according to the rules of string match ) will be returned. The returned keys will be in the order that they were inserted into the dictionary. dict lappend dictionaryVariable key ? value ... ? : This appends the given items to the list value that the given key maps to in the dictionary value contained in the given variable, writing the resulting dictionary value back to that variable. Non-existent keys are treated as if they map to an empty list, and it is legal for there to be no items to append to the list. It is an error for the value that the key maps to to not be representable as a list. The updated dictionary value is returned. If dictionaryVariable indicates an element that does not exist of an array that has a default value set, the default value and will be used as the value of the dictionary prior to the list-appending operation. dict map { keyVariable valueVariable } dictionaryValue body : This command applies a transformation to each element of a dictionary, returning a new dictionary. It takes three arguments: the first is a two-element list of variable names (for the key and value respectively of each mapping in the dictionary), the second the dictionary value to iterate across, and the third a script to be evaluated for each mapping with the key and value variables set appropriately (in the manner of lmap ). In an iteration where the evaluated script completes normally ( TCL_OK , as opposed to an error , etc.) the result of the script is put into an accumulator dictionary using the key that is the current contents of the keyVariable variable at that point. The result of the dict map command is the accumulator dictionary after all keys have been iterated over. If the evaluation of the body for any particular step generates a **break**, no further pairs from the dictionary will be iterated over and the **dict** map command will terminate successfully immediately. If the evaluation of the body for a particular step generates a **continue** result, the current iteration is aborted and the accumulator dictionary is not modified. The order of iteration is the natural order of the dictionary (typically the order in which the keys were added to the dictionary; the order is the same as that used in **dict for**). dict merge ? dictionaryValue ... ? : Return a dictionary that contains the contents of each of the dictionaryValue arguments. Where two (or more) dictionaries contain a mapping for the same key, the resulting dictionary maps that key to the value according to the last dictionary on the command line containing a mapping for that key. dict remove dictionaryValue ? key ... ? : Return a new dictionary that is a copy of an old one passed in as first argument except without mappings for each of the keys listed. It is legal for there to be no keys to remove, and it also legal for any of the keys to be removed to not be present in the input dictionary in the first place. dict replace dictionaryValue ? key value ... ? : Return a new dictionary that is a copy of an old one passed in as first argument except with some values different or some extra key/value pairs added. It is legal for this command to be called with no key/value pairs, but illegal for this command to be called with a key but no value. dict set dictionaryVariable key ? key ... ? value : This operation takes the name of a variable containing a dictionary value and places an updated dictionary value in that variable containing a mapping from the given key to the given value. When multiple keys are present, this operation creates or updates a chain of nested dictionaries. The updated dictionary value is returned. If dictionaryVariable indicates an element that does not exist of an array that has a default value set, the default value and will be used as the value of the dictionary prior to the value insert/update operation. dict size dictionaryValue : Return the number of key/value mappings in the given dictionary value. dict unset dictionaryVariable key ? key ... ? : This operation (the companion to dict set ) takes the name of a variable containing a dictionary value and places an updated dictionary value in that variable that does not contain a mapping for the given key. Where multiple keys are present, this describes a path through nested dictionaries to the mapping to remove. At least one key must be specified, but the last key on the key-path need not exist. All other components on the path must exist. The updated dictionary value is returned. If dictionaryVariable indicates an element that does not exist of an array that has a default value set, the default value and will be used as the value of the dictionary prior to the value remove operation. dict update dictionaryVariable key varName ? key varName ... ? body : Execute the Tcl script in body with the value for each key (as found by reading the dictionary value in dictionaryVariable ) mapped to the variable varName . There may be multiple key / varName pairs. If a key does not have a mapping, that corresponds to an unset varName . When body terminates, any changes made to the varName s is reflected back to the dictionary within dictionaryVariable (unless dictionaryVariable itself becomes unreadable, when all updates are silently discarded), even if the result of body is an error or some other kind of exceptional exit. The result of dict update is (unless some kind of error occurs) the result of the evaluation of body . If dictionaryVariable indicates an element that does not exist of an array that has a default value set, the default value and will be used as the value of the dictionary prior to the update operation. Each varName is mapped in the scope enclosing the dict update ; it is recommended that this command only be used in a local scope ( proc edure, lambda term for apply , or method). Because of this, the variables set by dict update will continue to exist after the command finishes (unless explicitly unset ). Note that the mapping of values to variables does not use traces; changes to the dictionaryVariable \\'s contents only happen when body terminates. dict values dictionaryValue ? globPattern ? : Return a list of all values in the given dictionary value. If a pattern is supplied, only those values that match it (according to the rules of string match ) will be returned. The returned values will be in the order of that the keys associated with those values were inserted into the dictionary. dict with dictionaryVariable ? key ... ? body : Execute the Tcl script in body with the value for each key in dictionaryVariable mapped (in a manner similarly to dict update) to a variable with the same name. Where one or more key s are available, these indicate a chain of nested dictionaries, with the innermost dictionary being the one opened out for the execution of body . As with dict update , making dictionaryVariable unreadable will make the updates to the dictionary be discarded, and this also happens if the contents of dictionaryVariable are adjusted so that the chain of dictionaries no longer exists. The result of dict with is (unless some kind of error occurs) the result of the evaluation of body . If dictionaryVariable indicates an element that does not exist of an array that has a default value set, the default value and will be used as the value of the dictionary prior to the updating operation. The variables are mapped in the scope enclosing the dict with ; it is recommended that this command only be used in a local scope ( proc edure, lambda term for apply , or method). Because of this, the variables set by dict with will continue to exist after the command finishes (unless explicitly unset ). Note that the mapping of values to variables does not use traces; changes to the dictionaryVariable \\'s contents only happen when body terminates. If the dictionaryVariable contains a value that is not a dictionary at the point when the body terminates (which can easily happen if the name is the same as any of the keys in dictionary) then an error occurs at that point. This command is thus not recommended for use when the keys in the dictionary are expected to clash with the dictionaryVariable name itself. Where the contained key does map to a dictionary, the net effect is to combine that inner dictionary into the outer dictionary; see the EXAMPLES below for an illustration of this. DICTIONARY VALUES Dictionaries are values that contain an efficient, order-preserving mapping from arbitrary keys to arbitrary values. Each key in the dictionary maps to a single value. They have a textual format that is exactly that of any list with an even number of elements, with each mapping in the dictionary being represented as two items in the list. When a command takes a dictionary and produces a new dictionary based on it (either returning it or writing it back into the variable that the starting dictionary was read from) the new dictionary will have the same order of keys, modulo any deleted keys and with new keys added on to the end. When a string is interpreted as a dictionary and it would otherwise have duplicate keys, only the last value for a particular key is used; the others are ignored, meaning that, and are equivalent dictionaries (with different string representations). Operations that derive a new dictionary from an old one (e.g., updates like dict set and dict unset ) preserve the order of keys in the dictionary. The exceptions to this are for any new keys they add, which are appended to the sequence, and any keys that are removed, which are excised from the order. EXAMPLES Basic dictionary usage: # Make a dictionary to map extensions to descriptions set filetypes [ dict create .txt \\\"Text File\\\" .tcl \\\"Tcl File\\\"] # Add/update the dictionary dict set filetypes .tcl \\\"Tcl Script\\\" dict set filetypes .tm \\\"Tcl Module\\\" dict set filetypes .gif \\\"GIF Image\\\" dict set filetypes .png \\\"PNG Image\\\" # Simple read from the dictionary set ext \\\".tcl\\\" set desc [ dict get \\$filetypes \\$ext] puts \\\"\\$ext is for a \\$desc\\\" # Somewhat more complex, with existence test foreach filename [glob *] { set ext [file extension \\$filename] if {[ dict exists \\$filetypes \\$ext]} { puts \\\"\\$filename is a [ dict get \\$filetypes \\$ext]\\\" } } Constructing and using nested dictionaries: # Data for one employee dict set employeeInfo 12345-A forenames \\\"Joe\\\" dict set employeeInfo 12345-A surname \\\"Schmoe\\\" dict set employeeInfo 12345-A street \\\"147 Short Street\\\" dict set employeeInfo 12345-A city \\\"Springfield\\\" dict set employeeInfo 12345-A phone \\\"555-1234\\\" # Data for another employee dict set employeeInfo 98372-J forenames \\\"Anne\\\" dict set employeeInfo 98372-J surname \\\"Other\\\" dict set employeeInfo 98372-J street \\\"32995 Oakdale Way\\\" dict set employeeInfo 98372-J city \\\"Springfield\\\" dict set employeeInfo 98372-J phone \\\"555-8765\\\" # The above data probably ought to come from a database... # Print out some employee info set i 0 puts \\\"There are [ dict size \\$employeeInfo] employees\\\" dict for {id info} \\$employeeInfo { puts \\\"Employee #[incr i]: \\$id\\\" dict with info { puts \\\" Name: \\$forenames \\$surname\\\" puts \\\" Address: \\$street, \\$city\\\" puts \\\" Telephone: \\$phone\\\" } } # Another way to iterate and pick out names... foreach id [ dict keys \\$employeeInfo] { puts \\\"Hello, [ dict get \\$employeeInfo \\$id forenames]!\\\" } A localizable version of string toupper : # Set up the basic C locale set capital [ dict create C [ dict create ]] foreach c [split {abcdefghijklmnopqrstuvwxyz} \\\"\\\"] { dict set capital C \\$c [string toupper \\$c] } # English locales can luckily share the \\\"C\\\" locale dict set capital en [ dict get \\$capital C] dict set capital en_US [ dict get \\$capital C] dict set capital en_GB [ dict get \\$capital C] # ... and so on for other supported languages ... # Now get the mapping for the current locale and use it. set upperCaseMap [ dict get \\$capital \\$env(LANG)] set upperCase [string map \\$upperCaseMap \\$string] Showing the detail of dict with : proc sumDictionary {varName} { upvar 1 \\$varName vbl foreach key [ dict keys \\$vbl] { # Manufacture an entry in the subdictionary dict set vbl \\$key total 0 # Add the values and remove the old dict with vbl \\$key { set total [expr {\\$x + \\$y + \\$z}] unset x y z } } puts \\\"last total was \\$total, for key \\$key\\\" } set myDict { a {x 1 y 2 z 3} b {x 6 y 5 z 4} } sumDictionary myDict # prints: last total was 15, for key b puts \\\"dictionary is now \\\\\"\\$myDict\\\\\"\\\" # prints: dictionary is now \\\"a {total 6} b {total 15}\\\" When dict with is used with a key that clashes with the name of the dictionary variable: set foo {foo {a b} bar 2 baz 3} dict with foo {} puts \\$foo # prints: a b foo {a b} bar 2 baz 3 SEE ALSO append(n), array(n), foreach(n), incr(n), list(n), lappend(n), lmap(n), set(n) KEYWORDS dictionary, create, update, lookup, iterate, filter, map","title":"NAME"},{"location":"dict/#name","text":"dict - Manipulate dictionaries","title":"NAME"},{"location":"dict/#synopsis","text":"dict option arg ? arg ... ?","title":"SYNOPSIS"},{"location":"dict/#description","text":"Performs one of several operations on dictionary values or variables containing dictionary values (see the DICTIONARY VALUES section below for a description), depending on option . The legal option s (which may be abbreviated) are: dict append dictionaryVariable key ? string ... ? : This appends the given string (or strings) to the value that the given key maps to in the dictionary value contained in the given variable, writing the resulting dictionary value back to that variable. Non-existent keys are treated as if they map to an empty string. The updated dictionary value is returned. If dictionaryVariable indicates an element that does not exist of an array that has a default value set, the default value and will be used as the value of the dictionary prior to the appending operation. dict create ? key value ... ? : Return a new dictionary that contains each of the key/value mappings listed as arguments (keys and values alternating, with each key being followed by its associated value.) dict exists dictionaryValue key ? key ... ? : This returns a boolean value indicating whether the given key (or path of keys through a set of nested dictionaries) exists in the given dictionary value. This returns a true value exactly when dict get on that path will succeed. dict filter dictionaryValue filterType arg ? arg ... ? : This takes a dictionary value and returns a new dictionary that contains just those key/value pairs that match the specified filter type (which may be abbreviated.) Supported filter types are: **dict filter ***dictionaryValue ***key** ?*globPattern \\...*? : The key rule only matches those key/value pairs whose keys match any of the given patterns (in the style of **string match**.) **dict filter ***dictionaryValue ***script {***keyVariable valueVariable***} ***script* : The script rule tests for matching by assigning the key to the *keyVariable* and the value to the *valueVariable*, and then evaluating the given script which should result in a boolean value (with the key/value pair only being included in the result of the **dict** filter when a true value is returned.) Note that the first argument after the rule selection word is a two-element list. If the *script* returns with a condition of **TCL_BREAK**, no further key/value pairs are considered for inclusion in the resulting dictionary, and a condition of **TCL_CONTINUE** is equivalent to a false result. The key/value pairs are tested in the order in which the keys were inserted into the dictionary. **dict filter ***dictionaryValue ***value **?*globPattern \\...*? : The value rule only matches those key/value pairs whose values match any of the given patterns (in the style of **string match**.) dict for { keyVariable valueVariable } dictionaryValue body : This command takes three arguments, the first a two-element list of variable names (for the key and value respectively of each mapping in the dictionary), the second the dictionary value to iterate across, and the third a script to be evaluated for each mapping with the key and value variables set appropriately (in the manner of foreach .) The result of the command is an empty string. If any evaluation of the body generates a TCL_BREAK result, no further pairs from the dictionary will be iterated over and the dict for command will terminate successfully immediately. If any evaluation of the body generates a TCL_CONTINUE result, this shall be treated exactly like a normal TCL_OK result. The order of iteration is the order in which the keys were inserted into the dictionary. dict get dictionaryValue ? key ... ? : Given a dictionary value (first argument) and a key (second argument), this will retrieve the value for that key. Where several keys are supplied, the behaviour of the command shall be as if the result of dict get \\$dictVal \\$key was passed as the first argument to dict get with the remaining arguments as second (and possibly subsequent) arguments. This facilitates lookups in nested dictionaries. For example, the following two commands are equivalent: dict get \\$dict foo bar spong dict get \\[dict get \\[dict get \\$dict foo\\] bar\\] spong If no keys are provided, **dict get** will return a list containing pairs of elements in a manner similar to **array get**. That is, the first element of each pair would be the key and the second element would be the value for that key. It is an error to attempt to retrieve a value for a key that is not present in the dictionary. dict getdef dictionaryValue ? key ... ? key default : dict getwithdefault dictionaryValue ? key ... ? key default : This behaves the same as dict get (with at least one key argument), returning the value that the key path maps to in the dictionary dictionaryValue , except that instead of producing an error because the key (or one of the key s on the key path) is absent, it returns the default argument instead. Note that there must always be at least one key provided, and that dict getdef and dict getwithdefault are aliases for each other. dict incr dictionaryVariable key ? increment ? : This adds the given increment value (an integer that defaults to 1 if not specified) to the value that the given key maps to in the dictionary value contained in the given variable, writing the resulting dictionary value back to that variable. Non-existent keys are treated as if they map to 0. It is an error to increment a value for an existing key if that value is not an integer. The updated dictionary value is returned. If dictionaryVariable indicates an element that does not exist of an array that has a default value set, the default value and will be used as the value of the dictionary prior to the incrementing operation. dict info dictionaryValue : This returns information (intended for display to people) about the given dictionary though the format of this data is dependent on the implementation of the dictionary. For dictionaries that are implemented by hash tables, it is expected that this will return the string produced by Tcl_HashStats , similar to array statistics . dict keys dictionaryValue ? globPattern ? : Return a list of all keys in the given dictionary value. If a pattern is supplied, only those keys that match it (according to the rules of string match ) will be returned. The returned keys will be in the order that they were inserted into the dictionary. dict lappend dictionaryVariable key ? value ... ? : This appends the given items to the list value that the given key maps to in the dictionary value contained in the given variable, writing the resulting dictionary value back to that variable. Non-existent keys are treated as if they map to an empty list, and it is legal for there to be no items to append to the list. It is an error for the value that the key maps to to not be representable as a list. The updated dictionary value is returned. If dictionaryVariable indicates an element that does not exist of an array that has a default value set, the default value and will be used as the value of the dictionary prior to the list-appending operation. dict map { keyVariable valueVariable } dictionaryValue body : This command applies a transformation to each element of a dictionary, returning a new dictionary. It takes three arguments: the first is a two-element list of variable names (for the key and value respectively of each mapping in the dictionary), the second the dictionary value to iterate across, and the third a script to be evaluated for each mapping with the key and value variables set appropriately (in the manner of lmap ). In an iteration where the evaluated script completes normally ( TCL_OK , as opposed to an error , etc.) the result of the script is put into an accumulator dictionary using the key that is the current contents of the keyVariable variable at that point. The result of the dict map command is the accumulator dictionary after all keys have been iterated over. If the evaluation of the body for any particular step generates a **break**, no further pairs from the dictionary will be iterated over and the **dict** map command will terminate successfully immediately. If the evaluation of the body for a particular step generates a **continue** result, the current iteration is aborted and the accumulator dictionary is not modified. The order of iteration is the natural order of the dictionary (typically the order in which the keys were added to the dictionary; the order is the same as that used in **dict for**). dict merge ? dictionaryValue ... ? : Return a dictionary that contains the contents of each of the dictionaryValue arguments. Where two (or more) dictionaries contain a mapping for the same key, the resulting dictionary maps that key to the value according to the last dictionary on the command line containing a mapping for that key. dict remove dictionaryValue ? key ... ? : Return a new dictionary that is a copy of an old one passed in as first argument except without mappings for each of the keys listed. It is legal for there to be no keys to remove, and it also legal for any of the keys to be removed to not be present in the input dictionary in the first place. dict replace dictionaryValue ? key value ... ? : Return a new dictionary that is a copy of an old one passed in as first argument except with some values different or some extra key/value pairs added. It is legal for this command to be called with no key/value pairs, but illegal for this command to be called with a key but no value. dict set dictionaryVariable key ? key ... ? value : This operation takes the name of a variable containing a dictionary value and places an updated dictionary value in that variable containing a mapping from the given key to the given value. When multiple keys are present, this operation creates or updates a chain of nested dictionaries. The updated dictionary value is returned. If dictionaryVariable indicates an element that does not exist of an array that has a default value set, the default value and will be used as the value of the dictionary prior to the value insert/update operation. dict size dictionaryValue : Return the number of key/value mappings in the given dictionary value. dict unset dictionaryVariable key ? key ... ? : This operation (the companion to dict set ) takes the name of a variable containing a dictionary value and places an updated dictionary value in that variable that does not contain a mapping for the given key. Where multiple keys are present, this describes a path through nested dictionaries to the mapping to remove. At least one key must be specified, but the last key on the key-path need not exist. All other components on the path must exist. The updated dictionary value is returned. If dictionaryVariable indicates an element that does not exist of an array that has a default value set, the default value and will be used as the value of the dictionary prior to the value remove operation. dict update dictionaryVariable key varName ? key varName ... ? body : Execute the Tcl script in body with the value for each key (as found by reading the dictionary value in dictionaryVariable ) mapped to the variable varName . There may be multiple key / varName pairs. If a key does not have a mapping, that corresponds to an unset varName . When body terminates, any changes made to the varName s is reflected back to the dictionary within dictionaryVariable (unless dictionaryVariable itself becomes unreadable, when all updates are silently discarded), even if the result of body is an error or some other kind of exceptional exit. The result of dict update is (unless some kind of error occurs) the result of the evaluation of body . If dictionaryVariable indicates an element that does not exist of an array that has a default value set, the default value and will be used as the value of the dictionary prior to the update operation. Each varName is mapped in the scope enclosing the dict update ; it is recommended that this command only be used in a local scope ( proc edure, lambda term for apply , or method). Because of this, the variables set by dict update will continue to exist after the command finishes (unless explicitly unset ). Note that the mapping of values to variables does not use traces; changes to the dictionaryVariable \\'s contents only happen when body terminates. dict values dictionaryValue ? globPattern ? : Return a list of all values in the given dictionary value. If a pattern is supplied, only those values that match it (according to the rules of string match ) will be returned. The returned values will be in the order of that the keys associated with those values were inserted into the dictionary. dict with dictionaryVariable ? key ... ? body : Execute the Tcl script in body with the value for each key in dictionaryVariable mapped (in a manner similarly to dict update) to a variable with the same name. Where one or more key s are available, these indicate a chain of nested dictionaries, with the innermost dictionary being the one opened out for the execution of body . As with dict update , making dictionaryVariable unreadable will make the updates to the dictionary be discarded, and this also happens if the contents of dictionaryVariable are adjusted so that the chain of dictionaries no longer exists. The result of dict with is (unless some kind of error occurs) the result of the evaluation of body . If dictionaryVariable indicates an element that does not exist of an array that has a default value set, the default value and will be used as the value of the dictionary prior to the updating operation. The variables are mapped in the scope enclosing the dict with ; it is recommended that this command only be used in a local scope ( proc edure, lambda term for apply , or method). Because of this, the variables set by dict with will continue to exist after the command finishes (unless explicitly unset ). Note that the mapping of values to variables does not use traces; changes to the dictionaryVariable \\'s contents only happen when body terminates. If the dictionaryVariable contains a value that is not a dictionary at the point when the body terminates (which can easily happen if the name is the same as any of the keys in dictionary) then an error occurs at that point. This command is thus not recommended for use when the keys in the dictionary are expected to clash with the dictionaryVariable name itself. Where the contained key does map to a dictionary, the net effect is to combine that inner dictionary into the outer dictionary; see the EXAMPLES below for an illustration of this.","title":"DESCRIPTION"},{"location":"dict/#dictionary-values","text":"Dictionaries are values that contain an efficient, order-preserving mapping from arbitrary keys to arbitrary values. Each key in the dictionary maps to a single value. They have a textual format that is exactly that of any list with an even number of elements, with each mapping in the dictionary being represented as two items in the list. When a command takes a dictionary and produces a new dictionary based on it (either returning it or writing it back into the variable that the starting dictionary was read from) the new dictionary will have the same order of keys, modulo any deleted keys and with new keys added on to the end. When a string is interpreted as a dictionary and it would otherwise have duplicate keys, only the last value for a particular key is used; the others are ignored, meaning that, and are equivalent dictionaries (with different string representations). Operations that derive a new dictionary from an old one (e.g., updates like dict set and dict unset ) preserve the order of keys in the dictionary. The exceptions to this are for any new keys they add, which are appended to the sequence, and any keys that are removed, which are excised from the order.","title":"DICTIONARY VALUES"},{"location":"dict/#examples","text":"Basic dictionary usage: # Make a dictionary to map extensions to descriptions set filetypes [ dict create .txt \\\"Text File\\\" .tcl \\\"Tcl File\\\"] # Add/update the dictionary dict set filetypes .tcl \\\"Tcl Script\\\" dict set filetypes .tm \\\"Tcl Module\\\" dict set filetypes .gif \\\"GIF Image\\\" dict set filetypes .png \\\"PNG Image\\\" # Simple read from the dictionary set ext \\\".tcl\\\" set desc [ dict get \\$filetypes \\$ext] puts \\\"\\$ext is for a \\$desc\\\" # Somewhat more complex, with existence test foreach filename [glob *] { set ext [file extension \\$filename] if {[ dict exists \\$filetypes \\$ext]} { puts \\\"\\$filename is a [ dict get \\$filetypes \\$ext]\\\" } } Constructing and using nested dictionaries: # Data for one employee dict set employeeInfo 12345-A forenames \\\"Joe\\\" dict set employeeInfo 12345-A surname \\\"Schmoe\\\" dict set employeeInfo 12345-A street \\\"147 Short Street\\\" dict set employeeInfo 12345-A city \\\"Springfield\\\" dict set employeeInfo 12345-A phone \\\"555-1234\\\" # Data for another employee dict set employeeInfo 98372-J forenames \\\"Anne\\\" dict set employeeInfo 98372-J surname \\\"Other\\\" dict set employeeInfo 98372-J street \\\"32995 Oakdale Way\\\" dict set employeeInfo 98372-J city \\\"Springfield\\\" dict set employeeInfo 98372-J phone \\\"555-8765\\\" # The above data probably ought to come from a database... # Print out some employee info set i 0 puts \\\"There are [ dict size \\$employeeInfo] employees\\\" dict for {id info} \\$employeeInfo { puts \\\"Employee #[incr i]: \\$id\\\" dict with info { puts \\\" Name: \\$forenames \\$surname\\\" puts \\\" Address: \\$street, \\$city\\\" puts \\\" Telephone: \\$phone\\\" } } # Another way to iterate and pick out names... foreach id [ dict keys \\$employeeInfo] { puts \\\"Hello, [ dict get \\$employeeInfo \\$id forenames]!\\\" } A localizable version of string toupper : # Set up the basic C locale set capital [ dict create C [ dict create ]] foreach c [split {abcdefghijklmnopqrstuvwxyz} \\\"\\\"] { dict set capital C \\$c [string toupper \\$c] } # English locales can luckily share the \\\"C\\\" locale dict set capital en [ dict get \\$capital C] dict set capital en_US [ dict get \\$capital C] dict set capital en_GB [ dict get \\$capital C] # ... and so on for other supported languages ... # Now get the mapping for the current locale and use it. set upperCaseMap [ dict get \\$capital \\$env(LANG)] set upperCase [string map \\$upperCaseMap \\$string] Showing the detail of dict with : proc sumDictionary {varName} { upvar 1 \\$varName vbl foreach key [ dict keys \\$vbl] { # Manufacture an entry in the subdictionary dict set vbl \\$key total 0 # Add the values and remove the old dict with vbl \\$key { set total [expr {\\$x + \\$y + \\$z}] unset x y z } } puts \\\"last total was \\$total, for key \\$key\\\" } set myDict { a {x 1 y 2 z 3} b {x 6 y 5 z 4} } sumDictionary myDict # prints: last total was 15, for key b puts \\\"dictionary is now \\\\\"\\$myDict\\\\\"\\\" # prints: dictionary is now \\\"a {total 6} b {total 15}\\\" When dict with is used with a key that clashes with the name of the dictionary variable: set foo {foo {a b} bar 2 baz 3} dict with foo {} puts \\$foo # prints: a b foo {a b} bar 2 baz 3","title":"EXAMPLES"},{"location":"dict/#see-also","text":"append(n), array(n), foreach(n), incr(n), list(n), lappend(n), lmap(n), set(n)","title":"SEE ALSO"},{"location":"dict/#keywords","text":"dictionary, create, update, lookup, iterate, filter, map","title":"KEYWORDS"},{"location":"eof/","text":"NAME eof - Check for end of file condition on channel SYNOPSIS eof channelId DESCRIPTION Returns 1 if an end of file condition occurred during the most recent input operation on channelId (such as gets ), 0 otherwise. ChannelId must be an identifier for an open channel such as a Tcl standard channel ( stdin , stdout , or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. EXAMPLES Read and print out the contents of a file line-by-line: set f [open somefile.txt] while {1} { set line [gets \\$f] if {[ eof \\$f]} { close \\$f break } puts \\\"Read line: \\$line\\\" } Read and print out the contents of a file by fixed-size records: set f [open somefile.dat] fconfigure \\$f -translation binary set recordSize 40 while {1} { set record [read \\$f \\$recordSize] if {[ eof \\$f]} { close \\$f break } puts \\\"Read record: \\$record\\\" } SEE ALSO file(n), open(n), close(n), fblocked(n), Tcl_StandardChannels(3) KEYWORDS channel, end of file","title":"NAME"},{"location":"eof/#name","text":"eof - Check for end of file condition on channel","title":"NAME"},{"location":"eof/#synopsis","text":"eof channelId","title":"SYNOPSIS"},{"location":"eof/#description","text":"Returns 1 if an end of file condition occurred during the most recent input operation on channelId (such as gets ), 0 otherwise. ChannelId must be an identifier for an open channel such as a Tcl standard channel ( stdin , stdout , or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension.","title":"DESCRIPTION"},{"location":"eof/#examples","text":"Read and print out the contents of a file line-by-line: set f [open somefile.txt] while {1} { set line [gets \\$f] if {[ eof \\$f]} { close \\$f break } puts \\\"Read line: \\$line\\\" } Read and print out the contents of a file by fixed-size records: set f [open somefile.dat] fconfigure \\$f -translation binary set recordSize 40 while {1} { set record [read \\$f \\$recordSize] if {[ eof \\$f]} { close \\$f break } puts \\\"Read record: \\$record\\\" }","title":"EXAMPLES"},{"location":"eof/#see-also","text":"file(n), open(n), close(n), fblocked(n), Tcl_StandardChannels(3)","title":"SEE ALSO"},{"location":"eof/#keywords","text":"channel, end of file","title":"KEYWORDS"},{"location":"error/","text":"NAME error - Generate an error SYNOPSIS error message ? info ? ? code ? DESCRIPTION Returns a TCL_ERROR code, which causes command interpretation to be unwound. Message is a string that is returned to the application to indicate what went wrong. The -errorinfo return option of an interpreter is used to accumulate a stack trace of what was in progress when an error occurred; as nested commands unwind, the Tcl interpreter adds information to the -errorinfo return option. If the info argument is present, it is used to initialize the -errorinfo return options and the first increment of unwind information will not be added by the Tcl interpreter. In other words, the command containing the error command will not appear in the stack trace; in its place will be info . Historically, this feature had been most useful in conjunction with the catch command: if a caught error cannot be handled successfully, info can be used to return a stack trace reflecting the original point of occurrence of the error: catch {...} errMsg set savedInfo \\$::errorInfo ... error \\$errMsg \\$savedInfo When working with Tcl 8.5 or later, the following code should be used instead: catch {...} errMsg options ... return -options \\$options \\$errMsg If the code argument is present, then its value is stored in the -errorcode return option. The -errorcode return option is intended to hold a machine-readable description of the error in cases where such information is available; see the return manual page for information on the proper format for this option\\'s value. EXAMPLE Generate an error if a basic mathematical operation fails: if {1+2 != 3} { error \\\"something is very wrong with addition\\\" } SEE ALSO catch(n), return(n) KEYWORDS error, exception","title":"NAME"},{"location":"error/#name","text":"error - Generate an error","title":"NAME"},{"location":"error/#synopsis","text":"error message ? info ? ? code ?","title":"SYNOPSIS"},{"location":"error/#description","text":"Returns a TCL_ERROR code, which causes command interpretation to be unwound. Message is a string that is returned to the application to indicate what went wrong. The -errorinfo return option of an interpreter is used to accumulate a stack trace of what was in progress when an error occurred; as nested commands unwind, the Tcl interpreter adds information to the -errorinfo return option. If the info argument is present, it is used to initialize the -errorinfo return options and the first increment of unwind information will not be added by the Tcl interpreter. In other words, the command containing the error command will not appear in the stack trace; in its place will be info . Historically, this feature had been most useful in conjunction with the catch command: if a caught error cannot be handled successfully, info can be used to return a stack trace reflecting the original point of occurrence of the error: catch {...} errMsg set savedInfo \\$::errorInfo ... error \\$errMsg \\$savedInfo When working with Tcl 8.5 or later, the following code should be used instead: catch {...} errMsg options ... return -options \\$options \\$errMsg If the code argument is present, then its value is stored in the -errorcode return option. The -errorcode return option is intended to hold a machine-readable description of the error in cases where such information is available; see the return manual page for information on the proper format for this option\\'s value.","title":"DESCRIPTION"},{"location":"error/#example","text":"Generate an error if a basic mathematical operation fails: if {1+2 != 3} { error \\\"something is very wrong with addition\\\" }","title":"EXAMPLE"},{"location":"error/#see-also","text":"catch(n), return(n)","title":"SEE ALSO"},{"location":"error/#keywords","text":"error, exception","title":"KEYWORDS"},{"location":"exec/","text":"NAME exec - Invoke subprocesses SYNOPSIS exec ? switches ? arg ? arg ... ? ? & ? DESCRIPTION This command treats its arguments as the specification of one or more subprocesses to execute. The arguments take the form of a standard shell pipeline where each arg becomes one word of a command, and each distinct command becomes a subprocess. The result of the command is the standard output of the final subprocess in the pipeline, interpreted using the system encoding ; to use any other encoding (especially including binary data), the pipeline must be open ed, configured and read explicitly. If the initial arguments to exec start with - then they are treated as command-line switches and are not part of the pipeline specification. The following switches are currently supported: -ignorestderr : Stops the exec command from treating the output of messages to the pipeline\\'s standard error channel as an error case. -keepnewline : Retains a trailing newline in the pipeline\\'s output. Normally a trailing newline will be deleted. -\u2006- : Marks the end of switches. The argument following this one will be treated as the first arg even if it starts with a - . If an arg (or pair of arg s) has one of the forms described below then it is used by exec to control the flow of input and output among the subprocess(es). Such arguments will not be passed to the subprocess(es). In forms such as fileName may either be in a separate argument from or in the same argument with no intervening space (i.e. | : Separates distinct commands in the pipeline. The standard output of the preceding command will be piped into the standard input of the next command. |& : Separates distinct commands in the pipeline. Both standard output and standard error of the preceding command will be piped into the standard input of the next command. This form of redirection overrides forms such as 2> and >&. \\<\u2007 fileName : The file named by fileName is opened and used as the standard input for the first command in the pipeline. \\<@\u2007 fileId : FileId must be the identifier for an open file, such as the return value from a previous call to open . It is used as the standard input for the first command in the pipeline. FileId must have been opened for reading. \\<\\<\u2007 value : Value is passed to the first command as its standard input. >\u2007 fileName : Standard output from the last command is redirected to the file named fileName , overwriting its previous contents. 2>\u2007 fileName : Standard error from all commands in the pipeline is redirected to the file named fileName , overwriting its previous contents. >&\u2007 fileName : Both standard output from the last command and standard error from all commands are redirected to the file named fileName , overwriting its previous contents. >>\u2007 fileName : Standard output from the last command is redirected to the file named fileName , appending to it rather than overwriting it. 2>>\u2007 fileName : Standard error from all commands in the pipeline is redirected to the file named fileName , appending to it rather than overwriting it. >>&\u2007 fileName : Both standard output from the last command and standard error from all commands are redirected to the file named fileName , appending to it rather than overwriting it. >@\u2007 fileId : FileId must be the identifier for an open file, such as the return value from a previous call to open . Standard output from the last command is redirected to fileId \\'s file, which must have been opened for writing. 2>@\u2007 fileId : FileId must be the identifier for an open file, such as the return value from a previous call to open . Standard error from all commands in the pipeline is redirected to fileId \\'s file. The file must have been opened for writing. 2>@1\u2007 : Standard error from all commands in the pipeline is redirected to the command result. This operator is only valid at the end of the command pipeline. >&@\u2007 fileId : FileId must be the identifier for an open file, such as the return value from a previous call to open . Both standard output from the last command and standard error from all commands are redirected to fileId \\'s file. The file must have been opened for writing. If standard output has not been redirected then the exec command returns the standard output from the last command in the pipeline, unless was specified, in which case standard error is included as well. If any of the commands in the pipeline exit abnormally or are killed or suspended, then exec will return an error and the error message will include the pipeline\\'s output followed by error messages describing the abnormal terminations; the -errorcode return option will contain additional information about the last abnormal termination encountered. If any of the commands writes to its standard error file and that standard error is not redirected and -ignorestderr is not specified, then exec will return an error; the error message will include the pipeline\\'s standard output, followed by messages about abnormal terminations (if any), followed by the standard error output. If the last character of the result or error message is a newline then that character is normally deleted from the result or error message. This is consistent with other Tcl return values, which do not normally end with newlines. However, if -keepnewline is specified then the trailing newline is retained. If standard input is not redirected with or then the standard input for the first command in the pipeline is taken from the application\\'s current standard input. If the last arg is then the pipeline will be executed in background. In this case the exec command will return a list whose elements are the process identifiers for all of the subprocesses in the pipeline. The standard output from the last command in the pipeline will go to the application\\'s standard output if it has not been redirected, and error output from all of the commands in the pipeline will go to the application\\'s standard error file unless redirected. The first word in each command is taken as the command name; if the result contains no slashes then the directories in the PATH environment variable are searched for an executable by the given name. If the name contains a slash then it must refer to an executable reachable from the current directory. No expansion or other shell-like substitutions are performed on the arguments to commands. PORTABILITY ISSUES Windows (all versions) : Reading from or writing to a socket, using the notation, does not work. When reading from a socket, a 16-bit DOS application will hang and a 32-bit application will return immediately with end-of-file. When either type of application writes to a socket, the information is instead sent to the console, if one is present, or is discarded. Note that the current escape resp. quoting of arguments for windows works only with executables using CommandLineToArgv, CRT-library or similar, as well as with the windows batch files (excepting the newline, see below). Although it is the common escape algorithm, but, in fact, the way how the executable parses the command-line (resp. splits it into single arguments) is decisive. Unfortunately, there is currently no way to supply newline character within an argument to the batch files ( .cmd or .bat ) or to the command processor ( cmd.exe /c ), because this causes truncation of command-line (also the argument chain) on the first newline character. But it works properly with an executable (using CommandLineToArgv, etc). The Tk console text widget does not provide real standard IO capabilities. Under Tk, when redirecting from standard input, all applications will see an immediate end-of-file; information redirected to standard output or standard error will be discarded. Either forward or backward slashes are accepted as path separators for arguments to Tcl commands. When executing an application, the path name specified for the application may also contain forward or backward slashes as path separators. Bear in mind, however, that most Windows applications accept arguments with forward slashes only as option delimiters and backslashes only in paths. Any arguments to an application that specify a path name with forward slashes will not automatically be converted to use the backslash character. If an argument contains forward slashes as the path separator, it may or may not be recognized as a path name, depending on the program. Two or more forward or backward slashes in a row in a path refer to a network path. For example, a simple concatenation of the root directory c:/ with a subdirectory /windows/system will yield c://windows/system (two slashes together), which refers to the mount point called system on the machine called windows (and the c:/ is ignored), and is not equivalent to c:/windows/system , which describes a directory on the current computer. The file join command should be used to concatenate path components. Note that there are two general types of Win32 console applications: [1] : CLI --- CommandLine Interface, simple stdio exchange. netstat.exe for example. [2] : TUI --- Textmode User Interface, any application that accesses the console API for doing such things as cursor movement, setting text color, detecting key presses and mouse movement, etc. An example would be telnet.exe from Windows 2000. These types of applications are not common in a windows environment, but do exist. exec will not work well with TUI applications when a console is not present, as is done when launching applications under wish. It is desirable to have console applications hidden and detached. This is a designed-in limitation as exec wants to communicate over pipes. The Expect extension addresses this issue when communicating with a TUI application. When attempting to execute an application, exec first searches for the name as it was specified. Then, in order, .com , .exe , .bat and .cmd are appended to the end of the specified name and it searches for the longer name. If a directory name was not specified as part of the application name, the following directories are automatically searched in order when attempting to locate the application: The directory from which the Tcl executable was loaded. The current directory. The Windows 32-bit system directory. The Windows home directory. The directories listed in the path. In order to execute shell built-in commands like dir and copy , the caller must prepend the desired command with because built-in commands are not implemented using executables. Unix (including Mac OS X) : The exec command is fully functional and works as described. UNIX EXAMPLES Here are some examples of the use of the exec command on Unix. To execute a simple program and get its result: exec uname -a WORKING WITH NON-ZERO RESULTS To execute a program that can return a non-zero result, you should wrap the call to exec in catch and check the contents of the -errorcode return option if you have an error: set status 0 if {[catch { exec grep foo bar.txt} results options]} { set details [dict get \\$options -errorcode] if {[lindex \\$details 0] eq \\\"CHILDSTATUS\\\"} { set status [lindex \\$details 2] } else { # Some other error; regenerate it to let caller handle return -options \\$options -level 0 \\$results } } This is more easily written using the try command, as that makes it simpler to trap specific types of errors. This is done using code like this: try { set results [ exec grep foo bar.txt] set status 0 } trap CHILDSTATUS {results options} { set status [lindex [dict get \\$options -errorcode] 2] } WORKING WITH QUOTED ARGUMENTS When translating a command from a Unix shell invocation, care should be taken over the fact that single quote characters have no special significance to Tcl. Thus: awk \\'{sum += \\$1} END {print sum}\\' numbers.list would be translated into something like: exec awk {{sum += \\$1} END {print sum}} numbers.list WORKING WITH GLOBBING If you are converting invocations involving shell globbing, you should remember that Tcl does not handle globbing or expand things into multiple arguments by default. Instead you should write things like this: exec ls -l {*}[glob *.tcl] WORKING WITH USER-SUPPLIED SHELL SCRIPT FRAGMENTS One useful technique can be to expose to users of a script the ability to specify a fragment of shell script to execute that will have some data passed in on standard input that was produced by the Tcl program. This is a common technique for using the lpr program for printing. By far the simplest way of doing this is to pass the user\\'s script to the user\\'s shell for processing, as this avoids a lot of complexity with parsing other languages. set lprScript [ get from user... ] set postscriptData [ generate somehow... ] exec \\$env(SHELL) -c \\$lprScript \\<\\< \\$postscriptData WINDOWS EXAMPLES Here are some examples of the use of the exec command on Windows. To start an instance of notepad editing a file without waiting for the user to finish editing the file: exec notepad myfile.txt & To print a text file using notepad : exec notepad /p myfile.txt WORKING WITH CONSOLE PROGRAMS If a program calls other programs, such as is common with compilers, then you may need to resort to batch files to hide the console windows that sometimes pop up: exec cmp.bat somefile.c -o somefile With the file cmp.bat looking something like: \\@gcc %* or like another variant using single parameters: \\@gcc %1 %2 %3 %4 %5 %6 %7 %8 %9 WORKING WITH COMMAND BUILT-INS Sometimes you need to be careful, as different programs may have the same name and be in the path. It can then happen that typing a command at the DOS prompt finds a different program than the same command run via exec . This is because of the (documented) differences in behaviour between exec and DOS batch files. When in doubt, use the command auto_execok : it will return the complete path to the program as seen by the exec command. This applies especially when you want to run commands like dir from a Tcl script (if you just want to list filenames, use the glob command.) To do that, use this: exec {*}[auto_execok dir] *.tcl WORKING WITH NATIVE FILENAMES Many programs on Windows require filename arguments to be passed in with backslashes as pathname separators. This is done with the help of the file nativename command. For example, to make a directory (on NTFS) encrypted so that only the current user can access it requires use of the CIPHER command, like this: set secureDir [file join [file home] Desktop/SecureDirectory] file mkdir \\$secureDir exec CIPHER /e /s:[file nativename \\$secureDir] SEE ALSO error(n), file(n), open(n) KEYWORDS execute, pipeline, redirection, subprocess","title":"NAME"},{"location":"exec/#name","text":"exec - Invoke subprocesses","title":"NAME"},{"location":"exec/#synopsis","text":"exec ? switches ? arg ? arg ... ? ? & ?","title":"SYNOPSIS"},{"location":"exec/#description","text":"This command treats its arguments as the specification of one or more subprocesses to execute. The arguments take the form of a standard shell pipeline where each arg becomes one word of a command, and each distinct command becomes a subprocess. The result of the command is the standard output of the final subprocess in the pipeline, interpreted using the system encoding ; to use any other encoding (especially including binary data), the pipeline must be open ed, configured and read explicitly. If the initial arguments to exec start with - then they are treated as command-line switches and are not part of the pipeline specification. The following switches are currently supported: -ignorestderr : Stops the exec command from treating the output of messages to the pipeline\\'s standard error channel as an error case. -keepnewline : Retains a trailing newline in the pipeline\\'s output. Normally a trailing newline will be deleted. -\u2006- : Marks the end of switches. The argument following this one will be treated as the first arg even if it starts with a - . If an arg (or pair of arg s) has one of the forms described below then it is used by exec to control the flow of input and output among the subprocess(es). Such arguments will not be passed to the subprocess(es). In forms such as fileName may either be in a separate argument from or in the same argument with no intervening space (i.e. | : Separates distinct commands in the pipeline. The standard output of the preceding command will be piped into the standard input of the next command. |& : Separates distinct commands in the pipeline. Both standard output and standard error of the preceding command will be piped into the standard input of the next command. This form of redirection overrides forms such as 2> and >&. \\<\u2007 fileName : The file named by fileName is opened and used as the standard input for the first command in the pipeline. \\<@\u2007 fileId : FileId must be the identifier for an open file, such as the return value from a previous call to open . It is used as the standard input for the first command in the pipeline. FileId must have been opened for reading. \\<\\<\u2007 value : Value is passed to the first command as its standard input. >\u2007 fileName : Standard output from the last command is redirected to the file named fileName , overwriting its previous contents. 2>\u2007 fileName : Standard error from all commands in the pipeline is redirected to the file named fileName , overwriting its previous contents. >&\u2007 fileName : Both standard output from the last command and standard error from all commands are redirected to the file named fileName , overwriting its previous contents. >>\u2007 fileName : Standard output from the last command is redirected to the file named fileName , appending to it rather than overwriting it. 2>>\u2007 fileName : Standard error from all commands in the pipeline is redirected to the file named fileName , appending to it rather than overwriting it. >>&\u2007 fileName : Both standard output from the last command and standard error from all commands are redirected to the file named fileName , appending to it rather than overwriting it. >@\u2007 fileId : FileId must be the identifier for an open file, such as the return value from a previous call to open . Standard output from the last command is redirected to fileId \\'s file, which must have been opened for writing. 2>@\u2007 fileId : FileId must be the identifier for an open file, such as the return value from a previous call to open . Standard error from all commands in the pipeline is redirected to fileId \\'s file. The file must have been opened for writing. 2>@1\u2007 : Standard error from all commands in the pipeline is redirected to the command result. This operator is only valid at the end of the command pipeline. >&@\u2007 fileId : FileId must be the identifier for an open file, such as the return value from a previous call to open . Both standard output from the last command and standard error from all commands are redirected to fileId \\'s file. The file must have been opened for writing. If standard output has not been redirected then the exec command returns the standard output from the last command in the pipeline, unless was specified, in which case standard error is included as well. If any of the commands in the pipeline exit abnormally or are killed or suspended, then exec will return an error and the error message will include the pipeline\\'s output followed by error messages describing the abnormal terminations; the -errorcode return option will contain additional information about the last abnormal termination encountered. If any of the commands writes to its standard error file and that standard error is not redirected and -ignorestderr is not specified, then exec will return an error; the error message will include the pipeline\\'s standard output, followed by messages about abnormal terminations (if any), followed by the standard error output. If the last character of the result or error message is a newline then that character is normally deleted from the result or error message. This is consistent with other Tcl return values, which do not normally end with newlines. However, if -keepnewline is specified then the trailing newline is retained. If standard input is not redirected with or then the standard input for the first command in the pipeline is taken from the application\\'s current standard input. If the last arg is then the pipeline will be executed in background. In this case the exec command will return a list whose elements are the process identifiers for all of the subprocesses in the pipeline. The standard output from the last command in the pipeline will go to the application\\'s standard output if it has not been redirected, and error output from all of the commands in the pipeline will go to the application\\'s standard error file unless redirected. The first word in each command is taken as the command name; if the result contains no slashes then the directories in the PATH environment variable are searched for an executable by the given name. If the name contains a slash then it must refer to an executable reachable from the current directory. No expansion or other shell-like substitutions are performed on the arguments to commands.","title":"DESCRIPTION"},{"location":"exec/#portability-issues","text":"Windows (all versions) : Reading from or writing to a socket, using the notation, does not work. When reading from a socket, a 16-bit DOS application will hang and a 32-bit application will return immediately with end-of-file. When either type of application writes to a socket, the information is instead sent to the console, if one is present, or is discarded. Note that the current escape resp. quoting of arguments for windows works only with executables using CommandLineToArgv, CRT-library or similar, as well as with the windows batch files (excepting the newline, see below). Although it is the common escape algorithm, but, in fact, the way how the executable parses the command-line (resp. splits it into single arguments) is decisive. Unfortunately, there is currently no way to supply newline character within an argument to the batch files ( .cmd or .bat ) or to the command processor ( cmd.exe /c ), because this causes truncation of command-line (also the argument chain) on the first newline character. But it works properly with an executable (using CommandLineToArgv, etc). The Tk console text widget does not provide real standard IO capabilities. Under Tk, when redirecting from standard input, all applications will see an immediate end-of-file; information redirected to standard output or standard error will be discarded. Either forward or backward slashes are accepted as path separators for arguments to Tcl commands. When executing an application, the path name specified for the application may also contain forward or backward slashes as path separators. Bear in mind, however, that most Windows applications accept arguments with forward slashes only as option delimiters and backslashes only in paths. Any arguments to an application that specify a path name with forward slashes will not automatically be converted to use the backslash character. If an argument contains forward slashes as the path separator, it may or may not be recognized as a path name, depending on the program. Two or more forward or backward slashes in a row in a path refer to a network path. For example, a simple concatenation of the root directory c:/ with a subdirectory /windows/system will yield c://windows/system (two slashes together), which refers to the mount point called system on the machine called windows (and the c:/ is ignored), and is not equivalent to c:/windows/system , which describes a directory on the current computer. The file join command should be used to concatenate path components. Note that there are two general types of Win32 console applications: [1] : CLI --- CommandLine Interface, simple stdio exchange. netstat.exe for example. [2] : TUI --- Textmode User Interface, any application that accesses the console API for doing such things as cursor movement, setting text color, detecting key presses and mouse movement, etc. An example would be telnet.exe from Windows 2000. These types of applications are not common in a windows environment, but do exist. exec will not work well with TUI applications when a console is not present, as is done when launching applications under wish. It is desirable to have console applications hidden and detached. This is a designed-in limitation as exec wants to communicate over pipes. The Expect extension addresses this issue when communicating with a TUI application. When attempting to execute an application, exec first searches for the name as it was specified. Then, in order, .com , .exe , .bat and .cmd are appended to the end of the specified name and it searches for the longer name. If a directory name was not specified as part of the application name, the following directories are automatically searched in order when attempting to locate the application: The directory from which the Tcl executable was loaded. The current directory. The Windows 32-bit system directory. The Windows home directory. The directories listed in the path. In order to execute shell built-in commands like dir and copy , the caller must prepend the desired command with because built-in commands are not implemented using executables. Unix (including Mac OS X) : The exec command is fully functional and works as described.","title":"PORTABILITY ISSUES"},{"location":"exec/#unix-examples","text":"Here are some examples of the use of the exec command on Unix. To execute a simple program and get its result: exec uname -a","title":"UNIX EXAMPLES"},{"location":"exec/#working-with-non-zero-results","text":"To execute a program that can return a non-zero result, you should wrap the call to exec in catch and check the contents of the -errorcode return option if you have an error: set status 0 if {[catch { exec grep foo bar.txt} results options]} { set details [dict get \\$options -errorcode] if {[lindex \\$details 0] eq \\\"CHILDSTATUS\\\"} { set status [lindex \\$details 2] } else { # Some other error; regenerate it to let caller handle return -options \\$options -level 0 \\$results } } This is more easily written using the try command, as that makes it simpler to trap specific types of errors. This is done using code like this: try { set results [ exec grep foo bar.txt] set status 0 } trap CHILDSTATUS {results options} { set status [lindex [dict get \\$options -errorcode] 2] }","title":"WORKING WITH NON-ZERO RESULTS"},{"location":"exec/#working-with-quoted-arguments","text":"When translating a command from a Unix shell invocation, care should be taken over the fact that single quote characters have no special significance to Tcl. Thus: awk \\'{sum += \\$1} END {print sum}\\' numbers.list would be translated into something like: exec awk {{sum += \\$1} END {print sum}} numbers.list","title":"WORKING WITH QUOTED ARGUMENTS"},{"location":"exec/#working-with-globbing","text":"If you are converting invocations involving shell globbing, you should remember that Tcl does not handle globbing or expand things into multiple arguments by default. Instead you should write things like this: exec ls -l {*}[glob *.tcl]","title":"WORKING WITH GLOBBING"},{"location":"exec/#working-with-user-supplied-shell-script-fragments","text":"One useful technique can be to expose to users of a script the ability to specify a fragment of shell script to execute that will have some data passed in on standard input that was produced by the Tcl program. This is a common technique for using the lpr program for printing. By far the simplest way of doing this is to pass the user\\'s script to the user\\'s shell for processing, as this avoids a lot of complexity with parsing other languages. set lprScript [ get from user... ] set postscriptData [ generate somehow... ] exec \\$env(SHELL) -c \\$lprScript \\<\\< \\$postscriptData","title":"WORKING WITH USER-SUPPLIED SHELL SCRIPT FRAGMENTS"},{"location":"exec/#windows-examples","text":"Here are some examples of the use of the exec command on Windows. To start an instance of notepad editing a file without waiting for the user to finish editing the file: exec notepad myfile.txt & To print a text file using notepad : exec notepad /p myfile.txt","title":"WINDOWS EXAMPLES"},{"location":"exec/#working-with-console-programs","text":"If a program calls other programs, such as is common with compilers, then you may need to resort to batch files to hide the console windows that sometimes pop up: exec cmp.bat somefile.c -o somefile With the file cmp.bat looking something like: \\@gcc %* or like another variant using single parameters: \\@gcc %1 %2 %3 %4 %5 %6 %7 %8 %9","title":"WORKING WITH CONSOLE PROGRAMS"},{"location":"exec/#working-with-command-built-ins","text":"Sometimes you need to be careful, as different programs may have the same name and be in the path. It can then happen that typing a command at the DOS prompt finds a different program than the same command run via exec . This is because of the (documented) differences in behaviour between exec and DOS batch files. When in doubt, use the command auto_execok : it will return the complete path to the program as seen by the exec command. This applies especially when you want to run commands like dir from a Tcl script (if you just want to list filenames, use the glob command.) To do that, use this: exec {*}[auto_execok dir] *.tcl","title":"WORKING WITH COMMAND BUILT-INS"},{"location":"exec/#working-with-native-filenames","text":"Many programs on Windows require filename arguments to be passed in with backslashes as pathname separators. This is done with the help of the file nativename command. For example, to make a directory (on NTFS) encrypted so that only the current user can access it requires use of the CIPHER command, like this: set secureDir [file join [file home] Desktop/SecureDirectory] file mkdir \\$secureDir exec CIPHER /e /s:[file nativename \\$secureDir]","title":"WORKING WITH NATIVE FILENAMES"},{"location":"exec/#see-also","text":"error(n), file(n), open(n)","title":"SEE ALSO"},{"location":"exec/#keywords","text":"execute, pipeline, redirection, subprocess","title":"KEYWORDS"},{"location":"expr/","text":"NAME expr - Evaluate an expression SYNOPSIS expr arg ? arg arg ... ? DESCRIPTION Concatenates arg s, separated by a space, into an expression, and evaluates that expression, returning its value. The operators permitted in an expression include a subset of the operators permitted in C expressions. For those operators common to both Tcl and C, Tcl applies the same meaning and precedence as the corresponding C operators. The value of an expression is often a numeric result, either an integer or a floating-point value, but may also be a non-numeric value. For example, the expression expr 8.2 + 6 evaluates to 14.2. Expressions differ from C expressions in the way that operands are specified. Expressions also support non-numeric operands, string comparisons, and some additional operators not found in C. When the result of expression is an integer, it is in decimal form, and when the result is a floating-point number, it is in the form produced by the %g format specifier of format . At any point in the expression except within double quotes or braces, # is the beginning of a comment, which lasts to the end of the line or the end of the expression, whichever comes first. OPERANDS An expression consists of a combination of operands, operators, parentheses and commas, possibly with whitespace between any of these elements, which is ignored. Each operand is interpreted as a numeric value if at all possible. Each operand has one of the following forms: A numeric value : Either integer or floating-point. The first two characters of an integer may also be 0d for decimal, 0b for binary, 0o for octal or 0x for hexadicimal. A floating-point number may be take any of several common decimal formats, and may use the decimal point . , e or E for scientific notation, and the sign characters + and - . The following are all valid floating-point numbers: 2.1, 3., 6e4, 7.91e+16. The strings Inf and NaN , in any combination of case, are also recognized as floating point values. An operand that doesn\\'t have a numeric interpretation must be quoted with either braces or with double quotes. Digits in any numeric value may be separated with one or more underscore characters, \\\" _ \\\". A separator may only appear between digits, not appear at the start of a numeric value, between the leading 0 and radix specifier, or at the end of a numeric value. Here are some examples: expr 100_000_000 100000000 expr 0xffff_ffff 4294967295 format 0x%x 0b1111_1110_1101_1011 0xfedb A boolean value : Using any form understood by string is boolean . A variable : Using standard \\$ notation. The value of the variable is the value of the operand. A string enclosed in double-quotes : Backslash, variable, and command substitution are performed according to the rules for Tcl . A string enclosed in braces . : The operand is treated as a braced value according to the rule for braces in Tcl . A Tcl command enclosed in brackets : Command substitution is performed as according to the command substitution rule for Tcl . A mathematical function such as sin(\\$x) , whose arguments have any of the above : forms for operands. See MATH FUNCTIONS below for a discussion of how mathematical functions are handled. Because expr parses and performs substitutions on values that have already been parsed and substituted by Tcl , it is usually best to enclose expressions in braces to avoid the first round of substitutions by Tcl . Below are some examples of simple expressions where the value of a is 3 and the value of b is 6. The command on the left side of each line produces the value on the right side. expr {3.1 + \\$a} 6.1 expr {2 + \\\"\\$a.\\$b\\\"} 5.6 expr {4*[llength {6 2}]} 8 expr {{word one} \\< \\\"word \\$a\\\"} 0 OPERATORS For operators having both a numeric mode and a string mode, the numeric mode is chosen when all operands have a numeric interpretation. The integer interpretation of an operand is preferred over the floating-point interpretation. To ensure string operations on arbitrary values it is generally a good idea to use eq , ne , or the string command instead of more versatile operators such as == . Unless otherwise specified, operators accept non-numeric operands. The value of a boolean operation is 1 if true, 0 otherwise. See also string is boolean . The valid operators, most of which are also available as commands in the tcl::mathop namespace (see mathop (n)), are listed below, grouped in decreasing order of precedence: -\u2007\u2007+\u2007\u2007\\~\u2007\u2007! : Unary minus, unary plus, bit-wise NOT, logical NOT. These operators may only be applied to numeric operands, and bit-wise NOT may only be applied to integers. ** : Exponentiation. Valid for numeric operands. The maximum exponent value that Tcl can handle if the first number is an integer > 1 is 268435455. *\u2007\u2007/\u2007\u2007% : Multiply and divide, which are valid for numeric operands, and remainder, which is valid for integers. The remainder, an absolute value smaller than the absolute value of the divisor, has the same sign as the divisor. When applied to integers, division and remainder can be considered to partition the number line into a sequence of adjacent non-overlapping pieces, where each piece is the size of the divisor; the quotient identifies which piece the dividend lies within, and the remainder identifies where within that piece the dividend lies. A consequence of this is that the result of is always -6, and the result of is always 3. +\u2007\u2007- : Add and subtract. Valid for numeric operands. \\<\\<\u2007\u2007>> : Left and right shift. Valid for integers. A right shift always propagates the sign bit. \\<\u2007\u2007>\u2007\u2007\\<=\u2007\u2007>= : Boolean numeric-preferring comparisons: less than, greater than, less than or equal, and greater than or equal. If either argument is not numeric, the comparison is done using UNICODE string comparison, as with the string comparison operators below, which have the same precedence. lt\u2007\u2007gt\u2007\u2007le\u2007\u2007ge : Boolean string comparisons: less than, greater than, less than or equal, and greater than or equal. These always compare values using their UNICODE strings (also see string compare ), unlike with the numeric-preferring comparisons abov, which have the same precedence. ==\u2007\u2007!= : Boolean equal and not equal. eq\u2007\u2007ne : Boolean string equal and string not equal. in\u2007\u2007ni : List containment and negated list containment. The first argument is interpreted as a string, the second as a list. in tests for membership in the list, and ni is the inverse. & : Bit-wise AND. Valid for integer operands. \\^ : Bit-wise exclusive OR. Valid for integer operands. | : Bit-wise OR. Valid for integer operands. && : Logical AND. If both operands are true, the result is 1, or 0 otherwise. This operator evaluates lazily; it only evaluates its second operand if it must in order to determine its result. This operator evaluates lazily; it only evaluates its second operand if it must in order to determine its result. || : Logical OR. If both operands are false, the result is 0, or 1 otherwise. This operator evaluates lazily; it only evaluates its second operand if it must in order to determine its result. x ? y : z : If-then-else, as in C. If x is false , the result is the value of y . Otherwise the result is the value of z . This operator evaluates lazily; it evaluates only one of y or z . The exponentiation operator promotes types in the same way that the multiply and divide operators do, and the result is is the same as the result of pow . Exponentiation groups right-to-left within a precedence level. Other binary operators group left-to-right. For example, the value of expr {4*2 \\< 7} is 0, while the value of expr {2**3**2} is 512. As in C, && , || , and ?: feature which means that operands are not evaluated if they are not needed to determine the outcome. For example, in expr {\\$v?[a]:[b]} only one of [a] or [b] is evaluated, depending on the value of \\$v . This is not true of the normal Tcl parser, so it is normally recommended to enclose the arguments to expr in braces. Without braces, as in expr \\$v ? [a] : [b] both [a] and [b] are evaluated before expr is even called. For more details on the results produced by each operator, see the documentation for C. MATH FUNCTIONS A mathematical function such as sin(\\$x) is replaced with a call to an ordinary Tcl command in the tcl::mathfunc namespace. The evaluation of an expression such as expr {sin(\\$x+\\$y)} is the same in every way as the evaluation of expr {[tcl::mathfunc::sin [ expr {\\$x+\\$y}]]} which in turn is the same as the evaluation of tcl::mathfunc::sin [ expr {\\$x+\\$y}] tcl::mathfunc::sin is resolved as described in NAMESPACE RESOLUTION in the namespace (n) documentation. Given the default value of namespace path , [namespace current]::tcl::mathfunc::sin or ::tcl::mathfunc::sin are the typical resolutions. As in C, a mathematical function may accept multiple arguments separated by commas. Thus, expr {hypot(\\$x,\\$y)} becomes tcl::mathfunc::hypot \\$x \\$y See the mathfunc (n) documentation for the math functions that are available by default. TYPES, OVERFLOW, AND PRECISION When needed to guarantee exact performance, internal computations involving integers use the LibTomMath multiple precision integer library. In Tcl releases prior to 8.5, integer calculations were performed using one of the C types long int or Tcl_WideInt , causing implicit range truncation in those calculations where values overflowed the range of those types. Any code that relied on these implicit truncations should instead call int() or wide() , which do truncate. Internal floating-point computations are performed using the double C type. When converting a string to floating-point value, exponent overflow is detected and results in the double value of Inf or -Inf as appropriate. Floating-point overflow and underflow are detected to the degree supported by the hardware, which is generally fairly reliable. Conversion among internal representations for integer, floating-point, and string operands is done automatically as needed. For arithmetic computations, integers are used until some floating-point number is introduced, after which floating-point values are used. For example, expr {5 / 4} returns 1, while expr {5 / 4.0} expr {5 / ( [string length \\\"abcd\\\"] + 0.0 )} both return 1.25. A floating-point result can be distinguished from an integer result by the presence of either or expr {20.0/5.0} returns 4.0 , not 4 . PERFORMANCE CONSIDERATIONS Where an expression contains syntax that Tcl would otherwise perform substitutions on, enclosing an expression in braces or otherwise quoting it so that it\\'s a static value allows the Tcl compiler to generate bytecode for the expression, resulting in better speed and smaller storage requirements. This also avoids issues that can arise if Tcl is allowed to perform substitution on the value before expr is called. In the following example, the value of the expression is 11 because the Tcl parser first substitutes \\$b and expr then substitutes \\$a as part of evaluating the expression Enclosing the expression in braces would result in a syntax error as \\$b does not evaluate to a numeric value. set a 3 set b {\\$a + 2} expr \\$b*4 When an expression is generated at runtime, like the one above is, the bytecode compiler must ensure that new code is generated each time the expression is evaluated. This is the most costly kind of expression from a performance perspective. In such cases, consider directly using the commands described in the mathfunc (n) or mathop (n) documentation instead of expr . Most expressions are not formed at runtime, but are literal strings or contain substitutions that don\\'t introduce other substitutions. To allow the bytecode compiler to work with an expression as a string literal at compilation time, ensure that it contains no substitutions or that it is enclosed in braces or otherwise quoted to prevent Tcl from performing substitutions, allowing expr to perform them instead. If it is necessary to include a non-constant expression string within the wider context of an otherwise-constant expression, the most efficient technique is to put the varying part inside a recursive expr , as this at least allows for the compilation of the outer part, though it does mean that the varying part must itself be evaluated as a separate expression. Thus, in this example the result is 20 and the outer expression benefits from fully cached bytecode compilation. set a 3 set b {\\$a + 2} expr {[ expr \\$b] * 4} In general, you should enclose your expression in braces wherever possible, and where not possible, the argument to expr should be an expression defined elsewhere as simply as possible. It is usually more efficient and safer to use other techniques (e.g., the commands in the tcl::mathop namespace) than it is to do complex expression generation. EXAMPLES A numeric comparison whose result is 1: expr {\\\"0x03\\\" > \\\"2\\\"} A string comparison whose result is 1: expr {\\\"0y\\\" > \\\"0x12\\\"} A forced string comparison whose result is 0: expr {\\\"0x03\\\" gt \\\"2\\\"} Define a procedure that computes an mathematical function: proc tcl::mathfunc::calc {x y} { expr { (\\$x**2 - \\$y**2) / exp(\\$x**2 + \\$y**2) } } Convert polar coordinates into cartesian coordinates: # convert from (\\$radius,\\$angle) set x [ expr { \\$radius * cos(\\$angle) }] set y [ expr { \\$radius * sin(\\$angle) }] Convert cartesian coordinates into polar coordinates: # convert from (\\$x,\\$y) set radius [ expr { hypot(\\$y, \\$x) }] set angle [ expr { atan2(\\$y, \\$x) }] Print a message describing the relationship of two string values to each other: puts \\\"a and b are [ expr {\\$a eq \\$b ? {equal} : {different}}]\\\" Set a variable indicating whether an environment variable is defined and has value of true: set isTrue [ expr { # Does the environment variable exist, and... [info exists ::env(SOME_ENV_VAR)] && # ...does it contain a proper true value? [string is true -strict \\$::env(SOME_ENV_VAR)] }] Generate a random integer in the range 0..99 inclusive: set randNum [ expr { int(100 * rand()) }] SEE ALSO array(n), for(n), if(n), mathfunc(n), mathop(n), namespace(n), proc(n), string(n), Tcl(n), while(n) KEYWORDS arithmetic, boolean, compare, expression, fuzzy comparison, integer value COPYRIGHT Copyright \u00a9 1993 The Regents of the University of California. Copyright \u00a9 1994-2000 Sun Microsystems Incorporated. Copyright \u00a9 2005 Kevin B. Kenny <kennykb@acm.org>. All rights reserved.","title":"NAME"},{"location":"expr/#name","text":"expr - Evaluate an expression","title":"NAME"},{"location":"expr/#synopsis","text":"expr arg ? arg arg ... ?","title":"SYNOPSIS"},{"location":"expr/#description","text":"Concatenates arg s, separated by a space, into an expression, and evaluates that expression, returning its value. The operators permitted in an expression include a subset of the operators permitted in C expressions. For those operators common to both Tcl and C, Tcl applies the same meaning and precedence as the corresponding C operators. The value of an expression is often a numeric result, either an integer or a floating-point value, but may also be a non-numeric value. For example, the expression expr 8.2 + 6 evaluates to 14.2. Expressions differ from C expressions in the way that operands are specified. Expressions also support non-numeric operands, string comparisons, and some additional operators not found in C. When the result of expression is an integer, it is in decimal form, and when the result is a floating-point number, it is in the form produced by the %g format specifier of format . At any point in the expression except within double quotes or braces, # is the beginning of a comment, which lasts to the end of the line or the end of the expression, whichever comes first.","title":"DESCRIPTION"},{"location":"expr/#operands","text":"An expression consists of a combination of operands, operators, parentheses and commas, possibly with whitespace between any of these elements, which is ignored. Each operand is interpreted as a numeric value if at all possible. Each operand has one of the following forms: A numeric value : Either integer or floating-point. The first two characters of an integer may also be 0d for decimal, 0b for binary, 0o for octal or 0x for hexadicimal. A floating-point number may be take any of several common decimal formats, and may use the decimal point . , e or E for scientific notation, and the sign characters + and - . The following are all valid floating-point numbers: 2.1, 3., 6e4, 7.91e+16. The strings Inf and NaN , in any combination of case, are also recognized as floating point values. An operand that doesn\\'t have a numeric interpretation must be quoted with either braces or with double quotes. Digits in any numeric value may be separated with one or more underscore characters, \\\" _ \\\". A separator may only appear between digits, not appear at the start of a numeric value, between the leading 0 and radix specifier, or at the end of a numeric value. Here are some examples: expr 100_000_000 100000000 expr 0xffff_ffff 4294967295 format 0x%x 0b1111_1110_1101_1011 0xfedb A boolean value : Using any form understood by string is boolean . A variable : Using standard \\$ notation. The value of the variable is the value of the operand. A string enclosed in double-quotes : Backslash, variable, and command substitution are performed according to the rules for Tcl . A string enclosed in braces . : The operand is treated as a braced value according to the rule for braces in Tcl . A Tcl command enclosed in brackets : Command substitution is performed as according to the command substitution rule for Tcl . A mathematical function such as sin(\\$x) , whose arguments have any of the above : forms for operands. See MATH FUNCTIONS below for a discussion of how mathematical functions are handled. Because expr parses and performs substitutions on values that have already been parsed and substituted by Tcl , it is usually best to enclose expressions in braces to avoid the first round of substitutions by Tcl . Below are some examples of simple expressions where the value of a is 3 and the value of b is 6. The command on the left side of each line produces the value on the right side. expr {3.1 + \\$a} 6.1 expr {2 + \\\"\\$a.\\$b\\\"} 5.6 expr {4*[llength {6 2}]} 8 expr {{word one} \\< \\\"word \\$a\\\"} 0","title":"OPERANDS"},{"location":"expr/#operators","text":"For operators having both a numeric mode and a string mode, the numeric mode is chosen when all operands have a numeric interpretation. The integer interpretation of an operand is preferred over the floating-point interpretation. To ensure string operations on arbitrary values it is generally a good idea to use eq , ne , or the string command instead of more versatile operators such as == . Unless otherwise specified, operators accept non-numeric operands. The value of a boolean operation is 1 if true, 0 otherwise. See also string is boolean . The valid operators, most of which are also available as commands in the tcl::mathop namespace (see mathop (n)), are listed below, grouped in decreasing order of precedence: -\u2007\u2007+\u2007\u2007\\~\u2007\u2007! : Unary minus, unary plus, bit-wise NOT, logical NOT. These operators may only be applied to numeric operands, and bit-wise NOT may only be applied to integers. ** : Exponentiation. Valid for numeric operands. The maximum exponent value that Tcl can handle if the first number is an integer > 1 is 268435455. *\u2007\u2007/\u2007\u2007% : Multiply and divide, which are valid for numeric operands, and remainder, which is valid for integers. The remainder, an absolute value smaller than the absolute value of the divisor, has the same sign as the divisor. When applied to integers, division and remainder can be considered to partition the number line into a sequence of adjacent non-overlapping pieces, where each piece is the size of the divisor; the quotient identifies which piece the dividend lies within, and the remainder identifies where within that piece the dividend lies. A consequence of this is that the result of is always -6, and the result of is always 3. +\u2007\u2007- : Add and subtract. Valid for numeric operands. \\<\\<\u2007\u2007>> : Left and right shift. Valid for integers. A right shift always propagates the sign bit. \\<\u2007\u2007>\u2007\u2007\\<=\u2007\u2007>= : Boolean numeric-preferring comparisons: less than, greater than, less than or equal, and greater than or equal. If either argument is not numeric, the comparison is done using UNICODE string comparison, as with the string comparison operators below, which have the same precedence. lt\u2007\u2007gt\u2007\u2007le\u2007\u2007ge : Boolean string comparisons: less than, greater than, less than or equal, and greater than or equal. These always compare values using their UNICODE strings (also see string compare ), unlike with the numeric-preferring comparisons abov, which have the same precedence. ==\u2007\u2007!= : Boolean equal and not equal. eq\u2007\u2007ne : Boolean string equal and string not equal. in\u2007\u2007ni : List containment and negated list containment. The first argument is interpreted as a string, the second as a list. in tests for membership in the list, and ni is the inverse. & : Bit-wise AND. Valid for integer operands. \\^ : Bit-wise exclusive OR. Valid for integer operands. | : Bit-wise OR. Valid for integer operands. && : Logical AND. If both operands are true, the result is 1, or 0 otherwise. This operator evaluates lazily; it only evaluates its second operand if it must in order to determine its result. This operator evaluates lazily; it only evaluates its second operand if it must in order to determine its result. || : Logical OR. If both operands are false, the result is 0, or 1 otherwise. This operator evaluates lazily; it only evaluates its second operand if it must in order to determine its result. x ? y : z : If-then-else, as in C. If x is false , the result is the value of y . Otherwise the result is the value of z . This operator evaluates lazily; it evaluates only one of y or z . The exponentiation operator promotes types in the same way that the multiply and divide operators do, and the result is is the same as the result of pow . Exponentiation groups right-to-left within a precedence level. Other binary operators group left-to-right. For example, the value of expr {4*2 \\< 7} is 0, while the value of expr {2**3**2} is 512. As in C, && , || , and ?: feature which means that operands are not evaluated if they are not needed to determine the outcome. For example, in expr {\\$v?[a]:[b]} only one of [a] or [b] is evaluated, depending on the value of \\$v . This is not true of the normal Tcl parser, so it is normally recommended to enclose the arguments to expr in braces. Without braces, as in expr \\$v ? [a] : [b] both [a] and [b] are evaluated before expr is even called. For more details on the results produced by each operator, see the documentation for C.","title":"OPERATORS"},{"location":"expr/#math-functions","text":"A mathematical function such as sin(\\$x) is replaced with a call to an ordinary Tcl command in the tcl::mathfunc namespace. The evaluation of an expression such as expr {sin(\\$x+\\$y)} is the same in every way as the evaluation of expr {[tcl::mathfunc::sin [ expr {\\$x+\\$y}]]} which in turn is the same as the evaluation of tcl::mathfunc::sin [ expr {\\$x+\\$y}] tcl::mathfunc::sin is resolved as described in NAMESPACE RESOLUTION in the namespace (n) documentation. Given the default value of namespace path , [namespace current]::tcl::mathfunc::sin or ::tcl::mathfunc::sin are the typical resolutions. As in C, a mathematical function may accept multiple arguments separated by commas. Thus, expr {hypot(\\$x,\\$y)} becomes tcl::mathfunc::hypot \\$x \\$y See the mathfunc (n) documentation for the math functions that are available by default.","title":"MATH FUNCTIONS"},{"location":"expr/#types-overflow-and-precision","text":"When needed to guarantee exact performance, internal computations involving integers use the LibTomMath multiple precision integer library. In Tcl releases prior to 8.5, integer calculations were performed using one of the C types long int or Tcl_WideInt , causing implicit range truncation in those calculations where values overflowed the range of those types. Any code that relied on these implicit truncations should instead call int() or wide() , which do truncate. Internal floating-point computations are performed using the double C type. When converting a string to floating-point value, exponent overflow is detected and results in the double value of Inf or -Inf as appropriate. Floating-point overflow and underflow are detected to the degree supported by the hardware, which is generally fairly reliable. Conversion among internal representations for integer, floating-point, and string operands is done automatically as needed. For arithmetic computations, integers are used until some floating-point number is introduced, after which floating-point values are used. For example, expr {5 / 4} returns 1, while expr {5 / 4.0} expr {5 / ( [string length \\\"abcd\\\"] + 0.0 )} both return 1.25. A floating-point result can be distinguished from an integer result by the presence of either or expr {20.0/5.0} returns 4.0 , not 4 .","title":"TYPES, OVERFLOW, AND PRECISION"},{"location":"expr/#performance-considerations","text":"Where an expression contains syntax that Tcl would otherwise perform substitutions on, enclosing an expression in braces or otherwise quoting it so that it\\'s a static value allows the Tcl compiler to generate bytecode for the expression, resulting in better speed and smaller storage requirements. This also avoids issues that can arise if Tcl is allowed to perform substitution on the value before expr is called. In the following example, the value of the expression is 11 because the Tcl parser first substitutes \\$b and expr then substitutes \\$a as part of evaluating the expression Enclosing the expression in braces would result in a syntax error as \\$b does not evaluate to a numeric value. set a 3 set b {\\$a + 2} expr \\$b*4 When an expression is generated at runtime, like the one above is, the bytecode compiler must ensure that new code is generated each time the expression is evaluated. This is the most costly kind of expression from a performance perspective. In such cases, consider directly using the commands described in the mathfunc (n) or mathop (n) documentation instead of expr . Most expressions are not formed at runtime, but are literal strings or contain substitutions that don\\'t introduce other substitutions. To allow the bytecode compiler to work with an expression as a string literal at compilation time, ensure that it contains no substitutions or that it is enclosed in braces or otherwise quoted to prevent Tcl from performing substitutions, allowing expr to perform them instead. If it is necessary to include a non-constant expression string within the wider context of an otherwise-constant expression, the most efficient technique is to put the varying part inside a recursive expr , as this at least allows for the compilation of the outer part, though it does mean that the varying part must itself be evaluated as a separate expression. Thus, in this example the result is 20 and the outer expression benefits from fully cached bytecode compilation. set a 3 set b {\\$a + 2} expr {[ expr \\$b] * 4} In general, you should enclose your expression in braces wherever possible, and where not possible, the argument to expr should be an expression defined elsewhere as simply as possible. It is usually more efficient and safer to use other techniques (e.g., the commands in the tcl::mathop namespace) than it is to do complex expression generation.","title":"PERFORMANCE CONSIDERATIONS"},{"location":"expr/#examples","text":"A numeric comparison whose result is 1: expr {\\\"0x03\\\" > \\\"2\\\"} A string comparison whose result is 1: expr {\\\"0y\\\" > \\\"0x12\\\"} A forced string comparison whose result is 0: expr {\\\"0x03\\\" gt \\\"2\\\"} Define a procedure that computes an mathematical function: proc tcl::mathfunc::calc {x y} { expr { (\\$x**2 - \\$y**2) / exp(\\$x**2 + \\$y**2) } } Convert polar coordinates into cartesian coordinates: # convert from (\\$radius,\\$angle) set x [ expr { \\$radius * cos(\\$angle) }] set y [ expr { \\$radius * sin(\\$angle) }] Convert cartesian coordinates into polar coordinates: # convert from (\\$x,\\$y) set radius [ expr { hypot(\\$y, \\$x) }] set angle [ expr { atan2(\\$y, \\$x) }] Print a message describing the relationship of two string values to each other: puts \\\"a and b are [ expr {\\$a eq \\$b ? {equal} : {different}}]\\\" Set a variable indicating whether an environment variable is defined and has value of true: set isTrue [ expr { # Does the environment variable exist, and... [info exists ::env(SOME_ENV_VAR)] && # ...does it contain a proper true value? [string is true -strict \\$::env(SOME_ENV_VAR)] }] Generate a random integer in the range 0..99 inclusive: set randNum [ expr { int(100 * rand()) }]","title":"EXAMPLES"},{"location":"expr/#see-also","text":"array(n), for(n), if(n), mathfunc(n), mathop(n), namespace(n), proc(n), string(n), Tcl(n), while(n)","title":"SEE ALSO"},{"location":"expr/#keywords","text":"arithmetic, boolean, compare, expression, fuzzy comparison, integer value","title":"KEYWORDS"},{"location":"expr/#copyright","text":"Copyright \u00a9 1993 The Regents of the University of California. Copyright \u00a9 1994-2000 Sun Microsystems Incorporated. Copyright \u00a9 2005 Kevin B. Kenny <kennykb@acm.org>. All rights reserved.","title":"COPYRIGHT"},{"location":"fblocked/","text":"NAME fblocked - Test whether the last input operation exhausted all available input SYNOPSIS fblocked channelId DESCRIPTION The fblocked command returns 1 if the most recent input operation on channelId returned less information than requested because all available input was exhausted. For example, if gets is invoked when there are only three characters available for input and no end-of-line sequence, gets returns an empty string and a subsequent call to fblocked will return 1. ChannelId must be an identifier for an open channel such as a Tcl standard channel ( stdin , stdout , or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. EXAMPLE The fblocked command is particularly useful when writing network servers, as it allows you to write your code in a line-by-line style without preventing the servicing of other connections. This can be seen in this simple echo-service: # This is called whenever a new client connects to the server proc connect {chan host port} { set clientName [format \\<%s:%d> \\$host \\$port] puts \\\"connection from \\$clientName\\\" fconfigure \\$chan -blocking 0 -buffering line fileevent \\$chan readable [list echoLine \\$chan \\$clientName] } # This is called whenever either at least one byte of input # data is available, or the channel was closed by the client. proc echoLine {chan clientName} { gets \\$chan line if {[eof \\$chan]} { puts \\\"finishing connection from \\$clientName\\\" close \\$chan } elseif {![ fblocked \\$chan]} { # Didn\\'t block waiting for end-of-line puts \\\"\\$clientName - \\$line\\\" puts \\$chan \\$line } } # Create the server socket and enter the event-loop to wait # for incoming connections... socket -server connect 12345 vwait forever SEE ALSO gets(n), open(n), read(n), socket(n), Tcl_StandardChannels(3) KEYWORDS blocking, nonblocking","title":"NAME"},{"location":"fblocked/#name","text":"fblocked - Test whether the last input operation exhausted all available input","title":"NAME"},{"location":"fblocked/#synopsis","text":"fblocked channelId","title":"SYNOPSIS"},{"location":"fblocked/#description","text":"The fblocked command returns 1 if the most recent input operation on channelId returned less information than requested because all available input was exhausted. For example, if gets is invoked when there are only three characters available for input and no end-of-line sequence, gets returns an empty string and a subsequent call to fblocked will return 1. ChannelId must be an identifier for an open channel such as a Tcl standard channel ( stdin , stdout , or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension.","title":"DESCRIPTION"},{"location":"fblocked/#example","text":"The fblocked command is particularly useful when writing network servers, as it allows you to write your code in a line-by-line style without preventing the servicing of other connections. This can be seen in this simple echo-service: # This is called whenever a new client connects to the server proc connect {chan host port} { set clientName [format \\<%s:%d> \\$host \\$port] puts \\\"connection from \\$clientName\\\" fconfigure \\$chan -blocking 0 -buffering line fileevent \\$chan readable [list echoLine \\$chan \\$clientName] } # This is called whenever either at least one byte of input # data is available, or the channel was closed by the client. proc echoLine {chan clientName} { gets \\$chan line if {[eof \\$chan]} { puts \\\"finishing connection from \\$clientName\\\" close \\$chan } elseif {![ fblocked \\$chan]} { # Didn\\'t block waiting for end-of-line puts \\\"\\$clientName - \\$line\\\" puts \\$chan \\$line } } # Create the server socket and enter the event-loop to wait # for incoming connections... socket -server connect 12345 vwait forever","title":"EXAMPLE"},{"location":"fblocked/#see-also","text":"gets(n), open(n), read(n), socket(n), Tcl_StandardChannels(3)","title":"SEE ALSO"},{"location":"fblocked/#keywords","text":"blocking, nonblocking","title":"KEYWORDS"},{"location":"fconfigure/","text":"NAME fconfigure - Set and get options on a channel SYNOPSIS fconfigure channelId fconfigure channelId name fconfigure channelId name value ?name value ...? DESCRIPTION The fconfigure command sets and retrieves options for channels. ChannelId identifies the channel for which to set or query an option and must refer to an open channel such as a Tcl standard channel ( stdin , stdout , or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. If no name or value arguments are supplied, the command returns a list containing alternating option names and values for the channel. If name is supplied but no value then the command returns the current value of the given option. If one or more pairs of name and value are supplied, the command sets each of the named options to the corresponding value ; in this case the return value is an empty string. The options described below are supported for all channels. In addition, each channel type may add options that only it supports. See the manual entry for the command that creates each type of channels for the options that that specific type of channel supports. For example, see the manual entry for the socket command for additional options for sockets, and the open command for additional options for serial devices. -blocking boolean : The -blocking option determines whether I/O operations on the channel can cause the process to block indefinitely. The value of the option must be a proper boolean value. Channels are normally in blocking mode; if a channel is placed into nonblocking mode it will affect the operation of the gets , read , puts , flush , and close commands by allowing them to operate asynchronously; see the documentation for those commands for details. For nonblocking mode to work correctly, the application must be using the Tcl event loop (e.g. by calling Tcl_DoOneEvent or invoking the vwait command). -buffering newValue : If newValue is full then the I/O system will buffer output until its internal buffer is full or until the flush command is invoked. If newValue is line , then the I/O system will automatically flush output for the channel whenever a newline character is output. If newValue is none , the I/O system will flush automatically after every output operation. The default is for -buffering to be set to full except for channels that connect to terminal-like devices; for these channels the initial setting is line . Additionally, stdin and stdout are initially set to line , and stderr is set to none . -buffersize newSize : Newvalue must be an integer; its value is used to set the size of buffers, in bytes, subsequently allocated for this channel to store input or output. Newvalue must be between one and one million, allowing buffers of one to one million bytes in size. -encoding name : This option is used to specify the encoding of the channel, so that the data can be converted to and from Unicode for use in Tcl. For instance, in order for Tcl to read characters from a Japanese file in shiftjis and properly process and display the contents, the encoding would be set to shiftjis . Thereafter, when reading from the channel, the bytes in the Japanese file would be converted to Unicode as they are read. Writing is also supported - as Tcl strings are written to the channel they will automatically be converted to the specified encoding on output. If a file contains pure binary data (for instance, a JPEG image), the encoding for the channel should be configured to be **binary**. Tcl will then assign no interpretation to the data in the file and simply read or write raw bytes. The Tcl **binary** command can be used to manipulate this byte-oriented data. It is usually better to set the **-translation** option to **binary** when you want to transfer binary data, as this turns off the other automatic interpretations of the bytes in the stream as well. The default encoding for newly opened channels is the same platform- and locale-dependent system encoding used for interfacing with the operating system, as returned by **encoding system**. -eofchar char : This option supports DOS file systems that use Control-z (\\x1A) as an end of file marker. If char is not an empty string, then this character signals end-of-file when it is encountered during input. If char is the empty string, then there is no special end of file character marker. The default value for -eofchar is the empty string. The acceptable range for -eofchar values is \\x01 - \\x7F; attempting to set -eofchar to a value outside of this range will generate an error. <!-- --> -profile profile : Specifies the encoding profile to be used on the channel. The encoding transforms in use for the channel\\'s input and output will then be subject to the rules of that profile. Any failures will result in a channel error. See PROFILES in the encoding(n) documentation for details about encoding profiles. <!-- --> -translation mode : -translation { inMode outMode } : In Tcl scripts the end of a line is always represented using a single newline character (\\n). However, in actual files and devices the end of a line may be represented differently on different platforms, or even for different devices on the same platform. For example, under UNIX newlines are used in files, whereas carriage-return-linefeed sequences are normally used in network connections. On input (i.e., with gets and read ) the Tcl I/O system automatically translates the external end-of-line representation into newline characters. Upon output (i.e., with puts ), the I/O system translates newlines to the external end-of-line representation. The default translation mode, auto , handles all the common cases automatically, but the -translation option provides explicit control over the end of line translations. The value associated with **-translation** is a single item for read-only and write-only channels. The value is a two-element list for read-write channels; the read translation mode is the first element of the list, and the write translation mode is the second element. As a convenience, when setting the translation mode for a read-write channel you can specify a single value that will apply to both reading and writing. When querying the translation mode of a read-write channel, a two-element list will always be returned. The following values are currently supported: **auto** : As the input translation mode, **auto** treats any of newline (**lf**), carriage return (**cr**), or carriage return followed by a newline (**crlf**) as the end of line representation. The end of line representation can even change from line-to-line, and all cases are translated to a newline. As the output translation mode, **auto** chooses a platform specific representation; for sockets on all platforms Tcl chooses **crlf**, for all Unix flavors, it chooses **lf**, and for the various flavors of Windows it chooses **crlf**. The default setting for **-translation** is **auto** for both input and output. **binary** : No end-of-line translations are performed. This is nearly identical to **lf** mode, except that in addition **binary** mode also sets the end-of-file character to the empty string (which disables it) and sets the encoding to **binary** (which disables encoding filtering). See the description of **-eofchar** and **-encoding** for more information. Internally, i.e. when it comes to the actual behaviour of the translator this value **is** identical to **lf** and is therefore reported as such when queried. Even if **binary** was used to set the translation. **cr** : The end of a line in the underlying file or device is represented by a single carriage return character. As the input translation mode, **cr** mode converts carriage returns to newline characters. As the output translation mode, **cr** mode translates newline characters to carriage returns. **crlf** : The end of a line in the underlying file or device is represented by a carriage return character followed by a linefeed character. As the input translation mode, **crlf** mode converts carriage-return-linefeed sequences to newline characters. As the output translation mode, **crlf** mode translates newline characters to carriage-return-linefeed sequences. This mode is typically used on Windows platforms and for network connections. **lf** : The end of a line in the underlying file or device is represented by a single newline (linefeed) character. In this mode no translations occur during either input or output. This mode is typically used on UNIX platforms. STANDARD CHANNELS The Tcl standard channels ( stdin , stdout , and stderr ) can be configured through this command like every other channel opened by the Tcl library. Beyond the standard options described above they will also support any special option according to their current type. If, for example, a Tcl application is started by the inet super-server common on Unix system its Tcl standard channels will be sockets and thus support the socket options. EXAMPLES Instruct Tcl to always send output to stdout immediately, whether or not it is to a terminal: fconfigure stdout -buffering none Open a socket and read lines from it without ever blocking the processing of other events: set s [socket some.where.com 12345] fconfigure \\$s -blocking 0 fileevent \\$s readable \\\"readMe \\$s\\\" proc readMe chan { if {[gets \\$chan line] \\< 0} { if {[eof \\$chan]} { close \\$chan return } # Could not read a complete line this time; Tcl\\'s # internal buffering will hold the partial line for us # until some more data is available over the socket. } else { puts stdout \\$line } } Read a PPM-format image from a file: # Open the file and put it into Unix ASCII mode set f [open teapot.ppm] fconfigure \\$f -encoding ascii -translation lf # Get the header if {[gets \\$f] ne \\\"P6\\\"} { error \\\"not a raw-bits PPM\\\" } # Read lines until we have got non-comment lines # that supply us with three decimal values. set words {} while {[llength \\$words] \\< 3} { gets \\$f line if {[string match \\\"#*\\\" \\$line]} continue lappend words {*}[join [scan \\$line %d%d%d]] } # Those words supply the size of the image and its # overall depth per channel. Assign to variables. lassign \\$words xSize ySize depth # Now switch to binary mode to pull in the data, # one byte per channel (red,green,blue) per pixel. fconfigure \\$f -translation binary set numDataBytes [expr {3 * \\$xSize * \\$ySize}] set data [read \\$f \\$numDataBytes] close \\$f SEE ALSO close(n), encoding(n), flush(n), gets(n), open(n), puts(n), read(n), socket(n), Tcl_StandardChannels(3) KEYWORDS blocking, buffering, carriage return, end of line, encoding, flushing, linemode, newline, nonblocking, platform, profile, translation, encoding, filter, byte array, binary","title":"NAME"},{"location":"fconfigure/#name","text":"fconfigure - Set and get options on a channel","title":"NAME"},{"location":"fconfigure/#synopsis","text":"fconfigure channelId fconfigure channelId name fconfigure channelId name value ?name value ...?","title":"SYNOPSIS"},{"location":"fconfigure/#description","text":"The fconfigure command sets and retrieves options for channels. ChannelId identifies the channel for which to set or query an option and must refer to an open channel such as a Tcl standard channel ( stdin , stdout , or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. If no name or value arguments are supplied, the command returns a list containing alternating option names and values for the channel. If name is supplied but no value then the command returns the current value of the given option. If one or more pairs of name and value are supplied, the command sets each of the named options to the corresponding value ; in this case the return value is an empty string. The options described below are supported for all channels. In addition, each channel type may add options that only it supports. See the manual entry for the command that creates each type of channels for the options that that specific type of channel supports. For example, see the manual entry for the socket command for additional options for sockets, and the open command for additional options for serial devices. -blocking boolean : The -blocking option determines whether I/O operations on the channel can cause the process to block indefinitely. The value of the option must be a proper boolean value. Channels are normally in blocking mode; if a channel is placed into nonblocking mode it will affect the operation of the gets , read , puts , flush , and close commands by allowing them to operate asynchronously; see the documentation for those commands for details. For nonblocking mode to work correctly, the application must be using the Tcl event loop (e.g. by calling Tcl_DoOneEvent or invoking the vwait command). -buffering newValue : If newValue is full then the I/O system will buffer output until its internal buffer is full or until the flush command is invoked. If newValue is line , then the I/O system will automatically flush output for the channel whenever a newline character is output. If newValue is none , the I/O system will flush automatically after every output operation. The default is for -buffering to be set to full except for channels that connect to terminal-like devices; for these channels the initial setting is line . Additionally, stdin and stdout are initially set to line , and stderr is set to none . -buffersize newSize : Newvalue must be an integer; its value is used to set the size of buffers, in bytes, subsequently allocated for this channel to store input or output. Newvalue must be between one and one million, allowing buffers of one to one million bytes in size. -encoding name : This option is used to specify the encoding of the channel, so that the data can be converted to and from Unicode for use in Tcl. For instance, in order for Tcl to read characters from a Japanese file in shiftjis and properly process and display the contents, the encoding would be set to shiftjis . Thereafter, when reading from the channel, the bytes in the Japanese file would be converted to Unicode as they are read. Writing is also supported - as Tcl strings are written to the channel they will automatically be converted to the specified encoding on output. If a file contains pure binary data (for instance, a JPEG image), the encoding for the channel should be configured to be **binary**. Tcl will then assign no interpretation to the data in the file and simply read or write raw bytes. The Tcl **binary** command can be used to manipulate this byte-oriented data. It is usually better to set the **-translation** option to **binary** when you want to transfer binary data, as this turns off the other automatic interpretations of the bytes in the stream as well. The default encoding for newly opened channels is the same platform- and locale-dependent system encoding used for interfacing with the operating system, as returned by **encoding system**. -eofchar char : This option supports DOS file systems that use Control-z (\\x1A) as an end of file marker. If char is not an empty string, then this character signals end-of-file when it is encountered during input. If char is the empty string, then there is no special end of file character marker. The default value for -eofchar is the empty string. The acceptable range for -eofchar values is \\x01 - \\x7F; attempting to set -eofchar to a value outside of this range will generate an error. <!-- --> -profile profile : Specifies the encoding profile to be used on the channel. The encoding transforms in use for the channel\\'s input and output will then be subject to the rules of that profile. Any failures will result in a channel error. See PROFILES in the encoding(n) documentation for details about encoding profiles. <!-- --> -translation mode : -translation { inMode outMode } : In Tcl scripts the end of a line is always represented using a single newline character (\\n). However, in actual files and devices the end of a line may be represented differently on different platforms, or even for different devices on the same platform. For example, under UNIX newlines are used in files, whereas carriage-return-linefeed sequences are normally used in network connections. On input (i.e., with gets and read ) the Tcl I/O system automatically translates the external end-of-line representation into newline characters. Upon output (i.e., with puts ), the I/O system translates newlines to the external end-of-line representation. The default translation mode, auto , handles all the common cases automatically, but the -translation option provides explicit control over the end of line translations. The value associated with **-translation** is a single item for read-only and write-only channels. The value is a two-element list for read-write channels; the read translation mode is the first element of the list, and the write translation mode is the second element. As a convenience, when setting the translation mode for a read-write channel you can specify a single value that will apply to both reading and writing. When querying the translation mode of a read-write channel, a two-element list will always be returned. The following values are currently supported: **auto** : As the input translation mode, **auto** treats any of newline (**lf**), carriage return (**cr**), or carriage return followed by a newline (**crlf**) as the end of line representation. The end of line representation can even change from line-to-line, and all cases are translated to a newline. As the output translation mode, **auto** chooses a platform specific representation; for sockets on all platforms Tcl chooses **crlf**, for all Unix flavors, it chooses **lf**, and for the various flavors of Windows it chooses **crlf**. The default setting for **-translation** is **auto** for both input and output. **binary** : No end-of-line translations are performed. This is nearly identical to **lf** mode, except that in addition **binary** mode also sets the end-of-file character to the empty string (which disables it) and sets the encoding to **binary** (which disables encoding filtering). See the description of **-eofchar** and **-encoding** for more information. Internally, i.e. when it comes to the actual behaviour of the translator this value **is** identical to **lf** and is therefore reported as such when queried. Even if **binary** was used to set the translation. **cr** : The end of a line in the underlying file or device is represented by a single carriage return character. As the input translation mode, **cr** mode converts carriage returns to newline characters. As the output translation mode, **cr** mode translates newline characters to carriage returns. **crlf** : The end of a line in the underlying file or device is represented by a carriage return character followed by a linefeed character. As the input translation mode, **crlf** mode converts carriage-return-linefeed sequences to newline characters. As the output translation mode, **crlf** mode translates newline characters to carriage-return-linefeed sequences. This mode is typically used on Windows platforms and for network connections. **lf** : The end of a line in the underlying file or device is represented by a single newline (linefeed) character. In this mode no translations occur during either input or output. This mode is typically used on UNIX platforms.","title":"DESCRIPTION"},{"location":"fconfigure/#standard-channels","text":"The Tcl standard channels ( stdin , stdout , and stderr ) can be configured through this command like every other channel opened by the Tcl library. Beyond the standard options described above they will also support any special option according to their current type. If, for example, a Tcl application is started by the inet super-server common on Unix system its Tcl standard channels will be sockets and thus support the socket options.","title":"STANDARD CHANNELS"},{"location":"fconfigure/#examples","text":"Instruct Tcl to always send output to stdout immediately, whether or not it is to a terminal: fconfigure stdout -buffering none Open a socket and read lines from it without ever blocking the processing of other events: set s [socket some.where.com 12345] fconfigure \\$s -blocking 0 fileevent \\$s readable \\\"readMe \\$s\\\" proc readMe chan { if {[gets \\$chan line] \\< 0} { if {[eof \\$chan]} { close \\$chan return } # Could not read a complete line this time; Tcl\\'s # internal buffering will hold the partial line for us # until some more data is available over the socket. } else { puts stdout \\$line } } Read a PPM-format image from a file: # Open the file and put it into Unix ASCII mode set f [open teapot.ppm] fconfigure \\$f -encoding ascii -translation lf # Get the header if {[gets \\$f] ne \\\"P6\\\"} { error \\\"not a raw-bits PPM\\\" } # Read lines until we have got non-comment lines # that supply us with three decimal values. set words {} while {[llength \\$words] \\< 3} { gets \\$f line if {[string match \\\"#*\\\" \\$line]} continue lappend words {*}[join [scan \\$line %d%d%d]] } # Those words supply the size of the image and its # overall depth per channel. Assign to variables. lassign \\$words xSize ySize depth # Now switch to binary mode to pull in the data, # one byte per channel (red,green,blue) per pixel. fconfigure \\$f -translation binary set numDataBytes [expr {3 * \\$xSize * \\$ySize}] set data [read \\$f \\$numDataBytes] close \\$f","title":"EXAMPLES"},{"location":"fconfigure/#see-also","text":"close(n), encoding(n), flush(n), gets(n), open(n), puts(n), read(n), socket(n), Tcl_StandardChannels(3)","title":"SEE ALSO"},{"location":"fconfigure/#keywords","text":"blocking, buffering, carriage return, end of line, encoding, flushing, linemode, newline, nonblocking, platform, profile, translation, encoding, filter, byte array, binary","title":"KEYWORDS"},{"location":"fcopy/","text":"NAME fcopy - Copy data from one channel to another SYNOPSIS fcopy inputChan outputChan ? -size size ? ? -command callback ? DESCRIPTION Reads characters from inputChan and writes them to outputChan until all characters are copied, blocking until the copy is complete and returning the number of characters copied. Leverages internal buffers to avoid extra copies and to avoid buffering too much data in main memory when copying large files to slow destinations like network sockets. -size limits the number of characters copied. -command makes fcopy return immediately, work in the background, and call callback when the copy completes, providing as an additional argument the number of characters written to outputChan . If an error occurres during the background copy, another argument provides the message for the error. inputChan and outputChan are automatically configured for non-blocking mode if needed. Background copying only works correctly if events are being processed e.g. via vwait or Tk. During a background copy no other read operation may be performed on inputChan , and no other write operation may be performed on outputChan . However, write operations may by performed on inputChan and read operations may be performed on outputChan , as exhibited by the bidirectional copy example below. If either inputChan or outputChan is closed while the copy is in progress, copying ceases and no callback is made. If inputChan is closed all data already queued is written to outputChan . There should be no event handler established for inputChan because it may become readable during a background copy. An attempt to read or write from within an event handler results result in the error, \\\"channel busy\\\". Any wrong-sided I/O attempted (by a fileevent handler or otherwise) results in a error. EXAMPLES The first example transfers the contents of one channel exactly to another. Note that when copying one file to another, it is better to use file copy which also copies file metadata (e.g. the file access permissions) where possible. fconfigure \\$in -translation binary fconfigure \\$out -translation binary fcopy \\$in \\$out This second example shows how the callback gets passed the number of bytes transferred. It also uses vwait to put the application into the event loop. Of course, this simplified example could be done without the command callback. proc Cleanup {in out bytes {error {}}} { global total set total \\$bytes close \\$in close \\$out if {[string length \\$error] != 0} { # error occurred during the copy } } set in [open \\$file1] set out [socket \\$server \\$port] fcopy \\$in \\$out -command [list Cleanup \\$in \\$out] vwait total The third example copies in chunks and tests for end of file in the command callback. proc CopyMore {in out chunk bytes {error {}}} { global total done incr total \\$bytes if {([string length \\$error] != 0) || [eof \\$in]} { set done \\$total close \\$in close \\$out } else { fcopy \\$in \\$out -size \\$chunk \\ -command [list CopyMore \\$in \\$out \\$chunk] } } set in [open \\$file1] set out [socket \\$server \\$port] set chunk 1024 set total 0 fcopy \\$in \\$out -size \\$chunk \\ -command [list CopyMore \\$in \\$out \\$chunk] vwait done The fourth example starts an asynchronous, bidirectional fcopy between two sockets. Those could also be pipes from two [open \\\"|hal 9000\\\" r+] (though their conversation would remain secret to the script, since all four fileevent slots are busy). set flows 2 proc Done {dir args} { global flows done puts \\\"\\$dir is over.\\\" incr flows -1 if {\\$flows\\<=0} {set done 1} } fcopy \\$sok1 \\$sok2 -command [list Done UP] fcopy \\$sok2 \\$sok1 -command [list Done DOWN] vwait done SEE ALSO eof(n), fblocked(n), fconfigure(n), file(n) KEYWORDS blocking, channel, end of line, end of file, nonblocking, read, translation","title":"NAME"},{"location":"fcopy/#name","text":"fcopy - Copy data from one channel to another","title":"NAME"},{"location":"fcopy/#synopsis","text":"fcopy inputChan outputChan ? -size size ? ? -command callback ?","title":"SYNOPSIS"},{"location":"fcopy/#description","text":"Reads characters from inputChan and writes them to outputChan until all characters are copied, blocking until the copy is complete and returning the number of characters copied. Leverages internal buffers to avoid extra copies and to avoid buffering too much data in main memory when copying large files to slow destinations like network sockets. -size limits the number of characters copied. -command makes fcopy return immediately, work in the background, and call callback when the copy completes, providing as an additional argument the number of characters written to outputChan . If an error occurres during the background copy, another argument provides the message for the error. inputChan and outputChan are automatically configured for non-blocking mode if needed. Background copying only works correctly if events are being processed e.g. via vwait or Tk. During a background copy no other read operation may be performed on inputChan , and no other write operation may be performed on outputChan . However, write operations may by performed on inputChan and read operations may be performed on outputChan , as exhibited by the bidirectional copy example below. If either inputChan or outputChan is closed while the copy is in progress, copying ceases and no callback is made. If inputChan is closed all data already queued is written to outputChan . There should be no event handler established for inputChan because it may become readable during a background copy. An attempt to read or write from within an event handler results result in the error, \\\"channel busy\\\". Any wrong-sided I/O attempted (by a fileevent handler or otherwise) results in a error.","title":"DESCRIPTION"},{"location":"fcopy/#examples","text":"The first example transfers the contents of one channel exactly to another. Note that when copying one file to another, it is better to use file copy which also copies file metadata (e.g. the file access permissions) where possible. fconfigure \\$in -translation binary fconfigure \\$out -translation binary fcopy \\$in \\$out This second example shows how the callback gets passed the number of bytes transferred. It also uses vwait to put the application into the event loop. Of course, this simplified example could be done without the command callback. proc Cleanup {in out bytes {error {}}} { global total set total \\$bytes close \\$in close \\$out if {[string length \\$error] != 0} { # error occurred during the copy } } set in [open \\$file1] set out [socket \\$server \\$port] fcopy \\$in \\$out -command [list Cleanup \\$in \\$out] vwait total The third example copies in chunks and tests for end of file in the command callback. proc CopyMore {in out chunk bytes {error {}}} { global total done incr total \\$bytes if {([string length \\$error] != 0) || [eof \\$in]} { set done \\$total close \\$in close \\$out } else { fcopy \\$in \\$out -size \\$chunk \\ -command [list CopyMore \\$in \\$out \\$chunk] } } set in [open \\$file1] set out [socket \\$server \\$port] set chunk 1024 set total 0 fcopy \\$in \\$out -size \\$chunk \\ -command [list CopyMore \\$in \\$out \\$chunk] vwait done The fourth example starts an asynchronous, bidirectional fcopy between two sockets. Those could also be pipes from two [open \\\"|hal 9000\\\" r+] (though their conversation would remain secret to the script, since all four fileevent slots are busy). set flows 2 proc Done {dir args} { global flows done puts \\\"\\$dir is over.\\\" incr flows -1 if {\\$flows\\<=0} {set done 1} } fcopy \\$sok1 \\$sok2 -command [list Done UP] fcopy \\$sok2 \\$sok1 -command [list Done DOWN] vwait done","title":"EXAMPLES"},{"location":"fcopy/#see-also","text":"eof(n), fblocked(n), fconfigure(n), file(n)","title":"SEE ALSO"},{"location":"fcopy/#keywords","text":"blocking, channel, end of line, end of file, nonblocking, read, translation","title":"KEYWORDS"},{"location":"file/","text":"NAME file - Manipulate file names and attributes SYNOPSIS file option name ? arg arg ... ? DESCRIPTION This command provides several operations on a file\\'s name or attributes. The name argument is the name of a file in most cases. The option argument indicates what to do with the file name. Any unique abbreviation for option is acceptable. The valid options are: file atime name ? time ? : Returns a decimal string giving the time at which file name was last accessed. If time is specified, it is an access time to set for the file. The time is measured in the standard POSIX fashion as seconds from a fixed starting time (often January 1, 1970). If the file does not exist or its access time cannot be queried or set then an error is generated. On Windows, FAT file systems do not support access time. file attributes name : file attributes name ? option ? : file attributes name ? option value option value... ? : This subcommand returns or sets platform-specific values associated with a file. The first form returns a list of the platform-specific options and their values. The second form returns the value for the given option. The third form sets one or more of the values. The values are as follows: On Unix, **-group** gets or sets the group name for the file. A group id can be given to the command, but it returns a group name. **-owner** gets or sets the user name of the owner of the file. The command returns the owner name, but the numerical id can be passed when setting the owner. **-permissions** retrieves or sets a file\\'s access permissions, using octal notation by default. This option also provides limited support for setting permissions using the symbolic notation accepted by the **chmod** command, following the form \\[**ugo**\\]?\\[\\[**+-=**\\]\\[**rwxst**\\]**,**\\[\\...\\]\\]. Multiple permission specifications may be given, separated by commas. E.g., **u+s,go-rw** would set the setuid bit for a file\\'s owner as well as remove read and write permission for the file\\'s group and other users. An **ls**-style string of the form **rwxrwxrwx** is also accepted but must always be 9 characters long. E.g., **rwxr-xr-t** is equivalent to **01755**. On versions of Unix supporting file flags, **-readonly** returns the value of, or sets, or clears the readonly attribute of a file, i.e., the user immutable flag (**uchg**) to the **chflags** command. On Windows, **-archive** gives the value or sets or clears the archive attribute of the file. **-hidden** gives the value or sets or clears the hidden attribute of the file. **-longname** will expand each path element to its long version. This attribute cannot be set. **-readonly** gives the value or sets or clears the readonly attribute of the file. **-shortname** gives a string where every path element is replaced with its short (8.3) version of the name. This attribute cannot be set. **-system** gives or sets or clears the value of the system attribute of the file. On Mac OS X and Darwin, **-creator** gives or sets the Finder creator type of the file. **-hidden** gives or sets or clears the hidden attribute of the file. **-readonly** gives or sets or clears the readonly attribute of the file. **-rsrclength** gives the length of the resource fork of the file, this attribute can only be set to the value 0, which results in the resource fork being stripped off the file. file channels ? pattern ? : If pattern is not specified, returns a list of names of all registered open channels in this interpreter. If pattern is specified, only those names matching pattern are returned. Matching is determined using the same rules as for string match . file copy ? -force ? ? -\u2006- ? source target : file copy ? -force ? ? -\u2006- ? source ? source ...? targetDir : The first form makes a copy of the file or directory source under the pathname target . If target is an existing directory, then the second form is used. The second form makes a copy inside targetDir of each source file listed. If a directory is specified as a source , then the contents of the directory will be recursively copied into targetDir . Existing files will not be overwritten unless the -force option is specified (when Tcl will also attempt to adjust permissions on the destination file or directory if that is necessary to allow the copy to proceed). When copying within a single filesystem, file copy will copy soft links (i.e. the links themselves are copied, not the things they point to). Trying to overwrite a non-empty directory, overwrite a directory with a file, or overwrite a file with a directory will all result in errors even if -force was specified. Arguments are processed in the order specified, halting at the first error, if any. A -\u2006- marks the end of switches; the argument following the -\u2006- will be treated as a source even if it starts with a - . file delete ? -force ? ? -\u2006- ? ? pathname ... ? : Removes the file or directory specified by each pathname argument. Non-empty directories will be removed only if the -force option is specified. When operating on symbolic links, the links themselves will be deleted, not the objects they point to. Trying to delete a non-existent file is not considered an error. Trying to delete a read-only file will cause the file to be deleted, even if the -force flags is not specified. If the -force option is specified on a directory, Tcl will attempt both to change permissions and move the current directory out of the given path if that is necessary to allow the deletion to proceed. Arguments are processed in the order specified, halting at the first error, if any. A -\u2006- marks the end of switches; the argument following the -\u2006- will be treated as a pathname even if it starts with a - . file dirname name : Returns a name comprised of all of the path components in name excluding the last element. If name is a relative file name and only contains one path element, then returns If name refers to a root directory, then the root directory is returned. For example, file dirname c:/ returns c:/ . file executable name : Returns 1 if file name is executable by the current user, 0 otherwise. On Windows, which does not have an executable attribute, the command treats all directories and any files with extensions exe , com , cmd or bat as executable. file exists name : Returns 1 if file name exists and the current user has search privileges for the directories leading to it, 0 otherwise. file extension name : Returns all of the characters in name after and including the last dot in the last element of name . If there is no dot in the last element of name then returns the empty string. file home ? username ? : If no argument is specified, the command returns the home directory of the current user. This is generally the value of the \\$HOME environment variable except that on Windows platforms backslashes in the path are replaced by forward slashes. An error is raised if the \\$HOME environment variable is not set. If username is specified, the command returns the home directory configured in the system for the specified user. Note this may be different than the value of the \\$HOME environment variable even when username corresponds to the current user. An error is raised if the username does not correspond to a user account on the system. file isdirectory name : Returns 1 if file name is a directory, 0 otherwise. file isfile name : Returns 1 if file name is a regular file, 0 otherwise. file join name ? name ... ? : Takes one or more file names and combines them, using the correct path separator for the current platform. If a particular name is relative, then it will be joined to the previous file name argument. Otherwise, any earlier arguments will be discarded, and joining will proceed from the current argument. For example, **file join** a b /foo bar returns **/foo/bar**. Note that any of the names can contain separators, and that the result is always canonical for the current platform: **/** for Unix and Windows. file link ? -linktype ? linkName ? target ? : If only one argument is given, that argument is assumed to be linkName , and this command returns the value of the link given by linkName (i.e. the name of the file it points to). If linkName is not a link or its value cannot be read (as, for example, seems to be the case with hard links, which look just like ordinary files), then an error is returned. If 2 arguments are given, then these are assumed to be *linkName* and *target*. If *linkName* already exists, or if *target* does not exist, an error will be returned. Otherwise, Tcl creates a new link called *linkName* which points to the existing filesystem object at *target* (which is also the returned value), where the type of the link is platform-specific (on Unix a symbolic link will be the default). This is useful for the case where the user wishes to create a link in a cross-platform way, and does not care what type of link is created. If the user wishes to make a link of a specific type only, (and signal an error if for some reason that is not possible), then the optional *-linktype* argument should be given. Accepted values for *-linktype* are and On Unix, symbolic links can be made to relative paths, and those paths must be relative to the actual *linkName*\\'s location (not to the cwd), but on all other platforms where relative links are not supported, target paths will always be converted to absolute, normalized form before the link is created (and therefore relative paths are interpreted as relative to the cwd). When creating links on filesystems that either do not support any links, or do not support the specific type requested, an error message will be returned. Most Unix platforms support both symbolic and hard links (the latter for files only). Windows supports symbolic directory links and hard file links on NTFS drives. file lstat name ?varName? : Same as stat option (see below) except uses the lstat kernel call instead of stat . This means that if name refers to a symbolic link the information returned is for the link rather than the file it refers to. On systems that do not support symbolic links this option behaves exactly the same as the stat option. file mkdir ? dir ...? : Creates each directory specified. For each pathname dir specified, this command will create all non-existing parent directories as well as dir itself. If an existing directory is specified, then no action is taken and no error is returned. Trying to overwrite an existing file with a directory will result in an error. Arguments are processed in the order specified, halting at the first error, if any. file mtime name ? time ? : Returns a decimal string giving the time at which file name was last modified. If time is specified, it is a modification time to set for the file (equivalent to Unix touch ). The time is measured in the standard POSIX fashion as seconds from a fixed starting time (often January 1, 1970). If the file does not exist or its modified time cannot be queried or set then an error is generated. file nativename name : Returns the platform-specific name of the file. This is useful if the filename is needed to pass to a platform-specific call, such as to a subprocess via exec under Windows (see EXAMPLES below). file normalize name : Returns a unique normalized path representation for the file-system object (file, directory, link, etc), whose string value can be used as a unique identifier for it. A normalized path is an absolute path which has all and removed. Also it is one which is in the format for the native platform. On Unix, this means the segments leading up to the path must be free of symbolic links/aliases (but the very last path component may be a symbolic link), and on Windows it also means we want the long form with that form\\'s case-dependence (which gives us a unique, case-dependent path). The one exception concerning the last link in the path is necessary, because Tcl or the user may wish to operate on the actual symbolic link itself (for example file delete , file rename , file copy are defined to operate on symbolic links, not on the things that they point to). file owned name : Returns 1 if file name is owned by the current user, 0 otherwise. file pathtype name : Returns one of absolute , relative , volumerelative . If name refers to a specific file on a specific volume, the path type will be absolute . If name refers to a file relative to the current working directory, then the path type will be relative . If name refers to a file relative to the current working directory on a specified volume, or to a specific file on the current working volume, then the path type is volumerelative . file readable name : Returns 1 if file name is readable by the current user, 0 otherwise. file readlink name : Returns the value of the symbolic link given by name (i.e. the name of the file it points to). If name is not a symbolic link or its value cannot be read, then an error is returned. On systems that do not support symbolic links this option is undefined. file rename ? -force ? ? -\u2006- ? source target : file rename ? -force ? ? -\u2006- ? source ? source ...? targetDir : The first form takes the file or directory specified by pathname source and renames it to target , moving the file if the pathname target specifies a name in a different directory. If target is an existing directory, then the second form is used. The second form moves each source file or directory into the directory targetDir . Existing files will not be overwritten unless the -force option is specified. When operating inside a single filesystem, Tcl will rename symbolic links rather than the things that they point to. Trying to overwrite a non-empty directory, overwrite a directory with a file, or a file with a directory will all result in errors. Arguments are processed in the order specified, halting at the first error, if any. A -\u2006- marks the end of switches; the argument following the -\u2006- will be treated as a source even if it starts with a - . file rootname name : Returns all of the characters in name up to but not including the last character in the last component of name. If the last component of name does not contain a dot, then returns name . file separator ? name ? : If no argument is given, returns the character which is used to separate path segments for native files on this platform. If a path is given, the filesystem responsible for that path is asked to return its separator character. If no file system accepts name , an error is generated. file size name : Returns a decimal string giving the size of file name in bytes. If the file does not exist or its size cannot be queried then an error is generated. file split name : Returns a list whose elements are the path components in name . The first element of the list will have the same path type as name . All other elements will be relative. Path separators will be discarded unless they are needed to ensure that an element is unambiguously relative. file stat name ?varName? : Invokes the stat kernel call on name , and returns a dictionary with the information returned from the kernel call. If varName is given, it uses the variable to hold the information. VarName is treated as an array variable, and in such case the command returns the empty string. The following elements are set: atime , ctime , dev , gid , ino , mode , mtime , nlink , size , type , uid . Each element except type is a decimal string with the value of the corresponding field from the stat return structure; see the manual entry for stat for details on the meanings of the values. The type element gives the type of the file in the same form returned by the command file type . file system name : Returns a list of one or two elements, the first of which is the name of the filesystem to use for the file, and the second, if given, an arbitrary string representing the filesystem-specific nature or type of the location within that filesystem. If a filesystem only supports one type of file, the second element may not be supplied. For example the native files have a first element and a second element which when given is a platform-specific type name for the file\\'s system (e.g. on Windows). A generic virtual file system might return the list to represent a file on a remote ftp site mounted as a virtual filesystem through an extension called If the file does not belong to any filesystem, an error is generated. file tail name : Returns all of the characters in the last filesystem component of name . Any trailing directory separator in name is ignored. If name contains no separators then returns name . So, file tail a/b , file tail a/b/ and file tail b all return b . file tempdir ? template ? : Creates a temporary directory (guaranteed to be newly created and writable by the current script) and returns its name. If template is given, it specifies one of or both of the existing directory (on a filesystem controlled by the operating system) to contain the temporary directory, and the base part of the directory name; it is considered to have the location of the directory if there is a directory separator in the name, and the base part is everything after the last directory separator (if non-empty). The default containing directory is determined by system-specific operations, and the default base name prefix is The following output is typical and illustrative; the actual output will vary between platforms: \\% file tempdir /var/tmp/tcl_u0kuy5 % file tempdir /tmp/myapp /tmp/myapp_8o7r9L % file tempdir /tmp/ /tmp/tcl_1mOJHD % file tempdir myapp /var/tmp/myapp_0ihS0n file tempfile ? nameVar ? ? template ? : Creates a temporary file and returns a read-write channel opened on that file. If the nameVar is given, it specifies a variable that the name of the temporary file will be written into; if absent, Tcl will attempt to arrange for the temporary file to be deleted once it is no longer required. If the template is present, it specifies parts of the template of the filename to use when creating it (such as the directory, base-name or extension) though some platforms may ignore some or all of these parts and use a built-in default instead. Note that temporary files are *only* ever created on the native filesystem. As such, they can be relied upon to be used with operating-system native APIs and external programs that require a filename. file tildeexpand name : Returns the result of performing tilde substitution on name . If the name begins with a tilde, then the file name will be interpreted as if the first element is replaced with the location of the home directory for the given user. If the tilde is followed immediately by a path separator, the \\$HOME environment variable is substituted. Otherwise the characters between the tilde and the next separator are taken as a user name, which is used to retrieve the user\\'s home directory for substitution. An error is raised if the \\$HOME environment variable or user does not exist. If the file name does not begin with a tilde, it is returned unmodified. file type name : Returns a string giving the type of file name , which will be one of file , directory , characterSpecial , blockSpecial , fifo , link , or socket . file volumes : Returns the absolute paths to the volumes mounted on the system, as a proper Tcl list. Without any virtual filesystems mounted as root volumes, on UNIX, the command will always return since all filesystems are locally mounted. On Windows, it will return a list of the available local drives (e.g. If any virtual filesystem has mounted additional volumes, they will be in the returned list. file writable name : Returns 1 if file name is writable by the current user, 0 otherwise. PORTABILITY ISSUES Unix \u2007\u2007\u2007\u2007\u2007\u2007\u2007 : These commands always operate using the real user and group identifiers, not the effective ones. Windows \u2007\u2007\u2007\u2007 : The file owned subcommand uses the user identifier (SID) of the process token, not the thread token which may be impersonating some other user. EXAMPLES This procedure shows how to search for C files in a given directory that have a correspondingly-named object file in the current directory: proc findMatchingCFiles {dir} { set files {} switch \\$::tcl_platform(platform) { windows { set ext .obj } unix { set ext .o } } foreach file [glob -nocomplain -directory \\$dir *.c] { set objectFile [ file tail [ file rootname \\$file]]\\$ext if {[ file exists \\$objectFile]} { lappend files \\$file } } return \\$files } Rename a file and leave a symbolic link pointing from the old location to the new place: set oldName foobar.txt set newName foo/bar.txt # Make sure that where we\\'re going to move to exists... if {![ file isdirectory [ file dirname \\$newName]]} { file mkdir [ file dirname \\$newName] } file rename \\$oldName \\$newName file link -symbolic \\$oldName \\$newName On Windows, a file can be easily enough (equivalent to double-clicking on it in the Explorer interface) but the name passed to the operating system must be in native format: exec {*}[auto_execok start] {} [ file nativename C:/Users/fred/example.txt] SEE ALSO filename(n), open(n), close(n), eof(n), gets(n), tell(n), seek(n), fblocked(n), flush(n) KEYWORDS attributes, copy files, delete files, directory, file, move files, name, rename files, stat, user","title":"NAME"},{"location":"file/#name","text":"file - Manipulate file names and attributes","title":"NAME"},{"location":"file/#synopsis","text":"file option name ? arg arg ... ?","title":"SYNOPSIS"},{"location":"file/#description","text":"This command provides several operations on a file\\'s name or attributes. The name argument is the name of a file in most cases. The option argument indicates what to do with the file name. Any unique abbreviation for option is acceptable. The valid options are: file atime name ? time ? : Returns a decimal string giving the time at which file name was last accessed. If time is specified, it is an access time to set for the file. The time is measured in the standard POSIX fashion as seconds from a fixed starting time (often January 1, 1970). If the file does not exist or its access time cannot be queried or set then an error is generated. On Windows, FAT file systems do not support access time. file attributes name : file attributes name ? option ? : file attributes name ? option value option value... ? : This subcommand returns or sets platform-specific values associated with a file. The first form returns a list of the platform-specific options and their values. The second form returns the value for the given option. The third form sets one or more of the values. The values are as follows: On Unix, **-group** gets or sets the group name for the file. A group id can be given to the command, but it returns a group name. **-owner** gets or sets the user name of the owner of the file. The command returns the owner name, but the numerical id can be passed when setting the owner. **-permissions** retrieves or sets a file\\'s access permissions, using octal notation by default. This option also provides limited support for setting permissions using the symbolic notation accepted by the **chmod** command, following the form \\[**ugo**\\]?\\[\\[**+-=**\\]\\[**rwxst**\\]**,**\\[\\...\\]\\]. Multiple permission specifications may be given, separated by commas. E.g., **u+s,go-rw** would set the setuid bit for a file\\'s owner as well as remove read and write permission for the file\\'s group and other users. An **ls**-style string of the form **rwxrwxrwx** is also accepted but must always be 9 characters long. E.g., **rwxr-xr-t** is equivalent to **01755**. On versions of Unix supporting file flags, **-readonly** returns the value of, or sets, or clears the readonly attribute of a file, i.e., the user immutable flag (**uchg**) to the **chflags** command. On Windows, **-archive** gives the value or sets or clears the archive attribute of the file. **-hidden** gives the value or sets or clears the hidden attribute of the file. **-longname** will expand each path element to its long version. This attribute cannot be set. **-readonly** gives the value or sets or clears the readonly attribute of the file. **-shortname** gives a string where every path element is replaced with its short (8.3) version of the name. This attribute cannot be set. **-system** gives or sets or clears the value of the system attribute of the file. On Mac OS X and Darwin, **-creator** gives or sets the Finder creator type of the file. **-hidden** gives or sets or clears the hidden attribute of the file. **-readonly** gives or sets or clears the readonly attribute of the file. **-rsrclength** gives the length of the resource fork of the file, this attribute can only be set to the value 0, which results in the resource fork being stripped off the file. file channels ? pattern ? : If pattern is not specified, returns a list of names of all registered open channels in this interpreter. If pattern is specified, only those names matching pattern are returned. Matching is determined using the same rules as for string match . file copy ? -force ? ? -\u2006- ? source target : file copy ? -force ? ? -\u2006- ? source ? source ...? targetDir : The first form makes a copy of the file or directory source under the pathname target . If target is an existing directory, then the second form is used. The second form makes a copy inside targetDir of each source file listed. If a directory is specified as a source , then the contents of the directory will be recursively copied into targetDir . Existing files will not be overwritten unless the -force option is specified (when Tcl will also attempt to adjust permissions on the destination file or directory if that is necessary to allow the copy to proceed). When copying within a single filesystem, file copy will copy soft links (i.e. the links themselves are copied, not the things they point to). Trying to overwrite a non-empty directory, overwrite a directory with a file, or overwrite a file with a directory will all result in errors even if -force was specified. Arguments are processed in the order specified, halting at the first error, if any. A -\u2006- marks the end of switches; the argument following the -\u2006- will be treated as a source even if it starts with a - . file delete ? -force ? ? -\u2006- ? ? pathname ... ? : Removes the file or directory specified by each pathname argument. Non-empty directories will be removed only if the -force option is specified. When operating on symbolic links, the links themselves will be deleted, not the objects they point to. Trying to delete a non-existent file is not considered an error. Trying to delete a read-only file will cause the file to be deleted, even if the -force flags is not specified. If the -force option is specified on a directory, Tcl will attempt both to change permissions and move the current directory out of the given path if that is necessary to allow the deletion to proceed. Arguments are processed in the order specified, halting at the first error, if any. A -\u2006- marks the end of switches; the argument following the -\u2006- will be treated as a pathname even if it starts with a - . file dirname name : Returns a name comprised of all of the path components in name excluding the last element. If name is a relative file name and only contains one path element, then returns If name refers to a root directory, then the root directory is returned. For example, file dirname c:/ returns c:/ . file executable name : Returns 1 if file name is executable by the current user, 0 otherwise. On Windows, which does not have an executable attribute, the command treats all directories and any files with extensions exe , com , cmd or bat as executable. file exists name : Returns 1 if file name exists and the current user has search privileges for the directories leading to it, 0 otherwise. file extension name : Returns all of the characters in name after and including the last dot in the last element of name . If there is no dot in the last element of name then returns the empty string. file home ? username ? : If no argument is specified, the command returns the home directory of the current user. This is generally the value of the \\$HOME environment variable except that on Windows platforms backslashes in the path are replaced by forward slashes. An error is raised if the \\$HOME environment variable is not set. If username is specified, the command returns the home directory configured in the system for the specified user. Note this may be different than the value of the \\$HOME environment variable even when username corresponds to the current user. An error is raised if the username does not correspond to a user account on the system. file isdirectory name : Returns 1 if file name is a directory, 0 otherwise. file isfile name : Returns 1 if file name is a regular file, 0 otherwise. file join name ? name ... ? : Takes one or more file names and combines them, using the correct path separator for the current platform. If a particular name is relative, then it will be joined to the previous file name argument. Otherwise, any earlier arguments will be discarded, and joining will proceed from the current argument. For example, **file join** a b /foo bar returns **/foo/bar**. Note that any of the names can contain separators, and that the result is always canonical for the current platform: **/** for Unix and Windows. file link ? -linktype ? linkName ? target ? : If only one argument is given, that argument is assumed to be linkName , and this command returns the value of the link given by linkName (i.e. the name of the file it points to). If linkName is not a link or its value cannot be read (as, for example, seems to be the case with hard links, which look just like ordinary files), then an error is returned. If 2 arguments are given, then these are assumed to be *linkName* and *target*. If *linkName* already exists, or if *target* does not exist, an error will be returned. Otherwise, Tcl creates a new link called *linkName* which points to the existing filesystem object at *target* (which is also the returned value), where the type of the link is platform-specific (on Unix a symbolic link will be the default). This is useful for the case where the user wishes to create a link in a cross-platform way, and does not care what type of link is created. If the user wishes to make a link of a specific type only, (and signal an error if for some reason that is not possible), then the optional *-linktype* argument should be given. Accepted values for *-linktype* are and On Unix, symbolic links can be made to relative paths, and those paths must be relative to the actual *linkName*\\'s location (not to the cwd), but on all other platforms where relative links are not supported, target paths will always be converted to absolute, normalized form before the link is created (and therefore relative paths are interpreted as relative to the cwd). When creating links on filesystems that either do not support any links, or do not support the specific type requested, an error message will be returned. Most Unix platforms support both symbolic and hard links (the latter for files only). Windows supports symbolic directory links and hard file links on NTFS drives. file lstat name ?varName? : Same as stat option (see below) except uses the lstat kernel call instead of stat . This means that if name refers to a symbolic link the information returned is for the link rather than the file it refers to. On systems that do not support symbolic links this option behaves exactly the same as the stat option. file mkdir ? dir ...? : Creates each directory specified. For each pathname dir specified, this command will create all non-existing parent directories as well as dir itself. If an existing directory is specified, then no action is taken and no error is returned. Trying to overwrite an existing file with a directory will result in an error. Arguments are processed in the order specified, halting at the first error, if any. file mtime name ? time ? : Returns a decimal string giving the time at which file name was last modified. If time is specified, it is a modification time to set for the file (equivalent to Unix touch ). The time is measured in the standard POSIX fashion as seconds from a fixed starting time (often January 1, 1970). If the file does not exist or its modified time cannot be queried or set then an error is generated. file nativename name : Returns the platform-specific name of the file. This is useful if the filename is needed to pass to a platform-specific call, such as to a subprocess via exec under Windows (see EXAMPLES below). file normalize name : Returns a unique normalized path representation for the file-system object (file, directory, link, etc), whose string value can be used as a unique identifier for it. A normalized path is an absolute path which has all and removed. Also it is one which is in the format for the native platform. On Unix, this means the segments leading up to the path must be free of symbolic links/aliases (but the very last path component may be a symbolic link), and on Windows it also means we want the long form with that form\\'s case-dependence (which gives us a unique, case-dependent path). The one exception concerning the last link in the path is necessary, because Tcl or the user may wish to operate on the actual symbolic link itself (for example file delete , file rename , file copy are defined to operate on symbolic links, not on the things that they point to). file owned name : Returns 1 if file name is owned by the current user, 0 otherwise. file pathtype name : Returns one of absolute , relative , volumerelative . If name refers to a specific file on a specific volume, the path type will be absolute . If name refers to a file relative to the current working directory, then the path type will be relative . If name refers to a file relative to the current working directory on a specified volume, or to a specific file on the current working volume, then the path type is volumerelative . file readable name : Returns 1 if file name is readable by the current user, 0 otherwise. file readlink name : Returns the value of the symbolic link given by name (i.e. the name of the file it points to). If name is not a symbolic link or its value cannot be read, then an error is returned. On systems that do not support symbolic links this option is undefined. file rename ? -force ? ? -\u2006- ? source target : file rename ? -force ? ? -\u2006- ? source ? source ...? targetDir : The first form takes the file or directory specified by pathname source and renames it to target , moving the file if the pathname target specifies a name in a different directory. If target is an existing directory, then the second form is used. The second form moves each source file or directory into the directory targetDir . Existing files will not be overwritten unless the -force option is specified. When operating inside a single filesystem, Tcl will rename symbolic links rather than the things that they point to. Trying to overwrite a non-empty directory, overwrite a directory with a file, or a file with a directory will all result in errors. Arguments are processed in the order specified, halting at the first error, if any. A -\u2006- marks the end of switches; the argument following the -\u2006- will be treated as a source even if it starts with a - . file rootname name : Returns all of the characters in name up to but not including the last character in the last component of name. If the last component of name does not contain a dot, then returns name . file separator ? name ? : If no argument is given, returns the character which is used to separate path segments for native files on this platform. If a path is given, the filesystem responsible for that path is asked to return its separator character. If no file system accepts name , an error is generated. file size name : Returns a decimal string giving the size of file name in bytes. If the file does not exist or its size cannot be queried then an error is generated. file split name : Returns a list whose elements are the path components in name . The first element of the list will have the same path type as name . All other elements will be relative. Path separators will be discarded unless they are needed to ensure that an element is unambiguously relative. file stat name ?varName? : Invokes the stat kernel call on name , and returns a dictionary with the information returned from the kernel call. If varName is given, it uses the variable to hold the information. VarName is treated as an array variable, and in such case the command returns the empty string. The following elements are set: atime , ctime , dev , gid , ino , mode , mtime , nlink , size , type , uid . Each element except type is a decimal string with the value of the corresponding field from the stat return structure; see the manual entry for stat for details on the meanings of the values. The type element gives the type of the file in the same form returned by the command file type . file system name : Returns a list of one or two elements, the first of which is the name of the filesystem to use for the file, and the second, if given, an arbitrary string representing the filesystem-specific nature or type of the location within that filesystem. If a filesystem only supports one type of file, the second element may not be supplied. For example the native files have a first element and a second element which when given is a platform-specific type name for the file\\'s system (e.g. on Windows). A generic virtual file system might return the list to represent a file on a remote ftp site mounted as a virtual filesystem through an extension called If the file does not belong to any filesystem, an error is generated. file tail name : Returns all of the characters in the last filesystem component of name . Any trailing directory separator in name is ignored. If name contains no separators then returns name . So, file tail a/b , file tail a/b/ and file tail b all return b . file tempdir ? template ? : Creates a temporary directory (guaranteed to be newly created and writable by the current script) and returns its name. If template is given, it specifies one of or both of the existing directory (on a filesystem controlled by the operating system) to contain the temporary directory, and the base part of the directory name; it is considered to have the location of the directory if there is a directory separator in the name, and the base part is everything after the last directory separator (if non-empty). The default containing directory is determined by system-specific operations, and the default base name prefix is The following output is typical and illustrative; the actual output will vary between platforms: \\% file tempdir /var/tmp/tcl_u0kuy5 % file tempdir /tmp/myapp /tmp/myapp_8o7r9L % file tempdir /tmp/ /tmp/tcl_1mOJHD % file tempdir myapp /var/tmp/myapp_0ihS0n file tempfile ? nameVar ? ? template ? : Creates a temporary file and returns a read-write channel opened on that file. If the nameVar is given, it specifies a variable that the name of the temporary file will be written into; if absent, Tcl will attempt to arrange for the temporary file to be deleted once it is no longer required. If the template is present, it specifies parts of the template of the filename to use when creating it (such as the directory, base-name or extension) though some platforms may ignore some or all of these parts and use a built-in default instead. Note that temporary files are *only* ever created on the native filesystem. As such, they can be relied upon to be used with operating-system native APIs and external programs that require a filename. file tildeexpand name : Returns the result of performing tilde substitution on name . If the name begins with a tilde, then the file name will be interpreted as if the first element is replaced with the location of the home directory for the given user. If the tilde is followed immediately by a path separator, the \\$HOME environment variable is substituted. Otherwise the characters between the tilde and the next separator are taken as a user name, which is used to retrieve the user\\'s home directory for substitution. An error is raised if the \\$HOME environment variable or user does not exist. If the file name does not begin with a tilde, it is returned unmodified. file type name : Returns a string giving the type of file name , which will be one of file , directory , characterSpecial , blockSpecial , fifo , link , or socket . file volumes : Returns the absolute paths to the volumes mounted on the system, as a proper Tcl list. Without any virtual filesystems mounted as root volumes, on UNIX, the command will always return since all filesystems are locally mounted. On Windows, it will return a list of the available local drives (e.g. If any virtual filesystem has mounted additional volumes, they will be in the returned list. file writable name : Returns 1 if file name is writable by the current user, 0 otherwise.","title":"DESCRIPTION"},{"location":"file/#portability-issues","text":"Unix \u2007\u2007\u2007\u2007\u2007\u2007\u2007 : These commands always operate using the real user and group identifiers, not the effective ones. Windows \u2007\u2007\u2007\u2007 : The file owned subcommand uses the user identifier (SID) of the process token, not the thread token which may be impersonating some other user.","title":"PORTABILITY ISSUES"},{"location":"file/#examples","text":"This procedure shows how to search for C files in a given directory that have a correspondingly-named object file in the current directory: proc findMatchingCFiles {dir} { set files {} switch \\$::tcl_platform(platform) { windows { set ext .obj } unix { set ext .o } } foreach file [glob -nocomplain -directory \\$dir *.c] { set objectFile [ file tail [ file rootname \\$file]]\\$ext if {[ file exists \\$objectFile]} { lappend files \\$file } } return \\$files } Rename a file and leave a symbolic link pointing from the old location to the new place: set oldName foobar.txt set newName foo/bar.txt # Make sure that where we\\'re going to move to exists... if {![ file isdirectory [ file dirname \\$newName]]} { file mkdir [ file dirname \\$newName] } file rename \\$oldName \\$newName file link -symbolic \\$oldName \\$newName On Windows, a file can be easily enough (equivalent to double-clicking on it in the Explorer interface) but the name passed to the operating system must be in native format: exec {*}[auto_execok start] {} [ file nativename C:/Users/fred/example.txt]","title":"EXAMPLES"},{"location":"file/#see-also","text":"filename(n), open(n), close(n), eof(n), gets(n), tell(n), seek(n), fblocked(n), flush(n)","title":"SEE ALSO"},{"location":"file/#keywords","text":"attributes, copy files, delete files, directory, file, move files, name, rename files, stat, user","title":"KEYWORDS"},{"location":"fileevent/","text":"NAME fileevent - Execute a script when a channel becomes readable or writable SYNOPSIS fileevent channelId readable ? script ? fileevent channelId writable ? script ? DESCRIPTION This command is used to create file event handlers . A file event handler is a binding between a channel and a script, such that the script is evaluated whenever the channel becomes readable or writable. File event handlers are most commonly used to allow data to be received from another process on an event-driven basis, so that the receiver can continue to interact with the user while waiting for the data to arrive. If an application invokes gets or read on a blocking channel when there is no input data available, the process will block; until the input data arrives, it will not be able to service other events, so it will appear to the user to With fileevent , the process can tell when data is present and only invoke gets or read when they will not block. The channelId argument to fileevent refers to an open channel such as a Tcl standard channel ( stdin , stdout , or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. If the script argument is specified, then fileevent creates a new event handler: script will be evaluated whenever the channel becomes readable or writable (depending on the second argument to fileevent ). In this case fileevent returns an empty string. The readable and writable event handlers for a file are independent, and may be created and deleted separately. However, there may be at most one readable and one writable handler for a file at a given time in a given interpreter. If fileevent is called when the specified handler already exists in the invoking interpreter, the new script replaces the old one. If the script argument is not specified, fileevent returns the current script for channelId , or an empty string if there is none. If the script argument is specified as an empty string then the event handler is deleted, so that no script will be invoked. A file event handler is also deleted automatically whenever its channel is closed or its interpreter is deleted. A channel is considered to be readable if there is unread data available on the underlying device. A channel is also considered to be readable if there is unread data in an input buffer, except in the special case where the most recent attempt to read from the channel was a gets call that could not find a complete line in the input buffer. This feature allows a file to be read a line at a time in nonblocking mode using events. A channel is also considered to be readable if an end of file or error condition is present on the underlying file or device. It is important for script to check for these conditions and handle them appropriately; for example, if there is no special check for end of file, an infinite loop may occur where script reads no data, returns, and is immediately invoked again. A channel is considered to be writable if at least one byte of data can be written to the underlying file or device without blocking, or if an error condition is present on the underlying file or device. Event-driven I/O works best for channels that have been placed into nonblocking mode with the fconfigure command. In blocking mode, a puts command may block if you give it more data than the underlying file or device can accept, and a gets or read command will block if you attempt to read more data than is ready; a readable underlying file or device may not even guarantee that a blocking [read 1] will succeed (counter-examples being multi-byte encodings, compression or encryption transforms ). In all such cases, no events will be processed while the commands block. In nonblocking mode puts , read , and gets never block. See the documentation for the individual commands for information on how they handle blocking and nonblocking channels. Testing for the end of file condition should be done after any attempts read the channel data. The eof flag is set once an attempt to read the end of data has occurred and testing before this read will require an additional event to be fired. The script for a file event is executed at global level (outside the context of any Tcl procedure) in the interpreter in which the fileevent command was invoked. If an error occurs while executing the script then the command registered with interp bgerror is used to report the error. In addition, the file event handler is deleted if it ever returns an error; this is done in order to prevent infinite loops due to buggy handlers. EXAMPLE In this setup GetData will be called with the channel as an argument whenever \\$chan becomes readable. The read call will read whatever binary data is currently available without blocking. Here the channel has the fileevent removed when an end of file occurs to avoid being continually called (see above). Alternatively the channel may be closed on this condition. proc GetData {chan} { set data [read \\$chan] puts \\\"[string length \\$data] \\$data\\\" if {[eof \\$chan]} { fileevent \\$chan readable {} } } fconfigure \\$chan -blocking 0 -encoding binary fileevent \\$chan readable [list GetData \\$chan] The next example demonstrates use of gets to read line-oriented data. proc GetData {chan} { if {[gets \\$chan line] >= 0} { puts \\$line } if {[eof \\$chan]} { close \\$chan } } fconfigure \\$chan -blocking 0 -buffering line -translation crlf fileevent \\$chan readable [list GetData \\$chan] CREDITS fileevent is based on the addinput command created by Mark Diekhans. SEE ALSO fconfigure(n), gets(n), interp(n), puts(n), read(n), Tcl_StandardChannels(3) KEYWORDS asynchronous I/O, blocking, channel, event handler, nonblocking, readable, script, writable.","title":"NAME"},{"location":"fileevent/#name","text":"fileevent - Execute a script when a channel becomes readable or writable","title":"NAME"},{"location":"fileevent/#synopsis","text":"fileevent channelId readable ? script ? fileevent channelId writable ? script ?","title":"SYNOPSIS"},{"location":"fileevent/#description","text":"This command is used to create file event handlers . A file event handler is a binding between a channel and a script, such that the script is evaluated whenever the channel becomes readable or writable. File event handlers are most commonly used to allow data to be received from another process on an event-driven basis, so that the receiver can continue to interact with the user while waiting for the data to arrive. If an application invokes gets or read on a blocking channel when there is no input data available, the process will block; until the input data arrives, it will not be able to service other events, so it will appear to the user to With fileevent , the process can tell when data is present and only invoke gets or read when they will not block. The channelId argument to fileevent refers to an open channel such as a Tcl standard channel ( stdin , stdout , or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. If the script argument is specified, then fileevent creates a new event handler: script will be evaluated whenever the channel becomes readable or writable (depending on the second argument to fileevent ). In this case fileevent returns an empty string. The readable and writable event handlers for a file are independent, and may be created and deleted separately. However, there may be at most one readable and one writable handler for a file at a given time in a given interpreter. If fileevent is called when the specified handler already exists in the invoking interpreter, the new script replaces the old one. If the script argument is not specified, fileevent returns the current script for channelId , or an empty string if there is none. If the script argument is specified as an empty string then the event handler is deleted, so that no script will be invoked. A file event handler is also deleted automatically whenever its channel is closed or its interpreter is deleted. A channel is considered to be readable if there is unread data available on the underlying device. A channel is also considered to be readable if there is unread data in an input buffer, except in the special case where the most recent attempt to read from the channel was a gets call that could not find a complete line in the input buffer. This feature allows a file to be read a line at a time in nonblocking mode using events. A channel is also considered to be readable if an end of file or error condition is present on the underlying file or device. It is important for script to check for these conditions and handle them appropriately; for example, if there is no special check for end of file, an infinite loop may occur where script reads no data, returns, and is immediately invoked again. A channel is considered to be writable if at least one byte of data can be written to the underlying file or device without blocking, or if an error condition is present on the underlying file or device. Event-driven I/O works best for channels that have been placed into nonblocking mode with the fconfigure command. In blocking mode, a puts command may block if you give it more data than the underlying file or device can accept, and a gets or read command will block if you attempt to read more data than is ready; a readable underlying file or device may not even guarantee that a blocking [read 1] will succeed (counter-examples being multi-byte encodings, compression or encryption transforms ). In all such cases, no events will be processed while the commands block. In nonblocking mode puts , read , and gets never block. See the documentation for the individual commands for information on how they handle blocking and nonblocking channels. Testing for the end of file condition should be done after any attempts read the channel data. The eof flag is set once an attempt to read the end of data has occurred and testing before this read will require an additional event to be fired. The script for a file event is executed at global level (outside the context of any Tcl procedure) in the interpreter in which the fileevent command was invoked. If an error occurs while executing the script then the command registered with interp bgerror is used to report the error. In addition, the file event handler is deleted if it ever returns an error; this is done in order to prevent infinite loops due to buggy handlers.","title":"DESCRIPTION"},{"location":"fileevent/#example","text":"In this setup GetData will be called with the channel as an argument whenever \\$chan becomes readable. The read call will read whatever binary data is currently available without blocking. Here the channel has the fileevent removed when an end of file occurs to avoid being continually called (see above). Alternatively the channel may be closed on this condition. proc GetData {chan} { set data [read \\$chan] puts \\\"[string length \\$data] \\$data\\\" if {[eof \\$chan]} { fileevent \\$chan readable {} } } fconfigure \\$chan -blocking 0 -encoding binary fileevent \\$chan readable [list GetData \\$chan] The next example demonstrates use of gets to read line-oriented data. proc GetData {chan} { if {[gets \\$chan line] >= 0} { puts \\$line } if {[eof \\$chan]} { close \\$chan } } fconfigure \\$chan -blocking 0 -buffering line -translation crlf fileevent \\$chan readable [list GetData \\$chan]","title":"EXAMPLE"},{"location":"fileevent/#credits","text":"fileevent is based on the addinput command created by Mark Diekhans.","title":"CREDITS"},{"location":"fileevent/#see-also","text":"fconfigure(n), gets(n), interp(n), puts(n), read(n), Tcl_StandardChannels(3)","title":"SEE ALSO"},{"location":"fileevent/#keywords","text":"asynchronous I/O, blocking, channel, event handler, nonblocking, readable, script, writable.","title":"KEYWORDS"},{"location":"filename/","text":"NAME filename - File name conventions supported by Tcl commands INTRODUCTION All Tcl commands and C procedures that take file names as arguments expect the file names to be in one of three forms, depending on the current platform. On each platform, Tcl supports file names in the standard forms(s) for that platform. In addition, on all platforms, Tcl supports a Unix-like syntax intended to provide a convenient way of constructing simple file names. However, scripts that are intended to be portable should not assume a particular form for file names. Instead, portable scripts must use the file split and file join commands to manipulate file names (see the file manual entry for more details). PATH TYPES File names are grouped into three general types based on the starting point for the path used to specify the file: absolute, relative, and volume-relative. Absolute names are completely qualified, giving a path to the file relative to a particular volume and the root directory on that volume. Relative names are unqualified, giving a path to the file relative to the current working directory. Volume-relative names are partially qualified, either giving the path relative to the root directory on the current volume, or relative to the current directory of the specified volume. The file pathtype command can be used to determine the type of a given path. PATH SYNTAX The rules for native names depend on the value reported in the Tcl platform element of the tcl_platform array: Unix : On Unix and Apple MacOS X platforms, Tcl uses path names where the components are separated by slashes. Path names may be relative or absolute, and file names may contain any character other than slash. The file names . and .. are special and refer to the current directory and the parent of the current directory respectively. Multiple adjacent slash characters are interpreted as a single separator, except for the first double slash // in absolute paths. Any number of trailing slash characters at the end of a path are simply ignored, so the paths foo , foo/ and foo// are all identical, and in particular foo/ does not necessarily mean a directory is being referred. The following examples illustrate various forms of path names: **/** : Absolute path to the root directory. **/etc/passwd** : Absolute path to the file named **passwd** in the directory **etc** in the root directory. **.** : Relative path to the current directory. **foo** : Relative path to the file **foo** in the current directory. **foo/bar** : Relative path to the file **bar** in the directory **foo** in the current directory. **../foo** : Relative path to the file **foo** in the directory above the current directory. Windows : On Microsoft Windows platforms, Tcl supports both drive-relative and UNC style names. Both / and \\ may be used as directory separators in either type of name. Drive-relative names consist of an optional drive specifier followed by an absolute or relative path. UNC paths follow the general form \\\\servername\\sharename\\path\\file , but must at the very least contain the server and share components, i.e. \\\\servername\\sharename . In both forms, the file names . and .. are special and refer to the current directory and the parent of the current directory respectively. The following examples illustrate various forms of path names: **\\\\\\\\Host\\\\share/file** : Absolute UNC path to a file called **file** in the root directory of the export point **share** on the host **Host**. Note that repeated use of **file dirname** on this path will give **//Host/share**, and will never give just **//Host**. **c:foo** : Volume-relative path to a file **foo** in the current directory on drive **c**. **c:/foo** : Absolute path to a file **foo** in the root directory of drive **c**. **foo\\\\bar** : Relative path to a file **bar** in the **foo** directory in the current directory on the current volume. **\\\\foo** : Volume-relative path to a file **foo** in the root directory of the current volume. **\\\\\\\\foo** : Volume-relative path to a file **foo** in the root directory of the current volume. This is not a valid UNC path, so the assumption is that the extra backslashes are superfluous. PORTABILITY ISSUES Not all file systems are case sensitive, so scripts should avoid code that depends on the case of characters in a file name. In addition, the character sets allowed on different devices may differ, so scripts should choose file names that do not contain special characters like: \\<>:?\\\"/\\| . The safest approach is to use names consisting of alphanumeric characters only. Care should be taken with filenames which contain spaces (common on Windows systems) and filenames where the backslash is the directory separator (Windows native path names). On Windows platforms there are file and path length restrictions. Complete paths or filenames longer than about 260 characters will lead to errors in most file operations. Another Windows peculiarity is that any number of trailing dots in filenames are totally ignored, so, for example, attempts to create a file or directory with a name will result in the creation of a file/directory with name This fact is reflected in the results of file normalize . Furthermore, a file name consisting only of dots or dots with trailing characters is illegal. SEE ALSO file(n), glob(n) KEYWORDS current directory, absolute file name, relative file name, volume-relative file name, portability","title":"NAME"},{"location":"filename/#name","text":"filename - File name conventions supported by Tcl commands","title":"NAME"},{"location":"filename/#introduction","text":"All Tcl commands and C procedures that take file names as arguments expect the file names to be in one of three forms, depending on the current platform. On each platform, Tcl supports file names in the standard forms(s) for that platform. In addition, on all platforms, Tcl supports a Unix-like syntax intended to provide a convenient way of constructing simple file names. However, scripts that are intended to be portable should not assume a particular form for file names. Instead, portable scripts must use the file split and file join commands to manipulate file names (see the file manual entry for more details).","title":"INTRODUCTION"},{"location":"filename/#path-types","text":"File names are grouped into three general types based on the starting point for the path used to specify the file: absolute, relative, and volume-relative. Absolute names are completely qualified, giving a path to the file relative to a particular volume and the root directory on that volume. Relative names are unqualified, giving a path to the file relative to the current working directory. Volume-relative names are partially qualified, either giving the path relative to the root directory on the current volume, or relative to the current directory of the specified volume. The file pathtype command can be used to determine the type of a given path.","title":"PATH TYPES"},{"location":"filename/#path-syntax","text":"The rules for native names depend on the value reported in the Tcl platform element of the tcl_platform array: Unix : On Unix and Apple MacOS X platforms, Tcl uses path names where the components are separated by slashes. Path names may be relative or absolute, and file names may contain any character other than slash. The file names . and .. are special and refer to the current directory and the parent of the current directory respectively. Multiple adjacent slash characters are interpreted as a single separator, except for the first double slash // in absolute paths. Any number of trailing slash characters at the end of a path are simply ignored, so the paths foo , foo/ and foo// are all identical, and in particular foo/ does not necessarily mean a directory is being referred. The following examples illustrate various forms of path names: **/** : Absolute path to the root directory. **/etc/passwd** : Absolute path to the file named **passwd** in the directory **etc** in the root directory. **.** : Relative path to the current directory. **foo** : Relative path to the file **foo** in the current directory. **foo/bar** : Relative path to the file **bar** in the directory **foo** in the current directory. **../foo** : Relative path to the file **foo** in the directory above the current directory. Windows : On Microsoft Windows platforms, Tcl supports both drive-relative and UNC style names. Both / and \\ may be used as directory separators in either type of name. Drive-relative names consist of an optional drive specifier followed by an absolute or relative path. UNC paths follow the general form \\\\servername\\sharename\\path\\file , but must at the very least contain the server and share components, i.e. \\\\servername\\sharename . In both forms, the file names . and .. are special and refer to the current directory and the parent of the current directory respectively. The following examples illustrate various forms of path names: **\\\\\\\\Host\\\\share/file** : Absolute UNC path to a file called **file** in the root directory of the export point **share** on the host **Host**. Note that repeated use of **file dirname** on this path will give **//Host/share**, and will never give just **//Host**. **c:foo** : Volume-relative path to a file **foo** in the current directory on drive **c**. **c:/foo** : Absolute path to a file **foo** in the root directory of drive **c**. **foo\\\\bar** : Relative path to a file **bar** in the **foo** directory in the current directory on the current volume. **\\\\foo** : Volume-relative path to a file **foo** in the root directory of the current volume. **\\\\\\\\foo** : Volume-relative path to a file **foo** in the root directory of the current volume. This is not a valid UNC path, so the assumption is that the extra backslashes are superfluous.","title":"PATH SYNTAX"},{"location":"filename/#portability-issues","text":"Not all file systems are case sensitive, so scripts should avoid code that depends on the case of characters in a file name. In addition, the character sets allowed on different devices may differ, so scripts should choose file names that do not contain special characters like: \\<>:?\\\"/\\| . The safest approach is to use names consisting of alphanumeric characters only. Care should be taken with filenames which contain spaces (common on Windows systems) and filenames where the backslash is the directory separator (Windows native path names). On Windows platforms there are file and path length restrictions. Complete paths or filenames longer than about 260 characters will lead to errors in most file operations. Another Windows peculiarity is that any number of trailing dots in filenames are totally ignored, so, for example, attempts to create a file or directory with a name will result in the creation of a file/directory with name This fact is reflected in the results of file normalize . Furthermore, a file name consisting only of dots or dots with trailing characters is illegal.","title":"PORTABILITY ISSUES"},{"location":"filename/#see-also","text":"file(n), glob(n)","title":"SEE ALSO"},{"location":"filename/#keywords","text":"current directory, absolute file name, relative file name, volume-relative file name, portability","title":"KEYWORDS"},{"location":"flush/","text":"NAME flush - Flush buffered output for a channel SYNOPSIS flush channelId DESCRIPTION Flushes any output that has been buffered for channelId . ChannelId must be an identifier for an open channel such as a Tcl standard channel ( stdout or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. The channel must have been opened for writing. If the channel is in blocking mode the command does not return until all the buffered output has been flushed to the channel. If the channel is in nonblocking mode, the command may return before all buffered output has been flushed; the remainder will be flushed in the background as fast as the underlying file or device is able to absorb it. EXAMPLE Prompt for the user to type some information in on the console: puts -nonewline \\\"Please type your name: \\\" flush stdout gets stdin name puts \\\"Hello there, \\$name!\\\" SEE ALSO file(n), open(n), socket(n), Tcl_StandardChannels(3) KEYWORDS blocking, buffer, channel, flush, nonblocking, output","title":"NAME"},{"location":"flush/#name","text":"flush - Flush buffered output for a channel","title":"NAME"},{"location":"flush/#synopsis","text":"flush channelId","title":"SYNOPSIS"},{"location":"flush/#description","text":"Flushes any output that has been buffered for channelId . ChannelId must be an identifier for an open channel such as a Tcl standard channel ( stdout or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. The channel must have been opened for writing. If the channel is in blocking mode the command does not return until all the buffered output has been flushed to the channel. If the channel is in nonblocking mode, the command may return before all buffered output has been flushed; the remainder will be flushed in the background as fast as the underlying file or device is able to absorb it.","title":"DESCRIPTION"},{"location":"flush/#example","text":"Prompt for the user to type some information in on the console: puts -nonewline \\\"Please type your name: \\\" flush stdout gets stdin name puts \\\"Hello there, \\$name!\\\"","title":"EXAMPLE"},{"location":"flush/#see-also","text":"file(n), open(n), socket(n), Tcl_StandardChannels(3)","title":"SEE ALSO"},{"location":"flush/#keywords","text":"blocking, buffer, channel, flush, nonblocking, output","title":"KEYWORDS"},{"location":"for/","text":"NAME for - \\'For\\' loop SYNOPSIS for start test next body DESCRIPTION For is a looping command, similar in structure to the C for statement. The start , next , and body arguments must be Tcl command strings, and test is an expression string. The for command first invokes the Tcl interpreter to execute start . Then it repeatedly evaluates test as an expression; if the result is non-zero it invokes the Tcl interpreter on body , then invokes the Tcl interpreter on next , then repeats the loop. The command terminates when test evaluates to 0. If a continue command is invoked within body then any remaining commands in the current execution of body are skipped; processing continues by invoking the Tcl interpreter on next , then evaluating test , and so on. If a break command is invoked within body or next , then the for command will return immediately. The operation of break and continue are similar to the corresponding statements in C. For returns an empty string. Note: test should almost always be enclosed in braces. If not, variable substitutions will be made before the for command starts executing, which means that variable changes made by the loop body will not be considered in the expression. This is likely to result in an infinite loop. If test is enclosed in braces, variable substitutions are delayed until the expression is evaluated (before each loop iteration), so changes in the variables will be visible. See below for an example: EXAMPLES Print a line for each of the integers from 0 to 9: for {set x 0} {\\$x\\<10} {incr x} { puts \\\"x is \\$x\\\" } Either loop infinitely or not at all because the expression being evaluated is actually the constant, or even generate an error! The actual behaviour will depend on whether the variable x exists before the for command is run and whether its value is a value that is less than or greater than/equal to ten, and this is because the expression will be substituted before the for command is executed. for {set x 0} \\$x\\<10 {incr x} { puts \\\"x is \\$x\\\" } Print out the powers of two from 1 to 1024: for {set x 1} {\\$x\\<=1024} {set x [expr {\\$x * 2}]} { puts \\\"x is \\$x\\\" } SEE ALSO break(n), continue(n), foreach(n), while(n) KEYWORDS boolean, for, iteration, loop","title":"NAME"},{"location":"for/#name","text":"for - \\'For\\' loop","title":"NAME"},{"location":"for/#synopsis","text":"for start test next body","title":"SYNOPSIS"},{"location":"for/#description","text":"For is a looping command, similar in structure to the C for statement. The start , next , and body arguments must be Tcl command strings, and test is an expression string. The for command first invokes the Tcl interpreter to execute start . Then it repeatedly evaluates test as an expression; if the result is non-zero it invokes the Tcl interpreter on body , then invokes the Tcl interpreter on next , then repeats the loop. The command terminates when test evaluates to 0. If a continue command is invoked within body then any remaining commands in the current execution of body are skipped; processing continues by invoking the Tcl interpreter on next , then evaluating test , and so on. If a break command is invoked within body or next , then the for command will return immediately. The operation of break and continue are similar to the corresponding statements in C. For returns an empty string. Note: test should almost always be enclosed in braces. If not, variable substitutions will be made before the for command starts executing, which means that variable changes made by the loop body will not be considered in the expression. This is likely to result in an infinite loop. If test is enclosed in braces, variable substitutions are delayed until the expression is evaluated (before each loop iteration), so changes in the variables will be visible. See below for an example:","title":"DESCRIPTION"},{"location":"for/#examples","text":"Print a line for each of the integers from 0 to 9: for {set x 0} {\\$x\\<10} {incr x} { puts \\\"x is \\$x\\\" } Either loop infinitely or not at all because the expression being evaluated is actually the constant, or even generate an error! The actual behaviour will depend on whether the variable x exists before the for command is run and whether its value is a value that is less than or greater than/equal to ten, and this is because the expression will be substituted before the for command is executed. for {set x 0} \\$x\\<10 {incr x} { puts \\\"x is \\$x\\\" } Print out the powers of two from 1 to 1024: for {set x 1} {\\$x\\<=1024} {set x [expr {\\$x * 2}]} { puts \\\"x is \\$x\\\" }","title":"EXAMPLES"},{"location":"for/#see-also","text":"break(n), continue(n), foreach(n), while(n)","title":"SEE ALSO"},{"location":"for/#keywords","text":"boolean, for, iteration, loop","title":"KEYWORDS"},{"location":"foreach/","text":"NAME foreach - Iterate over all elements in one or more lists SYNOPSIS foreach varname list body \\ foreach varlist1 list1 ? varlist2 list2 ... ? body DESCRIPTION The foreach command implements a loop where the loop variable(s) take on values from one or more lists. In the simplest case there is one loop variable, varname , and one list, list , that is a list of values to assign to varname . The body argument is a Tcl script. For each element of list (in order from first to last), foreach assigns the contents of the element to varname as if the lindex command had been used to extract the element, then calls the Tcl interpreter to execute body . In the general case there can be more than one value list (e.g., list1 and list2 ), and each value list can be associated with a list of loop variables (e.g., varlist1 and varlist2 ). During each iteration of the loop the variables of each varlist are assigned consecutive values from the corresponding list . Values in each list are used in order from first to last, and each value is used exactly once. The total number of loop iterations is large enough to use up all the values from all the value lists. If a value list does not contain enough elements for each of its loop variables in each iteration, empty values are used for the missing elements. The break and continue statements may be invoked inside body , with the same effect as in the for command. Foreach returns an empty string. EXAMPLES This loop prints every value in a list together with the square and cube of the value: set values {1 3 5 7 2 4 6 8} ;# Odd numbers first, for fun! puts \\\"Value\\tSquare\\tCube\\\" ;# Neat-looking header foreach x \\$values { ;# Now loop and print... puts \\\" \\$x\\t [expr {\\$x**2}]\\t [expr {\\$x**3}]\\\" } The following loop uses i and j as loop variables to iterate over pairs of elements of a single list. set x {} foreach {i j} {a b c d e f} { lappend x \\$j \\$i } # The value of x is \\\"b a d c f e\\\" # There are 3 iterations of the loop. The next loop uses i and j to iterate over two lists in parallel. set x {} foreach i {a b c} j {d e f g} { lappend x \\$i \\$j } # The value of x is \\\"a d b e c f {} g\\\" # There are 4 iterations of the loop. The two forms are combined in the following example. set x {} foreach i {a b c} {j k} {d e f g} { lappend x \\$i \\$j \\$k } # The value of x is \\\"a d e b f g c {} {}\\\" # There are 3 iterations of the loop. SEE ALSO for(n), while(n), break(n), continue(n) KEYWORDS foreach, iteration, list, loop","title":"NAME"},{"location":"foreach/#name","text":"foreach - Iterate over all elements in one or more lists","title":"NAME"},{"location":"foreach/#synopsis","text":"foreach varname list body \\ foreach varlist1 list1 ? varlist2 list2 ... ? body","title":"SYNOPSIS"},{"location":"foreach/#description","text":"The foreach command implements a loop where the loop variable(s) take on values from one or more lists. In the simplest case there is one loop variable, varname , and one list, list , that is a list of values to assign to varname . The body argument is a Tcl script. For each element of list (in order from first to last), foreach assigns the contents of the element to varname as if the lindex command had been used to extract the element, then calls the Tcl interpreter to execute body . In the general case there can be more than one value list (e.g., list1 and list2 ), and each value list can be associated with a list of loop variables (e.g., varlist1 and varlist2 ). During each iteration of the loop the variables of each varlist are assigned consecutive values from the corresponding list . Values in each list are used in order from first to last, and each value is used exactly once. The total number of loop iterations is large enough to use up all the values from all the value lists. If a value list does not contain enough elements for each of its loop variables in each iteration, empty values are used for the missing elements. The break and continue statements may be invoked inside body , with the same effect as in the for command. Foreach returns an empty string.","title":"DESCRIPTION"},{"location":"foreach/#examples","text":"This loop prints every value in a list together with the square and cube of the value: set values {1 3 5 7 2 4 6 8} ;# Odd numbers first, for fun! puts \\\"Value\\tSquare\\tCube\\\" ;# Neat-looking header foreach x \\$values { ;# Now loop and print... puts \\\" \\$x\\t [expr {\\$x**2}]\\t [expr {\\$x**3}]\\\" } The following loop uses i and j as loop variables to iterate over pairs of elements of a single list. set x {} foreach {i j} {a b c d e f} { lappend x \\$j \\$i } # The value of x is \\\"b a d c f e\\\" # There are 3 iterations of the loop. The next loop uses i and j to iterate over two lists in parallel. set x {} foreach i {a b c} j {d e f g} { lappend x \\$i \\$j } # The value of x is \\\"a d b e c f {} g\\\" # There are 4 iterations of the loop. The two forms are combined in the following example. set x {} foreach i {a b c} {j k} {d e f g} { lappend x \\$i \\$j \\$k } # The value of x is \\\"a d e b f g c {} {}\\\" # There are 3 iterations of the loop.","title":"EXAMPLES"},{"location":"foreach/#see-also","text":"for(n), while(n), break(n), continue(n)","title":"SEE ALSO"},{"location":"foreach/#keywords","text":"foreach, iteration, list, loop","title":"KEYWORDS"},{"location":"format/","text":"NAME format - Format a string in the style of sprintf SYNOPSIS format formatString ? arg arg ... ? INTRODUCTION This command generates a formatted string in a fashion similar to the ANSI C sprintf procedure. FormatString indicates how to format the result, using % conversion specifiers as in sprintf , and the additional arguments, if any, provide values to be substituted into the result. The return value from format is the formatted string. DETAILS ON FORMATTING The command operates by scanning formatString from left to right. Each character from the format string is appended to the result string unless it is a percent sign. If the character is a % then it is not copied to the result string. Instead, the characters following the % character are treated as a conversion specifier. The conversion specifier controls the conversion of the next successive arg to a particular format and the result is appended to the result string in place of the conversion specifier. If there are multiple conversion specifiers in the format string, then each one controls the conversion of one additional arg . The format command must be given enough arg s to meet the needs of all of the conversion specifiers in formatString . Each conversion specifier may contain up to six different parts: an XPG3 position specifier, a set of flags, a minimum field width, a precision, a size modifier, and a conversion character. Any of these fields may be omitted except for the conversion character. The fields that are present must appear in the order given above. The paragraphs below discuss each of these fields in turn. OPTIONAL POSITIONAL SPECIFIER If the % is followed by a decimal number and a \\$ , as in then the value to convert is not taken from the next sequential argument. Instead, it is taken from the argument indicated by the number, where 1 corresponds to the first arg . If the conversion specifier requires multiple arguments because of * characters in the specifier then successive arguments are used, starting with the argument given by the number. This follows the XPG3 conventions for positional specifiers. If there are any positional specifiers in formatString then all of the specifiers must be positional. OPTIONAL FLAGS The second portion of a conversion specifier may contain any of the following flag characters, in any order: - : Specifies that the converted argument should be left-justified in its field (numbers are normally right-justified with leading spaces if needed). + : Specifies that a number should always be printed with a sign, even if positive. space : Specifies that a space should be added to the beginning of the number if the first character is not a sign. 0 : Specifies that the number should be padded on the left with zeroes instead of spaces. # : Requests an alternate output form. For o conversions, 0o will be added to the beginning of the result unless it is zero. For x or X conversions, 0x will be added to the beginning of the result unless it is zero. For b conversions, 0b will be added to the beginning of the result unless it is zero. For d conversions, 0d there is no effect unless the 0 specifier is used as well: In that case, 0d will be added to the beginning. For all floating-point conversions ( e , E , f , g , and G ) it guarantees that the result always has a decimal point. For g and G conversions it specifies that trailing zeroes should not be removed. OPTIONAL FIELD WIDTH The third portion of a conversion specifier is a decimal number giving a minimum field width for this conversion. It is typically used to make columns line up in tabular printouts. If the converted argument contains fewer characters than the minimum field width then it will be padded so that it is as wide as the minimum field width. Padding normally occurs by adding extra spaces on the left of the converted argument, but the 0 and - flags may be used to specify padding with zeroes on the left or with spaces on the right, respectively. If the minimum field width is specified as * rather than a number, then the next argument to the format command determines the minimum field width; it must be an integer value. OPTIONAL PRECISION/BOUND The fourth portion of a conversion specifier is a precision, which consists of a period followed by a number. The number is used in different ways for different conversions. For e , E , and f conversions it specifies the number of digits to appear to the right of the decimal point. For g and G conversions it specifies the total number of digits to appear, including those on both sides of the decimal point (however, trailing zeroes after the decimal point will still be omitted unless the # flag has been specified). For integer conversions, it specifies a minimum number of digits to print (leading zeroes will be added if necessary). For s conversions it specifies the maximum number of characters to be printed; if the string is longer than this then the trailing characters will be dropped. If the precision is specified with * rather than a number then the next argument to the format command determines the precision; it must be a numeric string. OPTIONAL SIZE MODIFIER The fifth part of a conversion specifier is a size modifier, which must be ll , h , l , or L . If it is ll it specifies that an integer value is taken without truncation for conversion to a formatted substring. If it is h it specifies that an integer value is truncated to a 16-bit range before converting. This option is rarely useful. If it is l it specifies that the integer value is truncated to the same range as that produced by the wide() function of the expr command (at least a 64-bit range). If it is L it specifies that an integer or double value is taken without truncation for conversion to a formatted substring. If neither h nor l nor L are present, the integer value is truncated to the same range as that produced by the int() function of the expr command (at least a 32-bit range, but determined by the value of the wordSize element of the tcl_platform array). MANDATORY CONVERSION TYPE The last thing in a conversion specifier is an alphabetic character that determines what kind of conversion to perform. The following conversion characters are currently supported: d : Convert integer to signed decimal string. u : Convert integer to unsigned decimal string. i : Convert integer to signed decimal string (equivalent to d ). o : Convert integer to unsigned octal string. x or X : Convert integer to unsigned hexadecimal string, using digits for x and for X ). b : Convert integer to unsigned binary string, using digits 0 and 1. c : Convert integer to the Unicode character it represents. s : No conversion; just insert string. f : Convert number to signed decimal string of the form xx.yyy , where the number of y \\'s is determined by the precision (default: 6). If the precision is 0 then no decimal point is output. e or E : Convert number to scientific notation in the form x.yyy e\u00b1 zz , where the number of y \\'s is determined by the precision (default: 6). If the precision is 0 then no decimal point is output. If the E form is used then E is printed instead of e . g or G : If the exponent is less than -4 or greater than or equal to the precision, then convert number as for %e or %E . Otherwise convert as for %f . Trailing zeroes and a trailing decimal point are omitted. a or A : Convert double to hexadecimal notation in the form 0x1.yyy p\u00b1 zz , where the number of y \\'s is determined by the precision (default: 13). If the A form is used then the hex characters are printed in uppercase. % : No conversion: just insert % . p : Shorthand form for 0x%zx , so it outputs the integer in hexadecimal form with 0x prefix. DIFFERENCES FROM ANSI SPRINTF The behavior of the format command is the same as the ANSI C sprintf procedure except for the following differences: [1] : Tcl guarantees that it will be working with UNICODE characters. [2] : %n specifier is not supported. [3] : For %c conversions the argument must be an integer value, which will then be converted to the corresponding character value. [4] : The size modifiers are ignored when formatting floating-point values. The b specifier has no sprintf counterpart. EXAMPLES Convert the numeric value of a UNICODE character to the character itself: set value 120 set char [ format %c \\$value] Convert the output of time into seconds to an accuracy of hundredths of a second: set us [lindex [time \\$someTclCode] 0] puts [ format \\\"%.2f seconds to execute\\\" [expr {\\$us / 1e6}]] Create a packed X11 literal color specification: # Each color-component should be in range (0..255) set color [ format \\\"#%02x%02x%02x\\\" \\$r \\$g \\$b] Use XPG3 format codes to allow reordering of fields (a technique that is often used in localized message catalogs; see msgcat ) without reordering the data values passed to format : set fmt1 \\\"Today, %d shares in %s were bought at \\$%.2f each\\\" puts [ format \\$fmt1 123 \\\"Global BigCorp\\\" 19.37] set fmt2 \\\"Bought %2\\\\$s equity (\\$%3\\$.2f x %1\\\\$d) today\\\" puts [ format \\$fmt2 123 \\\"Global BigCorp\\\" 19.37] Print a small table of powers of three: # Set up the column widths set w1 5 set w2 10 # Make a nice header (with separator) for the table first set sep +-[string repeat - \\$w1]-+-[string repeat - \\$w2]-+ puts \\$sep puts [ format \\\"| %-*s | %-*s |\\\" \\$w1 \\\"Index\\\" \\$w2 \\\"Power\\\"] puts \\$sep # Print the contents of the table set p 1 for {set i 0} {\\$i\\<=20} {incr i} { puts [ format \\\"| %*d | %*ld |\\\" \\$w1 \\$i \\$w2 \\$p] set p [expr {wide(\\$p) * 3}] } # Finish off by printing the separator again puts \\$sep SEE ALSO scan(n), sprintf(3), string(n) KEYWORDS conversion specifier, format, sprintf, string, substitution","title":"NAME"},{"location":"format/#name","text":"format - Format a string in the style of sprintf","title":"NAME"},{"location":"format/#synopsis","text":"format formatString ? arg arg ... ?","title":"SYNOPSIS"},{"location":"format/#introduction","text":"This command generates a formatted string in a fashion similar to the ANSI C sprintf procedure. FormatString indicates how to format the result, using % conversion specifiers as in sprintf , and the additional arguments, if any, provide values to be substituted into the result. The return value from format is the formatted string.","title":"INTRODUCTION"},{"location":"format/#details-on-formatting","text":"The command operates by scanning formatString from left to right. Each character from the format string is appended to the result string unless it is a percent sign. If the character is a % then it is not copied to the result string. Instead, the characters following the % character are treated as a conversion specifier. The conversion specifier controls the conversion of the next successive arg to a particular format and the result is appended to the result string in place of the conversion specifier. If there are multiple conversion specifiers in the format string, then each one controls the conversion of one additional arg . The format command must be given enough arg s to meet the needs of all of the conversion specifiers in formatString . Each conversion specifier may contain up to six different parts: an XPG3 position specifier, a set of flags, a minimum field width, a precision, a size modifier, and a conversion character. Any of these fields may be omitted except for the conversion character. The fields that are present must appear in the order given above. The paragraphs below discuss each of these fields in turn.","title":"DETAILS ON FORMATTING"},{"location":"format/#optional-positional-specifier","text":"If the % is followed by a decimal number and a \\$ , as in then the value to convert is not taken from the next sequential argument. Instead, it is taken from the argument indicated by the number, where 1 corresponds to the first arg . If the conversion specifier requires multiple arguments because of * characters in the specifier then successive arguments are used, starting with the argument given by the number. This follows the XPG3 conventions for positional specifiers. If there are any positional specifiers in formatString then all of the specifiers must be positional.","title":"OPTIONAL POSITIONAL SPECIFIER"},{"location":"format/#optional-flags","text":"The second portion of a conversion specifier may contain any of the following flag characters, in any order: - : Specifies that the converted argument should be left-justified in its field (numbers are normally right-justified with leading spaces if needed). + : Specifies that a number should always be printed with a sign, even if positive. space : Specifies that a space should be added to the beginning of the number if the first character is not a sign. 0 : Specifies that the number should be padded on the left with zeroes instead of spaces. # : Requests an alternate output form. For o conversions, 0o will be added to the beginning of the result unless it is zero. For x or X conversions, 0x will be added to the beginning of the result unless it is zero. For b conversions, 0b will be added to the beginning of the result unless it is zero. For d conversions, 0d there is no effect unless the 0 specifier is used as well: In that case, 0d will be added to the beginning. For all floating-point conversions ( e , E , f , g , and G ) it guarantees that the result always has a decimal point. For g and G conversions it specifies that trailing zeroes should not be removed.","title":"OPTIONAL FLAGS"},{"location":"format/#optional-field-width","text":"The third portion of a conversion specifier is a decimal number giving a minimum field width for this conversion. It is typically used to make columns line up in tabular printouts. If the converted argument contains fewer characters than the minimum field width then it will be padded so that it is as wide as the minimum field width. Padding normally occurs by adding extra spaces on the left of the converted argument, but the 0 and - flags may be used to specify padding with zeroes on the left or with spaces on the right, respectively. If the minimum field width is specified as * rather than a number, then the next argument to the format command determines the minimum field width; it must be an integer value.","title":"OPTIONAL FIELD WIDTH"},{"location":"format/#optional-precisionbound","text":"The fourth portion of a conversion specifier is a precision, which consists of a period followed by a number. The number is used in different ways for different conversions. For e , E , and f conversions it specifies the number of digits to appear to the right of the decimal point. For g and G conversions it specifies the total number of digits to appear, including those on both sides of the decimal point (however, trailing zeroes after the decimal point will still be omitted unless the # flag has been specified). For integer conversions, it specifies a minimum number of digits to print (leading zeroes will be added if necessary). For s conversions it specifies the maximum number of characters to be printed; if the string is longer than this then the trailing characters will be dropped. If the precision is specified with * rather than a number then the next argument to the format command determines the precision; it must be a numeric string.","title":"OPTIONAL PRECISION/BOUND"},{"location":"format/#optional-size-modifier","text":"The fifth part of a conversion specifier is a size modifier, which must be ll , h , l , or L . If it is ll it specifies that an integer value is taken without truncation for conversion to a formatted substring. If it is h it specifies that an integer value is truncated to a 16-bit range before converting. This option is rarely useful. If it is l it specifies that the integer value is truncated to the same range as that produced by the wide() function of the expr command (at least a 64-bit range). If it is L it specifies that an integer or double value is taken without truncation for conversion to a formatted substring. If neither h nor l nor L are present, the integer value is truncated to the same range as that produced by the int() function of the expr command (at least a 32-bit range, but determined by the value of the wordSize element of the tcl_platform array).","title":"OPTIONAL SIZE MODIFIER"},{"location":"format/#mandatory-conversion-type","text":"The last thing in a conversion specifier is an alphabetic character that determines what kind of conversion to perform. The following conversion characters are currently supported: d : Convert integer to signed decimal string. u : Convert integer to unsigned decimal string. i : Convert integer to signed decimal string (equivalent to d ). o : Convert integer to unsigned octal string. x or X : Convert integer to unsigned hexadecimal string, using digits for x and for X ). b : Convert integer to unsigned binary string, using digits 0 and 1. c : Convert integer to the Unicode character it represents. s : No conversion; just insert string. f : Convert number to signed decimal string of the form xx.yyy , where the number of y \\'s is determined by the precision (default: 6). If the precision is 0 then no decimal point is output. e or E : Convert number to scientific notation in the form x.yyy e\u00b1 zz , where the number of y \\'s is determined by the precision (default: 6). If the precision is 0 then no decimal point is output. If the E form is used then E is printed instead of e . g or G : If the exponent is less than -4 or greater than or equal to the precision, then convert number as for %e or %E . Otherwise convert as for %f . Trailing zeroes and a trailing decimal point are omitted. a or A : Convert double to hexadecimal notation in the form 0x1.yyy p\u00b1 zz , where the number of y \\'s is determined by the precision (default: 13). If the A form is used then the hex characters are printed in uppercase. % : No conversion: just insert % . p : Shorthand form for 0x%zx , so it outputs the integer in hexadecimal form with 0x prefix.","title":"MANDATORY CONVERSION TYPE"},{"location":"format/#differences-from-ansi-sprintf","text":"The behavior of the format command is the same as the ANSI C sprintf procedure except for the following differences: [1] : Tcl guarantees that it will be working with UNICODE characters. [2] : %n specifier is not supported. [3] : For %c conversions the argument must be an integer value, which will then be converted to the corresponding character value. [4] : The size modifiers are ignored when formatting floating-point values. The b specifier has no sprintf counterpart.","title":"DIFFERENCES FROM ANSI SPRINTF"},{"location":"format/#examples","text":"Convert the numeric value of a UNICODE character to the character itself: set value 120 set char [ format %c \\$value] Convert the output of time into seconds to an accuracy of hundredths of a second: set us [lindex [time \\$someTclCode] 0] puts [ format \\\"%.2f seconds to execute\\\" [expr {\\$us / 1e6}]] Create a packed X11 literal color specification: # Each color-component should be in range (0..255) set color [ format \\\"#%02x%02x%02x\\\" \\$r \\$g \\$b] Use XPG3 format codes to allow reordering of fields (a technique that is often used in localized message catalogs; see msgcat ) without reordering the data values passed to format : set fmt1 \\\"Today, %d shares in %s were bought at \\$%.2f each\\\" puts [ format \\$fmt1 123 \\\"Global BigCorp\\\" 19.37] set fmt2 \\\"Bought %2\\\\$s equity (\\$%3\\$.2f x %1\\\\$d) today\\\" puts [ format \\$fmt2 123 \\\"Global BigCorp\\\" 19.37] Print a small table of powers of three: # Set up the column widths set w1 5 set w2 10 # Make a nice header (with separator) for the table first set sep +-[string repeat - \\$w1]-+-[string repeat - \\$w2]-+ puts \\$sep puts [ format \\\"| %-*s | %-*s |\\\" \\$w1 \\\"Index\\\" \\$w2 \\\"Power\\\"] puts \\$sep # Print the contents of the table set p 1 for {set i 0} {\\$i\\<=20} {incr i} { puts [ format \\\"| %*d | %*ld |\\\" \\$w1 \\$i \\$w2 \\$p] set p [expr {wide(\\$p) * 3}] } # Finish off by printing the separator again puts \\$sep","title":"EXAMPLES"},{"location":"format/#see-also","text":"scan(n), sprintf(3), string(n)","title":"SEE ALSO"},{"location":"format/#keywords","text":"conversion specifier, format, sprintf, string, substitution","title":"KEYWORDS"},{"location":"fpclassify/","text":"NAME fpclassify - Floating point number classification of Tcl values SYNOPSIS package require tcl 8.7 fpclassify value DESCRIPTION The fpclassify command takes a floating point number, value , and returns one of the following strings that describe it: zero : value is a floating point zero. subnormal : value is the result of a gradual underflow. normal : value is an ordinary floating-point number (not zero, subnormal, infinite, nor NaN). infinite : value is a floating-point infinity. nan : value is Not-a-Number. The fpclassify command throws an error if value is not a floating-point value and cannot be converted to one. EXAMPLE This shows how to check whether the result of a computation is numerically safe or not. (Note however that it does not guard against numerical errors; just against representational problems.) set value [command-that-computes-a-value] switch [ fpclassify \\$value] { normal - zero { puts \\\"Result is \\$value\\\" } infinite { puts \\\"Result is infinite\\\" } subnormal { puts \\\"Result is \\$value - WARNING! precision lost\\\" } nan { puts \\\"Computation completely failed\\\" } } SEE ALSO expr(n), mathfunc(n) KEYWORDS floating point STANDARDS This command depends on the fpclassify () C macro conforming to (i.e., to ISO/IEC 9899:1999). COPYRIGHT Copyright \u00a9 2018 Kevin B. Kenny <kennykb@acm.org>. All rights reserved","title":"NAME"},{"location":"fpclassify/#name","text":"fpclassify - Floating point number classification of Tcl values","title":"NAME"},{"location":"fpclassify/#synopsis","text":"package require tcl 8.7 fpclassify value","title":"SYNOPSIS"},{"location":"fpclassify/#description","text":"The fpclassify command takes a floating point number, value , and returns one of the following strings that describe it: zero : value is a floating point zero. subnormal : value is the result of a gradual underflow. normal : value is an ordinary floating-point number (not zero, subnormal, infinite, nor NaN). infinite : value is a floating-point infinity. nan : value is Not-a-Number. The fpclassify command throws an error if value is not a floating-point value and cannot be converted to one.","title":"DESCRIPTION"},{"location":"fpclassify/#example","text":"This shows how to check whether the result of a computation is numerically safe or not. (Note however that it does not guard against numerical errors; just against representational problems.) set value [command-that-computes-a-value] switch [ fpclassify \\$value] { normal - zero { puts \\\"Result is \\$value\\\" } infinite { puts \\\"Result is infinite\\\" } subnormal { puts \\\"Result is \\$value - WARNING! precision lost\\\" } nan { puts \\\"Computation completely failed\\\" } }","title":"EXAMPLE"},{"location":"fpclassify/#see-also","text":"expr(n), mathfunc(n)","title":"SEE ALSO"},{"location":"fpclassify/#keywords","text":"floating point","title":"KEYWORDS"},{"location":"fpclassify/#standards","text":"This command depends on the fpclassify () C macro conforming to (i.e., to ISO/IEC 9899:1999).","title":"STANDARDS"},{"location":"fpclassify/#copyright","text":"Copyright \u00a9 2018 Kevin B. Kenny <kennykb@acm.org>. All rights reserved","title":"COPYRIGHT"},{"location":"gets/","text":"NAME gets - Read a line from a channel SYNOPSIS gets channelId ? varName ? DESCRIPTION This command reads the next line from channelId , returns everything in the line up to (but not including) the end-of-line character(s), and discards the end-of-line character(s). ChannelId must be an identifier for an open channel such as the Tcl standard input channel ( stdin ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. The channel must have been opened for input. If varName is omitted the line is returned as the result of the command. If varName is specified then the line is placed in the variable by that name and the return value is a count of the number of characters returned. If end of file occurs while scanning for an end of line, the command returns whatever input is available up to the end of file. If channelId is in non-blocking mode and there is not a full line of input available, the command returns an empty string and does not consume any input. If varName is specified and an empty string is returned in varName because of end-of-file or because of insufficient data in non-blocking mode, then the return count is -1. Note that if varName is not specified then the end-of-file and no-full-line-available cases can produce the same results as if there were an input line consisting only of the end-of-line character(s). The eof and fblocked commands can be used to distinguish these three cases. EXAMPLE This example reads a file one line at a time and prints it out with the current line number attached to the start of each line. set chan [open \\\"some.file.txt\\\"] set lineNumber 0 while {[ gets \\$chan line] >= 0} { puts \\\"[incr lineNumber]: \\$line\\\" } close \\$chan SEE ALSO file(n), eof(n), fblocked(n), Tcl_StandardChannels(3) KEYWORDS blocking, channel, end of file, end of line, line, non-blocking, read","title":"NAME"},{"location":"gets/#name","text":"gets - Read a line from a channel","title":"NAME"},{"location":"gets/#synopsis","text":"gets channelId ? varName ?","title":"SYNOPSIS"},{"location":"gets/#description","text":"This command reads the next line from channelId , returns everything in the line up to (but not including) the end-of-line character(s), and discards the end-of-line character(s). ChannelId must be an identifier for an open channel such as the Tcl standard input channel ( stdin ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. The channel must have been opened for input. If varName is omitted the line is returned as the result of the command. If varName is specified then the line is placed in the variable by that name and the return value is a count of the number of characters returned. If end of file occurs while scanning for an end of line, the command returns whatever input is available up to the end of file. If channelId is in non-blocking mode and there is not a full line of input available, the command returns an empty string and does not consume any input. If varName is specified and an empty string is returned in varName because of end-of-file or because of insufficient data in non-blocking mode, then the return count is -1. Note that if varName is not specified then the end-of-file and no-full-line-available cases can produce the same results as if there were an input line consisting only of the end-of-line character(s). The eof and fblocked commands can be used to distinguish these three cases.","title":"DESCRIPTION"},{"location":"gets/#example","text":"This example reads a file one line at a time and prints it out with the current line number attached to the start of each line. set chan [open \\\"some.file.txt\\\"] set lineNumber 0 while {[ gets \\$chan line] >= 0} { puts \\\"[incr lineNumber]: \\$line\\\" } close \\$chan","title":"EXAMPLE"},{"location":"gets/#see-also","text":"file(n), eof(n), fblocked(n), Tcl_StandardChannels(3)","title":"SEE ALSO"},{"location":"gets/#keywords","text":"blocking, channel, end of file, end of line, line, non-blocking, read","title":"KEYWORDS"},{"location":"glob/","text":"NAME glob - Return names of files that match patterns SYNOPSIS glob ? switches ? ? pattern ... ? DESCRIPTION This command performs file name in a fashion similar to the csh shell or bash shell. It returns a list of the files whose names match any of the pattern arguments. No particular order is guaranteed in the list, so if a sorted list is required the caller should use lsort . OPTIONS If the initial arguments to glob start with - then they are treated as switches. The following switches are currently supported: -directory directory : Search for files which match the given patterns starting in the given directory . This allows searching of directories whose name contains glob-sensitive characters without the need to quote such characters explicitly. This option may not be used in conjunction with -path , which is used to allow searching for complete file paths whose names may contain glob-sensitive characters. -join : The remaining pattern arguments, after option processing, are treated as a single pattern obtained by joining the arguments with directory separators. -nocomplain : Allows an empty list to be returned without error; This is the default behavior in Tcl 9.0, so this switch has no effect any more. -path pathPrefix : Search for files with the given pathPrefix where the rest of the name matches the given patterns. This allows searching for files with names similar to a given file (as opposed to a directory) even when the names contain glob-sensitive characters. This option may not be used in conjunction with -directory . For example, to find all files with the same root name as \\$path, but differing extensions, you should use which will work even if \\$path contains numerous glob-sensitive characters. -tails : Only return the part of each file found which follows the last directory named in any -directory or -path path specification. Thus is equivalent to For -path specifications, the returned names will include the last path segment, so will return paths like foo.aux foo.bib foo.tex etc. -types typeList : Only list files or directories which match typeList , where the items in the list have two forms. The first form is like the -type option of the Unix find command: b (block special file), c (character special file), d (directory), f (plain file), l (symbolic link), p (named pipe), or s (socket), where multiple types may be specified in the list. Glob will return all files which match at least one of the types given. Note that symbolic links will be returned both if -types l is given, or if the target of a link matches the requested type. So, a link to a directory will be returned if -types d was specified. The second form specifies types where all the types given must match. These are *r*, *w*, *x* as file permissions, and *readonly*, *hidden* as special permission cases. On the Macintosh, MacOS types and creators are also supported, where any item which is four characters long is assumed to be a MacOS type (e.g. **TEXT**). Items which are of the form *{macintosh type XXXX}* or *{macintosh creator XXXX}* will match types or creators respectively. Unrecognized types, or specifications of multiple MacOS types/creators will signal an error. The two forms may be mixed, so **-types {d f r w}** will find all regular files OR directories that have both read AND write permissions. The following are equivalent: **glob -type d \\*** **glob \\*/** except that the first case doesn\\'t return the trailing and is more platform independent. -\u2006- : Marks the end of switches. The argument following this one will be treated as a pattern even if it starts with a - . GLOBBING PATTERNS The pattern arguments may contain any of the following special characters, which are a superset of those supported by string match : ? : Matches any single character. * : Matches any sequence of zero or more characters. [ chars ] : Matches any single character in chars . If chars contains a sequence of the form a - b then any character between a and b (inclusive) will match. \\ x : Matches the character x . { a , b , ... } : Matches any of the sub-patterns a , b , etc. On Unix, as with csh, a at the beginning of a file\\'s name or just after a must be matched explicitly or with a {} construct, unless the -types hidden flag is given (since at the beginning of a file\\'s name indicates that it is hidden). On other platforms, files beginning with a are handled no differently to any others, except the special directories and which must be matched explicitly (this is to avoid a recursive pattern like from recursing up the directory hierarchy as well as down). In addition, all characters must be matched explicitly. The glob command differs from csh globbing in two ways. First, it does not sort its result list (use the lsort command if you want the list sorted). Second, glob only returns the names of files that actually exist; in csh no check for existence is made unless a pattern contains a ?, *, or [] construct. WINDOWS PORTABILITY ISSUES For Windows UNC names, the servername and sharename components of the path may not contain ?, *, or [] constructs. Since the backslash character has a special meaning to the glob command, glob patterns containing Windows style path separators need special care. The pattern is interpreted as where will match the single character and will match the single character and will not be interpreted as a wildcard character. One solution to this problem is to use the Unix style forward slash as a path separator. Windows style paths can be converted to Unix style paths with the command or EXAMPLES Find all the Tcl files in the current directory: glob *.tcl Find all the Tcl files in the user\\'s home directory, irrespective of what the current directory is: glob -directory [file home] *.tcl Find all subdirectories of the current directory: glob -type d * Find all files whose name contains an a or the sequence glob -type f *{a,b,cde}* SEE ALSO file(n) KEYWORDS exist, file, glob, pattern","title":"NAME"},{"location":"glob/#name","text":"glob - Return names of files that match patterns","title":"NAME"},{"location":"glob/#synopsis","text":"glob ? switches ? ? pattern ... ?","title":"SYNOPSIS"},{"location":"glob/#description","text":"This command performs file name in a fashion similar to the csh shell or bash shell. It returns a list of the files whose names match any of the pattern arguments. No particular order is guaranteed in the list, so if a sorted list is required the caller should use lsort .","title":"DESCRIPTION"},{"location":"glob/#options","text":"If the initial arguments to glob start with - then they are treated as switches. The following switches are currently supported: -directory directory : Search for files which match the given patterns starting in the given directory . This allows searching of directories whose name contains glob-sensitive characters without the need to quote such characters explicitly. This option may not be used in conjunction with -path , which is used to allow searching for complete file paths whose names may contain glob-sensitive characters. -join : The remaining pattern arguments, after option processing, are treated as a single pattern obtained by joining the arguments with directory separators. -nocomplain : Allows an empty list to be returned without error; This is the default behavior in Tcl 9.0, so this switch has no effect any more. -path pathPrefix : Search for files with the given pathPrefix where the rest of the name matches the given patterns. This allows searching for files with names similar to a given file (as opposed to a directory) even when the names contain glob-sensitive characters. This option may not be used in conjunction with -directory . For example, to find all files with the same root name as \\$path, but differing extensions, you should use which will work even if \\$path contains numerous glob-sensitive characters. -tails : Only return the part of each file found which follows the last directory named in any -directory or -path path specification. Thus is equivalent to For -path specifications, the returned names will include the last path segment, so will return paths like foo.aux foo.bib foo.tex etc. -types typeList : Only list files or directories which match typeList , where the items in the list have two forms. The first form is like the -type option of the Unix find command: b (block special file), c (character special file), d (directory), f (plain file), l (symbolic link), p (named pipe), or s (socket), where multiple types may be specified in the list. Glob will return all files which match at least one of the types given. Note that symbolic links will be returned both if -types l is given, or if the target of a link matches the requested type. So, a link to a directory will be returned if -types d was specified. The second form specifies types where all the types given must match. These are *r*, *w*, *x* as file permissions, and *readonly*, *hidden* as special permission cases. On the Macintosh, MacOS types and creators are also supported, where any item which is four characters long is assumed to be a MacOS type (e.g. **TEXT**). Items which are of the form *{macintosh type XXXX}* or *{macintosh creator XXXX}* will match types or creators respectively. Unrecognized types, or specifications of multiple MacOS types/creators will signal an error. The two forms may be mixed, so **-types {d f r w}** will find all regular files OR directories that have both read AND write permissions. The following are equivalent: **glob -type d \\*** **glob \\*/** except that the first case doesn\\'t return the trailing and is more platform independent. -\u2006- : Marks the end of switches. The argument following this one will be treated as a pattern even if it starts with a - .","title":"OPTIONS"},{"location":"glob/#globbing-patterns","text":"The pattern arguments may contain any of the following special characters, which are a superset of those supported by string match : ? : Matches any single character. * : Matches any sequence of zero or more characters. [ chars ] : Matches any single character in chars . If chars contains a sequence of the form a - b then any character between a and b (inclusive) will match. \\ x : Matches the character x . { a , b , ... } : Matches any of the sub-patterns a , b , etc. On Unix, as with csh, a at the beginning of a file\\'s name or just after a must be matched explicitly or with a {} construct, unless the -types hidden flag is given (since at the beginning of a file\\'s name indicates that it is hidden). On other platforms, files beginning with a are handled no differently to any others, except the special directories and which must be matched explicitly (this is to avoid a recursive pattern like from recursing up the directory hierarchy as well as down). In addition, all characters must be matched explicitly. The glob command differs from csh globbing in two ways. First, it does not sort its result list (use the lsort command if you want the list sorted). Second, glob only returns the names of files that actually exist; in csh no check for existence is made unless a pattern contains a ?, *, or [] construct.","title":"GLOBBING PATTERNS"},{"location":"glob/#windows-portability-issues","text":"For Windows UNC names, the servername and sharename components of the path may not contain ?, *, or [] constructs. Since the backslash character has a special meaning to the glob command, glob patterns containing Windows style path separators need special care. The pattern is interpreted as where will match the single character and will match the single character and will not be interpreted as a wildcard character. One solution to this problem is to use the Unix style forward slash as a path separator. Windows style paths can be converted to Unix style paths with the command or","title":"WINDOWS PORTABILITY ISSUES"},{"location":"glob/#examples","text":"Find all the Tcl files in the current directory: glob *.tcl Find all the Tcl files in the user\\'s home directory, irrespective of what the current directory is: glob -directory [file home] *.tcl Find all subdirectories of the current directory: glob -type d * Find all files whose name contains an a or the sequence glob -type f *{a,b,cde}*","title":"EXAMPLES"},{"location":"glob/#see-also","text":"file(n)","title":"SEE ALSO"},{"location":"glob/#keywords","text":"exist, file, glob, pattern","title":"KEYWORDS"},{"location":"global/","text":"NAME global - Access global variables SYNOPSIS global ? varname ... ? DESCRIPTION This command has no effect unless executed in the context of a proc body. If the global command is executed in the context of a proc body, it creates local variables linked to the corresponding global variables (though these linked variables, like those created by upvar , are not included in the list returned by info locals ). If varname contains namespace qualifiers, the local variable\\'s name is the unqualified name of the global variable, as determined by the namespace tail command. varname is always treated as the name of a variable, not an array element. An error is returned if the name looks like an array element, such as a(b) . EXAMPLES This procedure sets the namespace variable ::a::x proc reset {} { global a::x set x 0 } This procedure accumulates the strings passed to it in a global buffer, separated by newlines. It is useful for situations when you want to build a message piece-by-piece (as if with puts ) but send that full message in a single piece (e.g. over a connection opened with socket or as part of a counted HTTP response). proc accum {string} { global accumulator append accumulator \\$string \\n } SEE ALSO namespace(n), upvar(n), variable(n) KEYWORDS global, namespace, procedure, variable","title":"NAME"},{"location":"global/#name","text":"global - Access global variables","title":"NAME"},{"location":"global/#synopsis","text":"global ? varname ... ?","title":"SYNOPSIS"},{"location":"global/#description","text":"This command has no effect unless executed in the context of a proc body. If the global command is executed in the context of a proc body, it creates local variables linked to the corresponding global variables (though these linked variables, like those created by upvar , are not included in the list returned by info locals ). If varname contains namespace qualifiers, the local variable\\'s name is the unqualified name of the global variable, as determined by the namespace tail command. varname is always treated as the name of a variable, not an array element. An error is returned if the name looks like an array element, such as a(b) .","title":"DESCRIPTION"},{"location":"global/#examples","text":"This procedure sets the namespace variable ::a::x proc reset {} { global a::x set x 0 } This procedure accumulates the strings passed to it in a global buffer, separated by newlines. It is useful for situations when you want to build a message piece-by-piece (as if with puts ) but send that full message in a single piece (e.g. over a connection opened with socket or as part of a counted HTTP response). proc accum {string} { global accumulator append accumulator \\$string \\n }","title":"EXAMPLES"},{"location":"global/#see-also","text":"namespace(n), upvar(n), variable(n)","title":"SEE ALSO"},{"location":"global/#keywords","text":"global, namespace, procedure, variable","title":"KEYWORDS"},{"location":"history/","text":"NAME history - Manipulate the history list SYNOPSIS history ? option ? ? arg arg ... ? DESCRIPTION The history command performs one of several operations related to recently-executed commands recorded in a history list. Each of these recorded commands is referred to as an When specifying an event to the history command, the following forms may be used: [1] : A number: if positive, it refers to the event with that number (all events are numbered starting at 1). If the number is negative, it selects an event relative to the current event ( -1 refers to the previous event, -2 to the one before that, and so on). Event 0 refers to the current event. [2] : A string: selects the most recent event that matches the string. An event is considered to match the string either if the string is the same as the first characters of the event, or if the string matches the event in the sense of the string match command. The history command can take any of the following forms: history : Same as history info , described below. history add command ? exec ? : Adds the command argument to the history list as a new event. If exec is specified (or abbreviated) then the command is also executed and its result is returned. If exec is not specified then an empty string is returned as result. history change newValue ? event ? : Replaces the value recorded for an event with newValue . Event specifies the event to replace, and defaults to the current event (not event -1 ). This command is intended for use in commands that implement new forms of history substitution and wish to replace the current event (which invokes the substitution) with the command created through substitution. The return value is an empty string. history clear : Erase the history list. The current keep limit is retained. The history event numbers are reset. history event ? event ? : Returns the value of the event given by event . Event defaults to -1 . history info ? count ? : Returns a formatted string (intended for humans to read) giving the event number and contents for each of the events in the history list except the current event. If count is specified then only the most recent count events are returned. history keep ? count ? : This command may be used to change the size of the history list to count events. Initially, 20 events are retained in the history list. If count is not specified, the current keep limit is returned. history nextid : Returns the number of the next event to be recorded in the history list. It is useful for things like printing the event number in command-line prompts. history redo ? event ? : Re-executes the command indicated by event and returns its result. Event defaults to -1 . This command results in history revision: see below for details. HISTORY REVISION Pre-8.0 Tcl had a complex history revision mechanism. The current mechanism is more limited, and the old history operations substitute and words have been removed. (As a consolation, the clear operation was added.) The history option redo results in much simpler When this option is invoked then the most recent event is modified to eliminate the history command and replace it with the result of the history command. If you want to redo an event without modifying history, then use the event operation to retrieve some event, and the add operation to add it to history and execute it. KEYWORDS event, history, record","title":"NAME"},{"location":"history/#name","text":"history - Manipulate the history list","title":"NAME"},{"location":"history/#synopsis","text":"history ? option ? ? arg arg ... ?","title":"SYNOPSIS"},{"location":"history/#description","text":"The history command performs one of several operations related to recently-executed commands recorded in a history list. Each of these recorded commands is referred to as an When specifying an event to the history command, the following forms may be used: [1] : A number: if positive, it refers to the event with that number (all events are numbered starting at 1). If the number is negative, it selects an event relative to the current event ( -1 refers to the previous event, -2 to the one before that, and so on). Event 0 refers to the current event. [2] : A string: selects the most recent event that matches the string. An event is considered to match the string either if the string is the same as the first characters of the event, or if the string matches the event in the sense of the string match command. The history command can take any of the following forms: history : Same as history info , described below. history add command ? exec ? : Adds the command argument to the history list as a new event. If exec is specified (or abbreviated) then the command is also executed and its result is returned. If exec is not specified then an empty string is returned as result. history change newValue ? event ? : Replaces the value recorded for an event with newValue . Event specifies the event to replace, and defaults to the current event (not event -1 ). This command is intended for use in commands that implement new forms of history substitution and wish to replace the current event (which invokes the substitution) with the command created through substitution. The return value is an empty string. history clear : Erase the history list. The current keep limit is retained. The history event numbers are reset. history event ? event ? : Returns the value of the event given by event . Event defaults to -1 . history info ? count ? : Returns a formatted string (intended for humans to read) giving the event number and contents for each of the events in the history list except the current event. If count is specified then only the most recent count events are returned. history keep ? count ? : This command may be used to change the size of the history list to count events. Initially, 20 events are retained in the history list. If count is not specified, the current keep limit is returned. history nextid : Returns the number of the next event to be recorded in the history list. It is useful for things like printing the event number in command-line prompts. history redo ? event ? : Re-executes the command indicated by event and returns its result. Event defaults to -1 . This command results in history revision: see below for details.","title":"DESCRIPTION"},{"location":"history/#history-revision","text":"Pre-8.0 Tcl had a complex history revision mechanism. The current mechanism is more limited, and the old history operations substitute and words have been removed. (As a consolation, the clear operation was added.) The history option redo results in much simpler When this option is invoked then the most recent event is modified to eliminate the history command and replace it with the result of the history command. If you want to redo an event without modifying history, then use the event operation to retrieve some event, and the add operation to add it to history and execute it.","title":"HISTORY REVISION"},{"location":"history/#keywords","text":"event, history, record","title":"KEYWORDS"},{"location":"http/","text":"NAME http - Client-side implementation of the HTTP/1.1 protocol SYNOPSIS package require http ? 2.10 ? ::http::config ? -option value ...? ::http::geturl url ? -option value ...? ::http::formatQuery key value ? key value ...? ::http::quoteString value ::http::reset token ? why ? ::http::wait token ::http::status token ::http::size token ::http::error token ::http::postError token ::http::cleanup token ::http::requestLine token ::http::requestHeaders token ? headerName ? ::http::requestHeaderValue token headerName ::http::responseLine token ::http::responseCode token ::http::reasonPhrase code ::http::responseHeaders token ? headerName ? ::http::responseHeaderValue token headerName ::http::responseInfo token ::http::responseBody token ::http::register proto port command ::http::registerError port ? message ? ::http::unregister proto ::http::code token ::http::data token ::http::meta token ? headerName ? ::http::metaValue token headerName ::http::ncode token EXPORTED COMMANDS Namespace http exports the commands config , formatQuery , geturl , postError , quoteString , reasonPhrase , register , registerError , requestHeaders , requestHeaderValue , requestLine , responseBody , responseCode , responseHeaders , responseHeaderValue , responseInfo , responseLine , reset , unregister , and wait . It does not export the commands cleanup , code , data , error , meta , metaValue , ncode , size , or status . DESCRIPTION The http package provides the client side of the HTTP/1.1 protocol, as defined in RFC 9110 to 9112, which supersede RFC 7230 to RFC 7235, which in turn supersede RFC 2616. The package implements the GET, POST, and HEAD operations of HTTP/1.1. It allows configuration of a proxy host to get through firewalls. The package is compatible with the Safesock security policy, so it can be used by untrusted applets to do URL fetching from a restricted set of hosts. This package can be extended to support additional HTTP transport protocols, such as HTTPS, by providing a custom socket command, via ::http::register . The ::http::geturl procedure does a HTTP transaction. Its options * determine whether a GET, POST, or HEAD transaction is performed. The return value of ::http::geturl * is a token for the transaction. The token can be supplied as an argument to other commands, to manage the transaction and examine its results. If the -command option is specified, then the HTTP operation is done in the background. ::http::geturl returns immediately after generating the HTTP request and the -command callback is invoked when the transaction completes. For this to work, the Tcl event loop must be active. In Tk applications this is always true. For pure-Tcl applications, the caller can use ::http::wait after calling ::http::geturl to start the event loop. Note: The event queue is even used without the -command option. As a side effect, arbitrary commands may be processed while http::geturl is running. When the HTTP server has replied to the request, call the command ::http::responseInfo , which returns a dict of metadata that is essential for identifying a successful transaction and making use of the response. See section METADATA for details of the information returned. The response itself is returned by command ::http::responseBody , unless it has been redirected to a file by the -channel option of ::http::geturl . COMMANDS ::http::config ? options ? : The ::http::config command is used to set and query the name of the proxy server and port, and the User-Agent name used in the HTTP requests. If no options are specified, then the current configuration is returned. If a single argument is specified, then it should be one of the flags described below. In this case the current value of that setting is returned. Otherwise, the options should be a set of flags and values that define the configuration: **-accept** *mimetypes* : The Accept header of the request. The default is \\*/\\*, which means that all types of documents are accepted. Otherwise you can supply a comma-separated list of mime type patterns that you are willing to receive. For example, **-cookiejar** *command* : The cookie store for the package to use to manage HTTP cookies. *command* is a command prefix list; if the empty list (the default value) is used, no cookies will be sent by requests or stored from responses. The command indicated by *command*, if supplied, must obey the **COOKIE JAR PROTOCOL** described below. **-pipeline** *boolean* : Specifies whether HTTP/1.1 transactions on a persistent socket will be pipelined. See the **PERSISTENT SOCKETS** section for details. The default is 1. **-postfresh** *boolean* : Specifies whether requests that use the **POST** method will always use a fresh socket, overriding the **-keepalive** option of command **http::geturl**. See the **PERSISTENT SOCKETS** section for details. The default is 0. **-proxyauth** *string* : If non-empty, the string is supplied to the proxy server as the value of the request header Proxy-Authorization. This option can be used for HTTP Basic Authentication. If the proxy server requires authentication by another technique, e.g. Digest Authentication, the **-proxyauth** option is not useful. In that case the caller must expect a 407 response from the proxy, compute the authentication value to be supplied, and use the **-headers** option to supply it as the value of the Proxy-Authorization header. **-proxyfilter** *command* : The command is a callback that is made during **::http::geturl** to determine if a proxy is required for a given host. One argument, a host name, is added to *command* when it is invoked. If a proxy is required, the callback should return a two-element list containing the proxy server and proxy port. Otherwise the filter command should return an empty list. The default value of **-proxyfilter** is **http::ProxyRequired**, and this command returns the values of the **-proxyhost** and **-proxyport** settings if they are non-empty. The options **-proxyhost**, **-proxyport**, and **-proxynot** are used only by **http::ProxyRequired**, and nowhere else in **::http::geturl**. A user-supplied **-proxyfilter** command may use these options, or alternatively it may obtain values from elsewhere in the calling script. In the latter case, any values provided for **-proxyhost**, **-proxyport**, and **-proxynot** are unused. The **::http::geturl** command runs the **-proxyfilter** callback inside a **catch** command. Therefore an error in the callback command does not call the **bgerror** handler. See the **ERRORS** section for details. **-proxyhost** *hostname* : The host name or IP address of the proxy server, if any. If this value is the empty string, the URL host is contacted directly. See **-proxyfilter** for how the value is used. **-proxynot** *list* : A Tcl list of domain names and IP addresses that should be accessed directly, not through the proxy server. The target hostname is compared with each list element using a case-insensitive **string match**. It is often convenient to use the wildcard \\\"\\*\\\" at the start of a domain name (e.g. \\*.example.com) or at the end of an IP address (e.g. 192.168.0.\\*). See **-proxyfilter** for how the value is used. **-proxyport** *number* : The port number of the proxy server. See **-proxyfilter** for how the value is used. **-repost** *boolean* : Specifies what to do if a POST request over a persistent connection fails because the server has half-closed the connection. If boolean **true**, the request will be automatically retried; if boolean **false** it will not, and the application that uses **http::geturl** is expected to seek user confirmation before retrying the POST. The value **true** should be used only under certain conditions. See the **PERSISTENT SOCKETS** section for details. The default is 0. **-threadlevel** *level* : Specifies whether and how to use the **Thread** package. Possible values of *level* are 0, 1 or 2. 0 - (the default) do not use Thread 1 - use Thread if it is available, do not use it if it is unavailable 2 - use Thread if it is available, raise an error if it is unavailable The Tcl **socket -async** command can block in adverse cases (e.g. a slow DNS lookup). Using the Thread package works around this problem, for both HTTP and HTTPS transactions. Values of *level* other than 0 are available only to the main interpreter in each thread. See section **THREADS** for more information. **-urlencoding** *encoding* : The *encoding* used for creating the x-url-encoded URLs with **::http::formatQuery** and **::http::quoteString**. The default is **utf-8**, as specified by RFC 2718. **-useragent** *string* : The value of the User-Agent header in the HTTP request. In an unsafe interpreter, the default value depends upon the operating system, and the version numbers of **http** and **Tcl**, and is (for example) A safe interpreter cannot determine its operating system, and so the default in a safe interpreter is to use a Windows 10 value with the current version numbers of **http** and **Tcl**. **-zip** *boolean* : If the value is boolean **true**, then by default requests will send a header If the value is boolean **false**, then by default requests will send a header In either case the default can be overridden for an individual request by supplying a custom **Accept-Encoding** header in the **-headers** option of **http::geturl**. The default value is 1. ::http::geturl url ? options ? : The ::http::geturl command is the main procedure in the package. The -query or -querychannel option causes a POST operation and the -validate option causes a HEAD operation; otherwise, a GET operation is performed. The ::http::geturl command returns a token value that can be passed as an argument to other commands to get information about the transaction. See the METADATA and ERRORS section for details. The ::http::geturl command blocks until the operation completes, unless the -command option specifies a callback that is invoked when the HTTP transaction completes. ::http::geturl takes several options: **-binary** *boolean* : Specifies whether to force interpreting the URL data as binary. Normally this is auto-detected (anything not beginning with a **text** content type or whose content encoding is **gzip** or **deflate** is considered binary data). **-blocksize** *size* : The block size used when reading the URL. At most *size* bytes are read at once. After each block, a call to the **-progress** callback is made (if that option is specified). **-channel** *name* : Copy the URL contents to channel *name* instead of saving it in a Tcl variable for retrieval by **::http::responseBody**. **-command** *callback* : The presence of this option causes **::http::geturl** to return immediately. After the HTTP transaction completes, the value of *callback* is expanded, an additional argument is added, and the resulting command is evaluated. The additional argument is the *token* returned from **::http::geturl**. This token is the name of an array that is described in the **STATE ARRAY** section. Here is a template for the callback: proc httpCallback {token} { upvar 0 \\$token state \\# Access state as a Tcl array defined in this proc \\... return } The **::http::geturl** command runs the **-command** callback inside a **catch** command. Therefore an error in the callback command does not call the **bgerror** handler. See the **ERRORS** section for details. **-guesstype** *boolean* : Attempt to guess the **Content-Type** and character set when a misconfigured server provides no information. The default value is *false* (do nothing). If boolean *true* then, if the server does not send a **Content-Type** header, or if it sends the value \\\"application/octet-stream\\\", **http::geturl** will attempt to guess appropriate values. This is not intended to become a general-purpose tool, and currently it is limited to detecting XML documents that begin with an XML declaration. In this case the **Content-Type** is changed to \\\"application/xml\\\", the binary flag state(binary) is changed to 0, and the character set is changed to the one specified by the \\\"encoding\\\" tag of the XML line, or to utf-8 if no encoding is specified. Not used if a *-channel* is specified. **-handler** *callback* : If this option is absent, **http::geturl** processes incoming data itself, either appending it to the state(body) variable or writing it to the -channel. But if the **-handler** option is present, **http::geturl** does not do this processing and instead calls *callback*. Whenever HTTP data is available, the value of *callback* is expanded, an additional two arguments are added, and the resulting command is evaluated. The two additional arguments are: the socket for the HTTP data and the *token* returned from **::http::geturl**. The token is the name of a global array that is described in the **STATE ARRAY** section. The procedure is expected to return the number of bytes read from the socket. Here is a template for the callback: proc httpHandlerCallback {socket token} { upvar 0 \\$token state \\# Access socket, and state as a Tcl array defined in this proc \\# For example\\... \\... set data \\[read \\$socket 1000\\] set nbytes \\[string length \\$data\\] \\... return \\$nbytes } The **http::geturl** code for the **-handler** option is not compatible with either compression or chunked transfer-encoding. If **-handler** is specified, then to work around these issues **http::geturl** will reduce the HTTP protocol to 1.0, and override the **-zip** option (i.e. it will send the header **Accept-Encoding: identity** instead of **Accept-Encoding: gzip,deflate**). If options **-handler** and **-channel** are used together, the handler is responsible for copying the data from the HTTP socket to the specified channel. The name of the channel is available to the handler as element **-channel** of the token array. The **::http::geturl** command runs the **-handler** callback inside a **catch** command. Therefore an error in the callback command does not call the **bgerror** handler. See the **ERRORS** section for details. **-headers** *keyvaluelist* : This option is used to add headers not already specified by **::http::config** to the HTTP request. The *keyvaluelist* argument must be a list with an even number of elements that alternate between keys and values. The keys become header field names. Newlines are stripped from the values so the header cannot be corrupted. For example, if *keyvaluelist* is **Pragma no-cache** then the following header is included in the HTTP request: Pragma: no-cache **-keepalive** *boolean* : If boolean **true**, attempt to keep the connection open for servicing multiple requests. Default is 0. **-method** *type* : Force the HTTP request method to *type*. **::http::geturl** will auto-select GET, POST or HEAD based on other options, but this option overrides that selection and enables choices like PUT and DELETE for WebDAV support. It is the caller\\'s responsibility to ensure that the headers and request body (if any) conform to the requirements of the request method. For example, if using **-method** *POST* to send a POST with an empty request body, the caller must also supply the option -headers {Content-Length 0} **-myaddr** *address* : Pass an specific local address to the underlying **socket** call in case multiple interfaces are available. **-progress** *callback* : If the **-progress** option is present, then the *callback* is made after each transfer of data from the URL. The value of *callback* is expanded, an additional three arguments are added, and the resulting command is evaluated. The three additional arguments are: the *token* returned from **::http::geturl**, the expected total size of the contents from the **Content-Length** response header, and the current number of bytes transferred so far. The token is the name of a global array that is described in the **STATE ARRAY** section. The expected total size may be unknown, in which case zero is passed to the callback. Here is a template for the progress callback: proc httpProgress {token total current} { upvar 0 \\$token state \\# Access state as a Tcl array defined in this proc \\... return } **-protocol** *version* : Select the HTTP protocol version to use. This should be 1.0 or 1.1 (the default). Should only be necessary for servers that do not understand or otherwise complain about HTTP/1.1. **-query** *query* : This flag (if the value is non-empty) causes **::http::geturl** to do a POST request that passes the string *query* verbatim to the server as the request payload. The content format (and encoding) of *query* is announced by the request header **Content-Type** which is set by the option **-type**. Any value of **-type** is permitted, and it is the responsibility of the caller to supply *query* in the correct format. If **-type** is not specified, it defaults to *application/x-www-form-urlencoded*, which requires *query* to be an x-url-encoding formatted query-string (this **-type** and query format are used in a POST submitted from an html form). The **::http::formatQuery** procedure can be used to do the formatting. **-queryblocksize** *size* : The block size used when posting query data to the URL. At most *size* bytes are written at once. After each block, a call to the **-queryprogress** callback is made (if that option is specified). **-querychannel** *channelID* : This flag causes **::http::geturl** to do a POST request that passes the data contained in *channelID* to the server. The data contained in *channelID* must be an x-url-encoding formatted query unless the **-type** option below is used. If a **Content-Length** header is not specified via the **-headers** options, **::http::geturl** attempts to determine the size of the post data in order to create that header. If it is unable to determine the size, it returns an error. **-queryprogress** *callback* : If the **-queryprogress** option is present, then the *callback* is made after each transfer of data to the URL in a POST request (i.e. a call to **::http::geturl** with option **-query** or **-querychannel**) and acts exactly like the **-progress** option (the callback format is the same). **-strict** *boolean* : If true then the command will test that the URL complies with RFC 3986, i.e. that it has no characters that should be \\\"x-url-encoded\\\" (e.g. a space should be encoded to \\\"%20\\\"). Default value is 1. **-timeout** *milliseconds* : If *milliseconds* is non-zero, then **::http::geturl** sets up a timeout to occur after the specified number of milliseconds. A timeout results in a call to **::http::reset** and to the **-command** callback, if specified. The return value of **::http::status** (and the value of the *status* key in the dictionary returned by **::http::responseInfo**) is **timeout** after a timeout has occurred. **-type** *mime-type* : Use *mime-type* as the **Content-Type** value, instead of the default value (**application/x-www-form-urlencoded**) during a POST operation. **-validate** *boolean* : If *boolean* is non-zero, then **::http::geturl** does an HTTP HEAD request. This server returns the same status line and response headers as it would for a HTTP GET request, but omits the response entity (the URL \\\"contents\\\"). The response headers are available after the transaction using command **::http::responseHeaders** or, for selected information, **::http::responseInfo**. ::http::formatQuery key value ? key value ...? : This procedure does x-url-encoding of query data. It takes an even number of arguments that are the keys and values of the query. It encodes the keys and values, and generates one string that has the proper & and = separators. The result is suitable for the -query value passed to ::http::geturl . ::http::quoteString value : This procedure does x-url-encoding of string. It takes a single argument and encodes it. ::http::reset token ? why ? : This command resets the HTTP transaction identified by token , if any. This sets the state(status) value to why , which defaults to reset , and then calls the registered -command callback. ::http::wait token : This command blocks and waits for the transaction to complete. This only works in trusted code because it uses vwait . Also, it is not useful for the case where ::http::geturl is called without the -command option because in this case the ::http::geturl call does not return until the HTTP transaction is complete, and thus there is nothing to wait for. ::http::status token : This command returns a description of the status of the HTTP transaction. The return value is the empty string until the HTTP transaction is completed; after completion it has one of the values ok, eof, error, timeout, and reset. The meaning of these values is described in the section ERRORS (below). The name \\\"status\\\" is not related to the terms \\\"status line\\\" and \\\"status code\\\" that are defined for a HTTP response. ::http::size token : This command returns the number of bytes received so far from the URL in the ::http::geturl call. ::http::error token : This command returns the error information if the HTTP transaction failed, or the empty string if there was no error. The information is a Tcl list of the error message, stack trace, and error code. ::http::postError token : A POST request is a call to ::http::geturl with either the -query or -querychannel option. The ::http::postError command returns the error information generated when a HTTP POST request sends its request-body to the server; or the empty string if there was no error. The information is a Tcl list of the error message, stack trace, and error code. When this type of error occurs, the ::http::geturl command continues the transaction and attempts to receive a response from the server. ::http::cleanup token : This procedure cleans up the state associated with the connection identified by token . After this call, the procedures like ::http::responseBody cannot be used to get information about the operation. It is strongly recommended that you call this function after you are done with a given HTTP request. Not doing so will result in memory not being freed, and if your app calls ::http::geturl enough times, the memory leak could cause a performance hit...or worse. ::http::requestLine token : This command returns the \\\"request line\\\" sent to the server. The \\\"request line\\\" is the first line of a HTTP client request, and has three elements separated by spaces: the HTTP method, the URL relative to the server, and the HTTP version. Examples: GET / HTTP/1.1 GET /introduction.html?subject=plumbing HTTP/1.1 POST /forms/order.html HTTP/1.1 ::http::requestHeaders token ? headerName ? : This command returns the HTTP request header names and values, in the order that they were sent to the server, as a Tcl list of the form ?name value ...? Header names are case-insensitive and are converted to lower case. The return value is not a dict because some header names may occur more than once. If one argument is supplied, all request headers are returned. If two arguments are supplied, the second provides the value of a header name. Only headers with the requested name (converted to lower case) are returned. If no such headers are found, an empty list is returned. ::http::requestHeaderValue token headerName : This command returns the value of the HTTP request header named headerName . Header names are case-insensitive and are converted to lower case. If no such header exists, the return value is the empty string. If there are multiple headers named headerName , the result is obtained by joining the individual values with the string \\\", \\\" (comma and space), preserving their order. ::http::responseLine token : This command returns the first line of the server response: the HTTP \\\"status line\\\". The \\\"status line\\\" has three elements separated by spaces: the HTTP version, a three-digit numerical \\\"status code\\\", and a \\\"reason phrase\\\". Only the reason phrase may contain spaces. Examples: HTTP/1.1 200 OK HTTP/1.0 404 Not Found The \\\"status code\\\" is a three-digit number in the range 100 to 599. A value of 200 is the normal return from a GET request, and its matching \\\"reason phrase\\\" is \\\"OK\\\". Codes beginning with 4 or 5 indicate errors. Codes beginning with 3 are redirection errors. In this case the Location response header specifies a new URL that contains the requested information. The \\\"reason phrase\\\" is a textual description of the \\\"status code\\\": it may vary from server to server, and can be changed without affecting the HTTP protocol. The recommended values (RFC 7231 and IANA assignments) for each code are provided by the command ::http::reasonPhrase . ::http::responseCode token : This command returns the \\\"status code\\\" (200, 404, etc.) of the server \\\"status line\\\". If a three-digit code cannot be found, the full status line is returned. See command ::http::responseLine for more information on the \\\"status line\\\". ::http::reasonPhrase code : This command returns the IANA recommended \\\"reason phrase\\\" for a particular \\\"status code\\\" returned by a HTTP server. The argument code is a valid status code, and therefore is an integer in the range 100 to 599 inclusive. For numbers in this range with no assigned meaning, the command returns the value \\\"Unassigned\\\". Several status codes are used only in response to the methods defined by HTTP extensions such as WebDAV, and not in response to a HEAD, GET, or POST request method. The \\\"reason phrase\\\" returned by a HTTP server may differ from the recommended value, without affecting the HTTP protocol. The value returned by ::http::geturl can be obtained by calling either command ::http::responseLine (which returns the full status line) or command ::http::responseInfo (which returns a dictionary, with the \\\"reason phrase\\\" stored in key reasonPhrase ). A registry of valid status codes is maintained at https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ::http::responseHeaders token ? headerName ? : The response from a HTTP server includes metadata headers that describe the response body and the transaction itself. This command returns the HTTP response header names and values, in the order that they were received from the server, as a Tcl list of the form ?name value ...? Header names are case-insensitive and are converted to lower case. The return value is not a dict because some header names may occur more than once, notably Set-Cookie . If the second argument is not supplied, all response headers are returned. If the second argument is supplied, it provides the value of a header name. Only headers with the requested name (converted to lower case) are returned. If no such headers are found, an empty list is returned. See section METADATA for more information. ::http::responseHeaderValue token headerName : This command returns the value of the HTTP response header named headerName . Header names are case-insensitive and are converted to lower case. If no such header exists, the return value is the empty string. If there are multiple headers named headerName , the result is obtained by joining the individual values with the string \\\", \\\" (comma and space), preserving their order. Multiple headers with the same name may be processed in this manner, except Set-Cookie which does not conform to the comma-separated-list syntax and cannot be combined into a single value. Each Set-Cookie header must be treated individually, e.g. by processing the return value of ::http::responseHeaders token Set-Cookie . ::http::responseInfo token : This command returns a dict of selected response metadata that are essential for identifying a successful transaction and making use of the response, along with other metadata that are informational. The keys of the dict are stage , status , responseCode , reasonPhrase , contentType , binary , redirection , upgrade , error , postError , method , charset , compression , httpRequest , httpResponse , url , connectionRequest , connectionResponse , connectionActual , transferEncoding , totalPost , currentPost , totalSize , and currentSize . The meaning of these keys is described in the section METADATA below. It is always worth checking the value of *binary* after a HTTP transaction, to determine whether a misconfigured server has caused http to interpret a text resource as a binary, or vice versa. After a POST transaction, check the value of *postError* to verify that the request body was uploaded without error. ::http::responseBody token : This command returns the entity sent by the HTTP server (unless -channel was used, in which case the entity was delivered to the channel, and the command returns the empty string). Other terms for \\\"entity\\\", with varying precision, include \\\"representation of resource\\\", \\\"resource\\\", \\\"response body after decoding\\\", \\\"payload\\\", \\\"message body after decoding\\\", \\\"content(s)\\\", and \\\"file\\\". ::http::register proto port command : This procedure allows one to provide custom HTTP transport types such as HTTPS, by registering a prefix, the default port, and the command to execute to create the Tcl channel . E.g.: package require http package require tls ::http::register https 443 ::tls::socket set token \\[::http::geturl https://my.secure.site/\\] ::http::registerError port ? message ? : This procedure allows a registered protocol handler to deliver an error message for use by http . Calling this command does not raise an error. The command is useful when a registered protocol detects an problem (for example, an invalid TLS certificate) that will cause an error to propagate to http . The command allows http to provide a precise error message rather than a general one. The command returns the value provided by the last call with argument message , or the empty string if no such call has been made. ::http::unregister proto : This procedure unregisters a protocol handler that was previously registered via ::http::register , returning a two-item list of the default port and handler command that was previously installed (via ::http::register ) if there was such a handler, and an error if there was no such handler. ::http::code token : An alternative name for the command ::http::responseLine ::http::data token : An alternative name for the command ::http::responseBody . ::http::meta token ? headerName ? : An alternative name for the command ::http::responseHeaders ::http::ncode token : An alternative name for the command ::http::responseCode ERRORS The ::http::geturl procedure will raise errors in the following cases: invalid command line options, or an invalid URL. These errors mean that it cannot even start the network transaction. For synchronous ::http::geturl calls (where -command is not specified), it will raise an error if the URL is on a non-existent host or at a bad port on an existing host. It will also raise an error for any I/O errors while writing out the HTTP request line and headers, or reading the HTTP reply headers or data. Because ::http::geturl does not return a token in these cases, it does all the required cleanup and there is no issue of your app having to call ::http::cleanup . For asynchronous ::http::geturl calls, all of the above error situations apply, except that if there is any error while reading the HTTP reply headers or data, no exception is thrown. This is because after writing the HTTP headers, ::http::geturl returns, and the rest of the HTTP transaction occurs in the background. The command callback can check if any error occurred during the read by calling ::http::responseInfo to check the transaction status. Alternatively, if the main program flow reaches a point where it needs to know the result of the asynchronous HTTP request, it can call ::http::wait and then check status and error, just as the synchronous call does. The ::http::geturl command runs the -command , -handler , and -proxyfilter callbacks inside a catch command. Therefore an error in the callback command does not call the bgerror handler. When debugging one of these callbacks, it may be convenient to report errors by using a catch command within the callback command itself, e.g. to write an error message to stdout. In any case, you must still call ::http::cleanup to delete the state array when you are done. There are other possible results of the HTTP transaction determined by examining the status from ::http::status (or the value of the status key in the dictionary returned by ::http::responseInfo ). These are described below. ok : If the HTTP transaction completes entirely, then status will be ok . However, you should still check the ::http::responseLine value to get the HTTP status. The ::http::responseCode procedure provides just the numeric error (e.g., 200, 404 or 500) while the ::http::responseLine procedure returns a value like <!-- --> eof : If the server closes the socket without replying, then no error is raised, but the status of the transaction will be eof . error : The error message, stack trace, and error code are accessible via ::http::error . The error message is also provided by the value of the error key in the dictionary returned by ::http::responseInfo . timeout : A timeout occurred before the transaction could complete. reset : The user has called ::http::reset . \\\"\\\" : (empty string) The transaction has not yet finished. Another error possibility is that ::http::geturl failed to write the whole of the POST request body ( -query or -querychannel data) to the server. ::http::geturl stores the error message for later retrieval by the ::http::postError or ::http::responseInfo commands, and then attempts to complete the transaction. If it can read the server\\'s response the status will be ok , but it is important to call ::http::postError or ::http::responseInfo after every POST to check that the data was sent in full. If the server has closed the connection the status will be eof . METADATA MOST USEFUL METADATA When a HTTP server responds to a request, it supplies not only the entity requested, but also metadata. This is provided by the first line (the \\\"status line\\\") of the response, and by a number of HTTP headers. Further metadata relates to how ::http::geturl has processed the response from the server. The most important metadata can be accessed with the command ::http::responseInfo . This command returns a dict of metadata that are essential for identifying a successful transaction and making use of the response, along with other metadata that are informational. The keys of the dict are: ===== Essential Values ===== stage : This value, set by ::http::geturl , describes the stage that the transaction has reached. Values, in order of the transaction lifecycle, are: \\\"created\\\", \\\"connecting\\\", \\\"header\\\", \\\"body\\\", and \\\"complete\\\". The other dict keys will not be available until the value of stage is \\\"body\\\" or \\\"complete\\\". The key currentSize has its final value only when stage is \\\"complete\\\". status : This value, set by ::http::geturl , is \\\"ok\\\" for a successful transaction; \\\"eof\\\", \\\"error\\\", \\\"timeout\\\", or \\\"reset\\\" for an unsuccessful transaction; or \\\"\\\" if the transaction is still in progress. The value is the same as that returned by command ::http::status . The meaning of these values is described in the section ERRORS (above). responseCode : The \\\"HTTP status code\\\" sent by the server in the first line (the \\\"status line\\\") of the response. If the value cannot be extracted from the status line, the full status line is returned. reasonPhrase : The \\\"reason phrase\\\" sent by the server as a description of the HTTP status code. If the value cannot be extracted from the status line, the full status line is returned. contentType : The value of the Content-Type response header or, if the header was not supplied, the default value \\\"application/octet-stream\\\". binary : This boolean value, set by ::http::geturl , describes how the command has interpreted the entity returned by the server (after decoding any compression specified by the Content-Encoding response header). This decoded entity is accessible as the return value of the command ::http::responseBody . The value is true if http has interpreted the decoded entity as binary. The value returned by ::http::responseBody is a Tcl binary string. This is a suitable format for image data, zip files, etc. ::http::geturl chooses this value if the user has requested a binary interpretation by passing the option -binary to the command, or if the server has supplied a binary content type in a Content-Type response header, or if the server has not supplied any Content-Type header. The value is false in other cases, and this means that http has interpreted the decoded entity as text. The text has been converted, from the character set notified by the server, into Tcl\\'s internal Unicode format; the value returned by ::http::responseBody is an ordinary Tcl string. It is always worth checking the value of \\\"binary\\\" after a HTTP transaction, to determine whether a misconfigured server has caused http to interpret a text resource as a binary, or vice versa. redirection : The URL that is the redirection target. The value is that of the Location response header. This header is sent when a response has status code 3XX (redirection). upgrade : If not empty, the value indicates the protocol(s) to which the server will switch after completion of this transaction, while continuing to use the same connection. When the server intends to switch protocols, it will also send the value \\\"101\\\" as the status code (the responseCode key), and the word \\\"upgrade\\\" as an element of the Connection response header (the connectionResponse key), and it will not send a response body. See the section PROTOCOL UPGRADES for more information. error : The error message, if there is one. Further information, including a stack trace and error code, are available from command ::http::error . postError : The error message (if any) generated when a HTTP POST request sends its request-body to the server. Further information, including a stack trace and error code, are available from command ::http::postError . A POST transaction may appear complete, according to the keys stage , status , and responseCode , but it is important to check this postError key in case an error occurred when uploading the request-body. ===== Informational Values ===== method : The HTTP method used in the request. charset : The value of the charset attribute of the Content-Type response header. The charset value is used only for a text resource. If the server did not specify a charset, the value defaults to that of the variable ::http::defaultCharset , which unless it has been deliberately modified by the caller is iso8859-1 . Incoming text data is automatically converted from the character set defined by charset to Tcl\\'s internal Unicode representation, i.e. to a Tcl string. compression : A copy of the Content-Encoding response-header value. httpRequest : The version of HTTP specified in the request (i.e. sent in the request line). The value is that of the option -protocol supplied to ::http::geturl (default value \\\"1.1\\\"), unless the command reduced the value to \\\"1.0\\\" because it was passed the -handler option. httpResponse : The version of HTTP used by the server (obtained from the response \\\"status line\\\"). The server uses this version of HTTP in its response, but ensures that this response is compatible with the HTTP version specified in the client\\'s request. If the value cannot be extracted from the status line, the full status line is returned. url : The requested URL, typically the URL supplied as an argument to ::http::geturl but without its \\\"fragment\\\" (the final part of the URL beginning with \\\"#\\\"). connectionRequest : The value, if any, sent to the server in Connection request header(s). connectionResponse : The value, if any, received from the server in Connection response header(s). connectionActual : This value, set by ::http::geturl , reports whether the connection was closed after the transaction (value \\\"close\\\"), or left open (value \\\"keep-alive\\\"). transferEncoding : The value of the Transfer-Encoding response header, if it is present. The value is either \\\"chunked\\\" (indicating HTTP/1.1 \\\"chunked encoding\\\") or the empty string. totalPost : The total length of the request body in a POST request. currentPost : The number of bytes of the POST request body sent to the server so far. The value is the same as that returned by command ::http::size . totalSize : A copy of the Content-Length response-header value. The number of bytes specified in a Content-Length header, if one was sent. If none was sent, the value is 0. A correctly configured server omits this header if the transfer-encoding is \\\"chunked\\\", or (for older servers) if the server closes the connection when it reaches the end of the resource. currentSize : The number of bytes fetched from the server so far. MORE METADATA The dictionary returned by ::http::responseInfo is the most useful subset of the available metadata. Other metadata include: 1. The full \\\"status line\\\" of the response, available as the return value of command ::http::responseLine . 2. The full response headers, available as the return value of command ::http::responseHeaders . This return value is a list of the response-header names and values, in the order that they were received from the server. The return value is not a dict because some header names may occur more than once, notably Set-Cookie . If the value is read into a dict or into an array (using array set), only the last header with each name will be preserved. Some of the header names (metadata keys) are listed below, but the HTTP standard defines several more, and servers are free to add their own. When a dictionary key is mentioned below, this refers to the dict value returned by command ::http::responseInfo . Content-Type : The content type of the URL contents. Examples include text/html , image/gif, application/postscript and application/x-tcl . Text values typically specify a character set, e.g. text/html; charset=UTF-8 . Dictionary key contentType . Content-Length : The advertised size in bytes of the contents, available as dictionary key totalSize . The actual number of bytes read by ::http::geturl so far is available as dictionary key currentSize . Content-Encoding : The compression algorithm used for the contents. Examples include gzip , deflate . Dictionary key content . Location : This header is sent when a response has status code 3XX (redirection). It provides the URL that is the redirection target. Dictionary key redirection . Set-Cookie : This header is sent to offer a cookie to the client. Cookie management is done by the ::http::config option -cookiejar , and so the Set-Cookie headers need not be parsed by user scripts. See section COOKIE JAR PROTOCOL . Connection : The value can be supplied as a comma-separated list, or by multiple headers. The list often has only one element, either \\\"close\\\" or \\\"keep-alive\\\". The value \\\"upgrade\\\" indicates a successful upgrade request and is typically combined with the status code 101, an Upgrade response header, and no response body. Dictionary key connectionResponse . Upgrade : The value indicates the protocol(s) to which the server will switch immediately after the empty line that terminates the 101 response headers. Dictionary key upgrade . EVEN MORE METADATA 1. Details of the HTTP request. The request is determined by the options supplied to ::http::geturl and ::http::config . However, it is sometimes helpful to examine what ::http::geturl actually sent to the server, and this information is available through commands ::http::requestHeaders and ::http::requestLine . 2. The state array: the internal variables of ::http::geturl . It may sometimes be helpful to examine this array. Details are given in the next section. STATE ARRAY The ::http::geturl procedure returns a token that can be used as an argument to other ::http::* commands, which examine and manage the state of the HTTP transaction. For most purposes these commands are sufficient. The token can also be used to access the internal state of the transaction, which is stored in a Tcl array. This facility is most useful when writing callback commands for the options -command , -handler , -progress , or -queryprogress . Use the following command inside the proc to define an easy-to-use array state as a local variable within the proc upvar 0 \\$token state Once the data associated with the URL is no longer needed, the state array should be unset to free up storage. The ::http::cleanup procedure is provided for that purpose. The following elements of the array are supported, and are the origin of the values returned by commands as described below. When a dictionary key is mentioned below, this refers to the dict value returned by command ::http::responseInfo . binary : For dictionary key binary . body : For command ::http::responseBody . charset : For dictionary key charset . coding : For dictionary key compression . connection : For dictionary key connectionActual . currentsize : For command ::http::size ; and for dictionary key currentSize . error : For command ::http::error ; part is used in dictionary key error . http : For command ::http::responseLine . httpResponse : For dictionary key httpResponse . meta : For command ::http::responseHeaders . Further discussion above in the section MORE METADATA . method : For dictionary key method . posterror : For dictionary key postError . postErrorFull : For command ::http::postError . -protocol : For dictionary key httpRequest . querylength : For dictionary key totalPost . queryoffset : For dictionary key currentPost . reasonPhrase : For dictionary key reasonPhrase . requestHeaders : For command ::http::requestHeaders . requestLine : For command ::http::requestLine . responseCode : For dictionary key responseCode . state : For dictionary key stage . status : For command ::http::status ; and for dictionary key status . totalsize : For dictionary key totalSize . transfer : For dictionary key transferEncoding . type : For dictionary key contentType . upgrade : For dictionary key upgrade . url : For dictionary key url . PERSISTENT CONNECTIONS BASICS See RFC 7230 Sec 6, which supersedes RFC 2616 Sec 8.1. A persistent connection allows multiple HTTP/1.1 transactions to be carried over the same TCP connection. Pipelining allows a client to make multiple requests over a persistent connection without waiting for each response. The server sends responses in the same order that the requests were received. If a POST request fails to complete, typically user confirmation is needed before sending the request again. The user may wish to verify whether the server was modified by the failed POST request, before sending the same request again. A HTTP request will use a persistent socket if the call to http::geturl has the option -keepalive true . It will use pipelining where permitted if the http::config option -pipeline is boolean true (its default value). The http package maintains no more than one persistent connection to each server (i.e. each value of If http::geturl is called to make a request over a persistent connection while the connection is busy with another request, the new request will be held in a queue until the connection is free. The http package does not support HTTP/1.0 persistent connections controlled by the Keep-Alive header. SPECIAL CASES This subsection discusses issues related to closure of the persistent connection by the server, automatic retry of failed requests, the special treatment necessary for POST requests, and the options for dealing with these cases. In accordance with RFC 7230, http::geturl does not pipeline requests that use the POST method. If a POST uses a persistent connection and is not the first request on that connection, http::geturl waits until it has received the response for the previous request; or (if http::config option -postfresh is boolean true ) it uses a new connection for each POST. If the server is processing a number of pipelined requests, and sends a response header with one of the responses (other than the last), then subsequent responses are unfulfilled. http::geturl will send the unfulfilled requests again over a new connection. A difficulty arises when a HTTP client sends a request over a persistent connection that has been idle for a while. The HTTP server may half-close an apparently idle connection while the client is sending a request, but before the request arrives at the server: in this case (an the request will fail. The difficulty arises because the client cannot be certain whether the POST modified the state of the server. For HEAD or GET requests, http::geturl opens another connection and retransmits the failed request. However, if the request was a POST, RFC 7230 forbids automatic retry by default, suggesting either user confirmation, or confirmation by user-agent software that has semantic understanding of the application. The http::config option -repost allows for either possibility. Asynchronous close events can occur only in a short interval of time. The http package monitors each persistent connection for closure by the server. Upon detection, the connection is also closed at the client end, and subsequent requests will use a fresh connection. If the http::geturl command is called with option -keepalive true , then it will both try to use an existing persistent connection (if one is available), and it will send the server a request header asking to keep the connection open for future requests. The http::config options -pipeline , -postfresh , and -repost relate to persistent connections. Option -pipeline , if boolean true , will pipeline GET and HEAD requests made over a persistent connection. POST requests will not be pipelined - if the POST is not the first transaction on the connection, its request will not be sent until the previous response has finished. GET and HEAD requests made after a POST will not be sent until the POST response has been delivered, and will not be sent if the POST fails. Option -postfresh , if boolean true , will override the http::geturl option -keepalive , and always open a fresh connection for a POST request. Option -repost , if true , permits automatic retry of a POST request that fails because it uses a persistent connection that the server has half-closed (an Subsequent GET and HEAD requests in a failed pipeline will also be retried. The -repost option should be used only if the application understands that the retry is appropriate - specifically, the application must know that if the failed POST successfully modified the state of the server, a repeat POST would have no adverse effect. COOKIE JAR PROTOCOL Cookies are short key-value pairs used to implement sessions within the otherwise-stateless HTTP protocol. (See RFC 6265 for details; Tcl does not implement the Cookie2 protocol as that is rarely seen in the wild.) Cookie storage managment commands --- --- must support these subcommands which form the HTTP cookie storage management protocol. Note that cookieJar below does not have to be a command name; it is properly a command prefix (a Tcl list of words that will be expanded in place) and admits many possible implementations. Though not formally part of the protocol, it is expected that particular values of cookieJar will correspond to sessions; it is up to the caller of ::http::config to decide what session applies and to manage the deletion of said sessions when they are no longer desired (which should be when they not configured as the current cookie jar). cookieJar getCookies protocol host requestPath : This command asks the cookie jar what cookies should be supplied for a particular request. It should take the protocol (typically http or https ), host name and requestPath (parsed from the url argument to ::http::geturl ) and return a list of cookie keys and values that describe the cookies to supply to the remote host. The list must have an even number of elements. There should only ever be at most one cookie with a particular key for any request (typically the one with the most specific *host*/domain match and most specific *requestPath*/path match), but there may be many cookies with different names in any request. cookieJar storeCookie cookieDictionary : This command asks the cookie jar to store a particular cookie that was returned by a request; the result of this command is ignored. The cookie (which will have been parsed by the http package) is described by a dictionary, cookieDictionary , that may have the following keys: **domain** : This is always present. Its value describes the domain hostname *or* prefix that the cookie should be returned for. The checking of the domain against the origin (below) should be careful since sites that issue cookies should only do so for domains related to themselves. Cookies that do not obey a relevant origin matching rule should be ignored. **expires** : This is optional. If present, the cookie is intended to be a persistent cookie and the value of the option is the Tcl timestamp (in seconds from the same base as **clock seconds**) of when the cookie expires (which may be in the past, which should result in the cookie being deleted immediately). If absent, the cookie is intended to be a session cookie that should be not persisted beyond the lifetime of the cookie jar. **hostonly** : This is always present. Its value is a boolean that describes whether the cookie is a single host cookie (true) or a domain-level cookie (false). **httponly** : This is always present. Its value is a boolean that is true when the site wishes the cookie to only ever be used with HTTP (or HTTPS) traffic. **key** : This is always present. Its value is the *key* of the cookie, which is part of the information that must be return when sending this cookie back in a future request. **origin** : This is always present. Its value describes where the http package believes it received the cookie from, which may be useful for checking whether the cookie\\'s domain is valid. **path** : This is always present. Its value describes the path prefix of requests to the cookie domain where the cookie should be returned. **secure** : This is always present. Its value is a boolean that is true when the cookie should only used on requests sent over secure channels (typically HTTPS). **value** : This is always present. Its value is the value of the cookie, which is part of the information that must be return when sending this cookie back in a future request. Other keys may always be ignored; they have no meaning in this protocol. PROTOCOL UPGRADES The HTTP/1.1 Connection and Upgrade request headers inform the server that the client wishes to change the protocol used over the existing connection (RFC 7230). This mechanism can be used to request a WebSocket (RFC 6455), a higher version of the HTTP protocol (HTTP 2), or TLS encryption. If the server accepts the upgrade request, its response code will be 101. To request a protocol upgrade when calling http::geturl , the -headers option must supply appropriate values for Connection and Upgrade , and the -command option must supply a command that implements the requested protocol and can also handle the server response if the server refuses the protocol upgrade. For upgrade requests http::geturl ignores the value of option -keepalive , and always uses the value 0 so that the upgrade request is not made over a connection that is intended for multiple HTTP requests. The Tcllib library websocket implements WebSockets, and makes the necessary calls to commands in the http package. There is currently no native Tcl client library for HTTP/2. The Upgrade mechanism is not used to request TLS in web browsers, because http and https are served over different ports. It is used by protocols such as Internet Printing Protocol (IPP) that are built on top of http(s) and use the same TCP port number for both secure and insecure traffic. In browsers, opportunistic encryption is instead implemented by the Upgrade-Insecure-Requests client header. If a secure service is available, the server response code is a 307 redirect, and the response header Location specifies the target URL. The browser must call http::geturl again in order to fetch this URL. See https://w3c.github.io/webappsec-upgrade-insecure-requests/ THREADS PURPOSE Command ::http::geturl uses the Tcl ::socket command with the -async option to connect to a remote server, but the return from this command can be delayed in adverse cases (e.g. a slow DNS lookup), preventing the event loop from processing other events. This delay is avoided if the ::socket command is evaluated in another thread. The Thread package is not part of Tcl but is provided in \\\"Batteries Included\\\" distributions. Instead of the ::socket command, the http package uses ::http::socket which makes connections in the manner specified by the value of -threadlevel and the availability of package Thread. WITH TLS (HTTPS) The same -threadlevel configuration applies to both HTTP and HTTPS connections. HTTPS is enabled by using the http::register command, typically by specifying the ::tls::socket command of the tls package to handle TLS cryptography. The ::tls::socket command connects to the remote server by using the command specified by the value of variable ::tls::socketCmd , and this value defaults to \\\"::socket\\\". If http::geturl finds that ::tls::socketCmd has this value, it replaces it with the value \\\"::http::socket\\\". If ::tls::socketCmd has a value other than \\\"::socket\\\", i.e. if the script or the Tcl installation has replaced the value \\\"::socket\\\" with the name of a different command, then http does not change the value. The script or installation that modified ::tls::socketCmd is responsible for integrating ::http::socket into its own replacement command. WITH A CHILD INTERPRETER The peer thread can transfer the socket only to the main interpreter of the script\\'s thread. Therefore the thread-based ::http::socket works with non-zero -threadlevel values only if the script runs in the main interpreter. A child interpreter must use -threadlevel 0 unless the parent interpreter has provided alternative facilities. The main parent interpreter may grant full -threadlevel facilities to a child interpreter, for example by aliasing, to ::http::socket in the child, a command that runs http::socket in the parent, and then transfers the socket to the child. EXAMPLE This example creates a procedure to copy a URL to a file while printing a progress meter, and prints the response headers associated with the URL. proc httpcopy { url file {chunk 4096} } { set out [open \\$file w] set token [ ::http::geturl \\$url -channel \\$out \\ -progress httpCopyProgress -blocksize \\$chunk] close \\$out # This ends the line started by httpCopyProgress puts stderr \\\"\\\" upvar 0 \\$token state set max 0 foreach {name value} \\$state(meta) { if {[string length \\$name] > \\$max} { set max [string length \\$name] } if {[regexp -nocase \\^location\\$ \\$name]} { # Handle URL redirects puts stderr \\\"Location:\\$value\\\" return [httpcopy [string trim \\$value] \\$file \\$chunk] } } incr max foreach {name value} \\$state(meta) { puts [format \\\"%-*s %s\\\" \\$max \\$name: \\$value] } return \\$token } proc httpCopyProgress {args} { puts -nonewline stderr . flush stderr } SEE ALSO safe(n), socket(n), safesock(n) KEYWORDS internet, security policy, socket, www","title":"NAME"},{"location":"http/#name","text":"http - Client-side implementation of the HTTP/1.1 protocol","title":"NAME"},{"location":"http/#synopsis","text":"package require http ? 2.10 ? ::http::config ? -option value ...? ::http::geturl url ? -option value ...? ::http::formatQuery key value ? key value ...? ::http::quoteString value ::http::reset token ? why ? ::http::wait token ::http::status token ::http::size token ::http::error token ::http::postError token ::http::cleanup token ::http::requestLine token ::http::requestHeaders token ? headerName ? ::http::requestHeaderValue token headerName ::http::responseLine token ::http::responseCode token ::http::reasonPhrase code ::http::responseHeaders token ? headerName ? ::http::responseHeaderValue token headerName ::http::responseInfo token ::http::responseBody token ::http::register proto port command ::http::registerError port ? message ? ::http::unregister proto ::http::code token ::http::data token ::http::meta token ? headerName ? ::http::metaValue token headerName ::http::ncode token","title":"SYNOPSIS"},{"location":"http/#exported-commands","text":"Namespace http exports the commands config , formatQuery , geturl , postError , quoteString , reasonPhrase , register , registerError , requestHeaders , requestHeaderValue , requestLine , responseBody , responseCode , responseHeaders , responseHeaderValue , responseInfo , responseLine , reset , unregister , and wait . It does not export the commands cleanup , code , data , error , meta , metaValue , ncode , size , or status .","title":"EXPORTED COMMANDS"},{"location":"http/#description","text":"The http package provides the client side of the HTTP/1.1 protocol, as defined in RFC 9110 to 9112, which supersede RFC 7230 to RFC 7235, which in turn supersede RFC 2616. The package implements the GET, POST, and HEAD operations of HTTP/1.1. It allows configuration of a proxy host to get through firewalls. The package is compatible with the Safesock security policy, so it can be used by untrusted applets to do URL fetching from a restricted set of hosts. This package can be extended to support additional HTTP transport protocols, such as HTTPS, by providing a custom socket command, via ::http::register . The ::http::geturl procedure does a HTTP transaction. Its options * determine whether a GET, POST, or HEAD transaction is performed. The return value of ::http::geturl * is a token for the transaction. The token can be supplied as an argument to other commands, to manage the transaction and examine its results. If the -command option is specified, then the HTTP operation is done in the background. ::http::geturl returns immediately after generating the HTTP request and the -command callback is invoked when the transaction completes. For this to work, the Tcl event loop must be active. In Tk applications this is always true. For pure-Tcl applications, the caller can use ::http::wait after calling ::http::geturl to start the event loop. Note: The event queue is even used without the -command option. As a side effect, arbitrary commands may be processed while http::geturl is running. When the HTTP server has replied to the request, call the command ::http::responseInfo , which returns a dict of metadata that is essential for identifying a successful transaction and making use of the response. See section METADATA for details of the information returned. The response itself is returned by command ::http::responseBody , unless it has been redirected to a file by the -channel option of ::http::geturl .","title":"DESCRIPTION"},{"location":"http/#commands","text":"::http::config ? options ? : The ::http::config command is used to set and query the name of the proxy server and port, and the User-Agent name used in the HTTP requests. If no options are specified, then the current configuration is returned. If a single argument is specified, then it should be one of the flags described below. In this case the current value of that setting is returned. Otherwise, the options should be a set of flags and values that define the configuration: **-accept** *mimetypes* : The Accept header of the request. The default is \\*/\\*, which means that all types of documents are accepted. Otherwise you can supply a comma-separated list of mime type patterns that you are willing to receive. For example, **-cookiejar** *command* : The cookie store for the package to use to manage HTTP cookies. *command* is a command prefix list; if the empty list (the default value) is used, no cookies will be sent by requests or stored from responses. The command indicated by *command*, if supplied, must obey the **COOKIE JAR PROTOCOL** described below. **-pipeline** *boolean* : Specifies whether HTTP/1.1 transactions on a persistent socket will be pipelined. See the **PERSISTENT SOCKETS** section for details. The default is 1. **-postfresh** *boolean* : Specifies whether requests that use the **POST** method will always use a fresh socket, overriding the **-keepalive** option of command **http::geturl**. See the **PERSISTENT SOCKETS** section for details. The default is 0. **-proxyauth** *string* : If non-empty, the string is supplied to the proxy server as the value of the request header Proxy-Authorization. This option can be used for HTTP Basic Authentication. If the proxy server requires authentication by another technique, e.g. Digest Authentication, the **-proxyauth** option is not useful. In that case the caller must expect a 407 response from the proxy, compute the authentication value to be supplied, and use the **-headers** option to supply it as the value of the Proxy-Authorization header. **-proxyfilter** *command* : The command is a callback that is made during **::http::geturl** to determine if a proxy is required for a given host. One argument, a host name, is added to *command* when it is invoked. If a proxy is required, the callback should return a two-element list containing the proxy server and proxy port. Otherwise the filter command should return an empty list. The default value of **-proxyfilter** is **http::ProxyRequired**, and this command returns the values of the **-proxyhost** and **-proxyport** settings if they are non-empty. The options **-proxyhost**, **-proxyport**, and **-proxynot** are used only by **http::ProxyRequired**, and nowhere else in **::http::geturl**. A user-supplied **-proxyfilter** command may use these options, or alternatively it may obtain values from elsewhere in the calling script. In the latter case, any values provided for **-proxyhost**, **-proxyport**, and **-proxynot** are unused. The **::http::geturl** command runs the **-proxyfilter** callback inside a **catch** command. Therefore an error in the callback command does not call the **bgerror** handler. See the **ERRORS** section for details. **-proxyhost** *hostname* : The host name or IP address of the proxy server, if any. If this value is the empty string, the URL host is contacted directly. See **-proxyfilter** for how the value is used. **-proxynot** *list* : A Tcl list of domain names and IP addresses that should be accessed directly, not through the proxy server. The target hostname is compared with each list element using a case-insensitive **string match**. It is often convenient to use the wildcard \\\"\\*\\\" at the start of a domain name (e.g. \\*.example.com) or at the end of an IP address (e.g. 192.168.0.\\*). See **-proxyfilter** for how the value is used. **-proxyport** *number* : The port number of the proxy server. See **-proxyfilter** for how the value is used. **-repost** *boolean* : Specifies what to do if a POST request over a persistent connection fails because the server has half-closed the connection. If boolean **true**, the request will be automatically retried; if boolean **false** it will not, and the application that uses **http::geturl** is expected to seek user confirmation before retrying the POST. The value **true** should be used only under certain conditions. See the **PERSISTENT SOCKETS** section for details. The default is 0. **-threadlevel** *level* : Specifies whether and how to use the **Thread** package. Possible values of *level* are 0, 1 or 2. 0 - (the default) do not use Thread 1 - use Thread if it is available, do not use it if it is unavailable 2 - use Thread if it is available, raise an error if it is unavailable The Tcl **socket -async** command can block in adverse cases (e.g. a slow DNS lookup). Using the Thread package works around this problem, for both HTTP and HTTPS transactions. Values of *level* other than 0 are available only to the main interpreter in each thread. See section **THREADS** for more information. **-urlencoding** *encoding* : The *encoding* used for creating the x-url-encoded URLs with **::http::formatQuery** and **::http::quoteString**. The default is **utf-8**, as specified by RFC 2718. **-useragent** *string* : The value of the User-Agent header in the HTTP request. In an unsafe interpreter, the default value depends upon the operating system, and the version numbers of **http** and **Tcl**, and is (for example) A safe interpreter cannot determine its operating system, and so the default in a safe interpreter is to use a Windows 10 value with the current version numbers of **http** and **Tcl**. **-zip** *boolean* : If the value is boolean **true**, then by default requests will send a header If the value is boolean **false**, then by default requests will send a header In either case the default can be overridden for an individual request by supplying a custom **Accept-Encoding** header in the **-headers** option of **http::geturl**. The default value is 1. ::http::geturl url ? options ? : The ::http::geturl command is the main procedure in the package. The -query or -querychannel option causes a POST operation and the -validate option causes a HEAD operation; otherwise, a GET operation is performed. The ::http::geturl command returns a token value that can be passed as an argument to other commands to get information about the transaction. See the METADATA and ERRORS section for details. The ::http::geturl command blocks until the operation completes, unless the -command option specifies a callback that is invoked when the HTTP transaction completes. ::http::geturl takes several options: **-binary** *boolean* : Specifies whether to force interpreting the URL data as binary. Normally this is auto-detected (anything not beginning with a **text** content type or whose content encoding is **gzip** or **deflate** is considered binary data). **-blocksize** *size* : The block size used when reading the URL. At most *size* bytes are read at once. After each block, a call to the **-progress** callback is made (if that option is specified). **-channel** *name* : Copy the URL contents to channel *name* instead of saving it in a Tcl variable for retrieval by **::http::responseBody**. **-command** *callback* : The presence of this option causes **::http::geturl** to return immediately. After the HTTP transaction completes, the value of *callback* is expanded, an additional argument is added, and the resulting command is evaluated. The additional argument is the *token* returned from **::http::geturl**. This token is the name of an array that is described in the **STATE ARRAY** section. Here is a template for the callback: proc httpCallback {token} { upvar 0 \\$token state \\# Access state as a Tcl array defined in this proc \\... return } The **::http::geturl** command runs the **-command** callback inside a **catch** command. Therefore an error in the callback command does not call the **bgerror** handler. See the **ERRORS** section for details. **-guesstype** *boolean* : Attempt to guess the **Content-Type** and character set when a misconfigured server provides no information. The default value is *false* (do nothing). If boolean *true* then, if the server does not send a **Content-Type** header, or if it sends the value \\\"application/octet-stream\\\", **http::geturl** will attempt to guess appropriate values. This is not intended to become a general-purpose tool, and currently it is limited to detecting XML documents that begin with an XML declaration. In this case the **Content-Type** is changed to \\\"application/xml\\\", the binary flag state(binary) is changed to 0, and the character set is changed to the one specified by the \\\"encoding\\\" tag of the XML line, or to utf-8 if no encoding is specified. Not used if a *-channel* is specified. **-handler** *callback* : If this option is absent, **http::geturl** processes incoming data itself, either appending it to the state(body) variable or writing it to the -channel. But if the **-handler** option is present, **http::geturl** does not do this processing and instead calls *callback*. Whenever HTTP data is available, the value of *callback* is expanded, an additional two arguments are added, and the resulting command is evaluated. The two additional arguments are: the socket for the HTTP data and the *token* returned from **::http::geturl**. The token is the name of a global array that is described in the **STATE ARRAY** section. The procedure is expected to return the number of bytes read from the socket. Here is a template for the callback: proc httpHandlerCallback {socket token} { upvar 0 \\$token state \\# Access socket, and state as a Tcl array defined in this proc \\# For example\\... \\... set data \\[read \\$socket 1000\\] set nbytes \\[string length \\$data\\] \\... return \\$nbytes } The **http::geturl** code for the **-handler** option is not compatible with either compression or chunked transfer-encoding. If **-handler** is specified, then to work around these issues **http::geturl** will reduce the HTTP protocol to 1.0, and override the **-zip** option (i.e. it will send the header **Accept-Encoding: identity** instead of **Accept-Encoding: gzip,deflate**). If options **-handler** and **-channel** are used together, the handler is responsible for copying the data from the HTTP socket to the specified channel. The name of the channel is available to the handler as element **-channel** of the token array. The **::http::geturl** command runs the **-handler** callback inside a **catch** command. Therefore an error in the callback command does not call the **bgerror** handler. See the **ERRORS** section for details. **-headers** *keyvaluelist* : This option is used to add headers not already specified by **::http::config** to the HTTP request. The *keyvaluelist* argument must be a list with an even number of elements that alternate between keys and values. The keys become header field names. Newlines are stripped from the values so the header cannot be corrupted. For example, if *keyvaluelist* is **Pragma no-cache** then the following header is included in the HTTP request: Pragma: no-cache **-keepalive** *boolean* : If boolean **true**, attempt to keep the connection open for servicing multiple requests. Default is 0. **-method** *type* : Force the HTTP request method to *type*. **::http::geturl** will auto-select GET, POST or HEAD based on other options, but this option overrides that selection and enables choices like PUT and DELETE for WebDAV support. It is the caller\\'s responsibility to ensure that the headers and request body (if any) conform to the requirements of the request method. For example, if using **-method** *POST* to send a POST with an empty request body, the caller must also supply the option -headers {Content-Length 0} **-myaddr** *address* : Pass an specific local address to the underlying **socket** call in case multiple interfaces are available. **-progress** *callback* : If the **-progress** option is present, then the *callback* is made after each transfer of data from the URL. The value of *callback* is expanded, an additional three arguments are added, and the resulting command is evaluated. The three additional arguments are: the *token* returned from **::http::geturl**, the expected total size of the contents from the **Content-Length** response header, and the current number of bytes transferred so far. The token is the name of a global array that is described in the **STATE ARRAY** section. The expected total size may be unknown, in which case zero is passed to the callback. Here is a template for the progress callback: proc httpProgress {token total current} { upvar 0 \\$token state \\# Access state as a Tcl array defined in this proc \\... return } **-protocol** *version* : Select the HTTP protocol version to use. This should be 1.0 or 1.1 (the default). Should only be necessary for servers that do not understand or otherwise complain about HTTP/1.1. **-query** *query* : This flag (if the value is non-empty) causes **::http::geturl** to do a POST request that passes the string *query* verbatim to the server as the request payload. The content format (and encoding) of *query* is announced by the request header **Content-Type** which is set by the option **-type**. Any value of **-type** is permitted, and it is the responsibility of the caller to supply *query* in the correct format. If **-type** is not specified, it defaults to *application/x-www-form-urlencoded*, which requires *query* to be an x-url-encoding formatted query-string (this **-type** and query format are used in a POST submitted from an html form). The **::http::formatQuery** procedure can be used to do the formatting. **-queryblocksize** *size* : The block size used when posting query data to the URL. At most *size* bytes are written at once. After each block, a call to the **-queryprogress** callback is made (if that option is specified). **-querychannel** *channelID* : This flag causes **::http::geturl** to do a POST request that passes the data contained in *channelID* to the server. The data contained in *channelID* must be an x-url-encoding formatted query unless the **-type** option below is used. If a **Content-Length** header is not specified via the **-headers** options, **::http::geturl** attempts to determine the size of the post data in order to create that header. If it is unable to determine the size, it returns an error. **-queryprogress** *callback* : If the **-queryprogress** option is present, then the *callback* is made after each transfer of data to the URL in a POST request (i.e. a call to **::http::geturl** with option **-query** or **-querychannel**) and acts exactly like the **-progress** option (the callback format is the same). **-strict** *boolean* : If true then the command will test that the URL complies with RFC 3986, i.e. that it has no characters that should be \\\"x-url-encoded\\\" (e.g. a space should be encoded to \\\"%20\\\"). Default value is 1. **-timeout** *milliseconds* : If *milliseconds* is non-zero, then **::http::geturl** sets up a timeout to occur after the specified number of milliseconds. A timeout results in a call to **::http::reset** and to the **-command** callback, if specified. The return value of **::http::status** (and the value of the *status* key in the dictionary returned by **::http::responseInfo**) is **timeout** after a timeout has occurred. **-type** *mime-type* : Use *mime-type* as the **Content-Type** value, instead of the default value (**application/x-www-form-urlencoded**) during a POST operation. **-validate** *boolean* : If *boolean* is non-zero, then **::http::geturl** does an HTTP HEAD request. This server returns the same status line and response headers as it would for a HTTP GET request, but omits the response entity (the URL \\\"contents\\\"). The response headers are available after the transaction using command **::http::responseHeaders** or, for selected information, **::http::responseInfo**. ::http::formatQuery key value ? key value ...? : This procedure does x-url-encoding of query data. It takes an even number of arguments that are the keys and values of the query. It encodes the keys and values, and generates one string that has the proper & and = separators. The result is suitable for the -query value passed to ::http::geturl . ::http::quoteString value : This procedure does x-url-encoding of string. It takes a single argument and encodes it. ::http::reset token ? why ? : This command resets the HTTP transaction identified by token , if any. This sets the state(status) value to why , which defaults to reset , and then calls the registered -command callback. ::http::wait token : This command blocks and waits for the transaction to complete. This only works in trusted code because it uses vwait . Also, it is not useful for the case where ::http::geturl is called without the -command option because in this case the ::http::geturl call does not return until the HTTP transaction is complete, and thus there is nothing to wait for. ::http::status token : This command returns a description of the status of the HTTP transaction. The return value is the empty string until the HTTP transaction is completed; after completion it has one of the values ok, eof, error, timeout, and reset. The meaning of these values is described in the section ERRORS (below). The name \\\"status\\\" is not related to the terms \\\"status line\\\" and \\\"status code\\\" that are defined for a HTTP response. ::http::size token : This command returns the number of bytes received so far from the URL in the ::http::geturl call. ::http::error token : This command returns the error information if the HTTP transaction failed, or the empty string if there was no error. The information is a Tcl list of the error message, stack trace, and error code. ::http::postError token : A POST request is a call to ::http::geturl with either the -query or -querychannel option. The ::http::postError command returns the error information generated when a HTTP POST request sends its request-body to the server; or the empty string if there was no error. The information is a Tcl list of the error message, stack trace, and error code. When this type of error occurs, the ::http::geturl command continues the transaction and attempts to receive a response from the server. ::http::cleanup token : This procedure cleans up the state associated with the connection identified by token . After this call, the procedures like ::http::responseBody cannot be used to get information about the operation. It is strongly recommended that you call this function after you are done with a given HTTP request. Not doing so will result in memory not being freed, and if your app calls ::http::geturl enough times, the memory leak could cause a performance hit...or worse. ::http::requestLine token : This command returns the \\\"request line\\\" sent to the server. The \\\"request line\\\" is the first line of a HTTP client request, and has three elements separated by spaces: the HTTP method, the URL relative to the server, and the HTTP version. Examples: GET / HTTP/1.1 GET /introduction.html?subject=plumbing HTTP/1.1 POST /forms/order.html HTTP/1.1 ::http::requestHeaders token ? headerName ? : This command returns the HTTP request header names and values, in the order that they were sent to the server, as a Tcl list of the form ?name value ...? Header names are case-insensitive and are converted to lower case. The return value is not a dict because some header names may occur more than once. If one argument is supplied, all request headers are returned. If two arguments are supplied, the second provides the value of a header name. Only headers with the requested name (converted to lower case) are returned. If no such headers are found, an empty list is returned. ::http::requestHeaderValue token headerName : This command returns the value of the HTTP request header named headerName . Header names are case-insensitive and are converted to lower case. If no such header exists, the return value is the empty string. If there are multiple headers named headerName , the result is obtained by joining the individual values with the string \\\", \\\" (comma and space), preserving their order. ::http::responseLine token : This command returns the first line of the server response: the HTTP \\\"status line\\\". The \\\"status line\\\" has three elements separated by spaces: the HTTP version, a three-digit numerical \\\"status code\\\", and a \\\"reason phrase\\\". Only the reason phrase may contain spaces. Examples: HTTP/1.1 200 OK HTTP/1.0 404 Not Found The \\\"status code\\\" is a three-digit number in the range 100 to 599. A value of 200 is the normal return from a GET request, and its matching \\\"reason phrase\\\" is \\\"OK\\\". Codes beginning with 4 or 5 indicate errors. Codes beginning with 3 are redirection errors. In this case the Location response header specifies a new URL that contains the requested information. The \\\"reason phrase\\\" is a textual description of the \\\"status code\\\": it may vary from server to server, and can be changed without affecting the HTTP protocol. The recommended values (RFC 7231 and IANA assignments) for each code are provided by the command ::http::reasonPhrase . ::http::responseCode token : This command returns the \\\"status code\\\" (200, 404, etc.) of the server \\\"status line\\\". If a three-digit code cannot be found, the full status line is returned. See command ::http::responseLine for more information on the \\\"status line\\\". ::http::reasonPhrase code : This command returns the IANA recommended \\\"reason phrase\\\" for a particular \\\"status code\\\" returned by a HTTP server. The argument code is a valid status code, and therefore is an integer in the range 100 to 599 inclusive. For numbers in this range with no assigned meaning, the command returns the value \\\"Unassigned\\\". Several status codes are used only in response to the methods defined by HTTP extensions such as WebDAV, and not in response to a HEAD, GET, or POST request method. The \\\"reason phrase\\\" returned by a HTTP server may differ from the recommended value, without affecting the HTTP protocol. The value returned by ::http::geturl can be obtained by calling either command ::http::responseLine (which returns the full status line) or command ::http::responseInfo (which returns a dictionary, with the \\\"reason phrase\\\" stored in key reasonPhrase ). A registry of valid status codes is maintained at https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml ::http::responseHeaders token ? headerName ? : The response from a HTTP server includes metadata headers that describe the response body and the transaction itself. This command returns the HTTP response header names and values, in the order that they were received from the server, as a Tcl list of the form ?name value ...? Header names are case-insensitive and are converted to lower case. The return value is not a dict because some header names may occur more than once, notably Set-Cookie . If the second argument is not supplied, all response headers are returned. If the second argument is supplied, it provides the value of a header name. Only headers with the requested name (converted to lower case) are returned. If no such headers are found, an empty list is returned. See section METADATA for more information. ::http::responseHeaderValue token headerName : This command returns the value of the HTTP response header named headerName . Header names are case-insensitive and are converted to lower case. If no such header exists, the return value is the empty string. If there are multiple headers named headerName , the result is obtained by joining the individual values with the string \\\", \\\" (comma and space), preserving their order. Multiple headers with the same name may be processed in this manner, except Set-Cookie which does not conform to the comma-separated-list syntax and cannot be combined into a single value. Each Set-Cookie header must be treated individually, e.g. by processing the return value of ::http::responseHeaders token Set-Cookie . ::http::responseInfo token : This command returns a dict of selected response metadata that are essential for identifying a successful transaction and making use of the response, along with other metadata that are informational. The keys of the dict are stage , status , responseCode , reasonPhrase , contentType , binary , redirection , upgrade , error , postError , method , charset , compression , httpRequest , httpResponse , url , connectionRequest , connectionResponse , connectionActual , transferEncoding , totalPost , currentPost , totalSize , and currentSize . The meaning of these keys is described in the section METADATA below. It is always worth checking the value of *binary* after a HTTP transaction, to determine whether a misconfigured server has caused http to interpret a text resource as a binary, or vice versa. After a POST transaction, check the value of *postError* to verify that the request body was uploaded without error. ::http::responseBody token : This command returns the entity sent by the HTTP server (unless -channel was used, in which case the entity was delivered to the channel, and the command returns the empty string). Other terms for \\\"entity\\\", with varying precision, include \\\"representation of resource\\\", \\\"resource\\\", \\\"response body after decoding\\\", \\\"payload\\\", \\\"message body after decoding\\\", \\\"content(s)\\\", and \\\"file\\\". ::http::register proto port command : This procedure allows one to provide custom HTTP transport types such as HTTPS, by registering a prefix, the default port, and the command to execute to create the Tcl channel . E.g.: package require http package require tls ::http::register https 443 ::tls::socket set token \\[::http::geturl https://my.secure.site/\\] ::http::registerError port ? message ? : This procedure allows a registered protocol handler to deliver an error message for use by http . Calling this command does not raise an error. The command is useful when a registered protocol detects an problem (for example, an invalid TLS certificate) that will cause an error to propagate to http . The command allows http to provide a precise error message rather than a general one. The command returns the value provided by the last call with argument message , or the empty string if no such call has been made. ::http::unregister proto : This procedure unregisters a protocol handler that was previously registered via ::http::register , returning a two-item list of the default port and handler command that was previously installed (via ::http::register ) if there was such a handler, and an error if there was no such handler. ::http::code token : An alternative name for the command ::http::responseLine ::http::data token : An alternative name for the command ::http::responseBody . ::http::meta token ? headerName ? : An alternative name for the command ::http::responseHeaders ::http::ncode token : An alternative name for the command ::http::responseCode","title":"COMMANDS"},{"location":"http/#errors","text":"The ::http::geturl procedure will raise errors in the following cases: invalid command line options, or an invalid URL. These errors mean that it cannot even start the network transaction. For synchronous ::http::geturl calls (where -command is not specified), it will raise an error if the URL is on a non-existent host or at a bad port on an existing host. It will also raise an error for any I/O errors while writing out the HTTP request line and headers, or reading the HTTP reply headers or data. Because ::http::geturl does not return a token in these cases, it does all the required cleanup and there is no issue of your app having to call ::http::cleanup . For asynchronous ::http::geturl calls, all of the above error situations apply, except that if there is any error while reading the HTTP reply headers or data, no exception is thrown. This is because after writing the HTTP headers, ::http::geturl returns, and the rest of the HTTP transaction occurs in the background. The command callback can check if any error occurred during the read by calling ::http::responseInfo to check the transaction status. Alternatively, if the main program flow reaches a point where it needs to know the result of the asynchronous HTTP request, it can call ::http::wait and then check status and error, just as the synchronous call does. The ::http::geturl command runs the -command , -handler , and -proxyfilter callbacks inside a catch command. Therefore an error in the callback command does not call the bgerror handler. When debugging one of these callbacks, it may be convenient to report errors by using a catch command within the callback command itself, e.g. to write an error message to stdout. In any case, you must still call ::http::cleanup to delete the state array when you are done. There are other possible results of the HTTP transaction determined by examining the status from ::http::status (or the value of the status key in the dictionary returned by ::http::responseInfo ). These are described below. ok : If the HTTP transaction completes entirely, then status will be ok . However, you should still check the ::http::responseLine value to get the HTTP status. The ::http::responseCode procedure provides just the numeric error (e.g., 200, 404 or 500) while the ::http::responseLine procedure returns a value like <!-- --> eof : If the server closes the socket without replying, then no error is raised, but the status of the transaction will be eof . error : The error message, stack trace, and error code are accessible via ::http::error . The error message is also provided by the value of the error key in the dictionary returned by ::http::responseInfo . timeout : A timeout occurred before the transaction could complete. reset : The user has called ::http::reset . \\\"\\\" : (empty string) The transaction has not yet finished. Another error possibility is that ::http::geturl failed to write the whole of the POST request body ( -query or -querychannel data) to the server. ::http::geturl stores the error message for later retrieval by the ::http::postError or ::http::responseInfo commands, and then attempts to complete the transaction. If it can read the server\\'s response the status will be ok , but it is important to call ::http::postError or ::http::responseInfo after every POST to check that the data was sent in full. If the server has closed the connection the status will be eof .","title":"ERRORS"},{"location":"http/#metadata","text":"","title":"METADATA"},{"location":"http/#most-useful-metadata","text":"When a HTTP server responds to a request, it supplies not only the entity requested, but also metadata. This is provided by the first line (the \\\"status line\\\") of the response, and by a number of HTTP headers. Further metadata relates to how ::http::geturl has processed the response from the server. The most important metadata can be accessed with the command ::http::responseInfo . This command returns a dict of metadata that are essential for identifying a successful transaction and making use of the response, along with other metadata that are informational. The keys of the dict are: ===== Essential Values ===== stage : This value, set by ::http::geturl , describes the stage that the transaction has reached. Values, in order of the transaction lifecycle, are: \\\"created\\\", \\\"connecting\\\", \\\"header\\\", \\\"body\\\", and \\\"complete\\\". The other dict keys will not be available until the value of stage is \\\"body\\\" or \\\"complete\\\". The key currentSize has its final value only when stage is \\\"complete\\\". status : This value, set by ::http::geturl , is \\\"ok\\\" for a successful transaction; \\\"eof\\\", \\\"error\\\", \\\"timeout\\\", or \\\"reset\\\" for an unsuccessful transaction; or \\\"\\\" if the transaction is still in progress. The value is the same as that returned by command ::http::status . The meaning of these values is described in the section ERRORS (above). responseCode : The \\\"HTTP status code\\\" sent by the server in the first line (the \\\"status line\\\") of the response. If the value cannot be extracted from the status line, the full status line is returned. reasonPhrase : The \\\"reason phrase\\\" sent by the server as a description of the HTTP status code. If the value cannot be extracted from the status line, the full status line is returned. contentType : The value of the Content-Type response header or, if the header was not supplied, the default value \\\"application/octet-stream\\\". binary : This boolean value, set by ::http::geturl , describes how the command has interpreted the entity returned by the server (after decoding any compression specified by the Content-Encoding response header). This decoded entity is accessible as the return value of the command ::http::responseBody . The value is true if http has interpreted the decoded entity as binary. The value returned by ::http::responseBody is a Tcl binary string. This is a suitable format for image data, zip files, etc. ::http::geturl chooses this value if the user has requested a binary interpretation by passing the option -binary to the command, or if the server has supplied a binary content type in a Content-Type response header, or if the server has not supplied any Content-Type header. The value is false in other cases, and this means that http has interpreted the decoded entity as text. The text has been converted, from the character set notified by the server, into Tcl\\'s internal Unicode format; the value returned by ::http::responseBody is an ordinary Tcl string. It is always worth checking the value of \\\"binary\\\" after a HTTP transaction, to determine whether a misconfigured server has caused http to interpret a text resource as a binary, or vice versa. redirection : The URL that is the redirection target. The value is that of the Location response header. This header is sent when a response has status code 3XX (redirection). upgrade : If not empty, the value indicates the protocol(s) to which the server will switch after completion of this transaction, while continuing to use the same connection. When the server intends to switch protocols, it will also send the value \\\"101\\\" as the status code (the responseCode key), and the word \\\"upgrade\\\" as an element of the Connection response header (the connectionResponse key), and it will not send a response body. See the section PROTOCOL UPGRADES for more information. error : The error message, if there is one. Further information, including a stack trace and error code, are available from command ::http::error . postError : The error message (if any) generated when a HTTP POST request sends its request-body to the server. Further information, including a stack trace and error code, are available from command ::http::postError . A POST transaction may appear complete, according to the keys stage , status , and responseCode , but it is important to check this postError key in case an error occurred when uploading the request-body. ===== Informational Values ===== method : The HTTP method used in the request. charset : The value of the charset attribute of the Content-Type response header. The charset value is used only for a text resource. If the server did not specify a charset, the value defaults to that of the variable ::http::defaultCharset , which unless it has been deliberately modified by the caller is iso8859-1 . Incoming text data is automatically converted from the character set defined by charset to Tcl\\'s internal Unicode representation, i.e. to a Tcl string. compression : A copy of the Content-Encoding response-header value. httpRequest : The version of HTTP specified in the request (i.e. sent in the request line). The value is that of the option -protocol supplied to ::http::geturl (default value \\\"1.1\\\"), unless the command reduced the value to \\\"1.0\\\" because it was passed the -handler option. httpResponse : The version of HTTP used by the server (obtained from the response \\\"status line\\\"). The server uses this version of HTTP in its response, but ensures that this response is compatible with the HTTP version specified in the client\\'s request. If the value cannot be extracted from the status line, the full status line is returned. url : The requested URL, typically the URL supplied as an argument to ::http::geturl but without its \\\"fragment\\\" (the final part of the URL beginning with \\\"#\\\"). connectionRequest : The value, if any, sent to the server in Connection request header(s). connectionResponse : The value, if any, received from the server in Connection response header(s). connectionActual : This value, set by ::http::geturl , reports whether the connection was closed after the transaction (value \\\"close\\\"), or left open (value \\\"keep-alive\\\"). transferEncoding : The value of the Transfer-Encoding response header, if it is present. The value is either \\\"chunked\\\" (indicating HTTP/1.1 \\\"chunked encoding\\\") or the empty string. totalPost : The total length of the request body in a POST request. currentPost : The number of bytes of the POST request body sent to the server so far. The value is the same as that returned by command ::http::size . totalSize : A copy of the Content-Length response-header value. The number of bytes specified in a Content-Length header, if one was sent. If none was sent, the value is 0. A correctly configured server omits this header if the transfer-encoding is \\\"chunked\\\", or (for older servers) if the server closes the connection when it reaches the end of the resource. currentSize : The number of bytes fetched from the server so far.","title":"MOST USEFUL METADATA"},{"location":"http/#more-metadata","text":"The dictionary returned by ::http::responseInfo is the most useful subset of the available metadata. Other metadata include: 1. The full \\\"status line\\\" of the response, available as the return value of command ::http::responseLine . 2. The full response headers, available as the return value of command ::http::responseHeaders . This return value is a list of the response-header names and values, in the order that they were received from the server. The return value is not a dict because some header names may occur more than once, notably Set-Cookie . If the value is read into a dict or into an array (using array set), only the last header with each name will be preserved. Some of the header names (metadata keys) are listed below, but the HTTP standard defines several more, and servers are free to add their own. When a dictionary key is mentioned below, this refers to the dict value returned by command ::http::responseInfo . Content-Type : The content type of the URL contents. Examples include text/html , image/gif, application/postscript and application/x-tcl . Text values typically specify a character set, e.g. text/html; charset=UTF-8 . Dictionary key contentType . Content-Length : The advertised size in bytes of the contents, available as dictionary key totalSize . The actual number of bytes read by ::http::geturl so far is available as dictionary key currentSize . Content-Encoding : The compression algorithm used for the contents. Examples include gzip , deflate . Dictionary key content . Location : This header is sent when a response has status code 3XX (redirection). It provides the URL that is the redirection target. Dictionary key redirection . Set-Cookie : This header is sent to offer a cookie to the client. Cookie management is done by the ::http::config option -cookiejar , and so the Set-Cookie headers need not be parsed by user scripts. See section COOKIE JAR PROTOCOL . Connection : The value can be supplied as a comma-separated list, or by multiple headers. The list often has only one element, either \\\"close\\\" or \\\"keep-alive\\\". The value \\\"upgrade\\\" indicates a successful upgrade request and is typically combined with the status code 101, an Upgrade response header, and no response body. Dictionary key connectionResponse . Upgrade : The value indicates the protocol(s) to which the server will switch immediately after the empty line that terminates the 101 response headers. Dictionary key upgrade .","title":"MORE METADATA"},{"location":"http/#even-more-metadata","text":"1. Details of the HTTP request. The request is determined by the options supplied to ::http::geturl and ::http::config . However, it is sometimes helpful to examine what ::http::geturl actually sent to the server, and this information is available through commands ::http::requestHeaders and ::http::requestLine . 2. The state array: the internal variables of ::http::geturl . It may sometimes be helpful to examine this array. Details are given in the next section.","title":"EVEN MORE METADATA"},{"location":"http/#state-array","text":"The ::http::geturl procedure returns a token that can be used as an argument to other ::http::* commands, which examine and manage the state of the HTTP transaction. For most purposes these commands are sufficient. The token can also be used to access the internal state of the transaction, which is stored in a Tcl array. This facility is most useful when writing callback commands for the options -command , -handler , -progress , or -queryprogress . Use the following command inside the proc to define an easy-to-use array state as a local variable within the proc upvar 0 \\$token state Once the data associated with the URL is no longer needed, the state array should be unset to free up storage. The ::http::cleanup procedure is provided for that purpose. The following elements of the array are supported, and are the origin of the values returned by commands as described below. When a dictionary key is mentioned below, this refers to the dict value returned by command ::http::responseInfo . binary : For dictionary key binary . body : For command ::http::responseBody . charset : For dictionary key charset . coding : For dictionary key compression . connection : For dictionary key connectionActual . currentsize : For command ::http::size ; and for dictionary key currentSize . error : For command ::http::error ; part is used in dictionary key error . http : For command ::http::responseLine . httpResponse : For dictionary key httpResponse . meta : For command ::http::responseHeaders . Further discussion above in the section MORE METADATA . method : For dictionary key method . posterror : For dictionary key postError . postErrorFull : For command ::http::postError . -protocol : For dictionary key httpRequest . querylength : For dictionary key totalPost . queryoffset : For dictionary key currentPost . reasonPhrase : For dictionary key reasonPhrase . requestHeaders : For command ::http::requestHeaders . requestLine : For command ::http::requestLine . responseCode : For dictionary key responseCode . state : For dictionary key stage . status : For command ::http::status ; and for dictionary key status . totalsize : For dictionary key totalSize . transfer : For dictionary key transferEncoding . type : For dictionary key contentType . upgrade : For dictionary key upgrade . url : For dictionary key url .","title":"STATE ARRAY"},{"location":"http/#persistent-connections","text":"","title":"PERSISTENT CONNECTIONS"},{"location":"http/#basics","text":"See RFC 7230 Sec 6, which supersedes RFC 2616 Sec 8.1. A persistent connection allows multiple HTTP/1.1 transactions to be carried over the same TCP connection. Pipelining allows a client to make multiple requests over a persistent connection without waiting for each response. The server sends responses in the same order that the requests were received. If a POST request fails to complete, typically user confirmation is needed before sending the request again. The user may wish to verify whether the server was modified by the failed POST request, before sending the same request again. A HTTP request will use a persistent socket if the call to http::geturl has the option -keepalive true . It will use pipelining where permitted if the http::config option -pipeline is boolean true (its default value). The http package maintains no more than one persistent connection to each server (i.e. each value of If http::geturl is called to make a request over a persistent connection while the connection is busy with another request, the new request will be held in a queue until the connection is free. The http package does not support HTTP/1.0 persistent connections controlled by the Keep-Alive header.","title":"BASICS"},{"location":"http/#special-cases","text":"This subsection discusses issues related to closure of the persistent connection by the server, automatic retry of failed requests, the special treatment necessary for POST requests, and the options for dealing with these cases. In accordance with RFC 7230, http::geturl does not pipeline requests that use the POST method. If a POST uses a persistent connection and is not the first request on that connection, http::geturl waits until it has received the response for the previous request; or (if http::config option -postfresh is boolean true ) it uses a new connection for each POST. If the server is processing a number of pipelined requests, and sends a response header with one of the responses (other than the last), then subsequent responses are unfulfilled. http::geturl will send the unfulfilled requests again over a new connection. A difficulty arises when a HTTP client sends a request over a persistent connection that has been idle for a while. The HTTP server may half-close an apparently idle connection while the client is sending a request, but before the request arrives at the server: in this case (an the request will fail. The difficulty arises because the client cannot be certain whether the POST modified the state of the server. For HEAD or GET requests, http::geturl opens another connection and retransmits the failed request. However, if the request was a POST, RFC 7230 forbids automatic retry by default, suggesting either user confirmation, or confirmation by user-agent software that has semantic understanding of the application. The http::config option -repost allows for either possibility. Asynchronous close events can occur only in a short interval of time. The http package monitors each persistent connection for closure by the server. Upon detection, the connection is also closed at the client end, and subsequent requests will use a fresh connection. If the http::geturl command is called with option -keepalive true , then it will both try to use an existing persistent connection (if one is available), and it will send the server a request header asking to keep the connection open for future requests. The http::config options -pipeline , -postfresh , and -repost relate to persistent connections. Option -pipeline , if boolean true , will pipeline GET and HEAD requests made over a persistent connection. POST requests will not be pipelined - if the POST is not the first transaction on the connection, its request will not be sent until the previous response has finished. GET and HEAD requests made after a POST will not be sent until the POST response has been delivered, and will not be sent if the POST fails. Option -postfresh , if boolean true , will override the http::geturl option -keepalive , and always open a fresh connection for a POST request. Option -repost , if true , permits automatic retry of a POST request that fails because it uses a persistent connection that the server has half-closed (an Subsequent GET and HEAD requests in a failed pipeline will also be retried. The -repost option should be used only if the application understands that the retry is appropriate - specifically, the application must know that if the failed POST successfully modified the state of the server, a repeat POST would have no adverse effect.","title":"SPECIAL CASES"},{"location":"http/#cookie-jar-protocol","text":"Cookies are short key-value pairs used to implement sessions within the otherwise-stateless HTTP protocol. (See RFC 6265 for details; Tcl does not implement the Cookie2 protocol as that is rarely seen in the wild.) Cookie storage managment commands --- --- must support these subcommands which form the HTTP cookie storage management protocol. Note that cookieJar below does not have to be a command name; it is properly a command prefix (a Tcl list of words that will be expanded in place) and admits many possible implementations. Though not formally part of the protocol, it is expected that particular values of cookieJar will correspond to sessions; it is up to the caller of ::http::config to decide what session applies and to manage the deletion of said sessions when they are no longer desired (which should be when they not configured as the current cookie jar). cookieJar getCookies protocol host requestPath : This command asks the cookie jar what cookies should be supplied for a particular request. It should take the protocol (typically http or https ), host name and requestPath (parsed from the url argument to ::http::geturl ) and return a list of cookie keys and values that describe the cookies to supply to the remote host. The list must have an even number of elements. There should only ever be at most one cookie with a particular key for any request (typically the one with the most specific *host*/domain match and most specific *requestPath*/path match), but there may be many cookies with different names in any request. cookieJar storeCookie cookieDictionary : This command asks the cookie jar to store a particular cookie that was returned by a request; the result of this command is ignored. The cookie (which will have been parsed by the http package) is described by a dictionary, cookieDictionary , that may have the following keys: **domain** : This is always present. Its value describes the domain hostname *or* prefix that the cookie should be returned for. The checking of the domain against the origin (below) should be careful since sites that issue cookies should only do so for domains related to themselves. Cookies that do not obey a relevant origin matching rule should be ignored. **expires** : This is optional. If present, the cookie is intended to be a persistent cookie and the value of the option is the Tcl timestamp (in seconds from the same base as **clock seconds**) of when the cookie expires (which may be in the past, which should result in the cookie being deleted immediately). If absent, the cookie is intended to be a session cookie that should be not persisted beyond the lifetime of the cookie jar. **hostonly** : This is always present. Its value is a boolean that describes whether the cookie is a single host cookie (true) or a domain-level cookie (false). **httponly** : This is always present. Its value is a boolean that is true when the site wishes the cookie to only ever be used with HTTP (or HTTPS) traffic. **key** : This is always present. Its value is the *key* of the cookie, which is part of the information that must be return when sending this cookie back in a future request. **origin** : This is always present. Its value describes where the http package believes it received the cookie from, which may be useful for checking whether the cookie\\'s domain is valid. **path** : This is always present. Its value describes the path prefix of requests to the cookie domain where the cookie should be returned. **secure** : This is always present. Its value is a boolean that is true when the cookie should only used on requests sent over secure channels (typically HTTPS). **value** : This is always present. Its value is the value of the cookie, which is part of the information that must be return when sending this cookie back in a future request. Other keys may always be ignored; they have no meaning in this protocol.","title":"COOKIE JAR PROTOCOL"},{"location":"http/#protocol-upgrades","text":"The HTTP/1.1 Connection and Upgrade request headers inform the server that the client wishes to change the protocol used over the existing connection (RFC 7230). This mechanism can be used to request a WebSocket (RFC 6455), a higher version of the HTTP protocol (HTTP 2), or TLS encryption. If the server accepts the upgrade request, its response code will be 101. To request a protocol upgrade when calling http::geturl , the -headers option must supply appropriate values for Connection and Upgrade , and the -command option must supply a command that implements the requested protocol and can also handle the server response if the server refuses the protocol upgrade. For upgrade requests http::geturl ignores the value of option -keepalive , and always uses the value 0 so that the upgrade request is not made over a connection that is intended for multiple HTTP requests. The Tcllib library websocket implements WebSockets, and makes the necessary calls to commands in the http package. There is currently no native Tcl client library for HTTP/2. The Upgrade mechanism is not used to request TLS in web browsers, because http and https are served over different ports. It is used by protocols such as Internet Printing Protocol (IPP) that are built on top of http(s) and use the same TCP port number for both secure and insecure traffic. In browsers, opportunistic encryption is instead implemented by the Upgrade-Insecure-Requests client header. If a secure service is available, the server response code is a 307 redirect, and the response header Location specifies the target URL. The browser must call http::geturl again in order to fetch this URL. See https://w3c.github.io/webappsec-upgrade-insecure-requests/","title":"PROTOCOL UPGRADES"},{"location":"http/#threads","text":"","title":"THREADS"},{"location":"http/#purpose","text":"Command ::http::geturl uses the Tcl ::socket command with the -async option to connect to a remote server, but the return from this command can be delayed in adverse cases (e.g. a slow DNS lookup), preventing the event loop from processing other events. This delay is avoided if the ::socket command is evaluated in another thread. The Thread package is not part of Tcl but is provided in \\\"Batteries Included\\\" distributions. Instead of the ::socket command, the http package uses ::http::socket which makes connections in the manner specified by the value of -threadlevel and the availability of package Thread.","title":"PURPOSE"},{"location":"http/#with-tls-https","text":"The same -threadlevel configuration applies to both HTTP and HTTPS connections. HTTPS is enabled by using the http::register command, typically by specifying the ::tls::socket command of the tls package to handle TLS cryptography. The ::tls::socket command connects to the remote server by using the command specified by the value of variable ::tls::socketCmd , and this value defaults to \\\"::socket\\\". If http::geturl finds that ::tls::socketCmd has this value, it replaces it with the value \\\"::http::socket\\\". If ::tls::socketCmd has a value other than \\\"::socket\\\", i.e. if the script or the Tcl installation has replaced the value \\\"::socket\\\" with the name of a different command, then http does not change the value. The script or installation that modified ::tls::socketCmd is responsible for integrating ::http::socket into its own replacement command.","title":"WITH TLS (HTTPS)"},{"location":"http/#with-a-child-interpreter","text":"The peer thread can transfer the socket only to the main interpreter of the script\\'s thread. Therefore the thread-based ::http::socket works with non-zero -threadlevel values only if the script runs in the main interpreter. A child interpreter must use -threadlevel 0 unless the parent interpreter has provided alternative facilities. The main parent interpreter may grant full -threadlevel facilities to a child interpreter, for example by aliasing, to ::http::socket in the child, a command that runs http::socket in the parent, and then transfers the socket to the child.","title":"WITH A CHILD INTERPRETER"},{"location":"http/#example","text":"This example creates a procedure to copy a URL to a file while printing a progress meter, and prints the response headers associated with the URL. proc httpcopy { url file {chunk 4096} } { set out [open \\$file w] set token [ ::http::geturl \\$url -channel \\$out \\ -progress httpCopyProgress -blocksize \\$chunk] close \\$out # This ends the line started by httpCopyProgress puts stderr \\\"\\\" upvar 0 \\$token state set max 0 foreach {name value} \\$state(meta) { if {[string length \\$name] > \\$max} { set max [string length \\$name] } if {[regexp -nocase \\^location\\$ \\$name]} { # Handle URL redirects puts stderr \\\"Location:\\$value\\\" return [httpcopy [string trim \\$value] \\$file \\$chunk] } } incr max foreach {name value} \\$state(meta) { puts [format \\\"%-*s %s\\\" \\$max \\$name: \\$value] } return \\$token } proc httpCopyProgress {args} { puts -nonewline stderr . flush stderr }","title":"EXAMPLE"},{"location":"http/#see-also","text":"safe(n), socket(n), safesock(n)","title":"SEE ALSO"},{"location":"http/#keywords","text":"internet, security policy, socket, www","title":"KEYWORDS"},{"location":"idna/","text":"NAME tcl::idna - Support for normalization of Internationalized Domain Names SYNOPSIS package require tcl::idna 1.0 tcl::idna decode hostname tcl::idna encode hostname tcl::idna puny decode string ?case? tcl::idna puny encode string ?case? tcl::idna version DESCRIPTION This package provides an implementation of the punycode scheme used in Internationalised Domain Names, and some access commands. (See RFC 3492 for a description of punycode.) tcl::idna decode hostname : This command takes the name of a host that potentially contains punycode-encoded character sequences, hostname , and returns the hostname as might be displayed to the user. Note that there are often UNICODE characters that have extremely similar glyphs, so care should be taken with displaying hostnames to users. tcl::idna encode hostname : This command takes the name of a host as might be displayed to the user, hostname , and returns the version of the hostname with characters not permitted in basic hostnames encoded with punycode. tcl::idna puny subcommand ... : This command provides direct access to the basic punycode encoder and decoder. It supports two subcommand s: **tcl::idna puny decode** *string* ?*case*? : This command decodes the punycode-encoded string, *string*, and returns the result. If *case* is provided, it is a boolean to make the case be folded to upper case (if *case* is true) or lower case (if *case* is false) during the decoding process; if omitted, no case transformation is applied. **tcl::idna puny encode** *string* ?*case*? : This command encodes the string, *string*, and returns the punycode-encoded version of the string. If *case* is provided, it is a boolean to make the case be folded to upper case (if *case* is true) or lower case (if *case* is false) during the encoding process; if omitted, no case transformation is applied. tcl::idna version : This returns the version of the tcl::idna package. EXAMPLE This is an example of how punycoding of a string works: package require tcl::idna puts [ tcl::idna puny encode \\\"abc\u2192def\\\"] # prints: abcdef-kn2c puts [ tcl::idna puny decode \\\"abcdef-kn2c\\\"] # prints: abc\u2192def SEE ALSO http(n), cookiejar(n) KEYWORDS internet, www","title":"NAME"},{"location":"idna/#name","text":"tcl::idna - Support for normalization of Internationalized Domain Names","title":"NAME"},{"location":"idna/#synopsis","text":"package require tcl::idna 1.0 tcl::idna decode hostname tcl::idna encode hostname tcl::idna puny decode string ?case? tcl::idna puny encode string ?case? tcl::idna version","title":"SYNOPSIS"},{"location":"idna/#description","text":"This package provides an implementation of the punycode scheme used in Internationalised Domain Names, and some access commands. (See RFC 3492 for a description of punycode.) tcl::idna decode hostname : This command takes the name of a host that potentially contains punycode-encoded character sequences, hostname , and returns the hostname as might be displayed to the user. Note that there are often UNICODE characters that have extremely similar glyphs, so care should be taken with displaying hostnames to users. tcl::idna encode hostname : This command takes the name of a host as might be displayed to the user, hostname , and returns the version of the hostname with characters not permitted in basic hostnames encoded with punycode. tcl::idna puny subcommand ... : This command provides direct access to the basic punycode encoder and decoder. It supports two subcommand s: **tcl::idna puny decode** *string* ?*case*? : This command decodes the punycode-encoded string, *string*, and returns the result. If *case* is provided, it is a boolean to make the case be folded to upper case (if *case* is true) or lower case (if *case* is false) during the decoding process; if omitted, no case transformation is applied. **tcl::idna puny encode** *string* ?*case*? : This command encodes the string, *string*, and returns the punycode-encoded version of the string. If *case* is provided, it is a boolean to make the case be folded to upper case (if *case* is true) or lower case (if *case* is false) during the encoding process; if omitted, no case transformation is applied. tcl::idna version : This returns the version of the tcl::idna package.","title":"DESCRIPTION"},{"location":"idna/#example","text":"This is an example of how punycoding of a string works: package require tcl::idna puts [ tcl::idna puny encode \\\"abc\u2192def\\\"] # prints: abcdef-kn2c puts [ tcl::idna puny decode \\\"abcdef-kn2c\\\"] # prints: abc\u2192def","title":"EXAMPLE"},{"location":"idna/#see-also","text":"http(n), cookiejar(n)","title":"SEE ALSO"},{"location":"idna/#keywords","text":"internet, www","title":"KEYWORDS"},{"location":"if/","text":"NAME if - Execute scripts conditionally SYNOPSIS if expr1 ? then ? body1 elseif expr2 ? then ? body2 elseif ... ? else ? ? bodyN ? DESCRIPTION The if command evaluates expr1 as an expression (in the same way that expr evaluates its argument). The value of the expression must be a boolean (a numeric value, where 0 is false and anything is true, or a string value such as true or yes for true and false or no for false); if it is true then body1 is executed by passing it to the Tcl interpreter. Otherwise expr2 is evaluated as an expression and if it is true then body2 is executed, and so on. If none of the expressions evaluates to true then bodyN is executed. The then and else arguments are optional to make the command easier to read. There may be any number of elseif clauses, including zero. BodyN may also be omitted as long as else is omitted too. The return value from the command is the result of the body script that was executed, or an empty string if none of the expressions was non-zero and there was no bodyN . EXAMPLES A simple conditional: if {\\$vbl == 1} { puts \\\"vbl is one\\\" } With an else -clause: if {\\$vbl == 1} { puts \\\"vbl is one\\\" } else { puts \\\"vbl is not one\\\" } With an elseif -clause too: if {\\$vbl == 1} { puts \\\"vbl is one\\\" } elseif {\\$vbl == 2} { puts \\\"vbl is two\\\" } else { puts \\\"vbl is not one or two\\\" } Remember, expressions can be multi-line, but in that case it can be a good idea to use the optional then keyword for clarity: if { \\$vbl == 1 || \\$vbl == 2 || \\$vbl == 3 } then { puts \\\"vbl is one, two or three\\\" } SEE ALSO expr(n), for(n), foreach(n) KEYWORDS boolean, conditional, else, false, if, true","title":"NAME"},{"location":"if/#name","text":"if - Execute scripts conditionally","title":"NAME"},{"location":"if/#synopsis","text":"if expr1 ? then ? body1 elseif expr2 ? then ? body2 elseif ... ? else ? ? bodyN ?","title":"SYNOPSIS"},{"location":"if/#description","text":"The if command evaluates expr1 as an expression (in the same way that expr evaluates its argument). The value of the expression must be a boolean (a numeric value, where 0 is false and anything is true, or a string value such as true or yes for true and false or no for false); if it is true then body1 is executed by passing it to the Tcl interpreter. Otherwise expr2 is evaluated as an expression and if it is true then body2 is executed, and so on. If none of the expressions evaluates to true then bodyN is executed. The then and else arguments are optional to make the command easier to read. There may be any number of elseif clauses, including zero. BodyN may also be omitted as long as else is omitted too. The return value from the command is the result of the body script that was executed, or an empty string if none of the expressions was non-zero and there was no bodyN .","title":"DESCRIPTION"},{"location":"if/#examples","text":"A simple conditional: if {\\$vbl == 1} { puts \\\"vbl is one\\\" } With an else -clause: if {\\$vbl == 1} { puts \\\"vbl is one\\\" } else { puts \\\"vbl is not one\\\" } With an elseif -clause too: if {\\$vbl == 1} { puts \\\"vbl is one\\\" } elseif {\\$vbl == 2} { puts \\\"vbl is two\\\" } else { puts \\\"vbl is not one or two\\\" } Remember, expressions can be multi-line, but in that case it can be a good idea to use the optional then keyword for clarity: if { \\$vbl == 1 || \\$vbl == 2 || \\$vbl == 3 } then { puts \\\"vbl is one, two or three\\\" }","title":"EXAMPLES"},{"location":"if/#see-also","text":"expr(n), for(n), foreach(n)","title":"SEE ALSO"},{"location":"if/#keywords","text":"boolean, conditional, else, false, if, true","title":"KEYWORDS"},{"location":"incr/","text":"NAME incr - Increment the value of a variable SYNOPSIS incr varName ? increment ? DESCRIPTION Increments the value stored in the variable whose name is varName . The value of the variable must be an integer. If increment is supplied then its value (which must be an integer) is added to the value of variable varName ; otherwise 1 is added to varName . The new value is stored as a decimal string in variable varName and also returned as result. Starting with the Tcl 8.5 release, the variable varName passed to incr may be unset, and in that case, it will be set to the value increment or to the default increment value of 1 . If varName indicate an element that does not exist of an array that has a default value set, the sum of the default value and the increment (or 1) will be stored in the array element. EXAMPLES Add one to the contents of the variable x : incr x Add 42 to the contents of the variable x : incr x 42 Add the contents of the variable y to the contents of the variable x : incr x \\$y Add nothing at all to the variable x (often useful for checking whether an argument to a procedure is actually integral and generating an error if it is not): incr x 0 SEE ALSO expr(n), set(n) KEYWORDS add, increment, variable, value","title":"NAME"},{"location":"incr/#name","text":"incr - Increment the value of a variable","title":"NAME"},{"location":"incr/#synopsis","text":"incr varName ? increment ?","title":"SYNOPSIS"},{"location":"incr/#description","text":"Increments the value stored in the variable whose name is varName . The value of the variable must be an integer. If increment is supplied then its value (which must be an integer) is added to the value of variable varName ; otherwise 1 is added to varName . The new value is stored as a decimal string in variable varName and also returned as result. Starting with the Tcl 8.5 release, the variable varName passed to incr may be unset, and in that case, it will be set to the value increment or to the default increment value of 1 . If varName indicate an element that does not exist of an array that has a default value set, the sum of the default value and the increment (or 1) will be stored in the array element.","title":"DESCRIPTION"},{"location":"incr/#examples","text":"Add one to the contents of the variable x : incr x Add 42 to the contents of the variable x : incr x 42 Add the contents of the variable y to the contents of the variable x : incr x \\$y Add nothing at all to the variable x (often useful for checking whether an argument to a procedure is actually integral and generating an error if it is not): incr x 0","title":"EXAMPLES"},{"location":"incr/#see-also","text":"expr(n), set(n)","title":"SEE ALSO"},{"location":"incr/#keywords","text":"add, increment, variable, value","title":"KEYWORDS"},{"location":"info/","text":"NAME info - Information about the state of the Tcl interpreter SYNOPSIS info option ? arg arg ... ? DESCRIPTION Available commands: info args procname : Returns the names of the parameters to the procedure named procname . info body procname : Returns the body of the procedure named procname . info class subcommand class ? arg ... : Returns information about the class named class . See CLASS INTROSPECTION below. info cmdcount : Returns the total number of commands evaluated in this interpreter. info cmdtype commandName : Returns a the type of the command named commandName . Built-in types are: alias : commandName was created by interp alias . In a safe interpreter an alias is only visible if both the alias and the target are visible. coroutine : commandName was created by coroutine . ensemble : commandName was created by namespace ensemble . import : commandName was created by namespace import . native : commandName was created by the Tcl_CreateObjProc interface directly without further registration of the type of command. object : commandName is the public command that represents an instance of oo::object or one of its subclasses. privateObject : commandName is the private command, my by default, that represents an instance of oo::object or one of its subclasses. proc : commandName was created by proc . interp : commandName was created by interp create . zlibStream : commandName was created by zlib stream . info commands ? pattern ? : Returns the names of all commands visible in the current namespace. If pattern is given, returns only those names that match according to string match . Only the last component of pattern is a pattern. Other components identify a namespace. See NAMESPACE RESOLUTION in the namespace (n) documentation. info complete command : Returns 1 if command is a complete command, and 0 otherwise. Typically used in line-oriented input environments to allow users to type in commands that span multiple lines. info coroutine : Returns the name of the current coroutine , or the empty string if there is no current coroutine or the current coroutine has been deleted. info default procname parameter varname : If the parameter parameter for the procedure named procname has a default value, stores that value in varname and returns 1 . Otherwise, returns 0 . info errorstack ? interp ? : Returns a description of the active command at each level for the last error in the current interpreter, or in the interpreter named interp if given. The description is a dictionary of tokens and parameters. Tokens are currently either **CALL**, **UP**, or **INNER**, but other values may be introduced in the future. **CALL** indicates a command call, and its parameter is the corresponding **info level** **0**. **UP** indicates a shift in variable frames generated by **uplevel** or similar, and applies to the previous **CALL** item. Its parameter is the level offset. **INNER** identifies the which is the innermost atomic command or bytecode instruction that raised the error, along with its arguments when available. While **CALL** and **UP** provide a trail of the call path, **INNER** provides details of the offending operation in the innermost procedure call, even to sub-expression granularity. This information is also present in the **-errorstack** entry of the options dictionary returned by 3-argument **catch**; **info errorstack** is a convenient way of retrieving it for uncaught errors at top-level in an interactive **interpreter**. info exists varName : Returns 1 if a variable named varName is visible and has been defined, and 0 otherwise. info frame ? depth ? : Returns the depth of the call to info frame itself. Otherwise, returns a dictionary describing the active command at the depth , which counts all commands visible to info level , plus commands that don\\'t create a new level, such as eval , source , or uplevel . The frame depth is always greater than the current level. If *depth* is greater than **0** it is the frame at that depth. Otherwise it is the number of frames up from the current frame. As with **info level** and error traces, for nested commands like only is seen by **info frame** invoked within The dictionary may contain the following keys: **type** : Always present. Possible values are **source**, **proc**, **eval**, and **precompiled**. **source** : A script loaded via the **source** command. **proc** : The body of a procedure that could not be traced back to a line in a particular script. **eval** : The body of a script provided to **eval** or **uplevel**. **precompiled** : A precompiled script (loadable by the package **tbcload**), and no further information is available. **line** : The line number of of the command inside its script. Not available for **precompiled** commands. When the type is **source**, the line number is relative to the beginning of the file, whereas for the last two types it is relative to the start of the script. **file** : For type **source**, provides the normalized path of the file that contains the command. **cmd** : The command before substitutions were performed. **proc** : For type **prod**, the name of the procedure containing the command. **lambda** : For a command in a script evaluated as the body of an unnamed routine via the **apply** command, the definition of that routine. **level** : For a frame that corresponds to a level, (to be determined). When a command can be traced to its literal definition in some script, e.g. procedures nested in statically defined procedures, and literal eval scripts in files or statically defined procedures, its type is **source** and its location is the absolute line number in the script. Otherwise, its type is **proc** and its location is its line number within the body of the procedure. In contrast, procedure definitions and **eval** within a dynamically **eval**uated environment count line numbers relative to the start of their script, even if they would be able to count relative to the start of the outer dynamic script. That type of number usually makes more sense. A different way of describing this behaviour is that file-based locations are tracked as deeply as possible, and where this is not possible the lines are counted based on the smallest possible **eval** or procedure body, as that scope is usually easier to find than any dynamic outer scope. The syntactic form **{\\*}** is handled like **eval**. I.e. if it is given a literal list argument the system tracks the line number within the list words as well, and otherwise all line numbers are counted relative to the start of each word (smallest scope) info functions ? pattern ? : If pattern is not given, returns a list of all the math functions currently defined. If pattern is given, returns only those names that match pattern according to string match . info globals ? pattern ? : If pattern is not given, returns a list of all the names of currently-defined global variables. Global variables are variables in the global namespace. If pattern is given, only those names matching pattern are returned. Matching is determined using the same rules as for string match . info hostname : Returns the name of the current host. This name is not guaranteed to be the fully-qualified domain name of the host. Where machines have several different names, as is common on systems with both TCP/IP (DNS) and NetBIOS-based networking installed, it is the name that is suitable for TCP/IP networking that is returned. info level ? level ? : If number is not given, the level this routine was called from. Otherwise returns the complete command active at the given level. If number is greater than 0 , it is the desired level. Otherwise, it is number levels up from the current level. A complete command is the words in the command, with all subsitutions performed, meaning that it is a list. See uplevel for more information on levels. info library : Returns the value of tcl_library , which is the name of the library directory in which the scripts distributed with Tcl scripts are stored. info loaded ? interp ? ? package ? : Returns the name of each file loaded in interp va load as part of package . If package is not given, returns a list where each item is the name of the loaded file and the name of the package for which the file was loaded. For a statically-loaded package the name of the file is the empty string. For interp , the empty string is the current interpreter. info locals ? pattern ? : If pattern is given, returns the name of each local variable matching pattern according to string match . Otherwise, returns the name of each local variable. A variables defined with the global , upvar or variable is not local. info nameofexecutable : Returns the absolute pathname of the program for the current interpreter. If such a file can not be identified an empty string is returned. info object subcommand object ? arg ... : Returns information about the object named object . subcommand is described OBJECT INTROSPECTION below. info patchlevel : Returns the value of the global variable tcl_patchLevel , in which the exact version of the Tcl library initially stored. info procs ? pattern ? : Returns the names of all visible procedures. If pattern is given, returns only those names that match according to string match . Only the final component in pattern is actually considered a pattern. Any qualifying components simply select a namespace. See NAMESPACE RESOLUTION in the namespace (n) documentation. info script ? filename ? : Returns the pathname of the innermost script currently being evaluated, or the empty string if no pathname can be determined. If filename is given, sets the return value of any future calls to info script for the duration of the innermost active script. This is useful in virtual file system applications. info sharedlibextension : Returns the extension used on this platform for names of shared libraries, e.g. .so under Solaris. Returns the empty string if shared libraries are not supported on this platform. info tclversion : Returns the value of the global variable tcl_version , in which the major and minor version of the Tcl library are stored. info vars ? pattern ? : If pattern is not given, returns the names of all visible variables. If pattern is given, returns only those names that match according to string match . Only the last component of pattern is a pattern. Other components identify a namespace. See NAMESPACE RESOLUTION in the namespace (n) documentation. When pattern is a qualified name, results are fully qualified. A variable that has declared but not yet defined is included in the results. CLASS INTROSPECTION The following subcommand values are supported by info class : info class call class method : Returns a description of the method implementations that are used to provide a stereotypical instance of class \\'s implementation of method (stereotypical instances being objects instantiated by a class without having any object-specific definitions added). This consists of a list of lists of four elements, where each sublist consists of a word that describes the general type of method implementation (being one of method for an ordinary method, filter for an applied filter, private for a private method, and unknown for a method that is invoked as part of unknown method handling), a word giving the name of the particular method invoked (which is always the same as method for the method type, and for the unknown type), a word giving the fully qualified name of the class that defined the method, and a word describing the type of method implementation (see info class methodtype ). Note that there is no inspection of whether the method implementations actually use next to transfer control along the call chain, and the call chains that this command files do not actually contain private methods. info class constructor class : This subcommand returns a description of the definition of the constructor of class class . The definition is described as a two element list; the first element is the list of arguments to the constructor in a form suitable for passing to another call to proc or a method definition, and the second element is the body of the constructor. If no constructor is present, this returns the empty list. info class definition class method : This subcommand returns a description of the definition of the method named method of class class . The definition is described as a two element list; the first element is the list of arguments to the method in a form suitable for passing to another call to proc or a method definition, and the second element is the body of the method. info class definitionnamespace class ? kind ? : This subcommand returns the definition namespace for kind definitions of the class class ; the definition namespace only affects the instances of class , not class itself. The kind can be either -class to return the definition namespace used for oo::define , or -instance to return the definition namespace used for oo::objdefine ; the -class kind is default (though this is only actually useful on classes that are subclasses of oo::class ). If class does not provide a definition namespace of the given kind, this command returns the empty string. In those circumstances, the oo::define and oo::objdefine commands look up which definition namespace to use using the class inheritance hierarchy. info class destructor class : This subcommand returns the body of the destructor of class class . If no destructor is present, this returns the empty string. info class filters class : This subcommand returns the list of filter methods set on the class. info class forward class method : This subcommand returns the argument list for the method forwarding called method that is set on the class called class . info class instances class ? pattern ? : This subcommand returns a list of instances of class class . If the optional pattern argument is present, it constrains the list of returned instances to those that match it according to the rules of string match . info class methods class ? options... ? : This subcommand returns a list of all public (i.e. exported) methods of the class called class . Any of the following option s may be given, controlling exactly which method names are returned: **-all** : If the **-all** flag is given, and the **-scope** flag is not given, the list of methods will include those methods defined not just by the class, but also by the class\\'s superclasses and mixins. **-private** : If the **-private** flag is given, and the **-scope** flag is not given, the list of methods will also include the non-exported methods of the class (and superclasses and mixins, if **-all** is also given). Note that this naming is an unfortunate clash with true private methods; this option name is retained for backward compatibility. **-scope*** scope* : Returns a list of all methods on *class* that have the given visibility *scope*. When this option is supplied, both the **-all** and **-private** options are ignored. The valid values for *scope* are: > public > > : Only methods with *public* scope (i.e., callable from anywhere > by any instance of this class) are to be returned. > > unexported > > : Only methods with *unexported* scope (i.e., only callable via > **my**) are to be returned. > > private > > : Only methods with *private* scope (i.e., only callable from > within this class\\'s methods) are to be returned. info class methodtype class method : This subcommand returns a description of the type of implementation used for the method named method of class class . When the result is method , further information can be discovered with info class definition, and when the result is forward , further information can be discovered with info class forward . info class mixins class : This subcommand returns a list of all classes that have been mixed into the class named class . info class subclasses class ? pattern ? : This subcommand returns a list of direct subclasses of class class . If the optional pattern argument is present, it constrains the list of returned classes to those that match it according to the rules of string match . info class superclasses class : This subcommand returns a list of direct superclasses of class class in inheritance precedence order. info class variables class ? -private ? : This subcommand returns a list of all variables that have been declared for the class named class (i.e. that are automatically present in the class\\'s methods, constructor and destructor). If the -private option is given, this lists the private variables declared instead. OBJECT INTROSPECTION The following subcommand values are supported by info object : info object call object method : Returns a description of the method implementations that are used to provide object \\'s implementation of method . This consists of a list of lists of four elements, where each sublist consists of a word that describes the general type of method implementation (being one of method for an ordinary method, filter for an applied filter, private for a private method, and unknown for a method that is invoked as part of unknown method handling), a word giving the name of the particular method invoked (which is always the same as method for the method type, and for the unknown type), a word giving what defined the method (the fully qualified name of the class, or the literal string object if the method implementation is on an instance), and a word describing the type of method implementation (see info object methodtype ). Note that there is no inspection of whether the method implementations actually use next to transfer control along the call chain, and the call chains that this command files do not actually contain private methods. info object class object ? className ? : If className is not given, this subcommand returns class of the object object. If className is present, this subcommand returns a boolean value indicating whether the object is of that class. info object creationid object : Returns the unique creation identifier for the object object. This creation identifier is unique to the object (within a Tcl interpreter) and cannot be controlled at object creation time or altered afterwards. Implementation note: the creation identifier is used to generate unique identifiers associated with the object, especially for private variables. info object definition object method : This subcommand returns a description of the definition of the method named method of object object . The definition is described as a two element list; the first element is the list of arguments to the method in a form suitable for passing to another call to proc or a method definition, and the second element is the body of the method. info object filters object : This subcommand returns the list of filter methods set on the object. info object forward object method : This subcommand returns the argument list for the method forwarding called method that is set on the object called object . info object isa category object ? arg ? : This subcommand tests whether an object belongs to a particular category, returning a boolean value that indicates whether the object argument meets the criteria for the category. The supported categories are: **info object isa class*** object* : This returns whether *object* is a class (i.e. an instance of **oo::class** or one of its subclasses). **info object isa metaclass*** object* : This returns whether *object* is a class that can manufacture classes (i.e. is **oo::class** or a subclass of it). **info object isa mixin*** object class* : This returns whether *class* is directly mixed into *object*. **info object isa object*** object* : This returns whether *object* really is an object. **info object isa typeof*** object class* : This returns whether *class* is the type of *object* (i.e. whether *object* is an instance of *class* or one of its subclasses, whether direct or indirect). info object methods object ? option... ? : This subcommand returns a list of all public (i.e. exported) methods of the object called object . Any of the following option s may be given, controlling exactly which method names are returned: **-all** : If the **-all** flag is given, and the **-scope** flag is not given, the list of methods will include those methods defined not just by the object, but also by the object\\'s class and mixins, plus the superclasses of those classes. **-private** : If the **-private** flag is given, and the **-scope** flag is not given, the list of methods will also include the non-exported methods of the object (and classes, if **-all** is also given). Note that this naming is an unfortunate clash with true private methods; this option name is retained for backward compatibility. **-scope*** scope* : Returns a list of all methods on *object* that have the given visibility *scope*. When this option is supplied, both the **-all** and **-private** options are ignored. The valid values for *scope* are: > public > > : Only methods with *public* scope (i.e., callable from > anywhere) are to be returned. > > unexported > > : Only methods with *unexported* scope (i.e., only callable via > **my**) are to be returned. > > private > > : Only methods with *private* scope (i.e., only callable from > within this object\\'s instance methods) are to be returned. info object methodtype object method : This subcommand returns a description of the type of implementation used for the method named method of object object . When the result is method , further information can be discovered with info object definition, and when the result is forward , further information can be discovered with info object forward . info object mixins object : This subcommand returns a list of all classes that have been mixed into the object named object . info object namespace object : This subcommand returns the name of the internal namespace of the object named object . info object variables object R ? -private ? : This subcommand returns a list of all variables that have been declared for the object named object (i.e. that are automatically present in the object\\'s methods). If the -private option is given, this lists the private variables declared instead. info object vars object ? pattern ? : This subcommand returns a list of all variables in the private namespace of the object named object . If the optional pattern argument is given, it is a filter (in the syntax of a string match glob pattern) that constrains the list of variables returned. Note that this is different from the list returned by info object variables ; that can include variables that are currently unset, whereas this can include variables that are not automatically included by any of object \\'s methods (or those of its class, superclasses or mixins). EXAMPLES This command prints out a procedure suitable for saving in a Tcl script: proc printProc {procName} { set result [list proc \\$procName] set formals {} foreach var [ info args \\$procName] { if {[ info default \\$procName \\$var def]} { lappend formals [list \\$var \\$def] } else { # Still need the list-quoting because variable # names may properly contain spaces. lappend formals [list \\$var] } } puts [lappend result \\$formals [ info body \\$procName]] } EXAMPLES WITH OBJECTS Every object necessarily knows what its class is; this information is trivially extractable through introspection: oo::class create c c create o puts [ info object class o] \u2192 prints \\\"::c\\\" puts [ info object class c] \u2192 prints \\\"::oo::class\\\" The introspection capabilities can be used to discover what class implements a method and get how it is defined. This procedure illustrates how: proc getDef {obj method} { foreach inf [ info object call \\$obj \\$method] { lassign \\$inf calltype name locus methodtype # Assume no forwards or filters, and hence no \\$calltype # or \\$methodtype checks... if {\\$locus eq \\\"object\\\"} { return [ info object definition \\$obj \\$name] } else { return [ info class definition \\$locus \\$name] } } error \\\"no definition for \\$method\\\" } This is an alternate way of looking up the definition; it is implemented by manually scanning the list of methods up the inheritance tree. This code assumes that only single inheritance is in use, and that there is no complex use of mixed-in classes (in such cases, using info object call as above is the simplest way of doing this by far): proc getDef {obj method} { if {\\$method in [ info object methods \\$obj]} { # Assume no forwards return [ info object definition \\$obj \\$method] } set cls [ info object class \\$obj] while {\\$method ni [ info class methods \\$cls]} { # Assume the simple case set cls [lindex [ info class superclass \\$cls] 0] if {\\$cls eq \\\"\\\"} { error \\\"no definition for \\$method\\\" } } # Assume no forwards return [ info class definition \\$cls \\$method] } SEE ALSO global(n), oo::class(n), oo::define(n), oo::object(n), proc(n), self(n), tcl_library(n), tcl_patchLevel(n), tcl_version(n) KEYWORDS command, information, interpreter, introspection, level, namespace, object, procedure, variable","title":"NAME"},{"location":"info/#name","text":"info - Information about the state of the Tcl interpreter","title":"NAME"},{"location":"info/#synopsis","text":"info option ? arg arg ... ?","title":"SYNOPSIS"},{"location":"info/#description","text":"Available commands: info args procname : Returns the names of the parameters to the procedure named procname . info body procname : Returns the body of the procedure named procname . info class subcommand class ? arg ... : Returns information about the class named class . See CLASS INTROSPECTION below. info cmdcount : Returns the total number of commands evaluated in this interpreter. info cmdtype commandName : Returns a the type of the command named commandName . Built-in types are: alias : commandName was created by interp alias . In a safe interpreter an alias is only visible if both the alias and the target are visible. coroutine : commandName was created by coroutine . ensemble : commandName was created by namespace ensemble . import : commandName was created by namespace import . native : commandName was created by the Tcl_CreateObjProc interface directly without further registration of the type of command. object : commandName is the public command that represents an instance of oo::object or one of its subclasses. privateObject : commandName is the private command, my by default, that represents an instance of oo::object or one of its subclasses. proc : commandName was created by proc . interp : commandName was created by interp create . zlibStream : commandName was created by zlib stream . info commands ? pattern ? : Returns the names of all commands visible in the current namespace. If pattern is given, returns only those names that match according to string match . Only the last component of pattern is a pattern. Other components identify a namespace. See NAMESPACE RESOLUTION in the namespace (n) documentation. info complete command : Returns 1 if command is a complete command, and 0 otherwise. Typically used in line-oriented input environments to allow users to type in commands that span multiple lines. info coroutine : Returns the name of the current coroutine , or the empty string if there is no current coroutine or the current coroutine has been deleted. info default procname parameter varname : If the parameter parameter for the procedure named procname has a default value, stores that value in varname and returns 1 . Otherwise, returns 0 . info errorstack ? interp ? : Returns a description of the active command at each level for the last error in the current interpreter, or in the interpreter named interp if given. The description is a dictionary of tokens and parameters. Tokens are currently either **CALL**, **UP**, or **INNER**, but other values may be introduced in the future. **CALL** indicates a command call, and its parameter is the corresponding **info level** **0**. **UP** indicates a shift in variable frames generated by **uplevel** or similar, and applies to the previous **CALL** item. Its parameter is the level offset. **INNER** identifies the which is the innermost atomic command or bytecode instruction that raised the error, along with its arguments when available. While **CALL** and **UP** provide a trail of the call path, **INNER** provides details of the offending operation in the innermost procedure call, even to sub-expression granularity. This information is also present in the **-errorstack** entry of the options dictionary returned by 3-argument **catch**; **info errorstack** is a convenient way of retrieving it for uncaught errors at top-level in an interactive **interpreter**. info exists varName : Returns 1 if a variable named varName is visible and has been defined, and 0 otherwise. info frame ? depth ? : Returns the depth of the call to info frame itself. Otherwise, returns a dictionary describing the active command at the depth , which counts all commands visible to info level , plus commands that don\\'t create a new level, such as eval , source , or uplevel . The frame depth is always greater than the current level. If *depth* is greater than **0** it is the frame at that depth. Otherwise it is the number of frames up from the current frame. As with **info level** and error traces, for nested commands like only is seen by **info frame** invoked within The dictionary may contain the following keys: **type** : Always present. Possible values are **source**, **proc**, **eval**, and **precompiled**. **source** : A script loaded via the **source** command. **proc** : The body of a procedure that could not be traced back to a line in a particular script. **eval** : The body of a script provided to **eval** or **uplevel**. **precompiled** : A precompiled script (loadable by the package **tbcload**), and no further information is available. **line** : The line number of of the command inside its script. Not available for **precompiled** commands. When the type is **source**, the line number is relative to the beginning of the file, whereas for the last two types it is relative to the start of the script. **file** : For type **source**, provides the normalized path of the file that contains the command. **cmd** : The command before substitutions were performed. **proc** : For type **prod**, the name of the procedure containing the command. **lambda** : For a command in a script evaluated as the body of an unnamed routine via the **apply** command, the definition of that routine. **level** : For a frame that corresponds to a level, (to be determined). When a command can be traced to its literal definition in some script, e.g. procedures nested in statically defined procedures, and literal eval scripts in files or statically defined procedures, its type is **source** and its location is the absolute line number in the script. Otherwise, its type is **proc** and its location is its line number within the body of the procedure. In contrast, procedure definitions and **eval** within a dynamically **eval**uated environment count line numbers relative to the start of their script, even if they would be able to count relative to the start of the outer dynamic script. That type of number usually makes more sense. A different way of describing this behaviour is that file-based locations are tracked as deeply as possible, and where this is not possible the lines are counted based on the smallest possible **eval** or procedure body, as that scope is usually easier to find than any dynamic outer scope. The syntactic form **{\\*}** is handled like **eval**. I.e. if it is given a literal list argument the system tracks the line number within the list words as well, and otherwise all line numbers are counted relative to the start of each word (smallest scope) info functions ? pattern ? : If pattern is not given, returns a list of all the math functions currently defined. If pattern is given, returns only those names that match pattern according to string match . info globals ? pattern ? : If pattern is not given, returns a list of all the names of currently-defined global variables. Global variables are variables in the global namespace. If pattern is given, only those names matching pattern are returned. Matching is determined using the same rules as for string match . info hostname : Returns the name of the current host. This name is not guaranteed to be the fully-qualified domain name of the host. Where machines have several different names, as is common on systems with both TCP/IP (DNS) and NetBIOS-based networking installed, it is the name that is suitable for TCP/IP networking that is returned. info level ? level ? : If number is not given, the level this routine was called from. Otherwise returns the complete command active at the given level. If number is greater than 0 , it is the desired level. Otherwise, it is number levels up from the current level. A complete command is the words in the command, with all subsitutions performed, meaning that it is a list. See uplevel for more information on levels. info library : Returns the value of tcl_library , which is the name of the library directory in which the scripts distributed with Tcl scripts are stored. info loaded ? interp ? ? package ? : Returns the name of each file loaded in interp va load as part of package . If package is not given, returns a list where each item is the name of the loaded file and the name of the package for which the file was loaded. For a statically-loaded package the name of the file is the empty string. For interp , the empty string is the current interpreter. info locals ? pattern ? : If pattern is given, returns the name of each local variable matching pattern according to string match . Otherwise, returns the name of each local variable. A variables defined with the global , upvar or variable is not local. info nameofexecutable : Returns the absolute pathname of the program for the current interpreter. If such a file can not be identified an empty string is returned. info object subcommand object ? arg ... : Returns information about the object named object . subcommand is described OBJECT INTROSPECTION below. info patchlevel : Returns the value of the global variable tcl_patchLevel , in which the exact version of the Tcl library initially stored. info procs ? pattern ? : Returns the names of all visible procedures. If pattern is given, returns only those names that match according to string match . Only the final component in pattern is actually considered a pattern. Any qualifying components simply select a namespace. See NAMESPACE RESOLUTION in the namespace (n) documentation. info script ? filename ? : Returns the pathname of the innermost script currently being evaluated, or the empty string if no pathname can be determined. If filename is given, sets the return value of any future calls to info script for the duration of the innermost active script. This is useful in virtual file system applications. info sharedlibextension : Returns the extension used on this platform for names of shared libraries, e.g. .so under Solaris. Returns the empty string if shared libraries are not supported on this platform. info tclversion : Returns the value of the global variable tcl_version , in which the major and minor version of the Tcl library are stored. info vars ? pattern ? : If pattern is not given, returns the names of all visible variables. If pattern is given, returns only those names that match according to string match . Only the last component of pattern is a pattern. Other components identify a namespace. See NAMESPACE RESOLUTION in the namespace (n) documentation. When pattern is a qualified name, results are fully qualified. A variable that has declared but not yet defined is included in the results.","title":"DESCRIPTION"},{"location":"info/#class-introspection","text":"The following subcommand values are supported by info class : info class call class method : Returns a description of the method implementations that are used to provide a stereotypical instance of class \\'s implementation of method (stereotypical instances being objects instantiated by a class without having any object-specific definitions added). This consists of a list of lists of four elements, where each sublist consists of a word that describes the general type of method implementation (being one of method for an ordinary method, filter for an applied filter, private for a private method, and unknown for a method that is invoked as part of unknown method handling), a word giving the name of the particular method invoked (which is always the same as method for the method type, and for the unknown type), a word giving the fully qualified name of the class that defined the method, and a word describing the type of method implementation (see info class methodtype ). Note that there is no inspection of whether the method implementations actually use next to transfer control along the call chain, and the call chains that this command files do not actually contain private methods. info class constructor class : This subcommand returns a description of the definition of the constructor of class class . The definition is described as a two element list; the first element is the list of arguments to the constructor in a form suitable for passing to another call to proc or a method definition, and the second element is the body of the constructor. If no constructor is present, this returns the empty list. info class definition class method : This subcommand returns a description of the definition of the method named method of class class . The definition is described as a two element list; the first element is the list of arguments to the method in a form suitable for passing to another call to proc or a method definition, and the second element is the body of the method. info class definitionnamespace class ? kind ? : This subcommand returns the definition namespace for kind definitions of the class class ; the definition namespace only affects the instances of class , not class itself. The kind can be either -class to return the definition namespace used for oo::define , or -instance to return the definition namespace used for oo::objdefine ; the -class kind is default (though this is only actually useful on classes that are subclasses of oo::class ). If class does not provide a definition namespace of the given kind, this command returns the empty string. In those circumstances, the oo::define and oo::objdefine commands look up which definition namespace to use using the class inheritance hierarchy. info class destructor class : This subcommand returns the body of the destructor of class class . If no destructor is present, this returns the empty string. info class filters class : This subcommand returns the list of filter methods set on the class. info class forward class method : This subcommand returns the argument list for the method forwarding called method that is set on the class called class . info class instances class ? pattern ? : This subcommand returns a list of instances of class class . If the optional pattern argument is present, it constrains the list of returned instances to those that match it according to the rules of string match . info class methods class ? options... ? : This subcommand returns a list of all public (i.e. exported) methods of the class called class . Any of the following option s may be given, controlling exactly which method names are returned: **-all** : If the **-all** flag is given, and the **-scope** flag is not given, the list of methods will include those methods defined not just by the class, but also by the class\\'s superclasses and mixins. **-private** : If the **-private** flag is given, and the **-scope** flag is not given, the list of methods will also include the non-exported methods of the class (and superclasses and mixins, if **-all** is also given). Note that this naming is an unfortunate clash with true private methods; this option name is retained for backward compatibility. **-scope*** scope* : Returns a list of all methods on *class* that have the given visibility *scope*. When this option is supplied, both the **-all** and **-private** options are ignored. The valid values for *scope* are: > public > > : Only methods with *public* scope (i.e., callable from anywhere > by any instance of this class) are to be returned. > > unexported > > : Only methods with *unexported* scope (i.e., only callable via > **my**) are to be returned. > > private > > : Only methods with *private* scope (i.e., only callable from > within this class\\'s methods) are to be returned. info class methodtype class method : This subcommand returns a description of the type of implementation used for the method named method of class class . When the result is method , further information can be discovered with info class definition, and when the result is forward , further information can be discovered with info class forward . info class mixins class : This subcommand returns a list of all classes that have been mixed into the class named class . info class subclasses class ? pattern ? : This subcommand returns a list of direct subclasses of class class . If the optional pattern argument is present, it constrains the list of returned classes to those that match it according to the rules of string match . info class superclasses class : This subcommand returns a list of direct superclasses of class class in inheritance precedence order. info class variables class ? -private ? : This subcommand returns a list of all variables that have been declared for the class named class (i.e. that are automatically present in the class\\'s methods, constructor and destructor). If the -private option is given, this lists the private variables declared instead.","title":"CLASS INTROSPECTION"},{"location":"info/#object-introspection","text":"The following subcommand values are supported by info object : info object call object method : Returns a description of the method implementations that are used to provide object \\'s implementation of method . This consists of a list of lists of four elements, where each sublist consists of a word that describes the general type of method implementation (being one of method for an ordinary method, filter for an applied filter, private for a private method, and unknown for a method that is invoked as part of unknown method handling), a word giving the name of the particular method invoked (which is always the same as method for the method type, and for the unknown type), a word giving what defined the method (the fully qualified name of the class, or the literal string object if the method implementation is on an instance), and a word describing the type of method implementation (see info object methodtype ). Note that there is no inspection of whether the method implementations actually use next to transfer control along the call chain, and the call chains that this command files do not actually contain private methods. info object class object ? className ? : If className is not given, this subcommand returns class of the object object. If className is present, this subcommand returns a boolean value indicating whether the object is of that class. info object creationid object : Returns the unique creation identifier for the object object. This creation identifier is unique to the object (within a Tcl interpreter) and cannot be controlled at object creation time or altered afterwards. Implementation note: the creation identifier is used to generate unique identifiers associated with the object, especially for private variables. info object definition object method : This subcommand returns a description of the definition of the method named method of object object . The definition is described as a two element list; the first element is the list of arguments to the method in a form suitable for passing to another call to proc or a method definition, and the second element is the body of the method. info object filters object : This subcommand returns the list of filter methods set on the object. info object forward object method : This subcommand returns the argument list for the method forwarding called method that is set on the object called object . info object isa category object ? arg ? : This subcommand tests whether an object belongs to a particular category, returning a boolean value that indicates whether the object argument meets the criteria for the category. The supported categories are: **info object isa class*** object* : This returns whether *object* is a class (i.e. an instance of **oo::class** or one of its subclasses). **info object isa metaclass*** object* : This returns whether *object* is a class that can manufacture classes (i.e. is **oo::class** or a subclass of it). **info object isa mixin*** object class* : This returns whether *class* is directly mixed into *object*. **info object isa object*** object* : This returns whether *object* really is an object. **info object isa typeof*** object class* : This returns whether *class* is the type of *object* (i.e. whether *object* is an instance of *class* or one of its subclasses, whether direct or indirect). info object methods object ? option... ? : This subcommand returns a list of all public (i.e. exported) methods of the object called object . Any of the following option s may be given, controlling exactly which method names are returned: **-all** : If the **-all** flag is given, and the **-scope** flag is not given, the list of methods will include those methods defined not just by the object, but also by the object\\'s class and mixins, plus the superclasses of those classes. **-private** : If the **-private** flag is given, and the **-scope** flag is not given, the list of methods will also include the non-exported methods of the object (and classes, if **-all** is also given). Note that this naming is an unfortunate clash with true private methods; this option name is retained for backward compatibility. **-scope*** scope* : Returns a list of all methods on *object* that have the given visibility *scope*. When this option is supplied, both the **-all** and **-private** options are ignored. The valid values for *scope* are: > public > > : Only methods with *public* scope (i.e., callable from > anywhere) are to be returned. > > unexported > > : Only methods with *unexported* scope (i.e., only callable via > **my**) are to be returned. > > private > > : Only methods with *private* scope (i.e., only callable from > within this object\\'s instance methods) are to be returned. info object methodtype object method : This subcommand returns a description of the type of implementation used for the method named method of object object . When the result is method , further information can be discovered with info object definition, and when the result is forward , further information can be discovered with info object forward . info object mixins object : This subcommand returns a list of all classes that have been mixed into the object named object . info object namespace object : This subcommand returns the name of the internal namespace of the object named object . info object variables object R ? -private ? : This subcommand returns a list of all variables that have been declared for the object named object (i.e. that are automatically present in the object\\'s methods). If the -private option is given, this lists the private variables declared instead. info object vars object ? pattern ? : This subcommand returns a list of all variables in the private namespace of the object named object . If the optional pattern argument is given, it is a filter (in the syntax of a string match glob pattern) that constrains the list of variables returned. Note that this is different from the list returned by info object variables ; that can include variables that are currently unset, whereas this can include variables that are not automatically included by any of object \\'s methods (or those of its class, superclasses or mixins).","title":"OBJECT INTROSPECTION"},{"location":"info/#examples","text":"This command prints out a procedure suitable for saving in a Tcl script: proc printProc {procName} { set result [list proc \\$procName] set formals {} foreach var [ info args \\$procName] { if {[ info default \\$procName \\$var def]} { lappend formals [list \\$var \\$def] } else { # Still need the list-quoting because variable # names may properly contain spaces. lappend formals [list \\$var] } } puts [lappend result \\$formals [ info body \\$procName]] }","title":"EXAMPLES"},{"location":"info/#examples-with-objects","text":"Every object necessarily knows what its class is; this information is trivially extractable through introspection: oo::class create c c create o puts [ info object class o] \u2192 prints \\\"::c\\\" puts [ info object class c] \u2192 prints \\\"::oo::class\\\" The introspection capabilities can be used to discover what class implements a method and get how it is defined. This procedure illustrates how: proc getDef {obj method} { foreach inf [ info object call \\$obj \\$method] { lassign \\$inf calltype name locus methodtype # Assume no forwards or filters, and hence no \\$calltype # or \\$methodtype checks... if {\\$locus eq \\\"object\\\"} { return [ info object definition \\$obj \\$name] } else { return [ info class definition \\$locus \\$name] } } error \\\"no definition for \\$method\\\" } This is an alternate way of looking up the definition; it is implemented by manually scanning the list of methods up the inheritance tree. This code assumes that only single inheritance is in use, and that there is no complex use of mixed-in classes (in such cases, using info object call as above is the simplest way of doing this by far): proc getDef {obj method} { if {\\$method in [ info object methods \\$obj]} { # Assume no forwards return [ info object definition \\$obj \\$method] } set cls [ info object class \\$obj] while {\\$method ni [ info class methods \\$cls]} { # Assume the simple case set cls [lindex [ info class superclass \\$cls] 0] if {\\$cls eq \\\"\\\"} { error \\\"no definition for \\$method\\\" } } # Assume no forwards return [ info class definition \\$cls \\$method] }","title":"EXAMPLES WITH OBJECTS"},{"location":"info/#see-also","text":"global(n), oo::class(n), oo::define(n), oo::object(n), proc(n), self(n), tcl_library(n), tcl_patchLevel(n), tcl_version(n)","title":"SEE ALSO"},{"location":"info/#keywords","text":"command, information, interpreter, introspection, level, namespace, object, procedure, variable","title":"KEYWORDS"},{"location":"interp/","text":"NAME interp - Create and manipulate Tcl interpreters SYNOPSIS interp subcommand ? arg arg ... ? DESCRIPTION This command makes it possible to create one or more new Tcl interpreters that co-exist with the creating interpreter in the same application. The creating interpreter is called the parent and the new interpreter is called a child . A parent can create any number of children, and each child can itself create additional children for which it is parent, resulting in a hierarchy of interpreters. Each interpreter is independent from the others: it has its own name space for commands, procedures, and global variables. A parent interpreter may create connections between its children and itself using a mechanism called an alias . An alias is a command in a child interpreter which, when invoked, causes a command to be invoked in its parent interpreter or in another child interpreter. The only other connections between interpreters are through environment variables (the env variable), which are normally shared among all interpreters in the application, and by resource limit exceeded callbacks. Note that the name space for files (such as the names returned by the open command) is no longer shared between interpreters. Explicit commands are provided to share files and to transfer references to open files from one interpreter to another. The interp command also provides support for safe interpreters. A safe interpreter is a child whose functions have been greatly restricted, so that it is safe to execute untrusted scripts without fear of them damaging other interpreters or the application\\'s environment. For example, all IO channel creation commands and subprocess creation commands are made inaccessible to safe interpreters. See SAFE INTERPRETERS below for more information on what features are present in a safe interpreter. The dangerous functionality is not removed from the safe interpreter; instead, it is hidden , so that only trusted interpreters can obtain access to it. For a detailed explanation of hidden commands, see HIDDEN COMMANDS , below. The alias mechanism can be used for protected communication (analogous to a kernel call) between a child interpreter and its parent. See ALIAS INVOCATION , below, for more details on how the alias mechanism works. A qualified interpreter name is a proper Tcl list containing a subset of its ancestors in the interpreter hierarchy, terminated by the string naming the interpreter in its immediate parent. Interpreter names are relative to the interpreter in which they are used. For example, if is a child of the current interpreter and it has a child which in turn has a child the qualified name of in is the list The interp command, described below, accepts qualified interpreter names as arguments; the interpreter in which the command is being evaluated can always be referred to as {} (the empty list or string). Note that it is impossible to refer to a parent (ancestor) interpreter by name in a child interpreter except through aliases. Also, there is no global name by which one can refer to the first interpreter created in an application. Both restrictions are motivated by safety concerns. THE INTERP COMMAND The interp command is used to create, delete, and manipulate child interpreters, and to share or transfer channels between interpreters. It can have any of several forms, depending on the subcommand argument: interp alias srcPath srcToken : Returns a Tcl list whose elements are the targetCmd and arg s associated with the alias represented by srcToken (this is the value returned when the alias was created; it is possible that the name of the source command in the child is different from srcToken ). interp alias srcPath srcToken {} : Deletes the alias for srcToken in the child interpreter identified by srcPath . srcToken refers to the value returned when the alias was created; if the source command has been renamed, the renamed command will be deleted. interp alias srcPath srcCmd targetPath targetCmd ? arg arg ... ? : This command creates an alias between one child and another (see the alias child command below for creating aliases between a child and its parent). In this command, either of the child interpreters may be anywhere in the hierarchy of interpreters under the interpreter invoking the command. SrcPath and srcCmd identify the source of the alias. SrcPath is a Tcl list whose elements select a particular interpreter. For example, identifies an interpreter which is a child of interpreter which is a child of the invoking interpreter. An empty list specifies the interpreter invoking the command. srcCmd gives the name of a new command, which will be created in the source interpreter. TargetPath and targetCmd specify a target interpreter and command, and the arg arguments, if any, specify additional arguments to targetCmd which are prepended to any arguments specified in the invocation of srcCmd . TargetCmd may be undefined at the time of this call, or it may already exist; it is not created by this command. The alias arranges for the given target command to be invoked in the target interpreter whenever the given source command is invoked in the source interpreter. See ALIAS INVOCATION below for more details. The command returns a token that uniquely identifies the command created srcCmd , even if the command is renamed afterwards. The token may but does not have to be equal to srcCmd . interp aliases ? path ? : This command returns a Tcl list of the tokens of all the source commands for aliases defined in the interpreter identified by path . The tokens correspond to the values returned when the aliases were created (which may not be the same as the current names of the commands). interp bgerror path ? cmdPrefix ? : This command either gets or sets the current background exception handler for the interpreter identified by path . If cmdPrefix is absent, the current background exception handler is returned, and if it is present, it is a list of words (of minimum length one) that describes what to set the interpreter\\'s background exception handler to. See the BACKGROUND EXCEPTION HANDLING section for more details. interp cancel ? -unwind ? ? -\u2006- ? ? path ? ? result ? : Cancels the script being evaluated in the interpreter identified by path . Without the -unwind switch the evaluation stack for the interpreter is unwound until an enclosing catch command is found or there are no further invocations of the interpreter left on the call stack. With the -unwind switch the evaluation stack for the interpreter is unwound without regard to any intervening catch command until there are no further invocations of the interpreter left on the call stack. The -\u2006- switch can be used to mark the end of switches; it may be needed if path is an unusual value such as -safe . If result is present, it will be used as the error message string; otherwise, a default error message string will be used. interp create ? -safe ? ? -\u2006- ? ? path ? : Creates a child interpreter identified by path and a new command, called a child command . The name of the child command is the last component of path . The new child interpreter and the child command are created in the interpreter identified by the path obtained by removing the last component from path . For example, if path is a b c then a new child interpreter and child command named c are created in the interpreter identified by the path a b . The child command may be used to manipulate the new interpreter as described below. If path is omitted, Tcl creates a unique name of the form interp x , where x is an integer, and uses it for the interpreter and the child command. If the -safe switch is specified (or if the parent interpreter is a safe interpreter), the new child interpreter will be created as a safe interpreter with limited functionality; otherwise the child will include the full set of Tcl built-in commands and variables. The -\u2006- switch can be used to mark the end of switches; it may be needed if path is an unusual value such as -safe . The result of the command is the name of the new interpreter. The name of a child interpreter must be unique among all the children for its parent; an error occurs if a child interpreter by the given name already exists in this parent. The initial recursion limit of the child interpreter is set to the current recursion limit of its parent interpreter. interp debug path ? -frame ? bool ?? : Controls whether frame-level stack information is captured in the child interpreter identified by path . If no arguments are given, option and current setting are returned. If -frame is given, the debug setting is set to the given boolean if provided and the current setting is returned. This only affects the output of info frame , in that exact frame-level information for command invocation at the bytecode level is only captured with this setting on. For example, with code like **proc** mycontrol {\\... script} { \\... **uplevel** 1 \\$script \\... } **proc** dosomething {\\...} { \\... mycontrol { somecode } } the standard setting will provide a relative line number for the command **somecode** and the relevant frame will be of type **eval**. With frame-debug active on the other hand the tracking extends so far that the system will be able to determine the file and absolute line number of this command, and return a frame of type **source**. This more exact information is paid for with slower execution of all commands. Note that once it is on, this flag cannot be switched back off: such attempts are silently ignored. This is needed to maintain the consistency of the underlying interpreter\\'s state. interp delete ? path ... ? : Deletes zero or more interpreters given by the optional path arguments, and for each interpreter, it also deletes its children. The command also deletes the child command for each interpreter deleted. For each path argument, if no interpreter by that name exists, the command raises an error. interp eval path arg ? arg ... ? : This command concatenates all of the arg arguments in the same fashion as the concat command, then evaluates the resulting string as a Tcl script in the child interpreter identified by path . The result of this evaluation (including all return options, such as -errorinfo and -errorcode information, if an error occurs) is returned to the invoking interpreter. Note that the script will be executed in the current context stack frame of the path interpreter; this is so that the implementations (in a parent interpreter) of aliases in a child interpreter can execute scripts in the child that find out information about the child\\'s current state and stack frame. interp exists path : Returns 1 if a child interpreter by the specified path exists in this parent, 0 otherwise. If path is omitted, the invoking interpreter is used. interp expose path hiddenName ? exposedCmdName ? : Makes the hidden command hiddenName exposed, eventually bringing it back under a new exposedCmdName name (this name is currently accepted only if it is a valid global name space name without any ::), in the interpreter denoted by path . If an exposed command with the targeted name already exists, this command fails. Hidden commands are explained in more detail in HIDDEN COMMANDS , below. interp hide path exposedCmdName ? hiddenCmdName ? : Makes the exposed command exposedCmdName hidden, renaming it to the hidden command hiddenCmdName , or keeping the same name if hiddenCmdName is not given, in the interpreter denoted by path . If a hidden command with the targeted name already exists, this command fails. Currently both exposedCmdName and hiddenCmdName can not contain namespace qualifiers, or an error is raised. Commands to be hidden by interp hide are looked up in the global namespace even if the current namespace is not the global one. This prevents children from fooling a parent interpreter into hiding the wrong command, by making the current namespace be different from the global one. Hidden commands are explained in more detail in HIDDEN COMMANDS , below. interp hidden path : Returns a list of the names of all hidden commands in the interpreter identified by path . interp invokehidden path ? -option ... ? hiddenCmdName ? arg ... ? : Invokes the hidden command hiddenCmdName with the arguments supplied in the interpreter denoted by path . No substitutions or evaluation are applied to the arguments. Three -option s are supported, all of which start with - : -namespace (which takes a single argument afterwards, nsName ), -global , and -\u2006- . If the -namespace flag is present, the hidden command is invoked in the namespace called nsName in the target interpreter. If the -global flag is present, the hidden command is invoked at the global level in the target interpreter; otherwise it is invoked at the current call frame and can access local variables in that and outer call frames. The -\u2006- flag allows the hiddenCmdName argument to start with a character, and is otherwise unnecessary. If both the -namespace and -global flags are present, the -namespace flag is ignored. Note that the hidden command will be executed (by default) in the current context stack frame of the path interpreter. Hidden commands are explained in more detail in HIDDEN COMMANDS , below. interp issafe ? path ? : Returns 1 if the interpreter identified by the specified path is safe, 0 otherwise. interp limit path limitType ? -option ? ? value ... ? : Sets up, manipulates and queries the configuration of the resource limit limitType for the interpreter denoted by path . If no -option is specified, return the current configuration of the limit. If -option is the sole argument, return the value of that option. Otherwise, a list of -option / value argument pairs must supplied. See RESOURCE LIMITS below for a more detailed explanation of what limits and options are supported. interp marktrusted path : Marks the interpreter identified by path as trusted. Does not expose the hidden commands. This command can only be invoked from a trusted interpreter. The command has no effect if the interpreter identified by path is already trusted. interp recursionlimit path ? newlimit ? : Returns the maximum allowable nesting depth for the interpreter specified by path . If newlimit is specified, the interpreter recursion limit will be set so that nesting of more than newlimit calls to Tcl_Eval and related procedures in that interpreter will return an error. The newlimit value is also returned. The newlimit value must be a positive integer between 1 and the maximum value of a non-long integer on the platform. The command sets the maximum size of the Tcl call stack only. It cannot by itself prevent stack overflows on the C stack being used by the application. If your machine has a limit on the size of the C stack, you may get stack overflows before reaching the limit set by the command. If this happens, see if there is a mechanism in your system for increasing the maximum size of the C stack. interp share srcPath channelId destPath : Causes the IO channel identified by channelId to become shared between the interpreter identified by srcPath and the interpreter identified by destPath . Both interpreters have the same permissions on the IO channel. Both interpreters must close it to close the underlying IO channel; IO channels accessible in an interpreter are automatically closed when an interpreter is destroyed. interp children ? path ? : Returns a Tcl list of the names of all the child interpreters associated with the interpreter identified by path . If path is omitted, the invoking interpreter is used. interp target path alias : Returns a Tcl list describing the target interpreter for an alias. The alias is specified with an interpreter path and source command name, just as in interp alias above. The name of the target interpreter is returned as an interpreter path, relative to the invoking interpreter. If the target interpreter for the alias is the invoking interpreter then an empty list is returned. If the target interpreter for the alias is not the invoking interpreter or one of its descendants then an error is generated. The target command does not have to be defined at the time of this invocation. interp transfer srcPath channelId destPath : Causes the IO channel identified by channelId to become available in the interpreter identified by destPath and unavailable in the interpreter identified by srcPath . CHILD COMMAND For each child interpreter created with the interp command, a new Tcl command is created in the parent interpreter with the same name as the new interpreter. This command may be used to invoke various operations on the interpreter. It has the following general form: child command ? arg arg ... ? Child is the name of the interpreter, and command and the arg s determine the exact behavior of the command. The valid forms of this command are: child aliases : Returns a Tcl list whose elements are the tokens of all the aliases in child . The tokens correspond to the values returned when the aliases were created (which may not be the same as the current names of the commands). child alias srcToken : Returns a Tcl list whose elements are the targetCmd and arg s associated with the alias represented by srcToken (this is the value returned when the alias was created; it is possible that the actual source command in the child is different from srcToken ). child alias srcToken {} : Deletes the alias for srcToken in the child interpreter. srcToken refers to the value returned when the alias was created; if the source command has been renamed, the renamed command will be deleted. child alias srcCmd targetCmd ? arg .. ? : Creates an alias such that whenever srcCmd is invoked in child , targetCmd is invoked in the parent. The arg arguments will be passed to targetCmd as additional arguments, prepended before any arguments passed in the invocation of srcCmd . See ALIAS INVOCATION below for details. The command returns a token that uniquely identifies the command created srcCmd , even if the command is renamed afterwards. The token may but does not have to be equal to srcCmd . child bgerror ? cmdPrefix ? : This command either gets or sets the current background exception handler for the child interpreter. If cmdPrefix is absent, the current background exception handler is returned, and if it is present, it is a list of words (of minimum length one) that describes what to set the interpreter\\'s background exception handler to. See the BACKGROUND EXCEPTION HANDLING section for more details. child eval arg ? arg .. ? : This command concatenates all of the arg arguments in the same fashion as the concat command, then evaluates the resulting string as a Tcl script in child . The result of this evaluation (including all return options, such as -errorinfo and -errorcode information, if an error occurs) is returned to the invoking interpreter. Note that the script will be executed in the current context stack frame of child ; this is so that the implementations (in a parent interpreter) of aliases in a child interpreter can execute scripts in the child that find out information about the child\\'s current state and stack frame. child expose hiddenName ? exposedCmdName ? : This command exposes the hidden command hiddenName , eventually bringing it back under a new exposedCmdName name (this name is currently accepted only if it is a valid global name space name without any ::), in child . If an exposed command with the targeted name already exists, this command fails. For more details on hidden commands, see HIDDEN COMMANDS , below. child hide exposedCmdName ? hiddenCmdName ? : This command hides the exposed command exposedCmdName , renaming it to the hidden command hiddenCmdName , or keeping the same name if the argument is not given, in the child interpreter. If a hidden command with the targeted name already exists, this command fails. Currently both exposedCmdName and hiddenCmdName can not contain namespace qualifiers, or an error is raised. Commands to be hidden are looked up in the global namespace even if the current namespace is not the global one. This prevents children from fooling a parent interpreter into hiding the wrong command, by making the current namespace be different from the global one. For more details on hidden commands, see HIDDEN COMMANDS , below. child hidden : Returns a list of the names of all hidden commands in child . child invokehidden ? -option ... ? hiddenName ? arg .. ? : This command invokes the hidden command hiddenName with the supplied arguments, in child . No substitutions or evaluations are applied to the arguments. Three -option s are supported, all of which start with - : -namespace (which takes a single argument afterwards, nsName ), -global , and -\u2006- . If the -namespace flag is given, the hidden command is invoked in the specified namespace in the child. If the -global flag is given, the command is invoked at the global level in the child; otherwise it is invoked at the current call frame and can access local variables in that or outer call frames. The -\u2006- flag allows the hiddenCmdName argument to start with a character, and is otherwise unnecessary. If both the -namespace and -global flags are given, the -namespace flag is ignored. Note that the hidden command will be executed (by default) in the current context stack frame of child . For more details on hidden commands, see HIDDEN COMMANDS , below. child issafe : Returns 1 if the child interpreter is safe, 0 otherwise. child limit limitType ? -option ? ? value ... ? : Sets up, manipulates and queries the configuration of the resource limit limitType for the child interpreter. If no -option is specified, return the current configuration of the limit. If -option is the sole argument, return the value of that option. Otherwise, a list of -option / value argument pairs must supplied. See RESOURCE LIMITS below for a more detailed explanation of what limits and options are supported. child marktrusted : Marks the child interpreter as trusted. Can only be invoked by a trusted interpreter. This command does not expose any hidden commands in the child interpreter. The command has no effect if the child is already trusted. child recursionlimit ? newlimit ? : Returns the maximum allowable nesting depth for the child interpreter. If newlimit is specified, the recursion limit in child will be set so that nesting of more than newlimit calls to Tcl_Eval() and related procedures in child will return an error. The newlimit value is also returned. The newlimit value must be a positive integer between 1 and the maximum value of a non-long integer on the platform. The command sets the maximum size of the Tcl call stack only. It cannot by itself prevent stack overflows on the C stack being used by the application. If your machine has a limit on the size of the C stack, you may get stack overflows before reaching the limit set by the command. If this happens, see if there is a mechanism in your system for increasing the maximum size of the C stack. SAFE INTERPRETERS A safe interpreter is one with restricted functionality, so that is safe to execute an arbitrary script from your worst enemy without fear of that script damaging the enclosing application or the rest of your computing environment. In order to make an interpreter safe, certain commands and variables are removed from the interpreter. For example, commands to create files on disk are removed, and the exec command is removed, since it could be used to cause damage through subprocesses. Limited access to these facilities can be provided, by creating aliases to the parent interpreter which check their arguments carefully and provide restricted access to a safe subset of facilities. For example, file creation might be allowed in a particular subdirectory and subprocess invocation might be allowed for a carefully selected and fixed set of programs. A safe interpreter is created by specifying the -safe switch to the interp create command. Furthermore, any child created by a safe interpreter will also be safe. A safe interpreter is created with exactly the following set of built-in commands: after append apply array binary break catch chan clock close concat continue dict eof error eval expr fblocked fcopy fileevent flush for foreach format gets global if incr info interp join lappend lassign ledit lindex linsert list llength lrange lrepeat lreplace lsearch lseq lset lsort namespace package pid proc puts read regexp regsub rename return scan seek set split string subst switch tell time trace unset update uplevel upvar variable vwait while The following commands are hidden by interp create when it creates a safe interpreter: cd encoding exec exit fconfigure file glob load open pwd socket source unload These commands can be recreated later as Tcl procedures or aliases, or re-exposed by interp expose . The following commands from Tcl\\'s library of support procedures are not present in a safe interpreter: auto_exec_ok auto_import auto_load auto_load_index auto_qualify unknown Note in particular that safe interpreters have no default unknown command, so Tcl\\'s default autoloading facilities are not available. Autoload access to Tcl\\'s commands that are normally autoloaded: auto_mkindex auto_mkindex_old auto_reset history parray pkg_mkIndex ::pkg::create ::safe::interpAddToAccessPath ::safe::interpCreate ::safe::interpConfigure ::safe::interpDelete ::safe::interpFindInAccessPath ::safe::interpInit ::safe::setLogCmd tcl_endOfWord tcl_findLibrary tcl_startOfNextWord tcl_startOfPreviousWord tcl_wordBreakAfter tcl_wordBreakBefore can only be provided by explicit definition of an unknown command in the safe interpreter. This will involve exposing the source command. This is most easily accomplished by creating the safe interpreter with Tcl\\'s Safe-Tcl mechanism. Safe-Tcl provides safe versions of source , load , and other Tcl commands needed to support autoloading of commands and the loading of packages. In addition, the env variable is not present in a safe interpreter, so it cannot share environment variables with other interpreters. The env variable poses a security risk, because users can store sensitive information in an environment variable. For example, the PGP manual recommends storing the PGP private key protection password in the environment variable PGPPASS . Making this variable available to untrusted code executing in a safe interpreter would incur a security risk. If extensions are loaded into a safe interpreter, they may also restrict their own functionality to eliminate unsafe commands. For a discussion of management of extensions for safety see the manual entries for Safe-Tcl and the load Tcl command. A safe interpreter may not alter the recursion limit of any interpreter, including itself. ALIAS INVOCATION The alias mechanism has been carefully designed so that it can be used safely in an untrusted script which is being executed in a safe interpreter even if the target of the alias is not a safe interpreter. The most important thing in guaranteeing safety is to ensure that information passed from the child to the parent is never evaluated or substituted in the parent; if this were to occur, it would enable an evil script in the child to invoke arbitrary functions in the parent, which would compromise security. When the source for an alias is invoked in the child interpreter, the usual Tcl substitutions are performed when parsing that command. These substitutions are carried out in the source interpreter just as they would be for any other command invoked in that interpreter. The command procedure for the source command takes its arguments and merges them with the targetCmd and arg s for the alias to create a new array of arguments. If the words of srcCmd were the new set of words will be where targetCmd and arg s are the values supplied when the alias was created. TargetCmd is then used to locate a command procedure in the target interpreter, and that command procedure is invoked with the new set of arguments. An error occurs if there is no command named targetCmd in the target interpreter. No additional substitutions are performed on the words: the target command procedure is invoked directly, without going through the normal Tcl evaluation mechanism. Substitutions are thus performed on each word exactly once: targetCmd and args were substituted when parsing the command that created the alias, and arg1 - argN are substituted when the alias\\'s source command is parsed in the source interpreter. When writing the targetCmd s for aliases in safe interpreters, it is very important that the arguments to that command never be evaluated or substituted, since this would provide an escape mechanism whereby the child interpreter could execute arbitrary code in the parent. This in turn would compromise the security of the system. HIDDEN COMMANDS Safe interpreters greatly restrict the functionality available to Tcl programs executing within them. Allowing the untrusted Tcl program to have direct access to this functionality is unsafe, because it can be used for a variety of attacks on the environment. However, there are times when there is a legitimate need to use the dangerous functionality in the context of the safe interpreter. For example, sometimes a program must be source d into the interpreter. Another example is Tk, where windows are bound to the hierarchy of windows for a specific interpreter; some potentially dangerous functions, e.g. window management, must be performed on these windows within the interpreter context. The interp command provides a solution to this problem in the form of hidden commands . Instead of removing the dangerous commands entirely from a safe interpreter, these commands are hidden so they become unavailable to Tcl scripts executing in the interpreter. However, such hidden commands can be invoked by any trusted ancestor of the safe interpreter, in the context of the safe interpreter, using interp invoke. Hidden commands and exposed commands reside in separate name spaces. It is possible to define a hidden command and an exposed command by the same name within one interpreter. Hidden commands in a child interpreter can be invoked in the body of procedures called in the parent during alias invocation. For example, an alias for source could be created in a child interpreter. When it is invoked in the child interpreter, a procedure is called in the parent interpreter to check that the operation is allowable (e.g. it asks to source a file that the child interpreter is allowed to access). The procedure then it invokes the hidden source command in the child interpreter to actually source in the contents of the file. Note that two commands named source exist in the child interpreter: the alias, and the hidden command. Because a parent interpreter may invoke a hidden command as part of handling an alias invocation, great care must be taken to avoid evaluating any arguments passed in through the alias invocation. Otherwise, malicious child interpreters could cause a trusted parent interpreter to execute dangerous commands on their behalf. See the section on ALIAS INVOCATION for a more complete discussion of this topic. To help avoid this problem, no substitutions or evaluations are applied to arguments of interp invokehidden . Safe interpreters are not allowed to invoke hidden commands in themselves or in their descendants. This prevents them from gaining access to hidden functionality in themselves or their descendants. The set of hidden commands in an interpreter can be manipulated by a trusted interpreter using interp expose and interp hide . The interp expose command moves a hidden command to the set of exposed commands in the interpreter identified by path , potentially renaming the command in the process. If an exposed command by the targeted name already exists, the operation fails. Similarly, interp hide moves an exposed command to the set of hidden commands in that interpreter. Safe interpreters are not allowed to move commands between the set of hidden and exposed commands, in either themselves or their descendants. Currently, the names of hidden commands cannot contain namespace qualifiers, and you must first rename a command in a namespace to the global namespace before you can hide it. Commands to be hidden by interp hide are looked up in the global namespace even if the current namespace is not the global one. This prevents children from fooling a parent interpreter into hiding the wrong command, by making the current namespace be different from the global one. RESOURCE LIMITS Every interpreter has two kinds of resource limits that may be imposed by any parent interpreter upon its children. Command limits (of type command ) restrict the total number of Tcl commands that may be executed by an interpreter (as can be inspected via the info cmdcount command), and time limits (of type time ) place a limit by which execution within the interpreter must complete. Note that time limits are expressed as absolute times (as in clock seconds ) and not relative times (as in after ) because they may be modified after creation. When a limit is exceeded for an interpreter, first any handler callbacks defined by parent interpreters are called. If those callbacks increase or remove the limit, execution within the (previously) limited interpreter continues. If the limit is still in force, an error is generated at that point and normal processing of errors within the interpreter (by the catch command) is disabled, so the error propagates outwards (building a stack-trace as it goes) to the point where the limited interpreter was invoked (e.g. by interp eval ) where it becomes the responsibility of the calling code to catch and handle. LIMIT OPTIONS Every limit has a number of options associated with it, some of which are common across all kinds of limits, and others of which are particular to the kind of limit. -command : This option (common for all limit types) specifies (if non-empty) a Tcl script to be executed in the global namespace of the interpreter reading and writing the option when the particular limit in the limited interpreter is exceeded. The callback may modify the limit on the interpreter if it wishes the limited interpreter to continue executing. If the callback generates an exception, it is reported through the background exception mechanism (see BACKGROUND EXCEPTION HANDLING ). Note that the callbacks defined by one interpreter are completely isolated from the callbacks defined by another, and that the order in which those callbacks are called is undefined. -granularity : This option (common for all limit types) specifies how frequently (out of the points when the Tcl interpreter is in a consistent state where limit checking is possible) that the limit is actually checked. This allows the tuning of how frequently a limit is checked, and hence how often the limit-checking overhead (which may be substantial in the case of time limits) is incurred. -milliseconds : This option specifies the number of milliseconds after the moment defined in the -seconds option that the time limit will fire. It should only ever be specified in conjunction with the -seconds option (whether it was set previously or is being set this invocation.) -seconds : This option specifies the number of seconds after the epoch (see clock seconds) that the time limit for the interpreter will be triggered. The limit will be triggered at the start of the second unless specified at a sub-second level using the -milliseconds option. This option may be the empty string, which indicates that a time limit is not set for the interpreter. -value : This option specifies the number of commands that the interpreter may execute before triggering the command limit. This option may be the empty string, which indicates that a command limit is not set for the interpreter. Where an interpreter with a resource limit set on it creates a child interpreter, that child interpreter will have resource limits imposed on it that are at least as restrictive as the limits on the creating parent interpreter. If the parent interpreter of the limited parent wishes to relax these conditions, it should hide the interp command in the child and then use aliases and the interp invokehidden subcommand to provide such access as it chooses to the interp command to the limited parent as necessary. BACKGROUND EXCEPTION HANDLING When an exception happens in a situation where it cannot be reported directly up the stack (e.g. when processing events in an update or vwait call) the exception is instead reported through the background exception handling mechanism. Every interpreter has a background exception handler registered; the default exception handler arranges for the bgerror command in the interpreter\\'s global namespace to be called, but other exception handlers may be installed and process background exceptions in substantially different ways. A background exception handler consists of a non-empty list of words to which will be appended two further words at invocation time. The first word will be the interpreter result at time of the exception, typically an error message, and the second will be the dictionary of return options at the time of the exception. These are the same values that catch can capture when it controls script evaluation in a non-background situation. The resulting list will then be executed in the interpreter\\'s global namespace without further substitutions being performed. CREDITS The safe interpreter mechanism is based on the Safe-Tcl prototype implemented by Nathaniel Borenstein and Marshall Rose. EXAMPLES Creating and using an alias for a command in the current interpreter: interp alias {} getIndex {} lsearch {alpha beta gamma delta} set idx [getIndex delta] Executing an arbitrary command in a safe interpreter where every invocation of lappend is logged: set i [ interp create -safe] interp hide \\$i lappend interp alias \\$i lappend {} loggedLappend \\$i proc loggedLappend {i args} { puts \\\"logged invocation of lappend \\$args\\\" interp invokehidden \\$i lappend {*}\\$args } interp eval \\$i \\$someUntrustedScript Setting a resource limit on an interpreter so that an infinite loop terminates. set i [ interp create ] interp limit \\$i command -value 1000 interp eval \\$i { set x 0 while {1} { puts \\\"Counting up... [incr x]\\\" } } SEE ALSO bgerror(n), load(n), safe(n), Tcl_CreateChild(3), Tcl_Eval(3), Tcl_BackgroundException(3) KEYWORDS alias, parent interpreter, safe interpreter, child interpreter","title":"NAME"},{"location":"interp/#name","text":"interp - Create and manipulate Tcl interpreters","title":"NAME"},{"location":"interp/#synopsis","text":"interp subcommand ? arg arg ... ?","title":"SYNOPSIS"},{"location":"interp/#description","text":"This command makes it possible to create one or more new Tcl interpreters that co-exist with the creating interpreter in the same application. The creating interpreter is called the parent and the new interpreter is called a child . A parent can create any number of children, and each child can itself create additional children for which it is parent, resulting in a hierarchy of interpreters. Each interpreter is independent from the others: it has its own name space for commands, procedures, and global variables. A parent interpreter may create connections between its children and itself using a mechanism called an alias . An alias is a command in a child interpreter which, when invoked, causes a command to be invoked in its parent interpreter or in another child interpreter. The only other connections between interpreters are through environment variables (the env variable), which are normally shared among all interpreters in the application, and by resource limit exceeded callbacks. Note that the name space for files (such as the names returned by the open command) is no longer shared between interpreters. Explicit commands are provided to share files and to transfer references to open files from one interpreter to another. The interp command also provides support for safe interpreters. A safe interpreter is a child whose functions have been greatly restricted, so that it is safe to execute untrusted scripts without fear of them damaging other interpreters or the application\\'s environment. For example, all IO channel creation commands and subprocess creation commands are made inaccessible to safe interpreters. See SAFE INTERPRETERS below for more information on what features are present in a safe interpreter. The dangerous functionality is not removed from the safe interpreter; instead, it is hidden , so that only trusted interpreters can obtain access to it. For a detailed explanation of hidden commands, see HIDDEN COMMANDS , below. The alias mechanism can be used for protected communication (analogous to a kernel call) between a child interpreter and its parent. See ALIAS INVOCATION , below, for more details on how the alias mechanism works. A qualified interpreter name is a proper Tcl list containing a subset of its ancestors in the interpreter hierarchy, terminated by the string naming the interpreter in its immediate parent. Interpreter names are relative to the interpreter in which they are used. For example, if is a child of the current interpreter and it has a child which in turn has a child the qualified name of in is the list The interp command, described below, accepts qualified interpreter names as arguments; the interpreter in which the command is being evaluated can always be referred to as {} (the empty list or string). Note that it is impossible to refer to a parent (ancestor) interpreter by name in a child interpreter except through aliases. Also, there is no global name by which one can refer to the first interpreter created in an application. Both restrictions are motivated by safety concerns.","title":"DESCRIPTION"},{"location":"interp/#the-interp-command","text":"The interp command is used to create, delete, and manipulate child interpreters, and to share or transfer channels between interpreters. It can have any of several forms, depending on the subcommand argument: interp alias srcPath srcToken : Returns a Tcl list whose elements are the targetCmd and arg s associated with the alias represented by srcToken (this is the value returned when the alias was created; it is possible that the name of the source command in the child is different from srcToken ). interp alias srcPath srcToken {} : Deletes the alias for srcToken in the child interpreter identified by srcPath . srcToken refers to the value returned when the alias was created; if the source command has been renamed, the renamed command will be deleted. interp alias srcPath srcCmd targetPath targetCmd ? arg arg ... ? : This command creates an alias between one child and another (see the alias child command below for creating aliases between a child and its parent). In this command, either of the child interpreters may be anywhere in the hierarchy of interpreters under the interpreter invoking the command. SrcPath and srcCmd identify the source of the alias. SrcPath is a Tcl list whose elements select a particular interpreter. For example, identifies an interpreter which is a child of interpreter which is a child of the invoking interpreter. An empty list specifies the interpreter invoking the command. srcCmd gives the name of a new command, which will be created in the source interpreter. TargetPath and targetCmd specify a target interpreter and command, and the arg arguments, if any, specify additional arguments to targetCmd which are prepended to any arguments specified in the invocation of srcCmd . TargetCmd may be undefined at the time of this call, or it may already exist; it is not created by this command. The alias arranges for the given target command to be invoked in the target interpreter whenever the given source command is invoked in the source interpreter. See ALIAS INVOCATION below for more details. The command returns a token that uniquely identifies the command created srcCmd , even if the command is renamed afterwards. The token may but does not have to be equal to srcCmd . interp aliases ? path ? : This command returns a Tcl list of the tokens of all the source commands for aliases defined in the interpreter identified by path . The tokens correspond to the values returned when the aliases were created (which may not be the same as the current names of the commands). interp bgerror path ? cmdPrefix ? : This command either gets or sets the current background exception handler for the interpreter identified by path . If cmdPrefix is absent, the current background exception handler is returned, and if it is present, it is a list of words (of minimum length one) that describes what to set the interpreter\\'s background exception handler to. See the BACKGROUND EXCEPTION HANDLING section for more details. interp cancel ? -unwind ? ? -\u2006- ? ? path ? ? result ? : Cancels the script being evaluated in the interpreter identified by path . Without the -unwind switch the evaluation stack for the interpreter is unwound until an enclosing catch command is found or there are no further invocations of the interpreter left on the call stack. With the -unwind switch the evaluation stack for the interpreter is unwound without regard to any intervening catch command until there are no further invocations of the interpreter left on the call stack. The -\u2006- switch can be used to mark the end of switches; it may be needed if path is an unusual value such as -safe . If result is present, it will be used as the error message string; otherwise, a default error message string will be used. interp create ? -safe ? ? -\u2006- ? ? path ? : Creates a child interpreter identified by path and a new command, called a child command . The name of the child command is the last component of path . The new child interpreter and the child command are created in the interpreter identified by the path obtained by removing the last component from path . For example, if path is a b c then a new child interpreter and child command named c are created in the interpreter identified by the path a b . The child command may be used to manipulate the new interpreter as described below. If path is omitted, Tcl creates a unique name of the form interp x , where x is an integer, and uses it for the interpreter and the child command. If the -safe switch is specified (or if the parent interpreter is a safe interpreter), the new child interpreter will be created as a safe interpreter with limited functionality; otherwise the child will include the full set of Tcl built-in commands and variables. The -\u2006- switch can be used to mark the end of switches; it may be needed if path is an unusual value such as -safe . The result of the command is the name of the new interpreter. The name of a child interpreter must be unique among all the children for its parent; an error occurs if a child interpreter by the given name already exists in this parent. The initial recursion limit of the child interpreter is set to the current recursion limit of its parent interpreter. interp debug path ? -frame ? bool ?? : Controls whether frame-level stack information is captured in the child interpreter identified by path . If no arguments are given, option and current setting are returned. If -frame is given, the debug setting is set to the given boolean if provided and the current setting is returned. This only affects the output of info frame , in that exact frame-level information for command invocation at the bytecode level is only captured with this setting on. For example, with code like **proc** mycontrol {\\... script} { \\... **uplevel** 1 \\$script \\... } **proc** dosomething {\\...} { \\... mycontrol { somecode } } the standard setting will provide a relative line number for the command **somecode** and the relevant frame will be of type **eval**. With frame-debug active on the other hand the tracking extends so far that the system will be able to determine the file and absolute line number of this command, and return a frame of type **source**. This more exact information is paid for with slower execution of all commands. Note that once it is on, this flag cannot be switched back off: such attempts are silently ignored. This is needed to maintain the consistency of the underlying interpreter\\'s state. interp delete ? path ... ? : Deletes zero or more interpreters given by the optional path arguments, and for each interpreter, it also deletes its children. The command also deletes the child command for each interpreter deleted. For each path argument, if no interpreter by that name exists, the command raises an error. interp eval path arg ? arg ... ? : This command concatenates all of the arg arguments in the same fashion as the concat command, then evaluates the resulting string as a Tcl script in the child interpreter identified by path . The result of this evaluation (including all return options, such as -errorinfo and -errorcode information, if an error occurs) is returned to the invoking interpreter. Note that the script will be executed in the current context stack frame of the path interpreter; this is so that the implementations (in a parent interpreter) of aliases in a child interpreter can execute scripts in the child that find out information about the child\\'s current state and stack frame. interp exists path : Returns 1 if a child interpreter by the specified path exists in this parent, 0 otherwise. If path is omitted, the invoking interpreter is used. interp expose path hiddenName ? exposedCmdName ? : Makes the hidden command hiddenName exposed, eventually bringing it back under a new exposedCmdName name (this name is currently accepted only if it is a valid global name space name without any ::), in the interpreter denoted by path . If an exposed command with the targeted name already exists, this command fails. Hidden commands are explained in more detail in HIDDEN COMMANDS , below. interp hide path exposedCmdName ? hiddenCmdName ? : Makes the exposed command exposedCmdName hidden, renaming it to the hidden command hiddenCmdName , or keeping the same name if hiddenCmdName is not given, in the interpreter denoted by path . If a hidden command with the targeted name already exists, this command fails. Currently both exposedCmdName and hiddenCmdName can not contain namespace qualifiers, or an error is raised. Commands to be hidden by interp hide are looked up in the global namespace even if the current namespace is not the global one. This prevents children from fooling a parent interpreter into hiding the wrong command, by making the current namespace be different from the global one. Hidden commands are explained in more detail in HIDDEN COMMANDS , below. interp hidden path : Returns a list of the names of all hidden commands in the interpreter identified by path . interp invokehidden path ? -option ... ? hiddenCmdName ? arg ... ? : Invokes the hidden command hiddenCmdName with the arguments supplied in the interpreter denoted by path . No substitutions or evaluation are applied to the arguments. Three -option s are supported, all of which start with - : -namespace (which takes a single argument afterwards, nsName ), -global , and -\u2006- . If the -namespace flag is present, the hidden command is invoked in the namespace called nsName in the target interpreter. If the -global flag is present, the hidden command is invoked at the global level in the target interpreter; otherwise it is invoked at the current call frame and can access local variables in that and outer call frames. The -\u2006- flag allows the hiddenCmdName argument to start with a character, and is otherwise unnecessary. If both the -namespace and -global flags are present, the -namespace flag is ignored. Note that the hidden command will be executed (by default) in the current context stack frame of the path interpreter. Hidden commands are explained in more detail in HIDDEN COMMANDS , below. interp issafe ? path ? : Returns 1 if the interpreter identified by the specified path is safe, 0 otherwise. interp limit path limitType ? -option ? ? value ... ? : Sets up, manipulates and queries the configuration of the resource limit limitType for the interpreter denoted by path . If no -option is specified, return the current configuration of the limit. If -option is the sole argument, return the value of that option. Otherwise, a list of -option / value argument pairs must supplied. See RESOURCE LIMITS below for a more detailed explanation of what limits and options are supported. interp marktrusted path : Marks the interpreter identified by path as trusted. Does not expose the hidden commands. This command can only be invoked from a trusted interpreter. The command has no effect if the interpreter identified by path is already trusted. interp recursionlimit path ? newlimit ? : Returns the maximum allowable nesting depth for the interpreter specified by path . If newlimit is specified, the interpreter recursion limit will be set so that nesting of more than newlimit calls to Tcl_Eval and related procedures in that interpreter will return an error. The newlimit value is also returned. The newlimit value must be a positive integer between 1 and the maximum value of a non-long integer on the platform. The command sets the maximum size of the Tcl call stack only. It cannot by itself prevent stack overflows on the C stack being used by the application. If your machine has a limit on the size of the C stack, you may get stack overflows before reaching the limit set by the command. If this happens, see if there is a mechanism in your system for increasing the maximum size of the C stack. interp share srcPath channelId destPath : Causes the IO channel identified by channelId to become shared between the interpreter identified by srcPath and the interpreter identified by destPath . Both interpreters have the same permissions on the IO channel. Both interpreters must close it to close the underlying IO channel; IO channels accessible in an interpreter are automatically closed when an interpreter is destroyed. interp children ? path ? : Returns a Tcl list of the names of all the child interpreters associated with the interpreter identified by path . If path is omitted, the invoking interpreter is used. interp target path alias : Returns a Tcl list describing the target interpreter for an alias. The alias is specified with an interpreter path and source command name, just as in interp alias above. The name of the target interpreter is returned as an interpreter path, relative to the invoking interpreter. If the target interpreter for the alias is the invoking interpreter then an empty list is returned. If the target interpreter for the alias is not the invoking interpreter or one of its descendants then an error is generated. The target command does not have to be defined at the time of this invocation. interp transfer srcPath channelId destPath : Causes the IO channel identified by channelId to become available in the interpreter identified by destPath and unavailable in the interpreter identified by srcPath .","title":"THE INTERP COMMAND"},{"location":"interp/#child-command","text":"For each child interpreter created with the interp command, a new Tcl command is created in the parent interpreter with the same name as the new interpreter. This command may be used to invoke various operations on the interpreter. It has the following general form: child command ? arg arg ... ? Child is the name of the interpreter, and command and the arg s determine the exact behavior of the command. The valid forms of this command are: child aliases : Returns a Tcl list whose elements are the tokens of all the aliases in child . The tokens correspond to the values returned when the aliases were created (which may not be the same as the current names of the commands). child alias srcToken : Returns a Tcl list whose elements are the targetCmd and arg s associated with the alias represented by srcToken (this is the value returned when the alias was created; it is possible that the actual source command in the child is different from srcToken ). child alias srcToken {} : Deletes the alias for srcToken in the child interpreter. srcToken refers to the value returned when the alias was created; if the source command has been renamed, the renamed command will be deleted. child alias srcCmd targetCmd ? arg .. ? : Creates an alias such that whenever srcCmd is invoked in child , targetCmd is invoked in the parent. The arg arguments will be passed to targetCmd as additional arguments, prepended before any arguments passed in the invocation of srcCmd . See ALIAS INVOCATION below for details. The command returns a token that uniquely identifies the command created srcCmd , even if the command is renamed afterwards. The token may but does not have to be equal to srcCmd . child bgerror ? cmdPrefix ? : This command either gets or sets the current background exception handler for the child interpreter. If cmdPrefix is absent, the current background exception handler is returned, and if it is present, it is a list of words (of minimum length one) that describes what to set the interpreter\\'s background exception handler to. See the BACKGROUND EXCEPTION HANDLING section for more details. child eval arg ? arg .. ? : This command concatenates all of the arg arguments in the same fashion as the concat command, then evaluates the resulting string as a Tcl script in child . The result of this evaluation (including all return options, such as -errorinfo and -errorcode information, if an error occurs) is returned to the invoking interpreter. Note that the script will be executed in the current context stack frame of child ; this is so that the implementations (in a parent interpreter) of aliases in a child interpreter can execute scripts in the child that find out information about the child\\'s current state and stack frame. child expose hiddenName ? exposedCmdName ? : This command exposes the hidden command hiddenName , eventually bringing it back under a new exposedCmdName name (this name is currently accepted only if it is a valid global name space name without any ::), in child . If an exposed command with the targeted name already exists, this command fails. For more details on hidden commands, see HIDDEN COMMANDS , below. child hide exposedCmdName ? hiddenCmdName ? : This command hides the exposed command exposedCmdName , renaming it to the hidden command hiddenCmdName , or keeping the same name if the argument is not given, in the child interpreter. If a hidden command with the targeted name already exists, this command fails. Currently both exposedCmdName and hiddenCmdName can not contain namespace qualifiers, or an error is raised. Commands to be hidden are looked up in the global namespace even if the current namespace is not the global one. This prevents children from fooling a parent interpreter into hiding the wrong command, by making the current namespace be different from the global one. For more details on hidden commands, see HIDDEN COMMANDS , below. child hidden : Returns a list of the names of all hidden commands in child . child invokehidden ? -option ... ? hiddenName ? arg .. ? : This command invokes the hidden command hiddenName with the supplied arguments, in child . No substitutions or evaluations are applied to the arguments. Three -option s are supported, all of which start with - : -namespace (which takes a single argument afterwards, nsName ), -global , and -\u2006- . If the -namespace flag is given, the hidden command is invoked in the specified namespace in the child. If the -global flag is given, the command is invoked at the global level in the child; otherwise it is invoked at the current call frame and can access local variables in that or outer call frames. The -\u2006- flag allows the hiddenCmdName argument to start with a character, and is otherwise unnecessary. If both the -namespace and -global flags are given, the -namespace flag is ignored. Note that the hidden command will be executed (by default) in the current context stack frame of child . For more details on hidden commands, see HIDDEN COMMANDS , below. child issafe : Returns 1 if the child interpreter is safe, 0 otherwise. child limit limitType ? -option ? ? value ... ? : Sets up, manipulates and queries the configuration of the resource limit limitType for the child interpreter. If no -option is specified, return the current configuration of the limit. If -option is the sole argument, return the value of that option. Otherwise, a list of -option / value argument pairs must supplied. See RESOURCE LIMITS below for a more detailed explanation of what limits and options are supported. child marktrusted : Marks the child interpreter as trusted. Can only be invoked by a trusted interpreter. This command does not expose any hidden commands in the child interpreter. The command has no effect if the child is already trusted. child recursionlimit ? newlimit ? : Returns the maximum allowable nesting depth for the child interpreter. If newlimit is specified, the recursion limit in child will be set so that nesting of more than newlimit calls to Tcl_Eval() and related procedures in child will return an error. The newlimit value is also returned. The newlimit value must be a positive integer between 1 and the maximum value of a non-long integer on the platform. The command sets the maximum size of the Tcl call stack only. It cannot by itself prevent stack overflows on the C stack being used by the application. If your machine has a limit on the size of the C stack, you may get stack overflows before reaching the limit set by the command. If this happens, see if there is a mechanism in your system for increasing the maximum size of the C stack.","title":"CHILD COMMAND"},{"location":"interp/#safe-interpreters","text":"A safe interpreter is one with restricted functionality, so that is safe to execute an arbitrary script from your worst enemy without fear of that script damaging the enclosing application or the rest of your computing environment. In order to make an interpreter safe, certain commands and variables are removed from the interpreter. For example, commands to create files on disk are removed, and the exec command is removed, since it could be used to cause damage through subprocesses. Limited access to these facilities can be provided, by creating aliases to the parent interpreter which check their arguments carefully and provide restricted access to a safe subset of facilities. For example, file creation might be allowed in a particular subdirectory and subprocess invocation might be allowed for a carefully selected and fixed set of programs. A safe interpreter is created by specifying the -safe switch to the interp create command. Furthermore, any child created by a safe interpreter will also be safe. A safe interpreter is created with exactly the following set of built-in commands: after append apply array binary break catch chan clock close concat continue dict eof error eval expr fblocked fcopy fileevent flush for foreach format gets global if incr info interp join lappend lassign ledit lindex linsert list llength lrange lrepeat lreplace lsearch lseq lset lsort namespace package pid proc puts read regexp regsub rename return scan seek set split string subst switch tell time trace unset update uplevel upvar variable vwait while The following commands are hidden by interp create when it creates a safe interpreter: cd encoding exec exit fconfigure file glob load open pwd socket source unload These commands can be recreated later as Tcl procedures or aliases, or re-exposed by interp expose . The following commands from Tcl\\'s library of support procedures are not present in a safe interpreter: auto_exec_ok auto_import auto_load auto_load_index auto_qualify unknown Note in particular that safe interpreters have no default unknown command, so Tcl\\'s default autoloading facilities are not available. Autoload access to Tcl\\'s commands that are normally autoloaded: auto_mkindex auto_mkindex_old auto_reset history parray pkg_mkIndex ::pkg::create ::safe::interpAddToAccessPath ::safe::interpCreate ::safe::interpConfigure ::safe::interpDelete ::safe::interpFindInAccessPath ::safe::interpInit ::safe::setLogCmd tcl_endOfWord tcl_findLibrary tcl_startOfNextWord tcl_startOfPreviousWord tcl_wordBreakAfter tcl_wordBreakBefore can only be provided by explicit definition of an unknown command in the safe interpreter. This will involve exposing the source command. This is most easily accomplished by creating the safe interpreter with Tcl\\'s Safe-Tcl mechanism. Safe-Tcl provides safe versions of source , load , and other Tcl commands needed to support autoloading of commands and the loading of packages. In addition, the env variable is not present in a safe interpreter, so it cannot share environment variables with other interpreters. The env variable poses a security risk, because users can store sensitive information in an environment variable. For example, the PGP manual recommends storing the PGP private key protection password in the environment variable PGPPASS . Making this variable available to untrusted code executing in a safe interpreter would incur a security risk. If extensions are loaded into a safe interpreter, they may also restrict their own functionality to eliminate unsafe commands. For a discussion of management of extensions for safety see the manual entries for Safe-Tcl and the load Tcl command. A safe interpreter may not alter the recursion limit of any interpreter, including itself.","title":"SAFE INTERPRETERS"},{"location":"interp/#alias-invocation","text":"The alias mechanism has been carefully designed so that it can be used safely in an untrusted script which is being executed in a safe interpreter even if the target of the alias is not a safe interpreter. The most important thing in guaranteeing safety is to ensure that information passed from the child to the parent is never evaluated or substituted in the parent; if this were to occur, it would enable an evil script in the child to invoke arbitrary functions in the parent, which would compromise security. When the source for an alias is invoked in the child interpreter, the usual Tcl substitutions are performed when parsing that command. These substitutions are carried out in the source interpreter just as they would be for any other command invoked in that interpreter. The command procedure for the source command takes its arguments and merges them with the targetCmd and arg s for the alias to create a new array of arguments. If the words of srcCmd were the new set of words will be where targetCmd and arg s are the values supplied when the alias was created. TargetCmd is then used to locate a command procedure in the target interpreter, and that command procedure is invoked with the new set of arguments. An error occurs if there is no command named targetCmd in the target interpreter. No additional substitutions are performed on the words: the target command procedure is invoked directly, without going through the normal Tcl evaluation mechanism. Substitutions are thus performed on each word exactly once: targetCmd and args were substituted when parsing the command that created the alias, and arg1 - argN are substituted when the alias\\'s source command is parsed in the source interpreter. When writing the targetCmd s for aliases in safe interpreters, it is very important that the arguments to that command never be evaluated or substituted, since this would provide an escape mechanism whereby the child interpreter could execute arbitrary code in the parent. This in turn would compromise the security of the system.","title":"ALIAS INVOCATION"},{"location":"interp/#hidden-commands","text":"Safe interpreters greatly restrict the functionality available to Tcl programs executing within them. Allowing the untrusted Tcl program to have direct access to this functionality is unsafe, because it can be used for a variety of attacks on the environment. However, there are times when there is a legitimate need to use the dangerous functionality in the context of the safe interpreter. For example, sometimes a program must be source d into the interpreter. Another example is Tk, where windows are bound to the hierarchy of windows for a specific interpreter; some potentially dangerous functions, e.g. window management, must be performed on these windows within the interpreter context. The interp command provides a solution to this problem in the form of hidden commands . Instead of removing the dangerous commands entirely from a safe interpreter, these commands are hidden so they become unavailable to Tcl scripts executing in the interpreter. However, such hidden commands can be invoked by any trusted ancestor of the safe interpreter, in the context of the safe interpreter, using interp invoke. Hidden commands and exposed commands reside in separate name spaces. It is possible to define a hidden command and an exposed command by the same name within one interpreter. Hidden commands in a child interpreter can be invoked in the body of procedures called in the parent during alias invocation. For example, an alias for source could be created in a child interpreter. When it is invoked in the child interpreter, a procedure is called in the parent interpreter to check that the operation is allowable (e.g. it asks to source a file that the child interpreter is allowed to access). The procedure then it invokes the hidden source command in the child interpreter to actually source in the contents of the file. Note that two commands named source exist in the child interpreter: the alias, and the hidden command. Because a parent interpreter may invoke a hidden command as part of handling an alias invocation, great care must be taken to avoid evaluating any arguments passed in through the alias invocation. Otherwise, malicious child interpreters could cause a trusted parent interpreter to execute dangerous commands on their behalf. See the section on ALIAS INVOCATION for a more complete discussion of this topic. To help avoid this problem, no substitutions or evaluations are applied to arguments of interp invokehidden . Safe interpreters are not allowed to invoke hidden commands in themselves or in their descendants. This prevents them from gaining access to hidden functionality in themselves or their descendants. The set of hidden commands in an interpreter can be manipulated by a trusted interpreter using interp expose and interp hide . The interp expose command moves a hidden command to the set of exposed commands in the interpreter identified by path , potentially renaming the command in the process. If an exposed command by the targeted name already exists, the operation fails. Similarly, interp hide moves an exposed command to the set of hidden commands in that interpreter. Safe interpreters are not allowed to move commands between the set of hidden and exposed commands, in either themselves or their descendants. Currently, the names of hidden commands cannot contain namespace qualifiers, and you must first rename a command in a namespace to the global namespace before you can hide it. Commands to be hidden by interp hide are looked up in the global namespace even if the current namespace is not the global one. This prevents children from fooling a parent interpreter into hiding the wrong command, by making the current namespace be different from the global one.","title":"HIDDEN COMMANDS"},{"location":"interp/#resource-limits","text":"Every interpreter has two kinds of resource limits that may be imposed by any parent interpreter upon its children. Command limits (of type command ) restrict the total number of Tcl commands that may be executed by an interpreter (as can be inspected via the info cmdcount command), and time limits (of type time ) place a limit by which execution within the interpreter must complete. Note that time limits are expressed as absolute times (as in clock seconds ) and not relative times (as in after ) because they may be modified after creation. When a limit is exceeded for an interpreter, first any handler callbacks defined by parent interpreters are called. If those callbacks increase or remove the limit, execution within the (previously) limited interpreter continues. If the limit is still in force, an error is generated at that point and normal processing of errors within the interpreter (by the catch command) is disabled, so the error propagates outwards (building a stack-trace as it goes) to the point where the limited interpreter was invoked (e.g. by interp eval ) where it becomes the responsibility of the calling code to catch and handle.","title":"RESOURCE LIMITS"},{"location":"interp/#limit-options","text":"Every limit has a number of options associated with it, some of which are common across all kinds of limits, and others of which are particular to the kind of limit. -command : This option (common for all limit types) specifies (if non-empty) a Tcl script to be executed in the global namespace of the interpreter reading and writing the option when the particular limit in the limited interpreter is exceeded. The callback may modify the limit on the interpreter if it wishes the limited interpreter to continue executing. If the callback generates an exception, it is reported through the background exception mechanism (see BACKGROUND EXCEPTION HANDLING ). Note that the callbacks defined by one interpreter are completely isolated from the callbacks defined by another, and that the order in which those callbacks are called is undefined. -granularity : This option (common for all limit types) specifies how frequently (out of the points when the Tcl interpreter is in a consistent state where limit checking is possible) that the limit is actually checked. This allows the tuning of how frequently a limit is checked, and hence how often the limit-checking overhead (which may be substantial in the case of time limits) is incurred. -milliseconds : This option specifies the number of milliseconds after the moment defined in the -seconds option that the time limit will fire. It should only ever be specified in conjunction with the -seconds option (whether it was set previously or is being set this invocation.) -seconds : This option specifies the number of seconds after the epoch (see clock seconds) that the time limit for the interpreter will be triggered. The limit will be triggered at the start of the second unless specified at a sub-second level using the -milliseconds option. This option may be the empty string, which indicates that a time limit is not set for the interpreter. -value : This option specifies the number of commands that the interpreter may execute before triggering the command limit. This option may be the empty string, which indicates that a command limit is not set for the interpreter. Where an interpreter with a resource limit set on it creates a child interpreter, that child interpreter will have resource limits imposed on it that are at least as restrictive as the limits on the creating parent interpreter. If the parent interpreter of the limited parent wishes to relax these conditions, it should hide the interp command in the child and then use aliases and the interp invokehidden subcommand to provide such access as it chooses to the interp command to the limited parent as necessary.","title":"LIMIT OPTIONS"},{"location":"interp/#background-exception-handling","text":"When an exception happens in a situation where it cannot be reported directly up the stack (e.g. when processing events in an update or vwait call) the exception is instead reported through the background exception handling mechanism. Every interpreter has a background exception handler registered; the default exception handler arranges for the bgerror command in the interpreter\\'s global namespace to be called, but other exception handlers may be installed and process background exceptions in substantially different ways. A background exception handler consists of a non-empty list of words to which will be appended two further words at invocation time. The first word will be the interpreter result at time of the exception, typically an error message, and the second will be the dictionary of return options at the time of the exception. These are the same values that catch can capture when it controls script evaluation in a non-background situation. The resulting list will then be executed in the interpreter\\'s global namespace without further substitutions being performed.","title":"BACKGROUND EXCEPTION HANDLING"},{"location":"interp/#credits","text":"The safe interpreter mechanism is based on the Safe-Tcl prototype implemented by Nathaniel Borenstein and Marshall Rose.","title":"CREDITS"},{"location":"interp/#examples","text":"Creating and using an alias for a command in the current interpreter: interp alias {} getIndex {} lsearch {alpha beta gamma delta} set idx [getIndex delta] Executing an arbitrary command in a safe interpreter where every invocation of lappend is logged: set i [ interp create -safe] interp hide \\$i lappend interp alias \\$i lappend {} loggedLappend \\$i proc loggedLappend {i args} { puts \\\"logged invocation of lappend \\$args\\\" interp invokehidden \\$i lappend {*}\\$args } interp eval \\$i \\$someUntrustedScript Setting a resource limit on an interpreter so that an infinite loop terminates. set i [ interp create ] interp limit \\$i command -value 1000 interp eval \\$i { set x 0 while {1} { puts \\\"Counting up... [incr x]\\\" } }","title":"EXAMPLES"},{"location":"interp/#see-also","text":"bgerror(n), load(n), safe(n), Tcl_CreateChild(3), Tcl_Eval(3), Tcl_BackgroundException(3)","title":"SEE ALSO"},{"location":"interp/#keywords","text":"alias, parent interpreter, safe interpreter, child interpreter","title":"KEYWORDS"},{"location":"join/","text":"NAME join - Create a string by joining together list elements SYNOPSIS join list ? joinString ? DESCRIPTION The list argument must be a valid Tcl list. This command returns the string formed by joining all of the elements of list together with joinString separating each adjacent pair of elements. The joinString argument defaults to a space character. EXAMPLES Making a comma-separated list: set data {1 2 3 4 5} join \\$data \\\", \\\" \u2192 1, 2, 3, 4, 5 Using join to flatten a list by a single level: set data {1 {2 3} 4 {5 {6 7} 8}} join \\$data \u2192 1 2 3 4 5 {6 7} 8 SEE ALSO list(n), lappend(n), split(n) KEYWORDS element, join, list, separator","title":"NAME"},{"location":"join/#name","text":"join - Create a string by joining together list elements","title":"NAME"},{"location":"join/#synopsis","text":"join list ? joinString ?","title":"SYNOPSIS"},{"location":"join/#description","text":"The list argument must be a valid Tcl list. This command returns the string formed by joining all of the elements of list together with joinString separating each adjacent pair of elements. The joinString argument defaults to a space character.","title":"DESCRIPTION"},{"location":"join/#examples","text":"Making a comma-separated list: set data {1 2 3 4 5} join \\$data \\\", \\\" \u2192 1, 2, 3, 4, 5 Using join to flatten a list by a single level: set data {1 {2 3} 4 {5 {6 7} 8}} join \\$data \u2192 1 2 3 4 5 {6 7} 8","title":"EXAMPLES"},{"location":"join/#see-also","text":"list(n), lappend(n), split(n)","title":"SEE ALSO"},{"location":"join/#keywords","text":"element, join, list, separator","title":"KEYWORDS"},{"location":"lappend/","text":"NAME lappend - Append list elements onto a variable SYNOPSIS lappend varName ? value value value ... ? DESCRIPTION This command treats the variable given by varName as a list and appends each of the value arguments to that list as a separate element, with spaces between elements. If varName does not exist, it is created as a list with elements given by the value arguments. If varName indicate an element that does not exist of an array that has a default value set, list that is comprised of the default value with all the value arguments appended as elements will be stored in the array element. Lappend is similar to append except that the value s are appended as list elements rather than raw text. This command provides a relatively efficient way to build up large lists. For example, is much more efficient than when \\$a is long. EXAMPLE Using lappend to build up a list of numbers. \\% set var 1 1 % lappend var 2 1 2 % lappend var 3 4 5 1 2 3 4 5 SEE ALSO list(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n) KEYWORDS append, element, list, variable","title":"NAME"},{"location":"lappend/#name","text":"lappend - Append list elements onto a variable","title":"NAME"},{"location":"lappend/#synopsis","text":"lappend varName ? value value value ... ?","title":"SYNOPSIS"},{"location":"lappend/#description","text":"This command treats the variable given by varName as a list and appends each of the value arguments to that list as a separate element, with spaces between elements. If varName does not exist, it is created as a list with elements given by the value arguments. If varName indicate an element that does not exist of an array that has a default value set, list that is comprised of the default value with all the value arguments appended as elements will be stored in the array element. Lappend is similar to append except that the value s are appended as list elements rather than raw text. This command provides a relatively efficient way to build up large lists. For example, is much more efficient than when \\$a is long.","title":"DESCRIPTION"},{"location":"lappend/#example","text":"Using lappend to build up a list of numbers. \\% set var 1 1 % lappend var 2 1 2 % lappend var 3 4 5 1 2 3 4 5","title":"EXAMPLE"},{"location":"lappend/#see-also","text":"list(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n)","title":"SEE ALSO"},{"location":"lappend/#keywords","text":"append, element, list, variable","title":"KEYWORDS"},{"location":"lassign/","text":"NAME lassign - Assign list elements to variables SYNOPSIS lassign list ? varName ... ? DESCRIPTION This command treats the value list as a list and assigns successive elements from that list to the variables given by the varName arguments in order. If there are more variable names than list elements, the remaining variables are set to the empty string. If there are more list elements than variables, a list of unassigned elements is returned. EXAMPLES An illustration of how multiple assignment works, and what happens when there are either too few or too many elements. lassign {a b c} x y z ;# Empty return puts \\$x ;# Prints \\\"a\\\" puts \\$y ;# Prints \\\"b\\\" puts \\$z ;# Prints \\\"c\\\" lassign {d e} x y z ;# Empty return puts \\$x ;# Prints \\\"d\\\" puts \\$y ;# Prints \\\"e\\\" puts \\$z ;# Prints \\\"\\\" lassign {f g h i} x y ;# Returns \\\"h i\\\" puts \\$x ;# Prints \\\"f\\\" puts \\$y ;# Prints \\\"g\\\" The lassign command has other uses. It can be used to create the analogue of the command in many shell languages like this: set ::argv [ lassign \\$::argv argumentToReadOff] SEE ALSO list(n), lappend(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n) KEYWORDS assign, element, list, multiple, set, variable","title":"NAME"},{"location":"lassign/#name","text":"lassign - Assign list elements to variables","title":"NAME"},{"location":"lassign/#synopsis","text":"lassign list ? varName ... ?","title":"SYNOPSIS"},{"location":"lassign/#description","text":"This command treats the value list as a list and assigns successive elements from that list to the variables given by the varName arguments in order. If there are more variable names than list elements, the remaining variables are set to the empty string. If there are more list elements than variables, a list of unassigned elements is returned.","title":"DESCRIPTION"},{"location":"lassign/#examples","text":"An illustration of how multiple assignment works, and what happens when there are either too few or too many elements. lassign {a b c} x y z ;# Empty return puts \\$x ;# Prints \\\"a\\\" puts \\$y ;# Prints \\\"b\\\" puts \\$z ;# Prints \\\"c\\\" lassign {d e} x y z ;# Empty return puts \\$x ;# Prints \\\"d\\\" puts \\$y ;# Prints \\\"e\\\" puts \\$z ;# Prints \\\"\\\" lassign {f g h i} x y ;# Returns \\\"h i\\\" puts \\$x ;# Prints \\\"f\\\" puts \\$y ;# Prints \\\"g\\\" The lassign command has other uses. It can be used to create the analogue of the command in many shell languages like this: set ::argv [ lassign \\$::argv argumentToReadOff]","title":"EXAMPLES"},{"location":"lassign/#see-also","text":"list(n), lappend(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n)","title":"SEE ALSO"},{"location":"lassign/#keywords","text":"assign, element, list, multiple, set, variable","title":"KEYWORDS"},{"location":"ledit/","text":"NAME ledit - Replace elements of a list stored in variable SYNOPSIS ledit listVar first last ? value value ... ? DESCRIPTION The command fetches the list value in variable listVar and replaces the elements in the range given by indices first to last (inclusive) with the value arguments. The resulting list is then stored back in listVar and returned as the result of the command. Arguments first and last are index values specifying the first and last elements of the range to replace. They are interpreted the same as index values for the command string index , supporting simple index arithmetic and indices relative to the end of the list. The index 0 refers to the first element of the list, and end refers to the last element of the list. If either first or last is less than zero, it is considered to refer to the position before the first element of the list. This allows elements to be prepended. If either first or last indicates a position greater than the index of the last element of the list, it is treated as if it is an index one greater than the last element. This allows elements to be appended. If last is less than first , then any specified elements will be inserted into the list before the element specified by first with no elements being deleted. The value arguments specify zero or more new elements to be added to the list in place of those that were deleted. Each value argument will become a separate element of the list. If no value arguments are specified, then the elements between first and last are simply deleted. EXAMPLES Prepend to a list. \\% set lst {c d e f g} c d e f g % ledit lst -1 -1 a b a b c d e f g Append to the list. \\% ledit lst end+1 end+1 h i a b c d e f g h i Delete third and fourth elements. \\% ledit lst 2 3 a b e f g h i Replace two elements with three. \\% ledit lst 2 3 x y z a b x y z g h i % set lst a b x y z g h i SEE ALSO list(n), lappend(n), lassign(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n), string(n) KEYWORDS element, list, replace","title":"NAME"},{"location":"ledit/#name","text":"ledit - Replace elements of a list stored in variable","title":"NAME"},{"location":"ledit/#synopsis","text":"ledit listVar first last ? value value ... ?","title":"SYNOPSIS"},{"location":"ledit/#description","text":"The command fetches the list value in variable listVar and replaces the elements in the range given by indices first to last (inclusive) with the value arguments. The resulting list is then stored back in listVar and returned as the result of the command. Arguments first and last are index values specifying the first and last elements of the range to replace. They are interpreted the same as index values for the command string index , supporting simple index arithmetic and indices relative to the end of the list. The index 0 refers to the first element of the list, and end refers to the last element of the list. If either first or last is less than zero, it is considered to refer to the position before the first element of the list. This allows elements to be prepended. If either first or last indicates a position greater than the index of the last element of the list, it is treated as if it is an index one greater than the last element. This allows elements to be appended. If last is less than first , then any specified elements will be inserted into the list before the element specified by first with no elements being deleted. The value arguments specify zero or more new elements to be added to the list in place of those that were deleted. Each value argument will become a separate element of the list. If no value arguments are specified, then the elements between first and last are simply deleted.","title":"DESCRIPTION"},{"location":"ledit/#examples","text":"Prepend to a list. \\% set lst {c d e f g} c d e f g % ledit lst -1 -1 a b a b c d e f g Append to the list. \\% ledit lst end+1 end+1 h i a b c d e f g h i Delete third and fourth elements. \\% ledit lst 2 3 a b e f g h i Replace two elements with three. \\% ledit lst 2 3 x y z a b x y z g h i % set lst a b x y z g h i","title":"EXAMPLES"},{"location":"ledit/#see-also","text":"list(n), lappend(n), lassign(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n), string(n)","title":"SEE ALSO"},{"location":"ledit/#keywords","text":"element, list, replace","title":"KEYWORDS"},{"location":"library/","text":"NAME auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore - standard library of Tcl procedures SYNOPSIS auto_execok cmd auto_import pattern auto_load cmd auto_mkindex dir pattern pattern ... auto_qualify command namespace auto_reset tcl_findLibrary basename version patch initScript enVarName varName parray arrayName ?pattern? tcl_endOfWord str start tcl_startOfNextWord str start tcl_startOfPreviousWord str start tcl_wordBreakAfter str start tcl_wordBreakBefore str start INTRODUCTION Tcl includes a library of Tcl procedures for commonly-needed functions. The procedures defined in the Tcl library are generic ones suitable for use by many different applications. The location of the Tcl library is returned by the info library command. In addition to the Tcl library, each application will normally have its own library of support procedures as well; the location of this library is normally given by the value of the \\$ app _library global variable, where app is the name of the application. For example, the location of the Tk library is kept in the variable tk_library . To access the procedures in the Tcl library, an application should source the file init.tcl in the library, for example with the Tcl command source [file join [info library] init.tcl] If the library procedure Tcl_Init is invoked from an application\\'s Tcl_AppInit procedure, this happens automatically. The code in init.tcl will define the unknown procedure and arrange for the other procedures to be loaded on-demand using the auto-load mechanism defined below. COMMAND PROCEDURES The following procedures are provided in the Tcl library: auto_execok cmd : Determines whether there is an executable file or shell builtin by the name cmd . If so, it returns a list of arguments to be passed to exec to execute the executable file or shell builtin named by cmd . If not, it returns an empty string. This command examines the directories in the current search path (given by the PATH environment variable) in its search for an executable file named cmd . On Windows platforms, the search is expanded with the same directories and file extensions as used by exec . Auto_execok remembers information about previous searches in an array named auto_execs ; this avoids the path search in future calls for the same cmd . The command auto_reset may be used to force auto_execok to forget its cached information. auto_import pattern : Auto_import is invoked during namespace import to see if the imported commands specified by pattern reside in an autoloaded library. If so, the commands are loaded so that they will be available to the interpreter for creating the import links. If the commands do not reside in an autoloaded library, auto_import does nothing. The pattern matching is performed according to the matching rules of namespace import . auto_load cmd : This command attempts to load the definition for a Tcl command named cmd . To do this, it searches an auto-load path , which is a list of one or more directories. The auto-load path is given by the global variable auto_path if it exists. If there is no auto_path variable, then the TCLLIBPATH environment variable is used, if it exists. Otherwise the auto-load path consists of just the Tcl library directory. Within each directory in the auto-load path there must be a file tclIndex that describes one or more commands defined in that directory and a script to evaluate to load each of the commands. The tclIndex file should be generated with the auto_mkindex command. If cmd is found in an index file, then the appropriate script is evaluated to create the command. The auto_load command returns 1 if cmd was successfully created. The command returns 0 if there was no index entry for cmd or if the script did not actually define cmd (e.g. because index information is out of date). If an error occurs while processing the script, then that error is returned. Auto_load only reads the index information once and saves it in the array auto_index ; future calls to auto_load check for cmd in the array rather than re-reading the index files. The cached index information may be deleted with the command auto_reset . This will force the next auto_load command to reload the index database from disk. auto_mkindex dir pattern pattern ... : Generates an index suitable for use by auto_load . The command searches dir for all files whose names match any of the pattern arguments (matching is done with the glob command), generates an index of all the Tcl command procedures defined in all the matching files, and stores the index information in a file named tclIndex in dir . If no pattern is given a pattern of *.tcl will be assumed. For example, the command **auto_mkindex foo \\*.tcl** will read all the **.tcl** files in subdirectory **foo** and generate a new index file **foo/tclIndex**. **Auto_mkindex** parses the Tcl scripts by sourcing them into a child interpreter and monitoring the proc and namespace commands that are executed. Extensions can use the (undocumented) auto_mkindex_parser package to register other commands that can contribute to the auto_load index. You will have to read through auto.tcl to see how this works. **Auto_mkindex_old** (which has the same syntax as **auto_mkindex**) parses the Tcl scripts in a relatively unsophisticated way: if any line contains the word as its first characters then it is assumed to be a procedure definition and the next word of the line is taken as the procedure\\'s name. Procedure definitions that do not appear in this way (e.g. they have spaces before the **proc**) will not be indexed. If your script contains code, such as global initialization code or procedure names with special characters like **\\$**, **\\***, **\\[** or **\\]**, you are safer using **auto_mkindex_old**. auto_reset : Destroys all the information cached by auto_execok and auto_load . This information will be re-read from disk the next time it is needed. Auto_reset also deletes any procedures listed in the auto-load index, so that fresh copies of them will be loaded the next time that they are used. auto_qualify command namespace : Computes a list of fully qualified names for command . This list mirrors the path a standard Tcl interpreter follows for command lookups: first it looks for the command in the current namespace, and then in the global namespace. Accordingly, if command is relative and namespace is not :: , the list returned has two elements: command scoped by namespace , as if it were a command in the namespace namespace; and command as if it were a command in the global namespace. Otherwise, if either command is absolute (it begins with :: ), or namespace is :: , the list contains only command as if it were a command in the global namespace. **Auto_qualify** is used by the auto-loading facilities in Tcl, both for producing auto-loading indexes such as *pkgIndex.tcl*, and for performing the actual auto-loading of functions at runtime. tcl_findLibrary basename version patch initScript enVarName varName : This is a standard search procedure for use by extensions during their initialization. They call this procedure to look for their script library in several standard directories. The last component of the name of the library directory is normally basenameversion (e.g., tk8.0), but it might be when in the build hierarchies. The initScript file will be sourced into the interpreter once it is found. The directory in which this file is found is stored into the global variable varName . If this variable is already defined (e.g., by C code during application initialization) then no searching is done. Otherwise the search looks in these directories: the directory named by the environment variable enVarName ; relative to the Tcl library directory; relative to the executable file in the standard installation bin or bin/ arch directory; relative to the executable file in the current build tree; relative to the executable file in a parallel build tree. parray arrayName ? pattern ? : Prints on standard output the names and values of all the elements in the array arrayName , or just the names that match pattern (using the matching rules of string match ) and their values if pattern is given. ArrayName must be an array accessible to the caller of parray . It may be either local or global. tcl_endOfWord str start : Returns the index of the first end-of-word location that occurs after a starting index start in the string str . An end-of-word location is defined to be the first non-word character following the first word character after the starting point. Returns -1 if there are no more end-of-word locations after the starting point. See the description of tcl_wordchars and tcl_nonwordchars below for more details on how Tcl determines which characters are word characters. tcl_startOfNextWord str start : Returns the index of the first start-of-word location that occurs after a starting index start in the string str . A start-of-word location is defined to be the first word character following a non-word character. Returns -1 if there are no more start-of-word locations after the starting point. tcl_startOfPreviousWord str start : Returns the index of the first start-of-word location that occurs before a starting index start in the string str . Returns -1 if there are no more start-of-word locations before the starting point. tcl_wordBreakAfter str start : Returns the index of the first word boundary after the starting index start in the string str . Returns -1 if there are no more boundaries after the starting point in the given string. The index returned refers to the second character of the pair that comprises a boundary. tcl_wordBreakBefore str start : Returns the index of the first word boundary before the starting index start in the string str . Returns -1 if there are no more boundaries before the starting point in the given string. The index returned refers to the second character of the pair that comprises a boundary. VARIABLES The following global variables are defined or used by the procedures in the Tcl library. They fall into two broad classes, handling unknown commands and packages, and determining what are words. AUTOLOADING AND PACKAGE MANAGEMENT VARIABLES auto_execs : Used by auto_execok to record information about whether particular commands exist as executable files. auto_index : Used by auto_load to save the index information read from disk. auto_noexec : If set to any value, then unknown will not attempt to auto-exec any commands. auto_noload : If set to any value, then unknown will not attempt to auto-load any commands. auto_path : If set, then it must contain a valid Tcl list giving directories to search during auto-load operations (including for package index files when using the default package unknown handler). This variable is initialized during startup to contain, in order: the directories listed in the TCLLIBPATH environment variable, the directory named by the tcl_library global variable, the parent directory of tcl_library , the directories listed in the tcl_pkgPath variable. Additional locations to look for files and package indices should normally be added to this variable using lappend . env(TCL_LIBRARY) : If set, then it specifies the location of the directory containing library scripts (the value of this variable will be assigned to the tcl_library variable and therefore returned by the command info library ). If this variable is not set then a default value is used. env(TCLLIBPATH) : If set, then it must contain a valid Tcl list giving directories to search during auto-load operations. Directories must be specified in Tcl format, using as the path separator, regardless of platform. This variable is only used when initializing the auto_path variable. WORD BOUNDARY DETERMINATION VARIABLES These variables are only used in the tcl_endOfWord , tcl_startOfNextWord , tcl_startOfPreviousWord , tcl_wordBreakAfter , and tcl_wordBreakBefore commands. tcl_nonwordchars : This variable contains a regular expression that is used by routines like tcl_endOfWord to identify whether a character is part of a word or not. If the pattern matches a character, the character is considered to be a non-word character. The default is \\\"\\W\\\". tcl_wordchars : This variable contains a regular expression that is used by routines like tcl_endOfWord to identify whether a character is part of a word or not. If the pattern matches a character, the character is considered to be a word character. The default is \\\"\\w\\\". SEE ALSO env(n), info(n), re_syntax(n) KEYWORDS auto-exec, auto-load, library, unknown, word, whitespace","title":"NAME"},{"location":"library/#name","text":"auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore - standard library of Tcl procedures","title":"NAME"},{"location":"library/#synopsis","text":"auto_execok cmd auto_import pattern auto_load cmd auto_mkindex dir pattern pattern ... auto_qualify command namespace auto_reset tcl_findLibrary basename version patch initScript enVarName varName parray arrayName ?pattern? tcl_endOfWord str start tcl_startOfNextWord str start tcl_startOfPreviousWord str start tcl_wordBreakAfter str start tcl_wordBreakBefore str start","title":"SYNOPSIS"},{"location":"library/#introduction","text":"Tcl includes a library of Tcl procedures for commonly-needed functions. The procedures defined in the Tcl library are generic ones suitable for use by many different applications. The location of the Tcl library is returned by the info library command. In addition to the Tcl library, each application will normally have its own library of support procedures as well; the location of this library is normally given by the value of the \\$ app _library global variable, where app is the name of the application. For example, the location of the Tk library is kept in the variable tk_library . To access the procedures in the Tcl library, an application should source the file init.tcl in the library, for example with the Tcl command source [file join [info library] init.tcl] If the library procedure Tcl_Init is invoked from an application\\'s Tcl_AppInit procedure, this happens automatically. The code in init.tcl will define the unknown procedure and arrange for the other procedures to be loaded on-demand using the auto-load mechanism defined below.","title":"INTRODUCTION"},{"location":"library/#command-procedures","text":"The following procedures are provided in the Tcl library: auto_execok cmd : Determines whether there is an executable file or shell builtin by the name cmd . If so, it returns a list of arguments to be passed to exec to execute the executable file or shell builtin named by cmd . If not, it returns an empty string. This command examines the directories in the current search path (given by the PATH environment variable) in its search for an executable file named cmd . On Windows platforms, the search is expanded with the same directories and file extensions as used by exec . Auto_execok remembers information about previous searches in an array named auto_execs ; this avoids the path search in future calls for the same cmd . The command auto_reset may be used to force auto_execok to forget its cached information. auto_import pattern : Auto_import is invoked during namespace import to see if the imported commands specified by pattern reside in an autoloaded library. If so, the commands are loaded so that they will be available to the interpreter for creating the import links. If the commands do not reside in an autoloaded library, auto_import does nothing. The pattern matching is performed according to the matching rules of namespace import . auto_load cmd : This command attempts to load the definition for a Tcl command named cmd . To do this, it searches an auto-load path , which is a list of one or more directories. The auto-load path is given by the global variable auto_path if it exists. If there is no auto_path variable, then the TCLLIBPATH environment variable is used, if it exists. Otherwise the auto-load path consists of just the Tcl library directory. Within each directory in the auto-load path there must be a file tclIndex that describes one or more commands defined in that directory and a script to evaluate to load each of the commands. The tclIndex file should be generated with the auto_mkindex command. If cmd is found in an index file, then the appropriate script is evaluated to create the command. The auto_load command returns 1 if cmd was successfully created. The command returns 0 if there was no index entry for cmd or if the script did not actually define cmd (e.g. because index information is out of date). If an error occurs while processing the script, then that error is returned. Auto_load only reads the index information once and saves it in the array auto_index ; future calls to auto_load check for cmd in the array rather than re-reading the index files. The cached index information may be deleted with the command auto_reset . This will force the next auto_load command to reload the index database from disk. auto_mkindex dir pattern pattern ... : Generates an index suitable for use by auto_load . The command searches dir for all files whose names match any of the pattern arguments (matching is done with the glob command), generates an index of all the Tcl command procedures defined in all the matching files, and stores the index information in a file named tclIndex in dir . If no pattern is given a pattern of *.tcl will be assumed. For example, the command **auto_mkindex foo \\*.tcl** will read all the **.tcl** files in subdirectory **foo** and generate a new index file **foo/tclIndex**. **Auto_mkindex** parses the Tcl scripts by sourcing them into a child interpreter and monitoring the proc and namespace commands that are executed. Extensions can use the (undocumented) auto_mkindex_parser package to register other commands that can contribute to the auto_load index. You will have to read through auto.tcl to see how this works. **Auto_mkindex_old** (which has the same syntax as **auto_mkindex**) parses the Tcl scripts in a relatively unsophisticated way: if any line contains the word as its first characters then it is assumed to be a procedure definition and the next word of the line is taken as the procedure\\'s name. Procedure definitions that do not appear in this way (e.g. they have spaces before the **proc**) will not be indexed. If your script contains code, such as global initialization code or procedure names with special characters like **\\$**, **\\***, **\\[** or **\\]**, you are safer using **auto_mkindex_old**. auto_reset : Destroys all the information cached by auto_execok and auto_load . This information will be re-read from disk the next time it is needed. Auto_reset also deletes any procedures listed in the auto-load index, so that fresh copies of them will be loaded the next time that they are used. auto_qualify command namespace : Computes a list of fully qualified names for command . This list mirrors the path a standard Tcl interpreter follows for command lookups: first it looks for the command in the current namespace, and then in the global namespace. Accordingly, if command is relative and namespace is not :: , the list returned has two elements: command scoped by namespace , as if it were a command in the namespace namespace; and command as if it were a command in the global namespace. Otherwise, if either command is absolute (it begins with :: ), or namespace is :: , the list contains only command as if it were a command in the global namespace. **Auto_qualify** is used by the auto-loading facilities in Tcl, both for producing auto-loading indexes such as *pkgIndex.tcl*, and for performing the actual auto-loading of functions at runtime. tcl_findLibrary basename version patch initScript enVarName varName : This is a standard search procedure for use by extensions during their initialization. They call this procedure to look for their script library in several standard directories. The last component of the name of the library directory is normally basenameversion (e.g., tk8.0), but it might be when in the build hierarchies. The initScript file will be sourced into the interpreter once it is found. The directory in which this file is found is stored into the global variable varName . If this variable is already defined (e.g., by C code during application initialization) then no searching is done. Otherwise the search looks in these directories: the directory named by the environment variable enVarName ; relative to the Tcl library directory; relative to the executable file in the standard installation bin or bin/ arch directory; relative to the executable file in the current build tree; relative to the executable file in a parallel build tree. parray arrayName ? pattern ? : Prints on standard output the names and values of all the elements in the array arrayName , or just the names that match pattern (using the matching rules of string match ) and their values if pattern is given. ArrayName must be an array accessible to the caller of parray . It may be either local or global. tcl_endOfWord str start : Returns the index of the first end-of-word location that occurs after a starting index start in the string str . An end-of-word location is defined to be the first non-word character following the first word character after the starting point. Returns -1 if there are no more end-of-word locations after the starting point. See the description of tcl_wordchars and tcl_nonwordchars below for more details on how Tcl determines which characters are word characters. tcl_startOfNextWord str start : Returns the index of the first start-of-word location that occurs after a starting index start in the string str . A start-of-word location is defined to be the first word character following a non-word character. Returns -1 if there are no more start-of-word locations after the starting point. tcl_startOfPreviousWord str start : Returns the index of the first start-of-word location that occurs before a starting index start in the string str . Returns -1 if there are no more start-of-word locations before the starting point. tcl_wordBreakAfter str start : Returns the index of the first word boundary after the starting index start in the string str . Returns -1 if there are no more boundaries after the starting point in the given string. The index returned refers to the second character of the pair that comprises a boundary. tcl_wordBreakBefore str start : Returns the index of the first word boundary before the starting index start in the string str . Returns -1 if there are no more boundaries before the starting point in the given string. The index returned refers to the second character of the pair that comprises a boundary.","title":"COMMAND PROCEDURES"},{"location":"library/#variables","text":"The following global variables are defined or used by the procedures in the Tcl library. They fall into two broad classes, handling unknown commands and packages, and determining what are words.","title":"VARIABLES"},{"location":"library/#autoloading-and-package-management-variables","text":"auto_execs : Used by auto_execok to record information about whether particular commands exist as executable files. auto_index : Used by auto_load to save the index information read from disk. auto_noexec : If set to any value, then unknown will not attempt to auto-exec any commands. auto_noload : If set to any value, then unknown will not attempt to auto-load any commands. auto_path : If set, then it must contain a valid Tcl list giving directories to search during auto-load operations (including for package index files when using the default package unknown handler). This variable is initialized during startup to contain, in order: the directories listed in the TCLLIBPATH environment variable, the directory named by the tcl_library global variable, the parent directory of tcl_library , the directories listed in the tcl_pkgPath variable. Additional locations to look for files and package indices should normally be added to this variable using lappend . env(TCL_LIBRARY) : If set, then it specifies the location of the directory containing library scripts (the value of this variable will be assigned to the tcl_library variable and therefore returned by the command info library ). If this variable is not set then a default value is used. env(TCLLIBPATH) : If set, then it must contain a valid Tcl list giving directories to search during auto-load operations. Directories must be specified in Tcl format, using as the path separator, regardless of platform. This variable is only used when initializing the auto_path variable.","title":"AUTOLOADING AND PACKAGE MANAGEMENT VARIABLES"},{"location":"library/#word-boundary-determination-variables","text":"These variables are only used in the tcl_endOfWord , tcl_startOfNextWord , tcl_startOfPreviousWord , tcl_wordBreakAfter , and tcl_wordBreakBefore commands. tcl_nonwordchars : This variable contains a regular expression that is used by routines like tcl_endOfWord to identify whether a character is part of a word or not. If the pattern matches a character, the character is considered to be a non-word character. The default is \\\"\\W\\\". tcl_wordchars : This variable contains a regular expression that is used by routines like tcl_endOfWord to identify whether a character is part of a word or not. If the pattern matches a character, the character is considered to be a word character. The default is \\\"\\w\\\".","title":"WORD BOUNDARY DETERMINATION VARIABLES"},{"location":"library/#see-also","text":"env(n), info(n), re_syntax(n)","title":"SEE ALSO"},{"location":"library/#keywords","text":"auto-exec, auto-load, library, unknown, word, whitespace","title":"KEYWORDS"},{"location":"lindex/","text":"NAME lindex - Retrieve an element from a list SYNOPSIS lindex list ? index ... ? DESCRIPTION The lindex command accepts a parameter, list , which it treats as a Tcl list. It also accepts zero or more indices into the list. The indices may be presented either consecutively on the command line, or grouped in a Tcl list and presented as a single argument. If no indices are presented, the command takes the form: lindex list or lindex list {} In this case, the return value of lindex is simply the value of the list parameter. When presented with a single index, the lindex command treats list as a Tcl list and returns the index \\'th element from it (0 refers to the first element of the list). In extracting the element, lindex observes the same rules concerning braces and quotes and backslashes as the Tcl command interpreter; however, variable substitution and command substitution do not occur. If index is negative or greater than or equal to the number of elements in value , then an empty string is returned. The interpretation of each simple index value is the same as for the command string index , supporting simple index arithmetic and indices relative to the end of the list. If additional index arguments are supplied, then each argument is used in turn to select an element from the previous indexing operation, allowing the script to select elements from sublists. The command, lindex \\$a 1 2 3 or lindex \\$a {1 2 3} is synonymous with lindex [ lindex [ lindex \\$a 1] 2] 3 EXAMPLES Lists can be indexed into from either end: lindex {a b c} 0 \u2192 a lindex {a b c} 2 \u2192 c lindex {a b c} end \u2192 c lindex {a b c} end-1 \u2192 b Lists or sequences of indices allow selection into lists of lists: lindex {a b c} \u2192 a b c lindex {a b c} {} \u2192 a b c lindex {{a b c} {d e f} {g h i}} 2 1 \u2192 h lindex {{a b c} {d e f} {g h i}} {2 1} \u2192 h lindex {{{a b} {c d}} {{e f} {g h}}} 1 1 0 \u2192 g lindex {{{a b} {c d}} {{e f} {g h}}} {1 1 0} \u2192 g List indices may also perform limited computation, adding or subtracting fixed amounts from other indices: set idx 1 lindex {a b c d e f} \\$idx+2 \u2192 d set idx 3 lindex {a b c d e f} \\$idx+2 \u2192 f SEE ALSO list(n), lappend(n), lassign(n), ledit(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n), string(n) KEYWORDS element, index, list","title":"NAME"},{"location":"lindex/#name","text":"lindex - Retrieve an element from a list","title":"NAME"},{"location":"lindex/#synopsis","text":"lindex list ? index ... ?","title":"SYNOPSIS"},{"location":"lindex/#description","text":"The lindex command accepts a parameter, list , which it treats as a Tcl list. It also accepts zero or more indices into the list. The indices may be presented either consecutively on the command line, or grouped in a Tcl list and presented as a single argument. If no indices are presented, the command takes the form: lindex list or lindex list {} In this case, the return value of lindex is simply the value of the list parameter. When presented with a single index, the lindex command treats list as a Tcl list and returns the index \\'th element from it (0 refers to the first element of the list). In extracting the element, lindex observes the same rules concerning braces and quotes and backslashes as the Tcl command interpreter; however, variable substitution and command substitution do not occur. If index is negative or greater than or equal to the number of elements in value , then an empty string is returned. The interpretation of each simple index value is the same as for the command string index , supporting simple index arithmetic and indices relative to the end of the list. If additional index arguments are supplied, then each argument is used in turn to select an element from the previous indexing operation, allowing the script to select elements from sublists. The command, lindex \\$a 1 2 3 or lindex \\$a {1 2 3} is synonymous with lindex [ lindex [ lindex \\$a 1] 2] 3","title":"DESCRIPTION"},{"location":"lindex/#examples","text":"Lists can be indexed into from either end: lindex {a b c} 0 \u2192 a lindex {a b c} 2 \u2192 c lindex {a b c} end \u2192 c lindex {a b c} end-1 \u2192 b Lists or sequences of indices allow selection into lists of lists: lindex {a b c} \u2192 a b c lindex {a b c} {} \u2192 a b c lindex {{a b c} {d e f} {g h i}} 2 1 \u2192 h lindex {{a b c} {d e f} {g h i}} {2 1} \u2192 h lindex {{{a b} {c d}} {{e f} {g h}}} 1 1 0 \u2192 g lindex {{{a b} {c d}} {{e f} {g h}}} {1 1 0} \u2192 g List indices may also perform limited computation, adding or subtracting fixed amounts from other indices: set idx 1 lindex {a b c d e f} \\$idx+2 \u2192 d set idx 3 lindex {a b c d e f} \\$idx+2 \u2192 f","title":"EXAMPLES"},{"location":"lindex/#see-also","text":"list(n), lappend(n), lassign(n), ledit(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n), string(n)","title":"SEE ALSO"},{"location":"lindex/#keywords","text":"element, index, list","title":"KEYWORDS"},{"location":"link/","text":"NAME link - create link from command to method of object SYNOPSIS package require tcl::oo link methodName ?...? link {commandName methodName} ?...? DESCRIPTION The link command is available within methods. It takes a series of one or more method names ( methodName ... ) and/or pairs of command- and method-name ( { commandName methodName } ) and makes the named methods available as commands without requiring the explicit use of the name of the object or the my command. The method does not need to exist at the time that the link is made; if the link command is invoked when the method does not exist, the standard unknown method handling system is used. The command name under which the method becomes available defaults to the method name, except where explicitly specified through an alias/method pair. Formally, every argument must be a list; if the list has two elements, the first element is the name of the command to create and the second element is the name of the method of the current object to which the command links; otherwise, the name of the command and the name of the method are the same string (the first element of the list). If the name of the command is not a fully-qualified command name, it will be resolved with respect to the current namespace (i.e., the object namespace). EXAMPLES This demonstrates linking a single method in various ways. First it makes a simple link, then a renamed link, then an external link. Note that the method itself is unexported, but that it can still be called directly from outside the class. oo::class create ABC { method Foo {} { puts \\\"This is Foo in [self]\\\" } constructor {} { link Foo # The method foo is now directly accessible as foo here link {bar Foo} # The method foo is now directly accessible as bar link {::ExternalCall Foo} # The method foo is now directly accessible in the global # namespace as ExternalCall } method grill {} { puts \\\"Step 1:\\\" Foo puts \\\"Step 2:\\\" bar } } ABC create abc abc grill \u2192 Step 1: \u2192 This is foo in ::abc \u2192 Step 2: \u2192 This is foo in ::abc # Direct access via the linked command puts \\\"Step 3:\\\"; ExternalCall \u2192 Step 3: \u2192 This is foo in ::abc This example shows that multiple linked commands can be made in a call to link , and that they can handle arguments. oo::class create Ex { constructor {} { link a b c # The methods a, b, and c (defined below) are all now # directly acessible within methods under their own names. } method a {} { puts \\\"This is a\\\" } method b {x} { puts \\\"This is b(\\$x)\\\" } method c {y z} { puts \\\"This is c(\\$y,\\$z)\\\" } method call {p q r} { a b \\$p c \\$q \\$r } } set o [Ex new] \\$o 3 5 7 \u2192 This is a \u2192 This is b(3) \u2192 This is c(5,7) SEE ALSO interp(n), my(n), oo::class(n), oo::define(n) KEYWORDS command, method, object","title":"NAME"},{"location":"link/#name","text":"link - create link from command to method of object","title":"NAME"},{"location":"link/#synopsis","text":"package require tcl::oo link methodName ?...? link {commandName methodName} ?...?","title":"SYNOPSIS"},{"location":"link/#description","text":"The link command is available within methods. It takes a series of one or more method names ( methodName ... ) and/or pairs of command- and method-name ( { commandName methodName } ) and makes the named methods available as commands without requiring the explicit use of the name of the object or the my command. The method does not need to exist at the time that the link is made; if the link command is invoked when the method does not exist, the standard unknown method handling system is used. The command name under which the method becomes available defaults to the method name, except where explicitly specified through an alias/method pair. Formally, every argument must be a list; if the list has two elements, the first element is the name of the command to create and the second element is the name of the method of the current object to which the command links; otherwise, the name of the command and the name of the method are the same string (the first element of the list). If the name of the command is not a fully-qualified command name, it will be resolved with respect to the current namespace (i.e., the object namespace).","title":"DESCRIPTION"},{"location":"link/#examples","text":"This demonstrates linking a single method in various ways. First it makes a simple link, then a renamed link, then an external link. Note that the method itself is unexported, but that it can still be called directly from outside the class. oo::class create ABC { method Foo {} { puts \\\"This is Foo in [self]\\\" } constructor {} { link Foo # The method foo is now directly accessible as foo here link {bar Foo} # The method foo is now directly accessible as bar link {::ExternalCall Foo} # The method foo is now directly accessible in the global # namespace as ExternalCall } method grill {} { puts \\\"Step 1:\\\" Foo puts \\\"Step 2:\\\" bar } } ABC create abc abc grill \u2192 Step 1: \u2192 This is foo in ::abc \u2192 Step 2: \u2192 This is foo in ::abc # Direct access via the linked command puts \\\"Step 3:\\\"; ExternalCall \u2192 Step 3: \u2192 This is foo in ::abc This example shows that multiple linked commands can be made in a call to link , and that they can handle arguments. oo::class create Ex { constructor {} { link a b c # The methods a, b, and c (defined below) are all now # directly acessible within methods under their own names. } method a {} { puts \\\"This is a\\\" } method b {x} { puts \\\"This is b(\\$x)\\\" } method c {y z} { puts \\\"This is c(\\$y,\\$z)\\\" } method call {p q r} { a b \\$p c \\$q \\$r } } set o [Ex new] \\$o 3 5 7 \u2192 This is a \u2192 This is b(3) \u2192 This is c(5,7)","title":"EXAMPLES"},{"location":"link/#see-also","text":"interp(n), my(n), oo::class(n), oo::define(n)","title":"SEE ALSO"},{"location":"link/#keywords","text":"command, method, object","title":"KEYWORDS"},{"location":"linsert/","text":"NAME linsert - Insert elements into a list SYNOPSIS linsert list index ? element element ... ? DESCRIPTION This command produces a new list from list by inserting all of the element arguments just before the index \\'th element of list . Each element argument will become a separate element of the new list. If index is less than or equal to zero, then the new elements are inserted at the beginning of the list, and if index is greater or equal to the length of list , it is as if it was end . As with string index , the index value supports both simple index arithmetic and end-relative indexing. Subject to the restrictions that indices must refer to locations inside the list and that the element s will always be inserted in order, insertions are done so that when index is start-relative, the first element will be at that index in the resulting list, and when index is end-relative, the last element will be at that index in the resulting list. EXAMPLE Putting some values into a list, first indexing from the start and then indexing from the end, and then chaining them together: set oldList {the fox jumps over the dog} set midList [ linsert \\$oldList 1 quick] set newList [ linsert \\$midList end-1 lazy] # The old lists still exist though... set newerList [ linsert [ linsert \\$oldList end-1 quick] 1 lazy] SEE ALSO list(n), lappend(n), lassign(n), ledit(n), lindex(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n), string(n) KEYWORDS element, insert, list","title":"NAME"},{"location":"linsert/#name","text":"linsert - Insert elements into a list","title":"NAME"},{"location":"linsert/#synopsis","text":"linsert list index ? element element ... ?","title":"SYNOPSIS"},{"location":"linsert/#description","text":"This command produces a new list from list by inserting all of the element arguments just before the index \\'th element of list . Each element argument will become a separate element of the new list. If index is less than or equal to zero, then the new elements are inserted at the beginning of the list, and if index is greater or equal to the length of list , it is as if it was end . As with string index , the index value supports both simple index arithmetic and end-relative indexing. Subject to the restrictions that indices must refer to locations inside the list and that the element s will always be inserted in order, insertions are done so that when index is start-relative, the first element will be at that index in the resulting list, and when index is end-relative, the last element will be at that index in the resulting list.","title":"DESCRIPTION"},{"location":"linsert/#example","text":"Putting some values into a list, first indexing from the start and then indexing from the end, and then chaining them together: set oldList {the fox jumps over the dog} set midList [ linsert \\$oldList 1 quick] set newList [ linsert \\$midList end-1 lazy] # The old lists still exist though... set newerList [ linsert [ linsert \\$oldList end-1 quick] 1 lazy]","title":"EXAMPLE"},{"location":"linsert/#see-also","text":"list(n), lappend(n), lassign(n), ledit(n), lindex(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n), string(n)","title":"SEE ALSO"},{"location":"linsert/#keywords","text":"element, insert, list","title":"KEYWORDS"},{"location":"list/","text":"NAME list - Create a list SYNOPSIS list ? arg arg ... ? DESCRIPTION This command returns a list comprised of all the arg s, or an empty string if no arg s are specified. Braces and backslashes get added as necessary, so that the lindex command may be used on the result to re-extract the original arguments, and also so that eval may be used to execute the resulting list, with arg1 comprising the command\\'s name and the other arg s comprising its arguments. List produces slightly different results than concat : concat removes one level of grouping before forming the list, while list works directly from the original arguments. EXAMPLE The command list a b \\\"c d e \\\" \\\" f {g h}\\\" will return a b {c d e } { f {g h}} while concat with the same arguments will return a b c d e f {g h} SEE ALSO lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n) KEYWORDS element, list, quoting","title":"NAME"},{"location":"list/#name","text":"list - Create a list","title":"NAME"},{"location":"list/#synopsis","text":"list ? arg arg ... ?","title":"SYNOPSIS"},{"location":"list/#description","text":"This command returns a list comprised of all the arg s, or an empty string if no arg s are specified. Braces and backslashes get added as necessary, so that the lindex command may be used on the result to re-extract the original arguments, and also so that eval may be used to execute the resulting list, with arg1 comprising the command\\'s name and the other arg s comprising its arguments. List produces slightly different results than concat : concat removes one level of grouping before forming the list, while list works directly from the original arguments.","title":"DESCRIPTION"},{"location":"list/#example","text":"The command list a b \\\"c d e \\\" \\\" f {g h}\\\" will return a b {c d e } { f {g h}} while concat with the same arguments will return a b c d e f {g h}","title":"EXAMPLE"},{"location":"list/#see-also","text":"lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n)","title":"SEE ALSO"},{"location":"list/#keywords","text":"element, list, quoting","title":"KEYWORDS"},{"location":"llength/","text":"NAME llength - Count the number of elements in a list SYNOPSIS llength list DESCRIPTION Treats list as a list and returns a decimal string giving the number of elements in it. EXAMPLES The result is the number of elements: \\% llength {a b c d e} 5 % llength {a b c} 3 % llength {} 0 Elements are not guaranteed to be exactly words in a dictionary sense of course, especially when quoting is used: \\% llength {a b {c d} e} 4 % llength {a b { } c d e} 6 An empty list is not necessarily an empty string: \\% set var { }; puts \\\"[string length \\$var],[ llength \\$var]\\\" 1,0 SEE ALSO list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n) KEYWORDS element, list, length","title":"NAME"},{"location":"llength/#name","text":"llength - Count the number of elements in a list","title":"NAME"},{"location":"llength/#synopsis","text":"llength list","title":"SYNOPSIS"},{"location":"llength/#description","text":"Treats list as a list and returns a decimal string giving the number of elements in it.","title":"DESCRIPTION"},{"location":"llength/#examples","text":"The result is the number of elements: \\% llength {a b c d e} 5 % llength {a b c} 3 % llength {} 0 Elements are not guaranteed to be exactly words in a dictionary sense of course, especially when quoting is used: \\% llength {a b {c d} e} 4 % llength {a b { } c d e} 6 An empty list is not necessarily an empty string: \\% set var { }; puts \\\"[string length \\$var],[ llength \\$var]\\\" 1,0","title":"EXAMPLES"},{"location":"llength/#see-also","text":"list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n)","title":"SEE ALSO"},{"location":"llength/#keywords","text":"element, list, length","title":"KEYWORDS"},{"location":"lmap/","text":"NAME lmap - Iterate over all elements in one or more lists and collect results SYNOPSIS lmap varname list body \\ lmap varlist1 list1 ? varlist2 list2 ... ? body DESCRIPTION The lmap command implements a loop where the loop variable(s) take on values from one or more lists, and the loop returns a list of results collected from each iteration. In the simplest case there is one loop variable, varname , and one list, list , that is a list of values to assign to varname . The body argument is a Tcl script. For each element of list (in order from first to last), lmap assigns the contents of the element to varname as if the lindex command had been used to extract the element, then calls the Tcl interpreter to execute body . If execution of the body completes normally then the result of the body is appended to an accumulator list. lmap returns the accumulator list. In the general case there can be more than one value list (e.g., list1 and list2 ), and each value list can be associated with a list of loop variables (e.g., varlist1 and varlist2 ). During each iteration of the loop the variables of each varlist are assigned consecutive values from the corresponding list . Values in each list are used in order from first to last, and each value is used exactly once. The total number of loop iterations is large enough to use up all the values from all the value lists. If a value list does not contain enough elements for each of its loop variables in each iteration, empty values are used for the missing elements. The break and continue statements may be invoked inside body , with the same effect as in the for and foreach commands. In these cases the body does not complete normally and the result is not appended to the accumulator list. EXAMPLES Zip lists together: set list1 {a b c d} set list2 {1 2 3 4} set zipped [ lmap a \\$list1 b \\$list2 {list \\$a \\$b}] # The value of zipped is \\\"{a 1} {b 2} {c 3} {d 4}\\\" Filter a list to remove odd values: set values {1 2 3 4 5 6 7 8} proc isEven {n} {expr {(\\$n % 2) == 0}} set goodOnes [ lmap x \\$values {expr { [isEven \\$x] ? \\$x : [continue] }}] # The value of goodOnes is \\\"2 4 6 8\\\" Take a prefix from a list based on the contents of the list: set values {8 7 6 5 4 3 2 1} proc isGood {counter} {expr {\\$n > 3}} set prefix [ lmap x \\$values {expr { [isGood \\$x] ? \\$x : [break] }}] # The value of prefix is \\\"8 7 6 5 4\\\" SEE ALSO break(n), continue(n), for(n), foreach(n), while(n), list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n) KEYWORDS foreach, iteration, list, loop, map","title":"NAME"},{"location":"lmap/#name","text":"lmap - Iterate over all elements in one or more lists and collect results","title":"NAME"},{"location":"lmap/#synopsis","text":"lmap varname list body \\ lmap varlist1 list1 ? varlist2 list2 ... ? body","title":"SYNOPSIS"},{"location":"lmap/#description","text":"The lmap command implements a loop where the loop variable(s) take on values from one or more lists, and the loop returns a list of results collected from each iteration. In the simplest case there is one loop variable, varname , and one list, list , that is a list of values to assign to varname . The body argument is a Tcl script. For each element of list (in order from first to last), lmap assigns the contents of the element to varname as if the lindex command had been used to extract the element, then calls the Tcl interpreter to execute body . If execution of the body completes normally then the result of the body is appended to an accumulator list. lmap returns the accumulator list. In the general case there can be more than one value list (e.g., list1 and list2 ), and each value list can be associated with a list of loop variables (e.g., varlist1 and varlist2 ). During each iteration of the loop the variables of each varlist are assigned consecutive values from the corresponding list . Values in each list are used in order from first to last, and each value is used exactly once. The total number of loop iterations is large enough to use up all the values from all the value lists. If a value list does not contain enough elements for each of its loop variables in each iteration, empty values are used for the missing elements. The break and continue statements may be invoked inside body , with the same effect as in the for and foreach commands. In these cases the body does not complete normally and the result is not appended to the accumulator list.","title":"DESCRIPTION"},{"location":"lmap/#examples","text":"Zip lists together: set list1 {a b c d} set list2 {1 2 3 4} set zipped [ lmap a \\$list1 b \\$list2 {list \\$a \\$b}] # The value of zipped is \\\"{a 1} {b 2} {c 3} {d 4}\\\" Filter a list to remove odd values: set values {1 2 3 4 5 6 7 8} proc isEven {n} {expr {(\\$n % 2) == 0}} set goodOnes [ lmap x \\$values {expr { [isEven \\$x] ? \\$x : [continue] }}] # The value of goodOnes is \\\"2 4 6 8\\\" Take a prefix from a list based on the contents of the list: set values {8 7 6 5 4 3 2 1} proc isGood {counter} {expr {\\$n > 3}} set prefix [ lmap x \\$values {expr { [isGood \\$x] ? \\$x : [break] }}] # The value of prefix is \\\"8 7 6 5 4\\\"","title":"EXAMPLES"},{"location":"lmap/#see-also","text":"break(n), continue(n), for(n), foreach(n), while(n), list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n)","title":"SEE ALSO"},{"location":"lmap/#keywords","text":"foreach, iteration, list, loop, map","title":"KEYWORDS"},{"location":"lpop/","text":"NAME lpop - Get and remove an element in a list SYNOPSIS lpop varName ?index ...? DESCRIPTION The lpop command accepts a parameter, varName , which it interprets as the name of a variable containing a Tcl list. It also accepts one or more indices into the list. If no indices are presented, it defaults to \\\"end\\\". When presented with a single index, the lpop command addresses the index \\'th element in it, removes if from the list and returns the element. If index is negative or greater or equal than the number of elements in \\$varName , then an error occurs. The interpretation of each simple index value is the same as for the command string index , supporting simple index arithmetic and indices relative to the end of the list. If additional index arguments are supplied, then each argument is used in turn to address an element within a sublist designated by the previous indexing operation, allowing the script to remove elements in sublists. The command, lpop a 1 2 gets and removes element 2 of sublist 1. EXAMPLES In each of these examples, the initial value of x is: set x [list [list a b c] [list d e f] [list g h i]] \u2192 {a b c} {d e f} {g h i} The indicated value becomes the new value of x (except in the last case, which is an error which leaves the value of x unchanged.) lpop x 0 \u2192 {d e f} {g h i} lpop x 2 \u2192 {a b c} {d e f} lpop x end \u2192 {a b c} {d e f} lpop x end-1 \u2192 {a b c} {g h i} lpop x 2 1 \u2192 {a b c} {d e f} {g i} lpop x 2 3 j \u2192 list index out of range In the following examples, the initial value of x is: set x [list [list [list a b] [list c d]] \\ [list [list e f] [list g h]]] \u2192 {{a b} {c d}} {{e f} {g h}} The indicated value becomes the new value of x . lpop x 1 1 0 \u2192 {{a b} {c d}} {{e f} h} SEE ALSO list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n), string(n) KEYWORDS element, index, list, remove, pop, stack, queue","title":"NAME"},{"location":"lpop/#name","text":"lpop - Get and remove an element in a list","title":"NAME"},{"location":"lpop/#synopsis","text":"lpop varName ?index ...?","title":"SYNOPSIS"},{"location":"lpop/#description","text":"The lpop command accepts a parameter, varName , which it interprets as the name of a variable containing a Tcl list. It also accepts one or more indices into the list. If no indices are presented, it defaults to \\\"end\\\". When presented with a single index, the lpop command addresses the index \\'th element in it, removes if from the list and returns the element. If index is negative or greater or equal than the number of elements in \\$varName , then an error occurs. The interpretation of each simple index value is the same as for the command string index , supporting simple index arithmetic and indices relative to the end of the list. If additional index arguments are supplied, then each argument is used in turn to address an element within a sublist designated by the previous indexing operation, allowing the script to remove elements in sublists. The command, lpop a 1 2 gets and removes element 2 of sublist 1.","title":"DESCRIPTION"},{"location":"lpop/#examples","text":"In each of these examples, the initial value of x is: set x [list [list a b c] [list d e f] [list g h i]] \u2192 {a b c} {d e f} {g h i} The indicated value becomes the new value of x (except in the last case, which is an error which leaves the value of x unchanged.) lpop x 0 \u2192 {d e f} {g h i} lpop x 2 \u2192 {a b c} {d e f} lpop x end \u2192 {a b c} {d e f} lpop x end-1 \u2192 {a b c} {g h i} lpop x 2 1 \u2192 {a b c} {d e f} {g i} lpop x 2 3 j \u2192 list index out of range In the following examples, the initial value of x is: set x [list [list [list a b] [list c d]] \\ [list [list e f] [list g h]]] \u2192 {{a b} {c d}} {{e f} {g h}} The indicated value becomes the new value of x . lpop x 1 1 0 \u2192 {{a b} {c d}} {{e f} h}","title":"EXAMPLES"},{"location":"lpop/#see-also","text":"list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n), string(n)","title":"SEE ALSO"},{"location":"lpop/#keywords","text":"element, index, list, remove, pop, stack, queue","title":"KEYWORDS"},{"location":"lrange/","text":"NAME lrange - Return one or more adjacent elements from a list SYNOPSIS lrange list first last DESCRIPTION List must be a valid Tcl list. This command will return a new list consisting of elements first through last , inclusive. The index values first and last are interpreted the same as index values for the command string index , supporting simple index arithmetic and indices relative to the end of the list. If first is less than zero, it is treated as if it were zero. If last is greater than or equal to the number of elements in the list, then it is treated as if it were end . If first is greater than last then an empty string is returned. Note: does not always produce the same result as (although it often does for simple fields that are not enclosed in braces); it does, however, produce exactly the same results as EXAMPLES Selecting the first two elements: \\% lrange {a b c d e} 0 1 a b Selecting the last three elements: \\% lrange {a b c d e} end-2 end c d e Selecting everything except the first and last element: \\% lrange {a b c d e} 1 end-1 b c d Selecting a single element with lrange is not the same as doing so with lindex : \\% set var {some {elements to} select} some {elements to} select % lindex \\$var 1 elements to % lrange \\$var 1 1 {elements to} SEE ALSO list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n), string(n) KEYWORDS element, list, range, sublist","title":"NAME"},{"location":"lrange/#name","text":"lrange - Return one or more adjacent elements from a list","title":"NAME"},{"location":"lrange/#synopsis","text":"lrange list first last","title":"SYNOPSIS"},{"location":"lrange/#description","text":"List must be a valid Tcl list. This command will return a new list consisting of elements first through last , inclusive. The index values first and last are interpreted the same as index values for the command string index , supporting simple index arithmetic and indices relative to the end of the list. If first is less than zero, it is treated as if it were zero. If last is greater than or equal to the number of elements in the list, then it is treated as if it were end . If first is greater than last then an empty string is returned. Note: does not always produce the same result as (although it often does for simple fields that are not enclosed in braces); it does, however, produce exactly the same results as","title":"DESCRIPTION"},{"location":"lrange/#examples","text":"Selecting the first two elements: \\% lrange {a b c d e} 0 1 a b Selecting the last three elements: \\% lrange {a b c d e} end-2 end c d e Selecting everything except the first and last element: \\% lrange {a b c d e} 1 end-1 b c d Selecting a single element with lrange is not the same as doing so with lindex : \\% set var {some {elements to} select} some {elements to} select % lindex \\$var 1 elements to % lrange \\$var 1 1 {elements to}","title":"EXAMPLES"},{"location":"lrange/#see-also","text":"list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n), string(n)","title":"SEE ALSO"},{"location":"lrange/#keywords","text":"element, list, range, sublist","title":"KEYWORDS"},{"location":"lremove/","text":"NAME lremove - Remove elements from a list by index SYNOPSIS lremove list ? index ... ? DESCRIPTION lremove returns a new list formed by simultaneously removing zero or more elements of list at each of the indices given by an arbirary number of index arguments. The indices may be in any order and may be repeated; the element at index will only be removed once. The index values are interpreted the same as index values for the command string index , supporting simple index arithmetic and indices relative to the end of the list. 0 refers to the first element of the list, and end refers to the last element of the list. EXAMPLES Removing the third element of a list: \\% lremove {a b c d e} 2 a b d e Removing two elements from a list: \\% lremove {a b c d e} end-1 1 a c e Removing the same element indicated in two different ways: \\% lremove {a b c d e} 2 end-2 a b d e SEE ALSO list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n) KEYWORDS element, list, remove","title":"NAME"},{"location":"lremove/#name","text":"lremove - Remove elements from a list by index","title":"NAME"},{"location":"lremove/#synopsis","text":"lremove list ? index ... ?","title":"SYNOPSIS"},{"location":"lremove/#description","text":"lremove returns a new list formed by simultaneously removing zero or more elements of list at each of the indices given by an arbirary number of index arguments. The indices may be in any order and may be repeated; the element at index will only be removed once. The index values are interpreted the same as index values for the command string index , supporting simple index arithmetic and indices relative to the end of the list. 0 refers to the first element of the list, and end refers to the last element of the list.","title":"DESCRIPTION"},{"location":"lremove/#examples","text":"Removing the third element of a list: \\% lremove {a b c d e} 2 a b d e Removing two elements from a list: \\% lremove {a b c d e} end-1 1 a c e Removing the same element indicated in two different ways: \\% lremove {a b c d e} 2 end-2 a b d e","title":"EXAMPLES"},{"location":"lremove/#see-also","text":"list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n)","title":"SEE ALSO"},{"location":"lremove/#keywords","text":"element, list, remove","title":"KEYWORDS"},{"location":"lrepeat/","text":"NAME lrepeat - Build a list by repeating elements SYNOPSIS lrepeat count ? element ... ? DESCRIPTION The lrepeat command creates a list of size count * number of elements by repeating count times the sequence of elements element ... . count must be a non-negative integer, element can be any Tcl value. Note that lrepeat 1 element ... is identical to list element ... . EXAMPLES lrepeat 3 a \u2192 a a a lrepeat 3 [ lrepeat 3 0] \u2192 {0 0 0} {0 0 0} {0 0 0} lrepeat 3 a b c \u2192 a b c a b c a b c lrepeat 3 [ lrepeat 2 a] b c \u2192 {a a} b c {a a} b c {a a} b c SEE ALSO list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n) KEYWORDS element, index, list","title":"NAME"},{"location":"lrepeat/#name","text":"lrepeat - Build a list by repeating elements","title":"NAME"},{"location":"lrepeat/#synopsis","text":"lrepeat count ? element ... ?","title":"SYNOPSIS"},{"location":"lrepeat/#description","text":"The lrepeat command creates a list of size count * number of elements by repeating count times the sequence of elements element ... . count must be a non-negative integer, element can be any Tcl value. Note that lrepeat 1 element ... is identical to list element ... .","title":"DESCRIPTION"},{"location":"lrepeat/#examples","text":"lrepeat 3 a \u2192 a a a lrepeat 3 [ lrepeat 3 0] \u2192 {0 0 0} {0 0 0} {0 0 0} lrepeat 3 a b c \u2192 a b c a b c a b c lrepeat 3 [ lrepeat 2 a] b c \u2192 {a a} b c {a a} b c {a a} b c","title":"EXAMPLES"},{"location":"lrepeat/#see-also","text":"list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n)","title":"SEE ALSO"},{"location":"lrepeat/#keywords","text":"element, index, list","title":"KEYWORDS"},{"location":"lreplace/","text":"NAME lreplace - Replace elements in a list with new elements SYNOPSIS lreplace list first last ? element element ... ? DESCRIPTION lreplace returns a new list formed by replacing zero or more elements of list with the element arguments. first and last are index values specifying the first and last elements of the range to replace. The index values first and last are interpreted the same as index values for the command string index , supporting simple index arithmetic and indices relative to the end of the list. 0 refers to the first element of the list, and end refers to the last element of the list. If either first or last is less than zero, it is considered to refer to before the first element of the list. This allows lreplace to prepend elements to list . If either first or last indicates a position greater than the index of the last element of the list, it is treated as if it is an index one greater than the last element. This allows lreplace to append elements to list . If last is less than first , then any specified elements will be inserted into the list before the element specified by first with no elements being deleted. The element arguments specify zero or more new elements to be added to the list in place of those that were deleted. Each element argument will become a separate element of the list. If no element arguments are specified, then the elements between first and last are simply deleted. EXAMPLES Replacing an element of a list with another: \\% lreplace {a b c d e} 1 1 foo a foo c d e Replacing two elements of a list with three: \\% lreplace {a b c d e} 1 2 three more elements a three more elements d e Deleting the last element from a list in a variable: \\% set var {a b c d e} a b c d e % set var [ lreplace \\$var end end] a b c d A procedure to delete a given element from a list: proc lremove {listVariable value} { upvar 1 \\$listVariable var set idx [lsearch -exact \\$var \\$value] set var [ lreplace \\$var \\$idx \\$idx] } Appending elements to the list; note that end+2 will initially be treated as if it is 6 here, but both that and 12345 are greater than the index of the final item so they behave identically: \\% set var {a b c d e} a b c d e % set var [ lreplace \\$var 12345 end+2 f g h i] a b c d e f g h i SEE ALSO list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n), string(n) KEYWORDS element, list, replace","title":"NAME"},{"location":"lreplace/#name","text":"lreplace - Replace elements in a list with new elements","title":"NAME"},{"location":"lreplace/#synopsis","text":"lreplace list first last ? element element ... ?","title":"SYNOPSIS"},{"location":"lreplace/#description","text":"lreplace returns a new list formed by replacing zero or more elements of list with the element arguments. first and last are index values specifying the first and last elements of the range to replace. The index values first and last are interpreted the same as index values for the command string index , supporting simple index arithmetic and indices relative to the end of the list. 0 refers to the first element of the list, and end refers to the last element of the list. If either first or last is less than zero, it is considered to refer to before the first element of the list. This allows lreplace to prepend elements to list . If either first or last indicates a position greater than the index of the last element of the list, it is treated as if it is an index one greater than the last element. This allows lreplace to append elements to list . If last is less than first , then any specified elements will be inserted into the list before the element specified by first with no elements being deleted. The element arguments specify zero or more new elements to be added to the list in place of those that were deleted. Each element argument will become a separate element of the list. If no element arguments are specified, then the elements between first and last are simply deleted.","title":"DESCRIPTION"},{"location":"lreplace/#examples","text":"Replacing an element of a list with another: \\% lreplace {a b c d e} 1 1 foo a foo c d e Replacing two elements of a list with three: \\% lreplace {a b c d e} 1 2 three more elements a three more elements d e Deleting the last element from a list in a variable: \\% set var {a b c d e} a b c d e % set var [ lreplace \\$var end end] a b c d A procedure to delete a given element from a list: proc lremove {listVariable value} { upvar 1 \\$listVariable var set idx [lsearch -exact \\$var \\$value] set var [ lreplace \\$var \\$idx \\$idx] } Appending elements to the list; note that end+2 will initially be treated as if it is 6 here, but both that and 12345 are greater than the index of the final item so they behave identically: \\% set var {a b c d e} a b c d e % set var [ lreplace \\$var 12345 end+2 f g h i] a b c d e f g h i","title":"EXAMPLES"},{"location":"lreplace/#see-also","text":"list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreverse(n), lsearch(n), lseq(n), lset(n), lsort(n), string(n)","title":"SEE ALSO"},{"location":"lreplace/#keywords","text":"element, list, replace","title":"KEYWORDS"},{"location":"lreverse/","text":"NAME lreverse - Reverse the order of a list SYNOPSIS lreverse list DESCRIPTION The lreverse command returns a list that has the same elements as its input list, list , except with the elements in the reverse order. EXAMPLES lreverse {a a b c} \u2192 c b a a lreverse {a b {c d} e f} \u2192 f e {c d} b a SEE ALSO list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lsearch(n), lseq(n), lset(n), lsort(n) KEYWORDS element, list, reverse","title":"NAME"},{"location":"lreverse/#name","text":"lreverse - Reverse the order of a list","title":"NAME"},{"location":"lreverse/#synopsis","text":"lreverse list","title":"SYNOPSIS"},{"location":"lreverse/#description","text":"The lreverse command returns a list that has the same elements as its input list, list , except with the elements in the reverse order.","title":"DESCRIPTION"},{"location":"lreverse/#examples","text":"lreverse {a a b c} \u2192 c b a a lreverse {a b {c d} e f} \u2192 f e {c d} b a","title":"EXAMPLES"},{"location":"lreverse/#see-also","text":"list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lsearch(n), lseq(n), lset(n), lsort(n)","title":"SEE ALSO"},{"location":"lreverse/#keywords","text":"element, list, reverse","title":"KEYWORDS"},{"location":"lsearch/","text":"NAME lsearch - See if a list contains a particular element SYNOPSIS lsearch ? options ? list pattern DESCRIPTION This command searches the elements of list to see if one of them matches pattern . If so, the command returns the index of the first matching element (unless the options -all or -inline are specified.) If not, the command returns -1 or (if options -all or -inline are specified) the empty string. The option arguments indicates how the elements of the list are to be matched against pattern and must have one of the values below: MATCHING STYLE OPTIONS If all matching style options are omitted, the default matching style is -glob . If more than one matching style is specified, the last matching style given takes precedence. -exact : Pattern is a literal string that is compared for exact equality against each list element. -glob : Pattern is a glob-style pattern which is matched against each list element using the same rules as the string match command. -regexp : Pattern is treated as a regular expression and matched against each list element using the rules described in the re_syntax reference page. -sorted : The list elements are in sorted order. If this option is specified, lsearch will use a more efficient searching algorithm to search list . If no other options are specified, list is assumed to be sorted in increasing order, and to contain ASCII strings. This option is mutually exclusive with -glob and -regexp , and is treated exactly like -exact when either -all or -not are specified. GENERAL MODIFIER OPTIONS These options may be given with all matching styles. -all : Changes the result to be the list of all matching indices (or all matching values if -inline is specified as well.) If indices are returned, the indices will be in ascending numeric order. If values are returned, the order of the values will be the order of those values within the input list . -inline : The matching value is returned instead of its index (or an empty string if no value matches.) If -all is also specified, then the result of the command is the list of all values that matched. -not : This negates the sense of the match, returning the index of the first non-matching value in the list. -start \u2007 index : The list is searched starting at position index . The interpretation of the index value is the same as for the command string index , supporting simple index arithmetic and indices relative to the end of the list. CONTENTS DESCRIPTION OPTIONS These options describe how to interpret the items in the list being searched. They are only meaningful when used with the -exact and -sorted options. If more than one is specified, the last one takes precedence. The default is -ascii . -ascii : The list elements are to be examined as Unicode strings (the name is for backward-compatibility reasons.) -dictionary : The list elements are to be compared using dictionary-style comparisons (see lsort for a fuller description). Note that this only makes a meaningful difference from the -ascii option when the -sorted option is given, because values are only dictionary-equal when exactly equal. -integer : The list elements are to be compared as integers. -nocase : Causes comparisons to be handled in a case-insensitive manner. Has no effect if combined with the -dictionary , -integer , or -real options. -real : The list elements are to be compared as floating-point values. SORTED LIST OPTIONS These options (only meaningful with the -sorted option) specify how the list is sorted. If more than one is given, the last one takes precedence. The default option is -increasing . -decreasing : The list elements are sorted in decreasing order. This option is only meaningful when used with -sorted . -increasing : The list elements are sorted in increasing order. This option is only meaningful when used with -sorted . -bisect : Inexact search when the list elements are in sorted order. For an increasing list the last index where the element is less than or equal to the pattern is returned. For a decreasing list the last index where the element is greater than or equal to the pattern is returned. If the pattern is before the first element or the list is empty, -1 is returned. This option implies -sorted and cannot be used with either -all or -not . NESTED LIST OPTIONS These options are used to search lists of lists. They may be used with any other options. -stride\u2007 strideLength : If this option is specified, the list is treated as consisting of groups of strideLength elements and the groups are searched by either their first element or, if the -index option is used, by the element within each group given by the first index passed to -index (which is then ignored by -index ). The resulting index always points to the first element in a group. The list length must be an integer multiple of strideLength , which in turn must be at least 1. A strideLength of 1 is the default and indicates no grouping. -index \u2007 indexList : This option is designed for use when searching within nested lists. The indexList argument gives a path of indices (much as might be used with the lindex or lset commands) within each element to allow the location of the term being matched against. -subindices : If this option is given, the index result from this command (or every index result when -all is also specified) will be a complete path (suitable for use with lindex or lset ) within the overall list to the term found. This option has no effect unless the -index is also specified, and is just a convenience short-cut. EXAMPLES Basic searching: lsearch {a b c d e} c \u2192 2 lsearch -all {a b c a b c} c \u2192 2 5 Using lsearch to filter lists: lsearch -inline {a20 b35 c47} b* \u2192 b35 lsearch -inline -not {a20 b35 c47} b* \u2192 a20 lsearch -all -inline -not {a20 b35 c47} b* \u2192 a20 c47 lsearch -all -not {a20 b35 c47} b* \u2192 0 2 This can even do a removal operation: lsearch -all -inline -not -exact {a b c a d e a f g a} a \u2192 b c d e f g Searching may start part-way through the list: lsearch -start 3 {a b c a b c} c \u2192 5 It is also possible to search inside elements: lsearch -index 1 -all -inline {{a abc} {b bcd} {c cde}} *bc* \u2192 {a abc} {b bcd} The same thing for a flattened list: lsearch -stride 2 -index 1 -all -inline {a abc b bcd c cde} *bc* \u2192 {a abc b bcd} SEE ALSO foreach(n), list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lseq(n), lset(n), lsort(n), string(n) KEYWORDS binary search, linear search, list, match, pattern, regular expression, search, string","title":"NAME"},{"location":"lsearch/#name","text":"lsearch - See if a list contains a particular element","title":"NAME"},{"location":"lsearch/#synopsis","text":"lsearch ? options ? list pattern","title":"SYNOPSIS"},{"location":"lsearch/#description","text":"This command searches the elements of list to see if one of them matches pattern . If so, the command returns the index of the first matching element (unless the options -all or -inline are specified.) If not, the command returns -1 or (if options -all or -inline are specified) the empty string. The option arguments indicates how the elements of the list are to be matched against pattern and must have one of the values below:","title":"DESCRIPTION"},{"location":"lsearch/#matching-style-options","text":"If all matching style options are omitted, the default matching style is -glob . If more than one matching style is specified, the last matching style given takes precedence. -exact : Pattern is a literal string that is compared for exact equality against each list element. -glob : Pattern is a glob-style pattern which is matched against each list element using the same rules as the string match command. -regexp : Pattern is treated as a regular expression and matched against each list element using the rules described in the re_syntax reference page. -sorted : The list elements are in sorted order. If this option is specified, lsearch will use a more efficient searching algorithm to search list . If no other options are specified, list is assumed to be sorted in increasing order, and to contain ASCII strings. This option is mutually exclusive with -glob and -regexp , and is treated exactly like -exact when either -all or -not are specified.","title":"MATCHING STYLE OPTIONS"},{"location":"lsearch/#general-modifier-options","text":"These options may be given with all matching styles. -all : Changes the result to be the list of all matching indices (or all matching values if -inline is specified as well.) If indices are returned, the indices will be in ascending numeric order. If values are returned, the order of the values will be the order of those values within the input list . -inline : The matching value is returned instead of its index (or an empty string if no value matches.) If -all is also specified, then the result of the command is the list of all values that matched. -not : This negates the sense of the match, returning the index of the first non-matching value in the list. -start \u2007 index : The list is searched starting at position index . The interpretation of the index value is the same as for the command string index , supporting simple index arithmetic and indices relative to the end of the list.","title":"GENERAL MODIFIER OPTIONS"},{"location":"lsearch/#contents-description-options","text":"These options describe how to interpret the items in the list being searched. They are only meaningful when used with the -exact and -sorted options. If more than one is specified, the last one takes precedence. The default is -ascii . -ascii : The list elements are to be examined as Unicode strings (the name is for backward-compatibility reasons.) -dictionary : The list elements are to be compared using dictionary-style comparisons (see lsort for a fuller description). Note that this only makes a meaningful difference from the -ascii option when the -sorted option is given, because values are only dictionary-equal when exactly equal. -integer : The list elements are to be compared as integers. -nocase : Causes comparisons to be handled in a case-insensitive manner. Has no effect if combined with the -dictionary , -integer , or -real options. -real : The list elements are to be compared as floating-point values.","title":"CONTENTS DESCRIPTION OPTIONS"},{"location":"lsearch/#sorted-list-options","text":"These options (only meaningful with the -sorted option) specify how the list is sorted. If more than one is given, the last one takes precedence. The default option is -increasing . -decreasing : The list elements are sorted in decreasing order. This option is only meaningful when used with -sorted . -increasing : The list elements are sorted in increasing order. This option is only meaningful when used with -sorted . -bisect : Inexact search when the list elements are in sorted order. For an increasing list the last index where the element is less than or equal to the pattern is returned. For a decreasing list the last index where the element is greater than or equal to the pattern is returned. If the pattern is before the first element or the list is empty, -1 is returned. This option implies -sorted and cannot be used with either -all or -not .","title":"SORTED LIST OPTIONS"},{"location":"lsearch/#nested-list-options","text":"These options are used to search lists of lists. They may be used with any other options. -stride\u2007 strideLength : If this option is specified, the list is treated as consisting of groups of strideLength elements and the groups are searched by either their first element or, if the -index option is used, by the element within each group given by the first index passed to -index (which is then ignored by -index ). The resulting index always points to the first element in a group. The list length must be an integer multiple of strideLength , which in turn must be at least 1. A strideLength of 1 is the default and indicates no grouping. -index \u2007 indexList : This option is designed for use when searching within nested lists. The indexList argument gives a path of indices (much as might be used with the lindex or lset commands) within each element to allow the location of the term being matched against. -subindices : If this option is given, the index result from this command (or every index result when -all is also specified) will be a complete path (suitable for use with lindex or lset ) within the overall list to the term found. This option has no effect unless the -index is also specified, and is just a convenience short-cut.","title":"NESTED LIST OPTIONS"},{"location":"lsearch/#examples","text":"Basic searching: lsearch {a b c d e} c \u2192 2 lsearch -all {a b c a b c} c \u2192 2 5 Using lsearch to filter lists: lsearch -inline {a20 b35 c47} b* \u2192 b35 lsearch -inline -not {a20 b35 c47} b* \u2192 a20 lsearch -all -inline -not {a20 b35 c47} b* \u2192 a20 c47 lsearch -all -not {a20 b35 c47} b* \u2192 0 2 This can even do a removal operation: lsearch -all -inline -not -exact {a b c a d e a f g a} a \u2192 b c d e f g Searching may start part-way through the list: lsearch -start 3 {a b c a b c} c \u2192 5 It is also possible to search inside elements: lsearch -index 1 -all -inline {{a abc} {b bcd} {c cde}} *bc* \u2192 {a abc} {b bcd} The same thing for a flattened list: lsearch -stride 2 -index 1 -all -inline {a abc b bcd c cde} *bc* \u2192 {a abc b bcd}","title":"EXAMPLES"},{"location":"lsearch/#see-also","text":"foreach(n), list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lseq(n), lset(n), lsort(n), string(n)","title":"SEE ALSO"},{"location":"lsearch/#keywords","text":"binary search, linear search, list, match, pattern, regular expression, search, string","title":"KEYWORDS"},{"location":"lseq/","text":"NAME lseq - Build a numeric sequence returned as a list SYNOPSIS lseq Start ?( .. | to )? End ?? by ? Step ? lseq Start count Count ?? by ? Step ? lseq Count ? by Step ? DESCRIPTION The lseq command creates a sequence of numeric values using the given parameters Start , End , and Step . The operation argument \\\"..\\\" or \\\"to\\\" defines an inclusive range. The \\\"count\\\" option is used to define a count of the number of elements in the list. The short form with a single count value will create a range from 0 to count-1. The numeric arguments, Start , End , Step , and Count , can also be a valid expression. the lseq command will evaluate the expression and use the numeric result, or return an error as with any invalid argument value. A valid expression is a valid [expr] expression, however, the result must be numeric; a non-numeric string will result in an error. EXAMPLES lseq 3 \u2192 0 1 2 lseq 3 0 \u2192 3 2 1 0 lseq 10 .. 1 by -2 \u2192 10 8 6 4 2 set l [lseq 0 -5] \u2192 0 -1 -2 -3 -4 -5 foreach i [lseq [llength \\$l]] { puts l(\\$i)=[lindex \\$l \\$i] } \u2192 l(0)=0 l(1)=-1 l(2)=-2 l(3)=-3 l(4)=-4 l(5)=-5 foreach i [lseq [llength \\$l]-1 0] { puts l(\\$i)=[lindex \\$l \\$i] } \u2192 l(5)=-5 l(4)=-4 l(3)=-3 l(2)=-2 l(1)=-1 l(0)=0 set i 17 \u2192 17 if {\\$i in [lseq 0 50]} { # equivalent to: (0 \\<= \\$i && \\$i \\< 50) puts \\\"Ok\\\" } else { puts \\\"outside :(\\\" } \u2192 Ok set sqrs [lmap i [lseq 1 10] {expr \\$i*\\$i}] \u2192 1 4 9 16 25 36 49 64 81 100 SEE ALSO foreach(n), list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lreplace(n), lreverse(n), lsearch(n), lset(n), lsort(n) KEYWORDS element, index, list","title":"NAME"},{"location":"lseq/#name","text":"lseq - Build a numeric sequence returned as a list","title":"NAME"},{"location":"lseq/#synopsis","text":"lseq Start ?( .. | to )? End ?? by ? Step ? lseq Start count Count ?? by ? Step ? lseq Count ? by Step ?","title":"SYNOPSIS"},{"location":"lseq/#description","text":"The lseq command creates a sequence of numeric values using the given parameters Start , End , and Step . The operation argument \\\"..\\\" or \\\"to\\\" defines an inclusive range. The \\\"count\\\" option is used to define a count of the number of elements in the list. The short form with a single count value will create a range from 0 to count-1. The numeric arguments, Start , End , Step , and Count , can also be a valid expression. the lseq command will evaluate the expression and use the numeric result, or return an error as with any invalid argument value. A valid expression is a valid [expr] expression, however, the result must be numeric; a non-numeric string will result in an error.","title":"DESCRIPTION"},{"location":"lseq/#examples","text":"lseq 3 \u2192 0 1 2 lseq 3 0 \u2192 3 2 1 0 lseq 10 .. 1 by -2 \u2192 10 8 6 4 2 set l [lseq 0 -5] \u2192 0 -1 -2 -3 -4 -5 foreach i [lseq [llength \\$l]] { puts l(\\$i)=[lindex \\$l \\$i] } \u2192 l(0)=0 l(1)=-1 l(2)=-2 l(3)=-3 l(4)=-4 l(5)=-5 foreach i [lseq [llength \\$l]-1 0] { puts l(\\$i)=[lindex \\$l \\$i] } \u2192 l(5)=-5 l(4)=-4 l(3)=-3 l(2)=-2 l(1)=-1 l(0)=0 set i 17 \u2192 17 if {\\$i in [lseq 0 50]} { # equivalent to: (0 \\<= \\$i && \\$i \\< 50) puts \\\"Ok\\\" } else { puts \\\"outside :(\\\" } \u2192 Ok set sqrs [lmap i [lseq 1 10] {expr \\$i*\\$i}] \u2192 1 4 9 16 25 36 49 64 81 100","title":"EXAMPLES"},{"location":"lseq/#see-also","text":"foreach(n), list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lreplace(n), lreverse(n), lsearch(n), lset(n), lsort(n)","title":"SEE ALSO"},{"location":"lseq/#keywords","text":"element, index, list","title":"KEYWORDS"},{"location":"lset/","text":"NAME lset - Change an element in a list SYNOPSIS lset varName ?index ...? newValue DESCRIPTION The lset command accepts a parameter, varName , which it interprets as the name of a variable containing a Tcl list. It also accepts zero or more indices into the list. The indices may be presented either consecutively on the command line, or grouped in a Tcl list and presented as a single argument. Finally, it accepts a new value for an element of varName . If no indices are presented, the command takes the form: lset varName newValue or lset varName {} newValue In this case, newValue replaces the old value of the variable varName . When presented with a single index, the lset command treats the content of the varName variable as a Tcl list. It addresses the index \\'th element in it (0 refers to the first element of the list). When interpreting the list, lset observes the same rules concerning braces and quotes and backslashes as the Tcl command interpreter; however, variable substitution and command substitution do not occur. The command constructs a new list in which the designated element is replaced with newValue . This new list is stored in the variable varName , and is also the return value from the lset command. If index is negative or greater than the number of elements in \\$varName , then an error occurs. If index is equal to the number of elements in \\$varName , then the given element is appended to the list. The interpretation of each simple index value is the same as for the command string index , supporting simple index arithmetic and indices relative to the end of the list. If additional index arguments are supplied, then each argument is used in turn to address an element within a sublist designated by the previous indexing operation, allowing the script to alter elements in sublists (or append elements to sublists). The command, lset a 1 2 newValue or lset a {1 2} newValue replaces element 2 of sublist 1 with newValue . The integer appearing in each index argument must be greater than or equal to zero. The integer appearing in each index argument must be less than or equal to the length of the corresponding list. In other words, the lset command can change the size of a list only by appending an element (setting the one after the current end). If an index is outside the permitted range, an error is reported. EXAMPLES In each of these examples, the initial value of x is: set x [list [list a b c] [list d e f] [list g h i]] \u2192 {a b c} {d e f} {g h i} The indicated return value also becomes the new value of x (except in the last case, which is an error which leaves the value of x unchanged.) lset x {j k l} \u2192 j k l lset x {} {j k l} \u2192 j k l lset x 0 j \u2192 j {d e f} {g h i} lset x 2 j \u2192 {a b c} {d e f} j lset x end j \u2192 {a b c} {d e f} j lset x end-1 j \u2192 {a b c} j {g h i} lset x 2 1 j \u2192 {a b c} {d e f} {g j i} lset x {2 1} j \u2192 {a b c} {d e f} {g j i} lset x {2 3} j \u2192 {a b c} {d e f} {g h i j} lset x {2 4} j \u2192 list index out of range In the following examples, the initial value of x is: set x [list [list [list a b] [list c d]] \\ [list [list e f] [list g h]]] \u2192 {{a b} {c d}} {{e f} {g h}} The indicated return value also becomes the new value of x . lset x 1 1 0 j \u2192 {{a b} {c d}} {{e f} {j h}} lset x {1 1 0} j \u2192 {{a b} {c d}} {{e f} {j h}} SEE ALSO list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lsort(n) string(n) KEYWORDS element, index, list, replace, set","title":"NAME"},{"location":"lset/#name","text":"lset - Change an element in a list","title":"NAME"},{"location":"lset/#synopsis","text":"lset varName ?index ...? newValue","title":"SYNOPSIS"},{"location":"lset/#description","text":"The lset command accepts a parameter, varName , which it interprets as the name of a variable containing a Tcl list. It also accepts zero or more indices into the list. The indices may be presented either consecutively on the command line, or grouped in a Tcl list and presented as a single argument. Finally, it accepts a new value for an element of varName . If no indices are presented, the command takes the form: lset varName newValue or lset varName {} newValue In this case, newValue replaces the old value of the variable varName . When presented with a single index, the lset command treats the content of the varName variable as a Tcl list. It addresses the index \\'th element in it (0 refers to the first element of the list). When interpreting the list, lset observes the same rules concerning braces and quotes and backslashes as the Tcl command interpreter; however, variable substitution and command substitution do not occur. The command constructs a new list in which the designated element is replaced with newValue . This new list is stored in the variable varName , and is also the return value from the lset command. If index is negative or greater than the number of elements in \\$varName , then an error occurs. If index is equal to the number of elements in \\$varName , then the given element is appended to the list. The interpretation of each simple index value is the same as for the command string index , supporting simple index arithmetic and indices relative to the end of the list. If additional index arguments are supplied, then each argument is used in turn to address an element within a sublist designated by the previous indexing operation, allowing the script to alter elements in sublists (or append elements to sublists). The command, lset a 1 2 newValue or lset a {1 2} newValue replaces element 2 of sublist 1 with newValue . The integer appearing in each index argument must be greater than or equal to zero. The integer appearing in each index argument must be less than or equal to the length of the corresponding list. In other words, the lset command can change the size of a list only by appending an element (setting the one after the current end). If an index is outside the permitted range, an error is reported.","title":"DESCRIPTION"},{"location":"lset/#examples","text":"In each of these examples, the initial value of x is: set x [list [list a b c] [list d e f] [list g h i]] \u2192 {a b c} {d e f} {g h i} The indicated return value also becomes the new value of x (except in the last case, which is an error which leaves the value of x unchanged.) lset x {j k l} \u2192 j k l lset x {} {j k l} \u2192 j k l lset x 0 j \u2192 j {d e f} {g h i} lset x 2 j \u2192 {a b c} {d e f} j lset x end j \u2192 {a b c} {d e f} j lset x end-1 j \u2192 {a b c} j {g h i} lset x 2 1 j \u2192 {a b c} {d e f} {g j i} lset x {2 1} j \u2192 {a b c} {d e f} {g j i} lset x {2 3} j \u2192 {a b c} {d e f} {g h i j} lset x {2 4} j \u2192 list index out of range In the following examples, the initial value of x is: set x [list [list [list a b] [list c d]] \\ [list [list e f] [list g h]]] \u2192 {{a b} {c d}} {{e f} {g h}} The indicated return value also becomes the new value of x . lset x 1 1 0 j \u2192 {{a b} {c d}} {{e f} {j h}} lset x {1 1 0} j \u2192 {{a b} {c d}} {{e f} {j h}}","title":"EXAMPLES"},{"location":"lset/#see-also","text":"list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lsort(n) string(n)","title":"SEE ALSO"},{"location":"lset/#keywords","text":"element, index, list, replace, set","title":"KEYWORDS"},{"location":"lsort/","text":"NAME lsort - Sort the elements of a list SYNOPSIS lsort ? options ? list DESCRIPTION This command sorts the elements of list , returning a new list in sorted order. The implementation of the lsort command uses the merge-sort algorithm which is a stable sort that has O(n log n) performance characteristics. By default ASCII sorting is used with the result returned in increasing order. However, any of the following options may be specified before list to control the sorting process (unique abbreviations are accepted): -ascii : Use string comparison with Unicode code-point collation order (the name is for backward-compatibility reasons.) This is the default. -dictionary : Use dictionary-style comparison. This is the same as -ascii except (a) case is ignored except as a tie-breaker and (b) if two strings contain embedded numbers, the numbers compare as integers, not characters. For example, in -dictionary mode, bigBoy sorts between bigbang and bigboy , and x10y sorts between x9y and x11y . Overrides the -nocase option. -integer : Convert list elements to integers and use integer comparison. -real : Convert list elements to floating-point values and use floating comparison. -command\u2007 command : Use command as a comparison command. To compare two elements, evaluate a Tcl script consisting of command with the two elements appended as additional arguments. The script should return an integer less than, equal to, or greater than zero if the first element is to be considered less than, equal to, or greater than the second, respectively. -increasing : Sort the list in increasing order This is the default. -decreasing : Sort the list in decreasing order <!-- --> -indices : Return a list of indices into list in sorted order instead of the values themselves. -index\u2007 indexList : If this option is specified, each of the elements of list must itself be a proper Tcl sublist (unless -stride is used). Instead of sorting based on whole sublists, lsort will extract the indexList \\'th element from each sublist (as if the overall element and the indexList were passed to lindex ) and sort based on the given element. For example, **lsort** -integer -index 1 \\\\ {{First 24} {Second 18} {Third 30}} returns **{Second 18} {First 24} {Third 30}**, **lsort** -index end-1 \\\\ {{a 1 e i} {b 2 3 f g} {c 4 5 6 d h}} returns **{c 4 5 6 d h} {a 1 e i} {b 2 3 f g}**, and **lsort** -index {0 1} { {{b i g} 12345} {{d e m o} 34512} {{c o d e} 54321} } returns **{{d e m o} 34512} {{b i g} 12345} {{c o d e} 54321}** (because **e** sorts before **i** which sorts before **o**.) This option is much more efficient than using **-command** to achieve the same effect. -stride\u2007 strideLength : If this option is specified, the list is treated as consisting of groups of strideLength elements and the groups are sorted by either their first element or, if the -index option is used, by the element within each group given by the first index passed to -index (which is then ignored by -index ). Elements always remain in the same position within their group. The list length must be an integer multiple of *strideLength*, which in turn must be at least 2. For example, **lsort** -stride 2 {carrot 10 apple 50 banana 25} returns and **lsort** -stride 2 -index 1 -integer {carrot 10 apple 50 banana 25} returns -nocase : Causes comparisons to be handled in a case-insensitive manner. Has no effect if combined with the -dictionary , -integer , or -real options. -unique : If this option is specified, then only the last set of duplicate elements found in the list will be retained. Note that duplicates are determined relative to the comparison used in the sort. Thus if -index 0 is used, {1 a} and {1 b} would be considered duplicates and only the second element, {1 b} , would be retained. NOTES The options to lsort only control what sort of comparison is used, and do not necessarily constrain what the values themselves actually are. This distinction is only noticeable when the list to be sorted has fewer than two elements. The lsort command is reentrant, meaning it is safe to use as part of the implementation of a command used in the -command option. EXAMPLES Sorting a list using ASCII sorting: % lsort {a10 B2 b1 a1 a2} B2 a1 a10 a2 b1 Sorting a list using Dictionary sorting: % lsort -dictionary {a10 B2 b1 a1 a2} a1 a2 a10 b1 B2 Sorting lists of integers: % lsort -integer {5 3 1 2 11 4} 1 2 3 4 5 11 % lsort -integer {1 2 0x5 7 0 4 -1} -1 0 1 2 4 0x5 7 Sorting lists of floating-point numbers: % lsort -real {5 3 1 2 11 4} 1 2 3 4 5 11 % lsort -real {.5 0.07e1 0.4 6e-1} 0.4 .5 6e-1 0.07e1 Sorting using indices: % # Note the space character before the c % lsort {{a 5} { c 3} {b 4} {e 1} {d 2}} { c 3} {a 5} {b 4} {d 2} {e 1} % lsort -index 0 {{a 5} { c 3} {b 4} {e 1} {d 2}} {a 5} {b 4} { c 3} {d 2} {e 1} % lsort -index 1 {{a 5} { c 3} {b 4} {e 1} {d 2}} {e 1} {d 2} { c 3} {b 4} {a 5} Sorting a dictionary: % set d [dict create c d a b h i f g c e] c e a b h i f g % lsort -stride 2 \\$d a b c e f g h i Sorting using striding and multiple indices: % # Note the first index value is relative to the group % lsort -stride 3 -index {0 1} \\ {{Bob Smith} 25 Audi {Jane Doe} 40 Ford} {{Jane Doe} 40 Ford {Bob Smith} 25 Audi} Stripping duplicate values using sorting: % lsort -unique {a b c a b c a b c} a b c More complex sorting using a comparison function: % proc compare {a b} { set a0 [lindex \\$a 0] set b0 [lindex \\$b 0] if {\\$a0 \\< \\$b0} { return -1 } elseif {\\$a0 > \\$b0} { return 1 } return [string compare [lindex \\$a 1] [lindex \\$b 1]] } % lsort -command compare \\ {{3 apple} {0x2 carrot} {1 dingo} {2 banana}} {1 dingo} {2 banana} {0x2 carrot} {3 apple} SEE ALSO list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n) KEYWORDS element, list, order, sort","title":"NAME"},{"location":"lsort/#name","text":"lsort - Sort the elements of a list","title":"NAME"},{"location":"lsort/#synopsis","text":"lsort ? options ? list","title":"SYNOPSIS"},{"location":"lsort/#description","text":"This command sorts the elements of list , returning a new list in sorted order. The implementation of the lsort command uses the merge-sort algorithm which is a stable sort that has O(n log n) performance characteristics. By default ASCII sorting is used with the result returned in increasing order. However, any of the following options may be specified before list to control the sorting process (unique abbreviations are accepted): -ascii : Use string comparison with Unicode code-point collation order (the name is for backward-compatibility reasons.) This is the default. -dictionary : Use dictionary-style comparison. This is the same as -ascii except (a) case is ignored except as a tie-breaker and (b) if two strings contain embedded numbers, the numbers compare as integers, not characters. For example, in -dictionary mode, bigBoy sorts between bigbang and bigboy , and x10y sorts between x9y and x11y . Overrides the -nocase option. -integer : Convert list elements to integers and use integer comparison. -real : Convert list elements to floating-point values and use floating comparison. -command\u2007 command : Use command as a comparison command. To compare two elements, evaluate a Tcl script consisting of command with the two elements appended as additional arguments. The script should return an integer less than, equal to, or greater than zero if the first element is to be considered less than, equal to, or greater than the second, respectively. -increasing : Sort the list in increasing order This is the default. -decreasing : Sort the list in decreasing order <!-- --> -indices : Return a list of indices into list in sorted order instead of the values themselves. -index\u2007 indexList : If this option is specified, each of the elements of list must itself be a proper Tcl sublist (unless -stride is used). Instead of sorting based on whole sublists, lsort will extract the indexList \\'th element from each sublist (as if the overall element and the indexList were passed to lindex ) and sort based on the given element. For example, **lsort** -integer -index 1 \\\\ {{First 24} {Second 18} {Third 30}} returns **{Second 18} {First 24} {Third 30}**, **lsort** -index end-1 \\\\ {{a 1 e i} {b 2 3 f g} {c 4 5 6 d h}} returns **{c 4 5 6 d h} {a 1 e i} {b 2 3 f g}**, and **lsort** -index {0 1} { {{b i g} 12345} {{d e m o} 34512} {{c o d e} 54321} } returns **{{d e m o} 34512} {{b i g} 12345} {{c o d e} 54321}** (because **e** sorts before **i** which sorts before **o**.) This option is much more efficient than using **-command** to achieve the same effect. -stride\u2007 strideLength : If this option is specified, the list is treated as consisting of groups of strideLength elements and the groups are sorted by either their first element or, if the -index option is used, by the element within each group given by the first index passed to -index (which is then ignored by -index ). Elements always remain in the same position within their group. The list length must be an integer multiple of *strideLength*, which in turn must be at least 2. For example, **lsort** -stride 2 {carrot 10 apple 50 banana 25} returns and **lsort** -stride 2 -index 1 -integer {carrot 10 apple 50 banana 25} returns -nocase : Causes comparisons to be handled in a case-insensitive manner. Has no effect if combined with the -dictionary , -integer , or -real options. -unique : If this option is specified, then only the last set of duplicate elements found in the list will be retained. Note that duplicates are determined relative to the comparison used in the sort. Thus if -index 0 is used, {1 a} and {1 b} would be considered duplicates and only the second element, {1 b} , would be retained.","title":"DESCRIPTION"},{"location":"lsort/#notes","text":"The options to lsort only control what sort of comparison is used, and do not necessarily constrain what the values themselves actually are. This distinction is only noticeable when the list to be sorted has fewer than two elements. The lsort command is reentrant, meaning it is safe to use as part of the implementation of a command used in the -command option.","title":"NOTES"},{"location":"lsort/#examples","text":"Sorting a list using ASCII sorting: % lsort {a10 B2 b1 a1 a2} B2 a1 a10 a2 b1 Sorting a list using Dictionary sorting: % lsort -dictionary {a10 B2 b1 a1 a2} a1 a2 a10 b1 B2 Sorting lists of integers: % lsort -integer {5 3 1 2 11 4} 1 2 3 4 5 11 % lsort -integer {1 2 0x5 7 0 4 -1} -1 0 1 2 4 0x5 7 Sorting lists of floating-point numbers: % lsort -real {5 3 1 2 11 4} 1 2 3 4 5 11 % lsort -real {.5 0.07e1 0.4 6e-1} 0.4 .5 6e-1 0.07e1 Sorting using indices: % # Note the space character before the c % lsort {{a 5} { c 3} {b 4} {e 1} {d 2}} { c 3} {a 5} {b 4} {d 2} {e 1} % lsort -index 0 {{a 5} { c 3} {b 4} {e 1} {d 2}} {a 5} {b 4} { c 3} {d 2} {e 1} % lsort -index 1 {{a 5} { c 3} {b 4} {e 1} {d 2}} {e 1} {d 2} { c 3} {b 4} {a 5} Sorting a dictionary: % set d [dict create c d a b h i f g c e] c e a b h i f g % lsort -stride 2 \\$d a b c e f g h i Sorting using striding and multiple indices: % # Note the first index value is relative to the group % lsort -stride 3 -index {0 1} \\ {{Bob Smith} 25 Audi {Jane Doe} 40 Ford} {{Jane Doe} 40 Ford {Bob Smith} 25 Audi} Stripping duplicate values using sorting: % lsort -unique {a b c a b c a b c} a b c More complex sorting using a comparison function: % proc compare {a b} { set a0 [lindex \\$a 0] set b0 [lindex \\$b 0] if {\\$a0 \\< \\$b0} { return -1 } elseif {\\$a0 > \\$b0} { return 1 } return [string compare [lindex \\$a 1] [lindex \\$b 1]] } % lsort -command compare \\ {{3 apple} {0x2 carrot} {1 dingo} {2 banana}} {1 dingo} {2 banana} {0x2 carrot} {3 apple}","title":"EXAMPLES"},{"location":"lsort/#see-also","text":"list(n), lappend(n), lassign(n), ledit(n), lindex(n), linsert(n), llength(n), lmap(n), lpop(n), lrange(n), lremove(n), lrepeat(n), lreplace(n), lreverse(n), lsearch(n), lseq(n), lset(n)","title":"SEE ALSO"},{"location":"lsort/#keywords","text":"element, list, order, sort","title":"KEYWORDS"},{"location":"man/","text":"","title":"Man"},{"location":"markdown/","text":"NAME source - Evaluate a file or resource as a Tcl script SYNOPSIS source fileName source -encoding encodingName fileName DESCRIPTION This command takes the contents of the specified file or resource and passes it to the Tcl interpreter as a text script. The return value from source is the return value of the last command executed in the script. If an error occurs in evaluating the contents of the script then the source command will return that error. If a return command is invoked from within the script then the remainder of the file will be skipped and the source command will return normally with the result from the return command. The end-of-file character for files is (\\^Z) for all platforms. The source command will read files up to this character. This restriction does not exist for the read or gets commands, allowing for files containing code and data segments (scripted documents). If you require a in code for string comparison, you can use which will be safely substituted by the Tcl interpreter into A leading BOM (Byte order mark) contained in the file is ignored for unicode encodings (utf-8, utf-16, ucs-2). The -encoding option is used to specify the encoding of the data stored in fileName . When the -encoding option is omitted, the utf-8 encoding is assumed. EXAMPLE Run the script in the file foo.tcl and then the script in the file bar.tcl : source foo.tcl source bar.tcl Alternatively: foreach scriptFile {foo.tcl bar.tcl} { source \\$scriptFile } SEE ALSO file(n), cd(n), encoding(n), info(n) KEYWORDS file, script","title":"NAME"},{"location":"markdown/#name","text":"source - Evaluate a file or resource as a Tcl script","title":"NAME"},{"location":"markdown/#synopsis","text":"source fileName source -encoding encodingName fileName","title":"SYNOPSIS"},{"location":"markdown/#description","text":"This command takes the contents of the specified file or resource and passes it to the Tcl interpreter as a text script. The return value from source is the return value of the last command executed in the script. If an error occurs in evaluating the contents of the script then the source command will return that error. If a return command is invoked from within the script then the remainder of the file will be skipped and the source command will return normally with the result from the return command. The end-of-file character for files is (\\^Z) for all platforms. The source command will read files up to this character. This restriction does not exist for the read or gets commands, allowing for files containing code and data segments (scripted documents). If you require a in code for string comparison, you can use which will be safely substituted by the Tcl interpreter into A leading BOM (Byte order mark) contained in the file is ignored for unicode encodings (utf-8, utf-16, ucs-2). The -encoding option is used to specify the encoding of the data stored in fileName . When the -encoding option is omitted, the utf-8 encoding is assumed.","title":"DESCRIPTION"},{"location":"markdown/#example","text":"Run the script in the file foo.tcl and then the script in the file bar.tcl : source foo.tcl source bar.tcl Alternatively: foreach scriptFile {foo.tcl bar.tcl} { source \\$scriptFile }","title":"EXAMPLE"},{"location":"markdown/#see-also","text":"file(n), cd(n), encoding(n), info(n)","title":"SEE ALSO"},{"location":"markdown/#keywords","text":"file, script","title":"KEYWORDS"},{"location":"mathfunc/","text":"NAME mathfunc - Mathematical functions for Tcl expressions SYNOPSIS package require Tcl 8.5- ::tcl::mathfunc::abs arg \\ ::tcl::mathfunc::acos arg \\ ::tcl::mathfunc::asin arg \\ ::tcl::mathfunc::atan arg \\ ::tcl::mathfunc::atan2 y x \\ ::tcl::mathfunc::bool arg \\ ::tcl::mathfunc::ceil arg \\ ::tcl::mathfunc::cos arg \\ ::tcl::mathfunc::cosh arg \\ ::tcl::mathfunc::double arg \\ ::tcl::mathfunc::entier arg \\ ::tcl::mathfunc::exp arg \\ ::tcl::mathfunc::floor arg \\ ::tcl::mathfunc::fmod x y \\ ::tcl::mathfunc::hypot x y \\ ::tcl::mathfunc::int arg \\ ::tcl::mathfunc::isfinite arg \\ ::tcl::mathfunc::isinf arg \\ ::tcl::mathfunc::isnan arg \\ ::tcl::mathfunc::isnormal arg \\ ::tcl::mathfunc::isqrt arg \\ ::tcl::mathfunc::issubnormal arg \\ ::tcl::mathfunc::isunordered x y \\ ::tcl::mathfunc::log arg \\ ::tcl::mathfunc::log10 arg \\ ::tcl::mathfunc::max arg ? arg ...?\\ ::tcl::mathfunc::min arg ? arg ...?\\ ::tcl::mathfunc::pow x y \\ ::tcl::mathfunc::rand \\ ::tcl::mathfunc::round arg \\ ::tcl::mathfunc::sin arg \\ ::tcl::mathfunc::sinh arg \\ ::tcl::mathfunc::sqrt arg \\ ::tcl::mathfunc::srand arg \\ ::tcl::mathfunc::tan arg \\ ::tcl::mathfunc::tanh arg \\ ::tcl::mathfunc::wide arg DESCRIPTION The expr command handles mathematical functions of the form sin(\\$x) or atan2(\\$y,\\$x) by converting them to calls of the form [tcl::mathfunc::sin [expr {\\$x}]] or [tcl::mathfunc::atan2 [expr {\\$y}] [expr {\\$x}]] . A number of math functions are available by default within the namespace ::tcl::mathfunc ; these functions are also available for code apart from expr , by invoking the given commands directly. Tcl supports the following mathematical functions in expressions, all of which work solely with floating-point numbers unless otherwise noted: abs acos asin atan atan2 bool ceil cos cosh double entier exp floor fmod hypot int isfinite isinf isnan isnormal isqrt issubnormal isunordered log log10 max min pow rand round sin sinh sqrt srand tan tanh wide In addition to these predefined functions, applications may define additional functions by using proc (or any other method, such as interp alias or Tcl_CreateObjCommand ) to define new commands in the tcl::mathfunc namespace. DETAILED DEFINITIONS abs arg : Returns the absolute value of arg . Arg may be either integer or floating-point, and the result is returned in the same form. acos arg : Returns the arc cosine of arg , in the range [ 0 , pi ] radians. Arg should be in the range [ -1 , 1 ]. asin arg : Returns the arc sine of arg , in the range [ -pi/2 , pi/2 ] radians. Arg should be in the range [ -1 , 1 ]. atan arg : Returns the arc tangent of arg , in the range [ -pi/2 , pi/2 ] radians. atan2 y x : Returns the arc tangent of y / x , in the range [ -pi , pi ] radians. x and y cannot both be 0. If x is greater than 0 , this is equivalent to <!-- --> bool arg : Accepts any numeric value, or any string acceptable to string is boolean , and returns the corresponding boolean value 0 or 1 . Non-zero numbers are true. Other numbers are false. Non-numeric strings produce boolean value in agreement with string is true and string is false . ceil arg : Returns the smallest integral floating-point value (i.e. with a zero fractional part) not less than arg . The argument may be any numeric value. cos arg : Returns the cosine of arg , measured in radians. cosh arg : Returns the hyperbolic cosine of arg . If the result would cause an overflow, an error is returned. double arg : The argument may be any numeric value, If arg is a floating-point value, returns arg , otherwise converts arg to floating-point and returns the converted value. May return Inf or -Inf when the argument is a numeric value that exceeds the floating-point range. entier arg : The argument may be any numeric value. The integer part of arg is determined and returned. The integer range returned by this function is unlimited, unlike int and wide which truncate their range to fit in particular storage widths. exp arg : Returns the exponential of arg , defined as e ** arg . If the result would cause an overflow, an error is returned. floor arg : Returns the largest integral floating-point value (i.e. with a zero fractional part) not greater than arg . The argument may be any numeric value. fmod x y : Returns the floating-point remainder of the division of x by y . If y is 0, an error is returned. hypot x y : Computes the length of the hypotenuse of a right-angled triangle, approximately except for being more numerically stable when the two arguments have substantially different magnitudes. int arg : The argument may be any numeric value. The integer part of arg is determined, and then the low order bits of that integer value up to the machine word size are returned as an integer value. For reference, the number of bytes in the machine word are stored in the wordSize element of the tcl_platform array. isfinite arg : Returns 1 if the floating-point number arg is finite. That is, if it is zero, subnormal, or normal. Returns 0 if the number is infinite or NaN. Throws an error if arg cannot be promoted to a floating-point value. isinf arg : Returns 1 if the floating-point number arg is infinite. Returns 0 if the number is finite or NaN. Throws an error if arg cannot be promoted to a floating-point value. isnan arg : Returns 1 if the floating-point number arg is Not-a-Number. Returns 0 if the number is finite or infinite. Throws an error if arg cannot be promoted to a floating-point value. isnormal arg : Returns 1 if the floating-point number arg is normal. Returns 0 if the number is zero, subnormal, infinite or NaN. Throws an error if arg cannot be promoted to a floating-point value. isqrt arg : Computes the integer part of the square root of arg . Arg must be a positive value, either an integer or a floating point number. Unlike sqrt , which is limited to the precision of a floating point number, isqrt will return a result of arbitrary precision. issubnormal arg : Returns 1 if the floating-point number arg is subnormal, i.e., the result of gradual underflow. Returns 0 if the number is zero, normal, infinite or NaN. Throws an error if arg cannot be promoted to a floating-point value. isunordered x y : Returns 1 if x and y cannot be compared for ordering, that is, if either one is NaN. Returns 0 if both values can be ordered, that is, if they are both chosen from among the set of zero, subnormal, normal and infinite values. Throws an error if either x or y cannot be promoted to a floating-point value. log arg : Returns the natural logarithm of arg . Arg must be a positive value. log10 arg : Returns the base 10 logarithm of arg . Arg must be a positive value. max arg ... : Accepts one or more numeric arguments. Returns the one argument with the greatest value. min arg ... : Accepts one or more numeric arguments. Returns the one argument with the least value. pow x y : Computes the value of x raised to the power y . If x is negative, y must be an integer value. rand : Returns a pseudo-random floating-point value in the range ( 0 , 1 ). The generator algorithm is a simple linear congruential generator that is not cryptographically secure. Each result from rand completely determines all future results from subsequent calls to rand , so rand should not be used to generate a sequence of secrets, such as one-time passwords. The seed of the generator is initialized from the internal clock of the machine or may be set with the srand function. round arg : If arg is an integer value, returns arg , otherwise converts arg to integer by rounding and returns the converted value. sin arg : Returns the sine of arg , measured in radians. sinh arg : Returns the hyperbolic sine of arg . If the result would cause an overflow, an error is returned. sqrt arg : The argument may be any non-negative numeric value. Returns a floating-point value that is the square root of arg . May return Inf when the argument is a numeric value that exceeds the square of the maximum value of the floating-point range. srand arg : The arg , which must be an integer, is used to reset the seed for the random number generator of rand . Returns the first random number (see rand ) from that seed. Each interpreter has its own seed. tan arg : Returns the tangent of arg , measured in radians. tanh arg : Returns the hyperbolic tangent of arg . wide arg : The argument may be any numeric value. The integer part of arg is determined, and then the low order 64 bits of that integer value are returned as an integer value. SEE ALSO expr(n), fpclassify(n), mathop(n), namespace(n) COPYRIGHT Copyright \u00a9 1993 The Regents of the University of California. Copyright \u00a9 1994-2000 Sun Microsystems Incorporated. Copyright \u00a9 2005-2006 Kevin B. Kenny <kennykb@acm.org>.","title":"NAME"},{"location":"mathfunc/#name","text":"mathfunc - Mathematical functions for Tcl expressions","title":"NAME"},{"location":"mathfunc/#synopsis","text":"package require Tcl 8.5- ::tcl::mathfunc::abs arg \\ ::tcl::mathfunc::acos arg \\ ::tcl::mathfunc::asin arg \\ ::tcl::mathfunc::atan arg \\ ::tcl::mathfunc::atan2 y x \\ ::tcl::mathfunc::bool arg \\ ::tcl::mathfunc::ceil arg \\ ::tcl::mathfunc::cos arg \\ ::tcl::mathfunc::cosh arg \\ ::tcl::mathfunc::double arg \\ ::tcl::mathfunc::entier arg \\ ::tcl::mathfunc::exp arg \\ ::tcl::mathfunc::floor arg \\ ::tcl::mathfunc::fmod x y \\ ::tcl::mathfunc::hypot x y \\ ::tcl::mathfunc::int arg \\ ::tcl::mathfunc::isfinite arg \\ ::tcl::mathfunc::isinf arg \\ ::tcl::mathfunc::isnan arg \\ ::tcl::mathfunc::isnormal arg \\ ::tcl::mathfunc::isqrt arg \\ ::tcl::mathfunc::issubnormal arg \\ ::tcl::mathfunc::isunordered x y \\ ::tcl::mathfunc::log arg \\ ::tcl::mathfunc::log10 arg \\ ::tcl::mathfunc::max arg ? arg ...?\\ ::tcl::mathfunc::min arg ? arg ...?\\ ::tcl::mathfunc::pow x y \\ ::tcl::mathfunc::rand \\ ::tcl::mathfunc::round arg \\ ::tcl::mathfunc::sin arg \\ ::tcl::mathfunc::sinh arg \\ ::tcl::mathfunc::sqrt arg \\ ::tcl::mathfunc::srand arg \\ ::tcl::mathfunc::tan arg \\ ::tcl::mathfunc::tanh arg \\ ::tcl::mathfunc::wide arg","title":"SYNOPSIS"},{"location":"mathfunc/#description","text":"The expr command handles mathematical functions of the form sin(\\$x) or atan2(\\$y,\\$x) by converting them to calls of the form [tcl::mathfunc::sin [expr {\\$x}]] or [tcl::mathfunc::atan2 [expr {\\$y}] [expr {\\$x}]] . A number of math functions are available by default within the namespace ::tcl::mathfunc ; these functions are also available for code apart from expr , by invoking the given commands directly. Tcl supports the following mathematical functions in expressions, all of which work solely with floating-point numbers unless otherwise noted: abs acos asin atan atan2 bool ceil cos cosh double entier exp floor fmod hypot int isfinite isinf isnan isnormal isqrt issubnormal isunordered log log10 max min pow rand round sin sinh sqrt srand tan tanh wide In addition to these predefined functions, applications may define additional functions by using proc (or any other method, such as interp alias or Tcl_CreateObjCommand ) to define new commands in the tcl::mathfunc namespace.","title":"DESCRIPTION"},{"location":"mathfunc/#detailed-definitions","text":"abs arg : Returns the absolute value of arg . Arg may be either integer or floating-point, and the result is returned in the same form. acos arg : Returns the arc cosine of arg , in the range [ 0 , pi ] radians. Arg should be in the range [ -1 , 1 ]. asin arg : Returns the arc sine of arg , in the range [ -pi/2 , pi/2 ] radians. Arg should be in the range [ -1 , 1 ]. atan arg : Returns the arc tangent of arg , in the range [ -pi/2 , pi/2 ] radians. atan2 y x : Returns the arc tangent of y / x , in the range [ -pi , pi ] radians. x and y cannot both be 0. If x is greater than 0 , this is equivalent to <!-- --> bool arg : Accepts any numeric value, or any string acceptable to string is boolean , and returns the corresponding boolean value 0 or 1 . Non-zero numbers are true. Other numbers are false. Non-numeric strings produce boolean value in agreement with string is true and string is false . ceil arg : Returns the smallest integral floating-point value (i.e. with a zero fractional part) not less than arg . The argument may be any numeric value. cos arg : Returns the cosine of arg , measured in radians. cosh arg : Returns the hyperbolic cosine of arg . If the result would cause an overflow, an error is returned. double arg : The argument may be any numeric value, If arg is a floating-point value, returns arg , otherwise converts arg to floating-point and returns the converted value. May return Inf or -Inf when the argument is a numeric value that exceeds the floating-point range. entier arg : The argument may be any numeric value. The integer part of arg is determined and returned. The integer range returned by this function is unlimited, unlike int and wide which truncate their range to fit in particular storage widths. exp arg : Returns the exponential of arg , defined as e ** arg . If the result would cause an overflow, an error is returned. floor arg : Returns the largest integral floating-point value (i.e. with a zero fractional part) not greater than arg . The argument may be any numeric value. fmod x y : Returns the floating-point remainder of the division of x by y . If y is 0, an error is returned. hypot x y : Computes the length of the hypotenuse of a right-angled triangle, approximately except for being more numerically stable when the two arguments have substantially different magnitudes. int arg : The argument may be any numeric value. The integer part of arg is determined, and then the low order bits of that integer value up to the machine word size are returned as an integer value. For reference, the number of bytes in the machine word are stored in the wordSize element of the tcl_platform array. isfinite arg : Returns 1 if the floating-point number arg is finite. That is, if it is zero, subnormal, or normal. Returns 0 if the number is infinite or NaN. Throws an error if arg cannot be promoted to a floating-point value. isinf arg : Returns 1 if the floating-point number arg is infinite. Returns 0 if the number is finite or NaN. Throws an error if arg cannot be promoted to a floating-point value. isnan arg : Returns 1 if the floating-point number arg is Not-a-Number. Returns 0 if the number is finite or infinite. Throws an error if arg cannot be promoted to a floating-point value. isnormal arg : Returns 1 if the floating-point number arg is normal. Returns 0 if the number is zero, subnormal, infinite or NaN. Throws an error if arg cannot be promoted to a floating-point value. isqrt arg : Computes the integer part of the square root of arg . Arg must be a positive value, either an integer or a floating point number. Unlike sqrt , which is limited to the precision of a floating point number, isqrt will return a result of arbitrary precision. issubnormal arg : Returns 1 if the floating-point number arg is subnormal, i.e., the result of gradual underflow. Returns 0 if the number is zero, normal, infinite or NaN. Throws an error if arg cannot be promoted to a floating-point value. isunordered x y : Returns 1 if x and y cannot be compared for ordering, that is, if either one is NaN. Returns 0 if both values can be ordered, that is, if they are both chosen from among the set of zero, subnormal, normal and infinite values. Throws an error if either x or y cannot be promoted to a floating-point value. log arg : Returns the natural logarithm of arg . Arg must be a positive value. log10 arg : Returns the base 10 logarithm of arg . Arg must be a positive value. max arg ... : Accepts one or more numeric arguments. Returns the one argument with the greatest value. min arg ... : Accepts one or more numeric arguments. Returns the one argument with the least value. pow x y : Computes the value of x raised to the power y . If x is negative, y must be an integer value. rand : Returns a pseudo-random floating-point value in the range ( 0 , 1 ). The generator algorithm is a simple linear congruential generator that is not cryptographically secure. Each result from rand completely determines all future results from subsequent calls to rand , so rand should not be used to generate a sequence of secrets, such as one-time passwords. The seed of the generator is initialized from the internal clock of the machine or may be set with the srand function. round arg : If arg is an integer value, returns arg , otherwise converts arg to integer by rounding and returns the converted value. sin arg : Returns the sine of arg , measured in radians. sinh arg : Returns the hyperbolic sine of arg . If the result would cause an overflow, an error is returned. sqrt arg : The argument may be any non-negative numeric value. Returns a floating-point value that is the square root of arg . May return Inf when the argument is a numeric value that exceeds the square of the maximum value of the floating-point range. srand arg : The arg , which must be an integer, is used to reset the seed for the random number generator of rand . Returns the first random number (see rand ) from that seed. Each interpreter has its own seed. tan arg : Returns the tangent of arg , measured in radians. tanh arg : Returns the hyperbolic tangent of arg . wide arg : The argument may be any numeric value. The integer part of arg is determined, and then the low order 64 bits of that integer value are returned as an integer value.","title":"DETAILED DEFINITIONS"},{"location":"mathfunc/#see-also","text":"expr(n), fpclassify(n), mathop(n), namespace(n)","title":"SEE ALSO"},{"location":"mathfunc/#copyright","text":"Copyright \u00a9 1993 The Regents of the University of California. Copyright \u00a9 1994-2000 Sun Microsystems Incorporated. Copyright \u00a9 2005-2006 Kevin B. Kenny <kennykb@acm.org>.","title":"COPYRIGHT"},{"location":"mathop/","text":"NAME mathop - Mathematical operators as Tcl commands SYNOPSIS package require Tcl 8.5- ::tcl::mathop::! number \\ ::tcl::mathop::\\~ number \\ ::tcl::mathop::+ ? number ...?\\ ::tcl::mathop::- number ? number ...?\\ ::tcl::mathop::* ? number ...?\\ ::tcl::mathop::/ number ? number ...?\\ ::tcl::mathop::% number number \\ ::tcl::mathop::** ? number ...?\\ ::tcl::mathop::& ? number ...?\\ ::tcl::mathop::| ? number ...?\\ ::tcl::mathop::\\^ ? number ...?\\ ::tcl::mathop::\\<\\< number number \\ ::tcl::mathop::>> number number \\ ::tcl::mathop::== ? arg ...?\\ ::tcl::mathop::!= arg arg \\ ::tcl::mathop::\\< ? arg ...?\\ ::tcl::mathop::\\<= ? arg ...?\\ ::tcl::mathop::>= ? arg ...?\\ ::tcl::mathop::> ? arg ...?\\ ::tcl::mathop::eq ? arg ...?\\ ::tcl::mathop::ne arg arg \\ ::tcl::mathop::lt ? arg ...?\\ ::tcl::mathop::le ? arg ...?\\ ::tcl::mathop::gt ? arg ...?\\ ::tcl::mathop::ge ? arg ...? \\ ::tcl::mathop::in arg list \\ ::tcl::mathop::ni arg list DESCRIPTION The commands in the ::tcl::mathop namespace implement the same set of operations as supported by the expr command. All are exported from the namespace, but are not imported into any other namespace by default. Note that renaming, reimplementing or deleting any of the commands in the namespace does not alter the way that the expr command behaves, and nor does defining any new commands in the ::tcl::mathop namespace. The following operator commands are supported: \\~ ! + - * / % ** & | \\^ >> \\<\\< == eq != ne \\< \\<= > >= in ni lt le gt ge MATHEMATICAL OPERATORS The behaviors of the mathematical operator commands are as follows: ! boolean : Returns the boolean negation of boolean , where boolean may be any numeric value or any other form of boolean value (i.e. it returns truth if the argument is falsity or zero, and falsity if the argument is truth or non-zero). + ? number ...? : Returns the sum of arbitrarily many arguments. Each number argument may be any numeric value. If no arguments are given, the result will be zero (the summation identity). - number ? number ...? : If only a single number argument is given, returns the negation of that numeric value. Otherwise returns the number that results when all subsequent numeric values are subtracted from the first one. All number arguments must be numeric values. At least one argument must be given. * ? number ...? : Returns the product of arbitrarily many arguments. Each number may be any numeric value. If no arguments are given, the result will be one (the multiplicative identity). / number ? number ...? : If only a single number argument is given, returns the reciprocal of that numeric value (i.e. the value obtained by dividing 1.0 by that value). Otherwise returns the number that results when the first numeric argument is divided by all subsequent numeric arguments. All number arguments must be numeric values. At least one argument must be given. Note that when the leading values in the list of arguments are integers, integer division will be used for those initial steps (i.e. the intermediate results will be as if the functions *floor* and *int* are applied to them, in that order). If all values in the operation are integers, the result will be an integer. % number number : Returns the integral modulus (i.e., remainder) of the first argument with respect to the second. Each number must have an integral value. Also, the sign of the result will be the same as the sign of the second number , which must not be zero. Note that Tcl defines this operation exactly even for negative numbers, so that the following command returns a true value (omitting the namespace for clarity): **==** \\[**\\*** \\[**/*** x y*\\] *y*\\] \\[**-*** x* \\[**%*** x y*\\]\\] ** ? number ...? : Returns the result of raising each value to the power of the result of recursively operating on the result of processing the following arguments, so is the same as Each number may be any numeric value, though the second number must not be fractional if the first is negative. The maximum exponent value that Tcl can handle if the first number is an integer > 1 is 268435455. If no arguments are given, the result will be one, and if only one argument is given, the result will be that argument. The result will have an integral value only when all arguments are integral values. COMPARISON OPERATORS The behaviors of the comparison operator commands (most of which operate preferentially on numeric arguments) are as follows: == ? arg ...? : Returns whether each argument is equal to the arguments on each side of it in the sense of the expr == operator ( i.e. , numeric comparison if possible, exact string comparison otherwise). If fewer than two arguments are given, this operation always returns a true value. eq ? arg ...? : Returns whether each argument is equal to the arguments on each side of it using exact string comparison. If fewer than two arguments are given, this operation always returns a true value. != arg arg : Returns whether the two arguments are not equal to each other, in the sense of the expr != operator ( i.e. , numeric comparison if possible, exact string comparison otherwise). ne arg arg : Returns whether the two arguments are not equal to each other using exact string comparison. \\< ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be strictly more than the one preceding it. Comparisons are performed preferentially on the numeric values, and are otherwise performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. When the arguments are numeric but should be compared as strings, the lt operator or the string compare command should be used instead. \\<= ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be equal to or more than the one preceding it. Comparisons are performed preferentially on the numeric values, and are otherwise performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. When the arguments are numeric but should be compared as strings, the le operator or the string compare command should be used instead. > ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be strictly less than the one preceding it. Comparisons are performed preferentially on the numeric values, and are otherwise performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. When the arguments are numeric but should be compared as strings, the gt operator or the string compare command should be used instead. >= ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be equal to or less than the one preceding it. Comparisons are performed preferentially on the numeric values, and are otherwise performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. When the arguments are numeric but should be compared as strings, the ge operator or the string compare command should be used instead. lt ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be strictly more than the one preceding it. Comparisons are performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. le ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be equal to or strictly more than the one preceding it. Comparisons are performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. gt ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be strictly less than the one preceding it. Comparisons are performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. ge ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be equal to or strictly less than the one preceding it. Comparisons are performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. BIT-WISE OPERATORS The behaviors of the bit-wise operator commands (all of which only operate on integral arguments) are as follows: \\~ number : Returns the bit-wise negation of number . Number may be an integer of any size. Note that the result of this operation will always have the opposite sign to the input number . & ? number ...? : Returns the bit-wise AND of each of the arbitrarily many arguments. Each number must have an integral value. If no arguments are given, the result will be minus one. | ? number ...? : Returns the bit-wise OR of each of the arbitrarily many arguments. Each number must have an integral value. If no arguments are given, the result will be zero. \\^ ? number ...? : Returns the bit-wise XOR of each of the arbitrarily many arguments. Each number must have an integral value. If no arguments are given, the result will be zero. \\<\\< number number : Returns the result of bit-wise shifting the first argument left by the number of bits specified in the second argument. Each number must have an integral value. >> number number : Returns the result of bit-wise shifting the first argument right by the number of bits specified in the second argument. Each number must have an integral value. LIST OPERATORS The behaviors of the list-oriented operator commands are as follows: in arg list : Returns whether the value arg is present in the list list (according to exact string comparison of elements). ni arg list : Returns whether the value arg is not present in the list list (according to exact string comparison of elements). EXAMPLES The simplest way to use the operators is often by using namespace path to make the commands available. This has the advantage of not affecting the set of commands defined by the current namespace. namespace path { ::tcl::mathop ::tcl::mathfunc} # Compute the sum of some numbers set sum [ + 1 2 3] # Compute the average of a list set list {1 2 3 4 5 6} set mean [ / [ + {*}\\$list] [double [llength \\$list]]] # Test for list membership set gotIt [ in 3 \\$list] # Test to see if a value is within some defined range set inRange [ \\<= 1 \\$x 5] # Test to see if a list is numerically sorted set sorted [ \\<= {*}\\$list] # Test to see if a list is lexically sorted set alphaList {a b c d e f} set sorted [ le {*}\\$alphaList] SEE ALSO expr(n), mathfunc(n), namespace(n) KEYWORDS command, expression, operator","title":"NAME"},{"location":"mathop/#name","text":"mathop - Mathematical operators as Tcl commands","title":"NAME"},{"location":"mathop/#synopsis","text":"package require Tcl 8.5- ::tcl::mathop::! number \\ ::tcl::mathop::\\~ number \\ ::tcl::mathop::+ ? number ...?\\ ::tcl::mathop::- number ? number ...?\\ ::tcl::mathop::* ? number ...?\\ ::tcl::mathop::/ number ? number ...?\\ ::tcl::mathop::% number number \\ ::tcl::mathop::** ? number ...?\\ ::tcl::mathop::& ? number ...?\\ ::tcl::mathop::| ? number ...?\\ ::tcl::mathop::\\^ ? number ...?\\ ::tcl::mathop::\\<\\< number number \\ ::tcl::mathop::>> number number \\ ::tcl::mathop::== ? arg ...?\\ ::tcl::mathop::!= arg arg \\ ::tcl::mathop::\\< ? arg ...?\\ ::tcl::mathop::\\<= ? arg ...?\\ ::tcl::mathop::>= ? arg ...?\\ ::tcl::mathop::> ? arg ...?\\ ::tcl::mathop::eq ? arg ...?\\ ::tcl::mathop::ne arg arg \\ ::tcl::mathop::lt ? arg ...?\\ ::tcl::mathop::le ? arg ...?\\ ::tcl::mathop::gt ? arg ...?\\ ::tcl::mathop::ge ? arg ...? \\ ::tcl::mathop::in arg list \\ ::tcl::mathop::ni arg list","title":"SYNOPSIS"},{"location":"mathop/#description","text":"The commands in the ::tcl::mathop namespace implement the same set of operations as supported by the expr command. All are exported from the namespace, but are not imported into any other namespace by default. Note that renaming, reimplementing or deleting any of the commands in the namespace does not alter the way that the expr command behaves, and nor does defining any new commands in the ::tcl::mathop namespace. The following operator commands are supported: \\~ ! + - * / % ** & | \\^ >> \\<\\< == eq != ne \\< \\<= > >= in ni lt le gt ge","title":"DESCRIPTION"},{"location":"mathop/#mathematical-operators","text":"The behaviors of the mathematical operator commands are as follows: ! boolean : Returns the boolean negation of boolean , where boolean may be any numeric value or any other form of boolean value (i.e. it returns truth if the argument is falsity or zero, and falsity if the argument is truth or non-zero). + ? number ...? : Returns the sum of arbitrarily many arguments. Each number argument may be any numeric value. If no arguments are given, the result will be zero (the summation identity). - number ? number ...? : If only a single number argument is given, returns the negation of that numeric value. Otherwise returns the number that results when all subsequent numeric values are subtracted from the first one. All number arguments must be numeric values. At least one argument must be given. * ? number ...? : Returns the product of arbitrarily many arguments. Each number may be any numeric value. If no arguments are given, the result will be one (the multiplicative identity). / number ? number ...? : If only a single number argument is given, returns the reciprocal of that numeric value (i.e. the value obtained by dividing 1.0 by that value). Otherwise returns the number that results when the first numeric argument is divided by all subsequent numeric arguments. All number arguments must be numeric values. At least one argument must be given. Note that when the leading values in the list of arguments are integers, integer division will be used for those initial steps (i.e. the intermediate results will be as if the functions *floor* and *int* are applied to them, in that order). If all values in the operation are integers, the result will be an integer. % number number : Returns the integral modulus (i.e., remainder) of the first argument with respect to the second. Each number must have an integral value. Also, the sign of the result will be the same as the sign of the second number , which must not be zero. Note that Tcl defines this operation exactly even for negative numbers, so that the following command returns a true value (omitting the namespace for clarity): **==** \\[**\\*** \\[**/*** x y*\\] *y*\\] \\[**-*** x* \\[**%*** x y*\\]\\] ** ? number ...? : Returns the result of raising each value to the power of the result of recursively operating on the result of processing the following arguments, so is the same as Each number may be any numeric value, though the second number must not be fractional if the first is negative. The maximum exponent value that Tcl can handle if the first number is an integer > 1 is 268435455. If no arguments are given, the result will be one, and if only one argument is given, the result will be that argument. The result will have an integral value only when all arguments are integral values.","title":"MATHEMATICAL OPERATORS"},{"location":"mathop/#comparison-operators","text":"The behaviors of the comparison operator commands (most of which operate preferentially on numeric arguments) are as follows: == ? arg ...? : Returns whether each argument is equal to the arguments on each side of it in the sense of the expr == operator ( i.e. , numeric comparison if possible, exact string comparison otherwise). If fewer than two arguments are given, this operation always returns a true value. eq ? arg ...? : Returns whether each argument is equal to the arguments on each side of it using exact string comparison. If fewer than two arguments are given, this operation always returns a true value. != arg arg : Returns whether the two arguments are not equal to each other, in the sense of the expr != operator ( i.e. , numeric comparison if possible, exact string comparison otherwise). ne arg arg : Returns whether the two arguments are not equal to each other using exact string comparison. \\< ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be strictly more than the one preceding it. Comparisons are performed preferentially on the numeric values, and are otherwise performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. When the arguments are numeric but should be compared as strings, the lt operator or the string compare command should be used instead. \\<= ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be equal to or more than the one preceding it. Comparisons are performed preferentially on the numeric values, and are otherwise performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. When the arguments are numeric but should be compared as strings, the le operator or the string compare command should be used instead. > ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be strictly less than the one preceding it. Comparisons are performed preferentially on the numeric values, and are otherwise performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. When the arguments are numeric but should be compared as strings, the gt operator or the string compare command should be used instead. >= ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be equal to or less than the one preceding it. Comparisons are performed preferentially on the numeric values, and are otherwise performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. When the arguments are numeric but should be compared as strings, the ge operator or the string compare command should be used instead. lt ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be strictly more than the one preceding it. Comparisons are performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. le ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be equal to or strictly more than the one preceding it. Comparisons are performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. gt ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be strictly less than the one preceding it. Comparisons are performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value. ge ? arg ...? : Returns whether the arbitrarily-many arguments are ordered, with each argument after the first having to be equal to or strictly less than the one preceding it. Comparisons are performed using UNICODE string comparison. If fewer than two arguments are present, this operation always returns a true value.","title":"COMPARISON OPERATORS"},{"location":"mathop/#bit-wise-operators","text":"The behaviors of the bit-wise operator commands (all of which only operate on integral arguments) are as follows: \\~ number : Returns the bit-wise negation of number . Number may be an integer of any size. Note that the result of this operation will always have the opposite sign to the input number . & ? number ...? : Returns the bit-wise AND of each of the arbitrarily many arguments. Each number must have an integral value. If no arguments are given, the result will be minus one. | ? number ...? : Returns the bit-wise OR of each of the arbitrarily many arguments. Each number must have an integral value. If no arguments are given, the result will be zero. \\^ ? number ...? : Returns the bit-wise XOR of each of the arbitrarily many arguments. Each number must have an integral value. If no arguments are given, the result will be zero. \\<\\< number number : Returns the result of bit-wise shifting the first argument left by the number of bits specified in the second argument. Each number must have an integral value. >> number number : Returns the result of bit-wise shifting the first argument right by the number of bits specified in the second argument. Each number must have an integral value.","title":"BIT-WISE OPERATORS"},{"location":"mathop/#list-operators","text":"The behaviors of the list-oriented operator commands are as follows: in arg list : Returns whether the value arg is present in the list list (according to exact string comparison of elements). ni arg list : Returns whether the value arg is not present in the list list (according to exact string comparison of elements).","title":"LIST OPERATORS"},{"location":"mathop/#examples","text":"The simplest way to use the operators is often by using namespace path to make the commands available. This has the advantage of not affecting the set of commands defined by the current namespace. namespace path { ::tcl::mathop ::tcl::mathfunc} # Compute the sum of some numbers set sum [ + 1 2 3] # Compute the average of a list set list {1 2 3 4 5 6} set mean [ / [ + {*}\\$list] [double [llength \\$list]]] # Test for list membership set gotIt [ in 3 \\$list] # Test to see if a value is within some defined range set inRange [ \\<= 1 \\$x 5] # Test to see if a list is numerically sorted set sorted [ \\<= {*}\\$list] # Test to see if a list is lexically sorted set alphaList {a b c d e f} set sorted [ le {*}\\$alphaList]","title":"EXAMPLES"},{"location":"mathop/#see-also","text":"expr(n), mathfunc(n), namespace(n)","title":"SEE ALSO"},{"location":"mathop/#keywords","text":"command, expression, operator","title":"KEYWORDS"},{"location":"memory/","text":"NAME memory - Control Tcl memory debugging capabilities SYNOPSIS memory option ? arg arg ... ? DESCRIPTION The memory command gives the Tcl developer control of Tcl\\'s memory debugging capabilities. The memory command has several suboptions, which are described below. It is only available when Tcl has been compiled with memory debugging enabled (when TCL_MEM_DEBUG is defined at compile time), and after Tcl_InitMemory has been called. memory active file : Write a list of all currently allocated memory to the specified file . memory break_on_malloc count : After the count allocations have been performed, Tcl_Alloc outputs a message to this effect and that it is now attempting to enter the C debugger. Tcl will then issue a SIGINT signal against itself. If you are running Tcl under a C debugger, it should then enter the debugger command mode. memory info : Returns a report containing the total allocations and frees since Tcl began, the current packets allocated (the current number of calls to Tcl_Alloc not met by a corresponding call to Tcl_Free ), the current bytes allocated, and the maximum number of packets and bytes allocated. memory init [ on | off ] : Turn on or off the preinitialization of all allocated memory with bogus bytes. Useful for detecting the use of uninitialized values. memory objs file : Causes a list of all allocated Tcl_Obj values to be written to the specified file immediately, together with where they were allocated. Useful for checking for leaks of values. memory onexit file : Causes a list of all allocated memory to be written to the specified file during the finalization of Tcl\\'s memory subsystem. Useful for checking that memory is properly cleaned up during process exit. memory tag string : Each packet of memory allocated by Tcl_Alloc can have associated with it a string-valued tag. In the lists of allocated memory generated by memory active and memory onexit , the tag for each packet is printed along with other information about the packet. The memory tag command sets the tag value for subsequent calls to Tcl_Alloc to be string . memory trace [ on | off ] : Turns memory tracing on or off. When memory tracing is on, every call to Tcl_Alloc causes a line of trace information to be written to stderr , consisting of the word Tcl_Alloc , followed by the address returned, the amount of memory allocated, and the C filename and line number of the code performing the allocation. For example: Tcl_Alloc 40e478 98 tclProc.c 1406 Calls to **Tcl_Free** are traced in the same manner. memory trace_on_at_malloc count : Enable memory tracing after count Tcl_Alloc s have been performed. For example, if you enter memory trace_on_at_malloc 100 , after the 100th call to Tcl_Alloc , memory trace information will begin being displayed for all allocations and frees. Since there can be a lot of memory activity before a problem occurs, judicious use of this option can reduce the slowdown caused by tracing (and the amount of trace information produced), if you can identify a number of allocations that occur before the problem sets in. The current number of memory allocations that have occurred since Tcl started is printed on a guard zone failure. memory validate [ on | off ] : Turns memory validation on or off. When memory validation is enabled, on every call to Tcl_Alloc or Tcl_Free , the guard zones are checked for every piece of memory currently in existence that was allocated by Tcl_Alloc . This has a large performance impact and should only be used when overwrite problems are strongly suspected. The advantage of enabling memory validation is that a guard zone overwrite can be detected on the first call to Tcl_Alloc or Tcl_Free after the overwrite occurred, rather than when the specific memory with the overwritten guard zone(s) is freed, which may occur long after the overwrite occurred. SEE ALSO Tcl_Alloc, Tcl_Free, Tcl_ValidateAllMemory, Tcl_DumpActiveMemory, TCL_MEM_DEBUG KEYWORDS memory, debug","title":"NAME"},{"location":"memory/#name","text":"memory - Control Tcl memory debugging capabilities","title":"NAME"},{"location":"memory/#synopsis","text":"memory option ? arg arg ... ?","title":"SYNOPSIS"},{"location":"memory/#description","text":"The memory command gives the Tcl developer control of Tcl\\'s memory debugging capabilities. The memory command has several suboptions, which are described below. It is only available when Tcl has been compiled with memory debugging enabled (when TCL_MEM_DEBUG is defined at compile time), and after Tcl_InitMemory has been called. memory active file : Write a list of all currently allocated memory to the specified file . memory break_on_malloc count : After the count allocations have been performed, Tcl_Alloc outputs a message to this effect and that it is now attempting to enter the C debugger. Tcl will then issue a SIGINT signal against itself. If you are running Tcl under a C debugger, it should then enter the debugger command mode. memory info : Returns a report containing the total allocations and frees since Tcl began, the current packets allocated (the current number of calls to Tcl_Alloc not met by a corresponding call to Tcl_Free ), the current bytes allocated, and the maximum number of packets and bytes allocated. memory init [ on | off ] : Turn on or off the preinitialization of all allocated memory with bogus bytes. Useful for detecting the use of uninitialized values. memory objs file : Causes a list of all allocated Tcl_Obj values to be written to the specified file immediately, together with where they were allocated. Useful for checking for leaks of values. memory onexit file : Causes a list of all allocated memory to be written to the specified file during the finalization of Tcl\\'s memory subsystem. Useful for checking that memory is properly cleaned up during process exit. memory tag string : Each packet of memory allocated by Tcl_Alloc can have associated with it a string-valued tag. In the lists of allocated memory generated by memory active and memory onexit , the tag for each packet is printed along with other information about the packet. The memory tag command sets the tag value for subsequent calls to Tcl_Alloc to be string . memory trace [ on | off ] : Turns memory tracing on or off. When memory tracing is on, every call to Tcl_Alloc causes a line of trace information to be written to stderr , consisting of the word Tcl_Alloc , followed by the address returned, the amount of memory allocated, and the C filename and line number of the code performing the allocation. For example: Tcl_Alloc 40e478 98 tclProc.c 1406 Calls to **Tcl_Free** are traced in the same manner. memory trace_on_at_malloc count : Enable memory tracing after count Tcl_Alloc s have been performed. For example, if you enter memory trace_on_at_malloc 100 , after the 100th call to Tcl_Alloc , memory trace information will begin being displayed for all allocations and frees. Since there can be a lot of memory activity before a problem occurs, judicious use of this option can reduce the slowdown caused by tracing (and the amount of trace information produced), if you can identify a number of allocations that occur before the problem sets in. The current number of memory allocations that have occurred since Tcl started is printed on a guard zone failure. memory validate [ on | off ] : Turns memory validation on or off. When memory validation is enabled, on every call to Tcl_Alloc or Tcl_Free , the guard zones are checked for every piece of memory currently in existence that was allocated by Tcl_Alloc . This has a large performance impact and should only be used when overwrite problems are strongly suspected. The advantage of enabling memory validation is that a guard zone overwrite can be detected on the first call to Tcl_Alloc or Tcl_Free after the overwrite occurred, rather than when the specific memory with the overwritten guard zone(s) is freed, which may occur long after the overwrite occurred.","title":"DESCRIPTION"},{"location":"memory/#see-also","text":"Tcl_Alloc, Tcl_Free, Tcl_ValidateAllMemory, Tcl_DumpActiveMemory, TCL_MEM_DEBUG","title":"SEE ALSO"},{"location":"memory/#keywords","text":"memory, debug","title":"KEYWORDS"},{"location":"msgcat/","text":"NAME msgcat - Tcl message catalog SYNOPSIS package require tcl 8.7 package require msgcat 1.7 ::msgcat::mc src-string ? arg arg ... ? ::msgcat::mcmax ? src-string src-string ... ? ::msgcat::mcexists ? -exactnamespace ? ? -exactlocale ? src-string ::msgcat::mcpackagenamespaceget ::msgcat::mclocale ? newLocale ? ::msgcat::mcpreferences ? locale preference ? ... ::msgcat::mcloadedlocales subcommand ? locale ? ::msgcat::mcload dirname ::msgcat::mcset locale src-string ? translate-string ? ::msgcat::mcmset locale src-trans-list ::msgcat::mcflset src-string ? translate-string ? ::msgcat::mcflmset src-trans-list ::msgcat::mcunknown locale src-string ? arg arg ... ? ::msgcat::mcpackagelocale subcommand ? locale ? ::msgcat::mcpackageconfig subcommand option ? value ? ::msgcat::mcforgetpackage ::msgcat::mcutil subcommand ? locale ? DESCRIPTION The msgcat package provides a set of functions that can be used to manage multi-lingual user interfaces. Text strings are defined in a which is independent from the application, and which can be edited or localized without modifying the application source code. New languages or locales may be provided by adding a new file to the message catalog. msgcat distinguishes packages by its namespace. Each package has its own message catalog and configuration settings in msgcat . A locale is a specification string describing a user language like de_ch for Swiss German. In msgcat , there is a global locale initialized by the system locale of the current system. Each package may decide to use the global locale or to use a package specific locale. The global locale may be changed on demand, for example by a user initiated language change or within a multi user application like a web server. Object oriented programming is supported by the use of a package namespace. COMMANDS ::msgcat::mc src-string ? arg arg ... ? : Returns a translation of src-string according to the current locale. If additional arguments past src-string are given, the format command is used to substitute the additional arguments in the translation of src-string . **::msgcat::mc** will search the messages defined in the current namespace for a translation of *src-string*; if none is found, it will search in the parent of the current namespace, and so on until it reaches the global namespace. If no translation string exists, **::msgcat::mcunknown** is called and the string returned from **::msgcat::mcunknown** is returned. **::msgcat::mc** is the main function used to localize an application. Instead of using an English string directly, an application can pass the English string through **::msgcat::mc** and use the result. If an application is written for a single language in this fashion, then it is easy to add support for additional languages later simply by defining new message catalog entries. <!-- --> ::msgcat::mcn namespace src-string ? arg arg ... ? : Like ::msgcat::mc , but with the message namespace specified as first argument. mcn may be used for cases where the package namespace is not the namespace of the caller. An example is shown within the description of the command ::msgcat::mcpackagenamespaceget below. ::msgcat::mcmax ? src-string src-string ... ? : Given several source strings, ::msgcat::mcmax returns the length of the longest translated string. This is useful when designing localized GUIs, which may require that all buttons, for example, be a fixed width (which will be the width of the widest button). <!-- --> ::msgcat::mcexists ? -exactnamespace ? ? -exactlocale ? ? -namespace namespace ? src-string : Return true, if there is a translation for the given src-string . The search may be limited by the option -exactnamespace to only check the current namespace and not any parent namespaces. It may also be limited by the option -exactlocale to only check the first prefered locale (e.g. first element returned by ::msgcat::mcpreferences if global locale is used). An explicit package namespace may be specified by the option -namespace . The namespace of the caller is used if not explicitly specified. ::msgcat::mcpackagenamespaceget : Return the package namespace of the caller. This command handles all cases described in section OBJECT ORIENTED PROGRAMMING . Example usage is a tooltip package, which saves the caller package namespace to update the translation each time the tooltip is shown: proc ::tooltip::tooltip {widget message} { ... set messagenamespace [uplevel 1 {::msgcat::mcpackagenamespaceget}] ... bind \\$widget [list ::tooltip::show \\$widget \\$messagenamespace \\$message] } proc ::tooltip::show {widget messagenamespace message} { ... set message [::msgcat::mcn \\$messagenamespace \\$message] ... } ::msgcat::mclocale ? newLocale ? : If newLocale is omitted, the current locale is returned, otherwise the current locale is set to newLocale . If the new locale is set to newLocale , the corresponding preferences are calculated and set. For example, if the current locale is en_US_funky, then ::msgcat::mcpreferences returns {en_us_funky en_us en {}} . The same result may be acheved by ::msgcat::mcpreferences {*}[ ::msgcat::mcutil getpreferences newLocale ]. The current locale is always the first element of the list returned by mcpreferences . msgcat stores and compares the locale in a case-insensitive manner, and returns locales in lowercase. The initial locale is determined by the locale specified in the user\\'s environment. See LOCALE SPECIFICATION below for a description of the locale string format. If the locale is set, the preference list of locales is evaluated. Locales in this list are loaded now, if not jet loaded. ::msgcat::mcpreferences ? locale preference ? ... : Without arguments, returns an ordered list of the locales preferred by the user. The list is ordered from most specific to least preference. A set of locale preferences may be given to set the list of locale preferences. The current locale is also set, which is the first element of the locale preferences list. Locale preferences are loaded now, if not jet loaded. As an example, the user may prefer French or English text. This may be configured by: ::msgcat::mcpreferences fr en {} ::msgcat::mcloadedlocales subcommand ? locale ? : This group of commands manage the list of loaded locales for packages not setting a package locale. The subcommand loaded returns the list of currently loaded locales. The subcommand clear removes all locales and their data, which are not in the current preference list. ::msgcat::mcload dirname : Searches the specified directory for files that match the language specifications returned by ::msgcat::mcloadedlocales loaded (or msgcat::mcpackagelocale preferences if a package locale is set) (note that these are all lowercase), extended by the file extension Each matching file is read in order, assuming a UTF-8 encoding. The file contents are then evaluated as a Tcl script. This means that Unicode characters may be present in the message file either directly in their UTF-8 encoded form, or by use of the backslash-u quoting recognized by Tcl evaluation. The number of message files which matched the specification and were loaded is returned. In addition, the given folder is stored in the msgcat package configuration option mcfolder to eventually load message catalog files required by a locale change. ::msgcat::mcset locale src-string ? translate-string ? : Sets the translation for src-string to translate-string in the specified locale and the current namespace. If translate-string is not specified, src-string is used for both. The function returns translate-string . ::msgcat::mcmset locale src-trans-list : Sets the translation for multiple source strings in src-trans-list in the specified locale and the current namespace. src-trans-list must have an even number of elements and is in the form { src-string translate-string ? src-string translate-string ...?} ::msgcat::mcmset can be significantly faster than multiple invocations of ::msgcat::mcset . The function returns the number of translations set. ::msgcat::mcflset src-string ? translate-string ? : Sets the translation for src-string to translate-string in the current namespace for the locale implied by the name of the message catalog being loaded via ::msgcat::mcload . If translate-string is not specified, src-string is used for both. The function returns translate-string . ::msgcat::mcflmset src-trans-list : Sets the translation for multiple source strings in src-trans-list in the current namespace for the locale implied by the name of the message catalog being loaded via ::msgcat::mcload . src-trans-list must have an even number of elements and is in the form { src-string translate-string ? src-string translate-string ... ?} ::msgcat::mcflmset can be significantly faster than multiple invocations of ::msgcat::mcflset . The function returns the number of translations set. ::msgcat::mcunknown locale src-string ? arg arg ... ? : This routine is called by ::msgcat::mc in the case when a translation for src-string is not defined in the current locale. The default action is to return src-string passed by format if there are any arguments. This procedure can be redefined by the application, for example to log error messages for each unknown string. The ::msgcat::mcunknown procedure is invoked at the same stack context as the call to ::msgcat::mc . The return value of ::msgcat::mcunknown is used as the return value for the call to ::msgcat::mc . Note that this routine is only called if the concerned package did not set a package locale unknown command name. ::msgcat::mcforgetpackage : The calling package clears all its state within the msgcat package including all settings and translations. <!-- --> ::msgcat::mcutil getpreferences locale : Return the preferences list of the given locale as described in section LOCALE SPECIFICATION . An example is the composition of a preference list for the bilingual region \\\"Biel/Bienne\\\" as a concatenation of swiss german and swiss french: \\% concat [lrange [msgcat::mcutil getpreferences fr_CH] 0 end-1] [msgcat::mcutil getpreferences de_CH] fr_ch fr de_ch de {} ::msgcat::mcutil getsystemlocale : The system locale is returned as described by the section LOCALE SPECIFICATION . LOCALE SPECIFICATION The locale is specified to msgcat by a locale string passed to ::msgcat::mclocale . The locale string consists of a language code, an optional country code, and an optional system-specific code, each separated by The country and language codes are specified in standards ISO-639 and ISO-3166. For example, the locale specifies English and specifies U.S. English. When the msgcat package is first loaded, the locale is initialized according to the user\\'s environment. The variables env(LC_ALL) , env(LC_MESSAGES) , and env(LANG) are examined in order. The first of them to have a non-empty value is used to determine the initial locale. The value is parsed according to the XPG4 pattern language[_country][.codeset][@modifier] to extract its parts. The initial locale is then set by calling ::msgcat::mclocale with the argument language[_country][_modifier] On Windows and Cygwin, if none of those environment variables is set, msgcat will attempt to extract locale information from the registry. From Windows Vista on, the RFC4747 locale name \\\"lang-script-country-options\\\" is transformed to the locale as \\\"lang_country_script\\\" (Example: sr-Latn-CS -> sr_cs_latin). For Windows XP, the language id is transformed analoguously (Example: 0c1a -> sr_yu_cyrillic). If all these attempts to discover an initial locale from the user\\'s environment fail, msgcat defaults to an initial locale of When a locale is specified by the user, a search is performed during string translation. For example, if a user specifies en_GB_Funky, the locales and (the empty string) are searched in order until a matching translation string is found. If no translation string is available, then the unknown handler is called. NAMESPACES AND MESSAGE CATALOGS Strings stored in the message catalog are stored relative to the namespace from which they were added. This allows multiple packages to use the same strings without fear of collisions with other packages. It also allows the source string to be shorter and less prone to typographical error. For example, executing the code ::msgcat::mcset en hello \\\"hello from ::\\\" namespace eval foo { ::msgcat::mcset en hello \\\"hello from ::foo\\\" } puts [ ::msgcat::mc hello] namespace eval foo {puts [ ::msgcat::mc hello]} will print hello from :: hello from ::foo When searching for a translation of a message, the message catalog will search first the current namespace, then the parent of the current namespace, and so on until the global namespace is reached. This allows child namespaces to messages from their parent namespace. For example, executing (in the locale) the code ::msgcat::mcset en m1 \\\":: message1\\\" ::msgcat::mcset en m2 \\\":: message2\\\" ::msgcat::mcset en m3 \\\":: message3\\\" namespace eval ::foo { ::msgcat::mcset en m2 \\\"::foo message2\\\" ::msgcat::mcset en m3 \\\"::foo message3\\\" } namespace eval ::foo::bar { ::msgcat::mcset en m3 \\\"::foo::bar message3\\\" } namespace import ::msgcat::mc puts \\\"[ mc m1]; [ mc m2]; [ mc m3]\\\" namespace eval ::foo {puts \\\"[ mc m1]; [ mc m2]; [ mc m3]\\\"} namespace eval ::foo::bar {puts \\\"[ mc m1]; [ mc m2]; [ mc m3]\\\"} will print :: message1; :: message2; :: message3 :: message1; ::foo message2; ::foo message3 :: message1; ::foo message2; ::foo::bar message3 LOCATION AND FORMAT OF MESSAGE FILES Message files can be located in any directory, subject to the following conditions: [1] : All message files for a package are in the same directory. [2] : The message file name is a msgcat locale specifier (all lowercase) followed by For example: es.msg --- spanish en_gb.msg --- United Kingdom English Exception: The message file for the root locale is called This exception is made so as not to cause peculiar behavior, such as marking the message file as on Unix file systems. [3] : The file contains a series of calls to mcflset and mcflmset , setting the necessary translation strings for the language, likely enclosed in a namespace eval so that all source strings are tied to the namespace of the package. For example, a short es.msg might contain: namespace eval ::mypackage { ::msgcat::mcflset \\\"Free Beer\\\" \\\"Cerveza Gratis\\\" } RECOMMENDED MESSAGE SETUP FOR PACKAGES If a package is installed into a subdirectory of the tcl_pkgPath and loaded via package require , the following procedure is recommended. [1] : During package installation, create a subdirectory msgs under your package directory. [2] : Copy your *.msg files into that directory. [3] : Add the following command to your package initialization script: # load language files, stored in msgs subdirectory ::msgcat::mcload [file join [file dirname [info script]] msgs] POSITIONAL CODES FOR FORMAT AND SCAN COMMANDS It is possible that a message string used as an argument to format might have positionally dependent parameters that might need to be repositioned. For example, it might be syntactically desirable to rearrange the sentence structure while translating. format \\\"We produced %d units in location %s\\\" \\$num \\$city format \\\"In location %s we produced %d units\\\" \\$city \\$num This can be handled by using the positional parameters: format \\\"We produced %1\\\\$d units in location %2\\\\$s\\\" \\$num \\$city format \\\"In location %2\\\\$s we produced %1\\\\$d units\\\" \\$num \\$city Similarly, positional parameters can be used with scan to extract values from internationalized strings. Note that it is not necessary to pass the output of ::msgcat::mc to format directly; by passing the values to substitute in as arguments, the formatting substitution is done directly. msgcat::mc {Produced %1\\$d at %2\\$s} \\$num \\$city # ... where that key is mapped to one of the # human-oriented versions by msgcat::mcset PACKAGE PRIVATE LOCALE A package using msgcat may choose to use its own package private locale and its own set of loaded locales, independent to the global locale set by ::msgcat::mclocale . This allows a package to change its locale without causing any locales load or removal in other packages and not to invoke the global locale change callback (see below). This action is controled by the following ensemble: ::msgcat::mcpackagelocale set ? locale ? : Set or change a package private locale. The package private locale is set to the given locale if the locale is given. If the option locale is not given, the package is set to package private locale mode, but no locale is changed (e.g. if the global locale was valid for the package before, it is copied to the package private locale). This command may cause the load of locales. ::msgcat::mcpackagelocale get : Return the package private locale or the global locale, if no package private locale is set. ::msgcat::mcpackagelocale preferences ? locale preference ? ... : With no parameters, return the package private preferences or the global preferences, if no package private locale is set. The package locale state (set or not) is not changed (in contrast to the command ::msgcat::mcpackagelocale set ). If a set of locale preferences is given, it is set as package locale preference list. The package locale is set to the first element of the preference list. A package locale is activated, if it was not set so far. Locale preferences are loaded now for the package, if not jet loaded. ::msgcat::mcpackagelocale loaded : Return the list of locales loaded for this package. ::msgcat::mcpackagelocale isset : Returns true, if a package private locale is set. ::msgcat::mcpackagelocale unset : Unset the package private locale and use the globale locale. Load and remove locales to adjust the list of loaded locales for the package to the global loaded locales list. ::msgcat::mcpackagelocale present locale : Returns true, if the given locale is loaded for the package. ::msgcat::mcpackagelocale clear : Clear any loaded locales of the package not present in the package preferences. CHANGING PACKAGE OPTIONS Each package using msgcat has a set of options within msgcat . The package options are described in the next sectionPackage options. Each package option may be set or unset individually using the following ensemble: ::msgcat::mcpackageconfig get option : Return the current value of the given option . This call returns an error if the option is not set for the package. ::msgcat::mcpackageconfig isset option : Returns 1, if the given option is set for the package, 0 otherwise. ::msgcat::mcpackageconfig set option value : Set the given option to the given value . This may invoke additional actions in dependency of the option . The return value is 0 or the number of loaded packages for the option mcfolder . ::msgcat::mcpackageconfig unset option : Unsets the given option for the package. No action is taken if the option is not set for the package. The empty string is returned. Package options The following package options are available for each package: mcfolder : This is the message folder of the package. This option is set by mcload and by the subcommand set. Both are identical and both return the number of loaded message catalog files. Setting or changing this value will load all locales contained in the preferences valid for the package. This implies also to invoke any set loadcmd (see below). Unsetting this value will disable message file load for the package. loadcmd : This callback is invoked before a set of message catalog files are loaded for the package which has this property set. This callback may be used to do any preparation work for message file load or to get the message data from another source like a data base. In this case, no message files are used (mcfolder is unset). See section callback invocation below. The parameter list appended to this callback is the list of locales to load. If this callback is changed, it is called with the preferences valid for the package. changecmd : This callback is invoked when a default local change was performed. Its purpose is to allow a package to update any dependency on the default locale like showing the GUI in another language. See the callback invocation section below. The parameter list appended to this callback is mcpreferences . The registered callbacks are invoked in no particular order. unknowncmd : Use a package locale mcunknown procedure instead of the standard version supplied by the msgcat package (msgcat::mcunknown). The called procedure must return the formatted message which will finally be returned by msgcat::mc. A generic unknown handler is used if set to the empty string. This consists in returning the key if no arguments are given. With given arguments, format is used to process the arguments. See section callback invocation below. The appended arguments are identical to ::msgcat::mcunknown . Callback invocation A package may decide to register one or multiple callbacks, as described above. Callbacks are invoked, if: 1. the callback command is set, 2. the command is not the empty string, 3. the registering namespace exists. If a called routine fails with an error, the bgerror routine for the interpreter is invoked after command completion. Only exception is the callback unknowncmd , where an error causes the invoking mc -command to fail with that error. OBJECT ORIENTED PROGRAMMING msgcat supports packages implemented by object oriented programming. Objects and classes should be defined within a package namespace. There are 3 supported cases where package namespace sensitive commands of msgcat ( mc , mcexists , mcpackagelocale , mcforgetpackage , mcpackagenamespaceget , mcpackageconfig , mcset and mcmset ) may be called: 1) In class definition script : msgcat command is called within a class definition script. namespace eval ::N2 { mcload \\$dir/msgs oo::class create C1 {puts [mc Hi!]} } 2) method defined in a class : msgcat command is called from a method in an object and the method is defined in a class. namespace eval ::N3Class { mcload \\$dir/msgs oo::class create C1 oo::define C1 method m1 { puts [mc Hi!] } } 3) method defined in a classless object : msgcat command is called from a method of a classless object. namespace eval ::N4 { mcload \\$dir/msgs oo::object create O1 oo::objdefine O1 method m1 {} { puts [mc Hi!] } } EXAMPLES Packages which display a GUI may update their widgets when the global locale changes. To register to a callback, use: namespace eval gui { msgcat::mcpackageconfig changecmd updateGUI proc updateGUI args { puts \\\"New locale is \\'[lindex \\$args 0]\\'.\\\" } } % msgcat::mclocale fr fr % New locale is \\'fr\\'. If locales (or additional locales) are contained in another source like a data base, a package may use the load callback and not mcload: namespace eval db { msgcat::mcpackageconfig loadcmd loadMessages proc loadMessages args { foreach locale \\$args { if {[LocaleInDB \\$locale]} { msgcat::mcmset \\$locale [GetLocaleList \\$locale] } } } } The clock command implementation uses msgcat with a package locale to implement the command line parameter -locale . Here are some sketches of the implementation: First, a package locale is initialized and the generic unknown function is desactivated: msgcat::mcpackagelocale set msgcat::mcpackageconfig unknowncmd \\\"\\\" As an example, the user requires the week day in a certain locale as follows: clock format [clock seconds] -format %A -locale fr clock sets the package locale to fr and looks for the day name as follows: msgcat::mcpackagelocale set \\$locale return [lindex [msgcat::mc DAYS_OF_WEEK_FULL] \\$day] ### Returns \\\"mercredi\\\" Within clock , some message-catalog items are heavy in computation and thus are dynamically cached using: proc ::tcl::clock::LocalizeFormat { locale format } { set key FORMAT_\\$format if { [::msgcat::mcexists -exactlocale -exactnamespace \\$key] } { return [mc \\$key] } #...expensive computation of format clipped... mcset \\$locale \\$key \\$format return \\$format } CREDITS The message catalog code was developed by Mark Harrison. SEE ALSO format(n), scan(n), namespace(n), package(n), oo::class(n), oo::object KEYWORDS internationalization, i18n, localization, l10n, message, text, translation, class, object","title":"NAME"},{"location":"msgcat/#name","text":"msgcat - Tcl message catalog","title":"NAME"},{"location":"msgcat/#synopsis","text":"package require tcl 8.7 package require msgcat 1.7 ::msgcat::mc src-string ? arg arg ... ? ::msgcat::mcmax ? src-string src-string ... ? ::msgcat::mcexists ? -exactnamespace ? ? -exactlocale ? src-string ::msgcat::mcpackagenamespaceget ::msgcat::mclocale ? newLocale ? ::msgcat::mcpreferences ? locale preference ? ... ::msgcat::mcloadedlocales subcommand ? locale ? ::msgcat::mcload dirname ::msgcat::mcset locale src-string ? translate-string ? ::msgcat::mcmset locale src-trans-list ::msgcat::mcflset src-string ? translate-string ? ::msgcat::mcflmset src-trans-list ::msgcat::mcunknown locale src-string ? arg arg ... ? ::msgcat::mcpackagelocale subcommand ? locale ? ::msgcat::mcpackageconfig subcommand option ? value ? ::msgcat::mcforgetpackage ::msgcat::mcutil subcommand ? locale ?","title":"SYNOPSIS"},{"location":"msgcat/#description","text":"The msgcat package provides a set of functions that can be used to manage multi-lingual user interfaces. Text strings are defined in a which is independent from the application, and which can be edited or localized without modifying the application source code. New languages or locales may be provided by adding a new file to the message catalog. msgcat distinguishes packages by its namespace. Each package has its own message catalog and configuration settings in msgcat . A locale is a specification string describing a user language like de_ch for Swiss German. In msgcat , there is a global locale initialized by the system locale of the current system. Each package may decide to use the global locale or to use a package specific locale. The global locale may be changed on demand, for example by a user initiated language change or within a multi user application like a web server. Object oriented programming is supported by the use of a package namespace.","title":"DESCRIPTION"},{"location":"msgcat/#commands","text":"::msgcat::mc src-string ? arg arg ... ? : Returns a translation of src-string according to the current locale. If additional arguments past src-string are given, the format command is used to substitute the additional arguments in the translation of src-string . **::msgcat::mc** will search the messages defined in the current namespace for a translation of *src-string*; if none is found, it will search in the parent of the current namespace, and so on until it reaches the global namespace. If no translation string exists, **::msgcat::mcunknown** is called and the string returned from **::msgcat::mcunknown** is returned. **::msgcat::mc** is the main function used to localize an application. Instead of using an English string directly, an application can pass the English string through **::msgcat::mc** and use the result. If an application is written for a single language in this fashion, then it is easy to add support for additional languages later simply by defining new message catalog entries. <!-- --> ::msgcat::mcn namespace src-string ? arg arg ... ? : Like ::msgcat::mc , but with the message namespace specified as first argument. mcn may be used for cases where the package namespace is not the namespace of the caller. An example is shown within the description of the command ::msgcat::mcpackagenamespaceget below. ::msgcat::mcmax ? src-string src-string ... ? : Given several source strings, ::msgcat::mcmax returns the length of the longest translated string. This is useful when designing localized GUIs, which may require that all buttons, for example, be a fixed width (which will be the width of the widest button). <!-- --> ::msgcat::mcexists ? -exactnamespace ? ? -exactlocale ? ? -namespace namespace ? src-string : Return true, if there is a translation for the given src-string . The search may be limited by the option -exactnamespace to only check the current namespace and not any parent namespaces. It may also be limited by the option -exactlocale to only check the first prefered locale (e.g. first element returned by ::msgcat::mcpreferences if global locale is used). An explicit package namespace may be specified by the option -namespace . The namespace of the caller is used if not explicitly specified. ::msgcat::mcpackagenamespaceget : Return the package namespace of the caller. This command handles all cases described in section OBJECT ORIENTED PROGRAMMING . Example usage is a tooltip package, which saves the caller package namespace to update the translation each time the tooltip is shown: proc ::tooltip::tooltip {widget message} { ... set messagenamespace [uplevel 1 {::msgcat::mcpackagenamespaceget}] ... bind \\$widget [list ::tooltip::show \\$widget \\$messagenamespace \\$message] } proc ::tooltip::show {widget messagenamespace message} { ... set message [::msgcat::mcn \\$messagenamespace \\$message] ... } ::msgcat::mclocale ? newLocale ? : If newLocale is omitted, the current locale is returned, otherwise the current locale is set to newLocale . If the new locale is set to newLocale , the corresponding preferences are calculated and set. For example, if the current locale is en_US_funky, then ::msgcat::mcpreferences returns {en_us_funky en_us en {}} . The same result may be acheved by ::msgcat::mcpreferences {*}[ ::msgcat::mcutil getpreferences newLocale ]. The current locale is always the first element of the list returned by mcpreferences . msgcat stores and compares the locale in a case-insensitive manner, and returns locales in lowercase. The initial locale is determined by the locale specified in the user\\'s environment. See LOCALE SPECIFICATION below for a description of the locale string format. If the locale is set, the preference list of locales is evaluated. Locales in this list are loaded now, if not jet loaded. ::msgcat::mcpreferences ? locale preference ? ... : Without arguments, returns an ordered list of the locales preferred by the user. The list is ordered from most specific to least preference. A set of locale preferences may be given to set the list of locale preferences. The current locale is also set, which is the first element of the locale preferences list. Locale preferences are loaded now, if not jet loaded. As an example, the user may prefer French or English text. This may be configured by: ::msgcat::mcpreferences fr en {} ::msgcat::mcloadedlocales subcommand ? locale ? : This group of commands manage the list of loaded locales for packages not setting a package locale. The subcommand loaded returns the list of currently loaded locales. The subcommand clear removes all locales and their data, which are not in the current preference list. ::msgcat::mcload dirname : Searches the specified directory for files that match the language specifications returned by ::msgcat::mcloadedlocales loaded (or msgcat::mcpackagelocale preferences if a package locale is set) (note that these are all lowercase), extended by the file extension Each matching file is read in order, assuming a UTF-8 encoding. The file contents are then evaluated as a Tcl script. This means that Unicode characters may be present in the message file either directly in their UTF-8 encoded form, or by use of the backslash-u quoting recognized by Tcl evaluation. The number of message files which matched the specification and were loaded is returned. In addition, the given folder is stored in the msgcat package configuration option mcfolder to eventually load message catalog files required by a locale change. ::msgcat::mcset locale src-string ? translate-string ? : Sets the translation for src-string to translate-string in the specified locale and the current namespace. If translate-string is not specified, src-string is used for both. The function returns translate-string . ::msgcat::mcmset locale src-trans-list : Sets the translation for multiple source strings in src-trans-list in the specified locale and the current namespace. src-trans-list must have an even number of elements and is in the form { src-string translate-string ? src-string translate-string ...?} ::msgcat::mcmset can be significantly faster than multiple invocations of ::msgcat::mcset . The function returns the number of translations set. ::msgcat::mcflset src-string ? translate-string ? : Sets the translation for src-string to translate-string in the current namespace for the locale implied by the name of the message catalog being loaded via ::msgcat::mcload . If translate-string is not specified, src-string is used for both. The function returns translate-string . ::msgcat::mcflmset src-trans-list : Sets the translation for multiple source strings in src-trans-list in the current namespace for the locale implied by the name of the message catalog being loaded via ::msgcat::mcload . src-trans-list must have an even number of elements and is in the form { src-string translate-string ? src-string translate-string ... ?} ::msgcat::mcflmset can be significantly faster than multiple invocations of ::msgcat::mcflset . The function returns the number of translations set. ::msgcat::mcunknown locale src-string ? arg arg ... ? : This routine is called by ::msgcat::mc in the case when a translation for src-string is not defined in the current locale. The default action is to return src-string passed by format if there are any arguments. This procedure can be redefined by the application, for example to log error messages for each unknown string. The ::msgcat::mcunknown procedure is invoked at the same stack context as the call to ::msgcat::mc . The return value of ::msgcat::mcunknown is used as the return value for the call to ::msgcat::mc . Note that this routine is only called if the concerned package did not set a package locale unknown command name. ::msgcat::mcforgetpackage : The calling package clears all its state within the msgcat package including all settings and translations. <!-- --> ::msgcat::mcutil getpreferences locale : Return the preferences list of the given locale as described in section LOCALE SPECIFICATION . An example is the composition of a preference list for the bilingual region \\\"Biel/Bienne\\\" as a concatenation of swiss german and swiss french: \\% concat [lrange [msgcat::mcutil getpreferences fr_CH] 0 end-1] [msgcat::mcutil getpreferences de_CH] fr_ch fr de_ch de {} ::msgcat::mcutil getsystemlocale : The system locale is returned as described by the section LOCALE SPECIFICATION .","title":"COMMANDS"},{"location":"msgcat/#locale-specification","text":"The locale is specified to msgcat by a locale string passed to ::msgcat::mclocale . The locale string consists of a language code, an optional country code, and an optional system-specific code, each separated by The country and language codes are specified in standards ISO-639 and ISO-3166. For example, the locale specifies English and specifies U.S. English. When the msgcat package is first loaded, the locale is initialized according to the user\\'s environment. The variables env(LC_ALL) , env(LC_MESSAGES) , and env(LANG) are examined in order. The first of them to have a non-empty value is used to determine the initial locale. The value is parsed according to the XPG4 pattern language[_country][.codeset][@modifier] to extract its parts. The initial locale is then set by calling ::msgcat::mclocale with the argument language[_country][_modifier] On Windows and Cygwin, if none of those environment variables is set, msgcat will attempt to extract locale information from the registry. From Windows Vista on, the RFC4747 locale name \\\"lang-script-country-options\\\" is transformed to the locale as \\\"lang_country_script\\\" (Example: sr-Latn-CS -> sr_cs_latin). For Windows XP, the language id is transformed analoguously (Example: 0c1a -> sr_yu_cyrillic). If all these attempts to discover an initial locale from the user\\'s environment fail, msgcat defaults to an initial locale of When a locale is specified by the user, a search is performed during string translation. For example, if a user specifies en_GB_Funky, the locales and (the empty string) are searched in order until a matching translation string is found. If no translation string is available, then the unknown handler is called.","title":"LOCALE SPECIFICATION"},{"location":"msgcat/#namespaces-and-message-catalogs","text":"Strings stored in the message catalog are stored relative to the namespace from which they were added. This allows multiple packages to use the same strings without fear of collisions with other packages. It also allows the source string to be shorter and less prone to typographical error. For example, executing the code ::msgcat::mcset en hello \\\"hello from ::\\\" namespace eval foo { ::msgcat::mcset en hello \\\"hello from ::foo\\\" } puts [ ::msgcat::mc hello] namespace eval foo {puts [ ::msgcat::mc hello]} will print hello from :: hello from ::foo When searching for a translation of a message, the message catalog will search first the current namespace, then the parent of the current namespace, and so on until the global namespace is reached. This allows child namespaces to messages from their parent namespace. For example, executing (in the locale) the code ::msgcat::mcset en m1 \\\":: message1\\\" ::msgcat::mcset en m2 \\\":: message2\\\" ::msgcat::mcset en m3 \\\":: message3\\\" namespace eval ::foo { ::msgcat::mcset en m2 \\\"::foo message2\\\" ::msgcat::mcset en m3 \\\"::foo message3\\\" } namespace eval ::foo::bar { ::msgcat::mcset en m3 \\\"::foo::bar message3\\\" } namespace import ::msgcat::mc puts \\\"[ mc m1]; [ mc m2]; [ mc m3]\\\" namespace eval ::foo {puts \\\"[ mc m1]; [ mc m2]; [ mc m3]\\\"} namespace eval ::foo::bar {puts \\\"[ mc m1]; [ mc m2]; [ mc m3]\\\"} will print :: message1; :: message2; :: message3 :: message1; ::foo message2; ::foo message3 :: message1; ::foo message2; ::foo::bar message3","title":"NAMESPACES AND MESSAGE CATALOGS"},{"location":"msgcat/#location-and-format-of-message-files","text":"Message files can be located in any directory, subject to the following conditions: [1] : All message files for a package are in the same directory. [2] : The message file name is a msgcat locale specifier (all lowercase) followed by For example: es.msg --- spanish en_gb.msg --- United Kingdom English Exception: The message file for the root locale is called This exception is made so as not to cause peculiar behavior, such as marking the message file as on Unix file systems. [3] : The file contains a series of calls to mcflset and mcflmset , setting the necessary translation strings for the language, likely enclosed in a namespace eval so that all source strings are tied to the namespace of the package. For example, a short es.msg might contain: namespace eval ::mypackage { ::msgcat::mcflset \\\"Free Beer\\\" \\\"Cerveza Gratis\\\" }","title":"LOCATION AND FORMAT OF MESSAGE FILES"},{"location":"msgcat/#recommended-message-setup-for-packages","text":"If a package is installed into a subdirectory of the tcl_pkgPath and loaded via package require , the following procedure is recommended. [1] : During package installation, create a subdirectory msgs under your package directory. [2] : Copy your *.msg files into that directory. [3] : Add the following command to your package initialization script: # load language files, stored in msgs subdirectory ::msgcat::mcload [file join [file dirname [info script]] msgs]","title":"RECOMMENDED MESSAGE SETUP FOR PACKAGES"},{"location":"msgcat/#positional-codes-for-format-and-scan-commands","text":"It is possible that a message string used as an argument to format might have positionally dependent parameters that might need to be repositioned. For example, it might be syntactically desirable to rearrange the sentence structure while translating. format \\\"We produced %d units in location %s\\\" \\$num \\$city format \\\"In location %s we produced %d units\\\" \\$city \\$num This can be handled by using the positional parameters: format \\\"We produced %1\\\\$d units in location %2\\\\$s\\\" \\$num \\$city format \\\"In location %2\\\\$s we produced %1\\\\$d units\\\" \\$num \\$city Similarly, positional parameters can be used with scan to extract values from internationalized strings. Note that it is not necessary to pass the output of ::msgcat::mc to format directly; by passing the values to substitute in as arguments, the formatting substitution is done directly. msgcat::mc {Produced %1\\$d at %2\\$s} \\$num \\$city # ... where that key is mapped to one of the # human-oriented versions by msgcat::mcset","title":"POSITIONAL CODES FOR FORMAT AND SCAN COMMANDS"},{"location":"msgcat/#package-private-locale","text":"A package using msgcat may choose to use its own package private locale and its own set of loaded locales, independent to the global locale set by ::msgcat::mclocale . This allows a package to change its locale without causing any locales load or removal in other packages and not to invoke the global locale change callback (see below). This action is controled by the following ensemble: ::msgcat::mcpackagelocale set ? locale ? : Set or change a package private locale. The package private locale is set to the given locale if the locale is given. If the option locale is not given, the package is set to package private locale mode, but no locale is changed (e.g. if the global locale was valid for the package before, it is copied to the package private locale). This command may cause the load of locales. ::msgcat::mcpackagelocale get : Return the package private locale or the global locale, if no package private locale is set. ::msgcat::mcpackagelocale preferences ? locale preference ? ... : With no parameters, return the package private preferences or the global preferences, if no package private locale is set. The package locale state (set or not) is not changed (in contrast to the command ::msgcat::mcpackagelocale set ). If a set of locale preferences is given, it is set as package locale preference list. The package locale is set to the first element of the preference list. A package locale is activated, if it was not set so far. Locale preferences are loaded now for the package, if not jet loaded. ::msgcat::mcpackagelocale loaded : Return the list of locales loaded for this package. ::msgcat::mcpackagelocale isset : Returns true, if a package private locale is set. ::msgcat::mcpackagelocale unset : Unset the package private locale and use the globale locale. Load and remove locales to adjust the list of loaded locales for the package to the global loaded locales list. ::msgcat::mcpackagelocale present locale : Returns true, if the given locale is loaded for the package. ::msgcat::mcpackagelocale clear : Clear any loaded locales of the package not present in the package preferences.","title":"PACKAGE PRIVATE LOCALE"},{"location":"msgcat/#changing-package-options","text":"Each package using msgcat has a set of options within msgcat . The package options are described in the next sectionPackage options. Each package option may be set or unset individually using the following ensemble: ::msgcat::mcpackageconfig get option : Return the current value of the given option . This call returns an error if the option is not set for the package. ::msgcat::mcpackageconfig isset option : Returns 1, if the given option is set for the package, 0 otherwise. ::msgcat::mcpackageconfig set option value : Set the given option to the given value . This may invoke additional actions in dependency of the option . The return value is 0 or the number of loaded packages for the option mcfolder . ::msgcat::mcpackageconfig unset option : Unsets the given option for the package. No action is taken if the option is not set for the package. The empty string is returned.","title":"CHANGING PACKAGE OPTIONS"},{"location":"msgcat/#package-options","text":"The following package options are available for each package: mcfolder : This is the message folder of the package. This option is set by mcload and by the subcommand set. Both are identical and both return the number of loaded message catalog files. Setting or changing this value will load all locales contained in the preferences valid for the package. This implies also to invoke any set loadcmd (see below). Unsetting this value will disable message file load for the package. loadcmd : This callback is invoked before a set of message catalog files are loaded for the package which has this property set. This callback may be used to do any preparation work for message file load or to get the message data from another source like a data base. In this case, no message files are used (mcfolder is unset). See section callback invocation below. The parameter list appended to this callback is the list of locales to load. If this callback is changed, it is called with the preferences valid for the package. changecmd : This callback is invoked when a default local change was performed. Its purpose is to allow a package to update any dependency on the default locale like showing the GUI in another language. See the callback invocation section below. The parameter list appended to this callback is mcpreferences . The registered callbacks are invoked in no particular order. unknowncmd : Use a package locale mcunknown procedure instead of the standard version supplied by the msgcat package (msgcat::mcunknown). The called procedure must return the formatted message which will finally be returned by msgcat::mc. A generic unknown handler is used if set to the empty string. This consists in returning the key if no arguments are given. With given arguments, format is used to process the arguments. See section callback invocation below. The appended arguments are identical to ::msgcat::mcunknown .","title":"Package options"},{"location":"msgcat/#callback-invocation","text":"A package may decide to register one or multiple callbacks, as described above. Callbacks are invoked, if: 1. the callback command is set, 2. the command is not the empty string, 3. the registering namespace exists. If a called routine fails with an error, the bgerror routine for the interpreter is invoked after command completion. Only exception is the callback unknowncmd , where an error causes the invoking mc -command to fail with that error.","title":"Callback invocation"},{"location":"msgcat/#object-oriented-programming","text":"msgcat supports packages implemented by object oriented programming. Objects and classes should be defined within a package namespace. There are 3 supported cases where package namespace sensitive commands of msgcat ( mc , mcexists , mcpackagelocale , mcforgetpackage , mcpackagenamespaceget , mcpackageconfig , mcset and mcmset ) may be called: 1) In class definition script : msgcat command is called within a class definition script. namespace eval ::N2 { mcload \\$dir/msgs oo::class create C1 {puts [mc Hi!]} } 2) method defined in a class : msgcat command is called from a method in an object and the method is defined in a class. namespace eval ::N3Class { mcload \\$dir/msgs oo::class create C1 oo::define C1 method m1 { puts [mc Hi!] } } 3) method defined in a classless object : msgcat command is called from a method of a classless object. namespace eval ::N4 { mcload \\$dir/msgs oo::object create O1 oo::objdefine O1 method m1 {} { puts [mc Hi!] } }","title":"OBJECT ORIENTED PROGRAMMING"},{"location":"msgcat/#examples","text":"Packages which display a GUI may update their widgets when the global locale changes. To register to a callback, use: namespace eval gui { msgcat::mcpackageconfig changecmd updateGUI proc updateGUI args { puts \\\"New locale is \\'[lindex \\$args 0]\\'.\\\" } } % msgcat::mclocale fr fr % New locale is \\'fr\\'. If locales (or additional locales) are contained in another source like a data base, a package may use the load callback and not mcload: namespace eval db { msgcat::mcpackageconfig loadcmd loadMessages proc loadMessages args { foreach locale \\$args { if {[LocaleInDB \\$locale]} { msgcat::mcmset \\$locale [GetLocaleList \\$locale] } } } } The clock command implementation uses msgcat with a package locale to implement the command line parameter -locale . Here are some sketches of the implementation: First, a package locale is initialized and the generic unknown function is desactivated: msgcat::mcpackagelocale set msgcat::mcpackageconfig unknowncmd \\\"\\\" As an example, the user requires the week day in a certain locale as follows: clock format [clock seconds] -format %A -locale fr clock sets the package locale to fr and looks for the day name as follows: msgcat::mcpackagelocale set \\$locale return [lindex [msgcat::mc DAYS_OF_WEEK_FULL] \\$day] ### Returns \\\"mercredi\\\" Within clock , some message-catalog items are heavy in computation and thus are dynamically cached using: proc ::tcl::clock::LocalizeFormat { locale format } { set key FORMAT_\\$format if { [::msgcat::mcexists -exactlocale -exactnamespace \\$key] } { return [mc \\$key] } #...expensive computation of format clipped... mcset \\$locale \\$key \\$format return \\$format }","title":"EXAMPLES"},{"location":"msgcat/#credits","text":"The message catalog code was developed by Mark Harrison.","title":"CREDITS"},{"location":"msgcat/#see-also","text":"format(n), scan(n), namespace(n), package(n), oo::class(n), oo::object","title":"SEE ALSO"},{"location":"msgcat/#keywords","text":"internationalization, i18n, localization, l10n, message, text, translation, class, object","title":"KEYWORDS"},{"location":"my/","text":"NAME my, myclass - invoke any method of current object or its class SYNOPSIS package require tcl::oo my methodName ?arg ...? myclass methodName ?arg ...? DESCRIPTION The my command is used to allow methods of objects to invoke methods of the object (or its class), and the myclass command is used to allow methods of objects to invoke methods of the current class of the object as an object . In particular, the set of valid values for methodName is the set of all methods supported by an object and its superclasses, including those that are not exported and private methods of the object or class when used within another method defined by that object or class. The object upon which the method is invoked via my is the one that owns the namespace that the my command is contained in initially ( NB: the link remains if the command is renamed), which is the currently invoked object by default. Similarly, the object on which the method is invoked via myclass is the object that is the current class of the object that owns the namespace that the myclass command is contained in initially. As with my , the link remains even if the command is renamed into another namespace, and defaults to being the manufacturing class of the current object. Each object has its own my and myclass commands, contained in its instance namespace. EXAMPLES This example shows basic use of my to use the variables method of the oo::object class, which is not publicly visible by default: oo::class create c { method count {} { my variable counter puts [incr counter] } } c create o o count \u2192 prints \\\"1\\\" o count \u2192 prints \\\"2\\\" o count \u2192 prints \\\"3\\\" This example shows how you can use my to make callbacks to private methods from outside the object (from a trace ), using namespace code to enter the correct context. (See the callback command for the recommended way of doing this.) oo::class create HasCallback { method makeCallback {} { return [namespace code { my Callback }] } method Callback {args} { puts \\\"callback: \\$args\\\" } } set o [HasCallback new] trace add variable xyz write [\\$o makeCallback] set xyz \\\"called\\\" \u2192 prints \\\"callback: xyz {} write\\\" This example shows how to access a private method of a class from an instance of that class. (See the classmethod declaration in oo::define for a higher level interface for doing this.) oo::class create CountedSteps { self { variable count method Count {} { return [incr count] } } method advanceTwice {} { puts \\\"in [self] step A: [ myclass Count]\\\" puts \\\"in [self] step B: [ myclass Count]\\\" } } CountedSteps create x CountedSteps create y x advanceTwice \u2192 prints \\\"in ::x step A: 1\\\" \u2192 prints \\\"in ::x step B: 2\\\" y advanceTwice \u2192 prints \\\"in ::y step A: 3\\\" \u2192 prints \\\"in ::y step B: 4\\\" x advanceTwice \u2192 prints \\\"in ::x step A: 5\\\" \u2192 prints \\\"in ::x step B: 6\\\" y advanceTwice \u2192 prints \\\"in ::y step A: 7\\\" \u2192 prints \\\"in ::y step B: 8\\\" SEE ALSO next(n), oo::object(n), self(n) KEYWORDS method, method visibility, object, private method, public method","title":"NAME"},{"location":"my/#name","text":"my, myclass - invoke any method of current object or its class","title":"NAME"},{"location":"my/#synopsis","text":"package require tcl::oo my methodName ?arg ...? myclass methodName ?arg ...?","title":"SYNOPSIS"},{"location":"my/#description","text":"The my command is used to allow methods of objects to invoke methods of the object (or its class), and the myclass command is used to allow methods of objects to invoke methods of the current class of the object as an object . In particular, the set of valid values for methodName is the set of all methods supported by an object and its superclasses, including those that are not exported and private methods of the object or class when used within another method defined by that object or class. The object upon which the method is invoked via my is the one that owns the namespace that the my command is contained in initially ( NB: the link remains if the command is renamed), which is the currently invoked object by default. Similarly, the object on which the method is invoked via myclass is the object that is the current class of the object that owns the namespace that the myclass command is contained in initially. As with my , the link remains even if the command is renamed into another namespace, and defaults to being the manufacturing class of the current object. Each object has its own my and myclass commands, contained in its instance namespace.","title":"DESCRIPTION"},{"location":"my/#examples","text":"This example shows basic use of my to use the variables method of the oo::object class, which is not publicly visible by default: oo::class create c { method count {} { my variable counter puts [incr counter] } } c create o o count \u2192 prints \\\"1\\\" o count \u2192 prints \\\"2\\\" o count \u2192 prints \\\"3\\\" This example shows how you can use my to make callbacks to private methods from outside the object (from a trace ), using namespace code to enter the correct context. (See the callback command for the recommended way of doing this.) oo::class create HasCallback { method makeCallback {} { return [namespace code { my Callback }] } method Callback {args} { puts \\\"callback: \\$args\\\" } } set o [HasCallback new] trace add variable xyz write [\\$o makeCallback] set xyz \\\"called\\\" \u2192 prints \\\"callback: xyz {} write\\\" This example shows how to access a private method of a class from an instance of that class. (See the classmethod declaration in oo::define for a higher level interface for doing this.) oo::class create CountedSteps { self { variable count method Count {} { return [incr count] } } method advanceTwice {} { puts \\\"in [self] step A: [ myclass Count]\\\" puts \\\"in [self] step B: [ myclass Count]\\\" } } CountedSteps create x CountedSteps create y x advanceTwice \u2192 prints \\\"in ::x step A: 1\\\" \u2192 prints \\\"in ::x step B: 2\\\" y advanceTwice \u2192 prints \\\"in ::y step A: 3\\\" \u2192 prints \\\"in ::y step B: 4\\\" x advanceTwice \u2192 prints \\\"in ::x step A: 5\\\" \u2192 prints \\\"in ::x step B: 6\\\" y advanceTwice \u2192 prints \\\"in ::y step A: 7\\\" \u2192 prints \\\"in ::y step B: 8\\\"","title":"EXAMPLES"},{"location":"my/#see-also","text":"next(n), oo::object(n), self(n)","title":"SEE ALSO"},{"location":"my/#keywords","text":"method, method visibility, object, private method, public method","title":"KEYWORDS"},{"location":"next/","text":"NAME next, nextto - invoke superclass method implementations SYNOPSIS package require tcl::oo next ?arg ...? nextto class ?arg ...? DESCRIPTION The next command is used to call implementations of a method by a class, superclass or mixin that are overridden by the current method. It can only be used from within a method. It is also used within filters to indicate the point where a filter calls the actual implementation (the filter may decide to not go along the chain, and may process the results of going along the chain of methods as it chooses). The result of the next command is the result of the next method in the method chain; if there are no further methods in the method chain, the result of next will be an error. The arguments, arg , to next are the arguments to pass to the next method in the chain. The nextto command is the same as the next command, except that it takes an additional class argument that identifies a class whose implementation of the current method chain (see info object call ) should be used; the method implementation selected will be the one provided by the given class, and it must refer to an existing non-filter invocation that lies further along the chain than the current implementation. THE METHOD CHAIN When a method of an object is invoked, things happen in several stages: [1] : The structure of the object, its class, superclasses, filters, and mixins, are examined to build a method chain , which contains a list of method implementations to invoke. [2] : The first method implementation on the chain is invoked. [3] : If that method implementation invokes the next command, the next method implementation is invoked (with its arguments being those that were passed to next ). [4] : The result from the overall method call is the result from the outermost method implementation; inner method implementations return their results through next . [5] : The method chain is cached for future use. METHOD SEARCH ORDER When constructing the method chain, method implementations are searched for in the following order: [1] : In the classes mixed into the object, in class traversal order. The list of mixins is checked in natural order. [2] : In the classes mixed into the classes of the object, with sources of mixing in being searched in class traversal order. Within each class, the list of mixins is processed in natural order. [3] : In the object itself. [4] : In the object\\'s class. [5] : In the superclasses of the class, following each superclass in a depth-first fashion in the natural order of the superclass list. Any particular method implementation always comes as late in the resulting list of implementations as possible; this means that if some class, A, is both mixed into a class, B, and is also a superclass of B, the instances of B will always treat A as a superclass from the perspective of inheritance. This is true even when the multiple inheritance is processed indirectly. FILTERS When an object has a list of filter names set upon it, or is an instance of a class (or has mixed in a class) that has a list of filter names set upon it, before every invocation of any method the filters are processed. Filter implementations are found in class traversal order, as are the lists of filter names (each of which is traversed in natural list order). Explicitly invoking a method used as a filter will cause that method to be invoked twice, once as a filter and once as a normal method. Each filter should decide for itself whether to permit the execution to go forward to the proper implementation of the method (which it does by invoking the next command as filters are inserted into the front of the method call chain) and is responsible for returning the result of next . Filters are invoked when processing an invocation of the unknown method because of a failure to locate a method implementation, but not when invoking either constructors or destructors. (Note however that the destroy method is a conventional method, and filters are invoked as normal when it is called.) EXAMPLES This example demonstrates how to use the next command to call the (super)class\\'s implementation of a method. The script: oo::class create theSuperclass { method example {args} { puts \\\"in the superclass, args = \\$args\\\" } } oo::class create theSubclass { superclass theSuperclass method example {args} { puts \\\"before chaining from subclass, args = \\$args\\\" next a {*}\\$args b next pureSynthesis puts \\\"after chaining from subclass\\\" } } theSubclass create obj oo::objdefine obj method example args { puts \\\"per-object method, args = \\$args\\\" next x {*}\\$args y next } obj example 1 2 3 prints the following: per-object method, args = 1 2 3 before chaining from subclass, args = x 1 2 3 y in the superclass, args = a x 1 2 3 y b in the superclass, args = pureSynthesis after chaining from subclass before chaining from subclass, args = in the superclass, args = a b in the superclass, args = pureSynthesis after chaining from subclass This example demonstrates how to build a simple cache class that applies memoization to all the method calls of the objects it is mixed into, and shows how it can make a difference to computation times: oo::class create cache { filter Memoize method Memoize args { # Do not filter the core method implementations if {[lindex [self target] 0] eq \\\"::oo::object\\\"} { return [ next {*}\\$args] } # Check if the value is already in the cache my variable ValueCache set key [self target],\\$args if {[info exist ValueCache(\\$key)]} { return \\$ValueCache(\\$key) } # Compute value, insert into cache, and return it return [set ValueCache(\\$key) [ next {*}\\$args]] } method flushCache {} { my variable ValueCache unset ValueCache # Skip the caching return -level 2 \\\"\\\" } } oo::object create demo oo::objdefine demo { mixin cache method compute {a b c} { after 3000 ;# Simulate deep thought return [expr {\\$a + \\$b * \\$c}] } method compute2 {a b c} { after 3000 ;# Simulate deep thought return [expr {\\$a * \\$b + \\$c}] } } puts [demo compute 1 2 3] \u2192 prints \\\"7\\\" after delay puts [demo compute2 4 5 6] \u2192 prints \\\"26\\\" after delay puts [demo compute 1 2 3] \u2192 prints \\\"7\\\" instantly puts [demo compute2 4 5 6] \u2192 prints \\\"26\\\" instantly puts [demo compute 4 5 6] \u2192 prints \\\"34\\\" after delay puts [demo compute 4 5 6] \u2192 prints \\\"34\\\" instantly puts [demo compute 1 2 3] \u2192 prints \\\"7\\\" instantly demo flushCache puts [demo compute 1 2 3] \u2192 prints \\\"7\\\" after delay SEE ALSO oo::class(n), oo::define(n), oo::object(n), self(n) KEYWORDS call, method, method chain","title":"NAME"},{"location":"next/#name","text":"next, nextto - invoke superclass method implementations","title":"NAME"},{"location":"next/#synopsis","text":"package require tcl::oo next ?arg ...? nextto class ?arg ...?","title":"SYNOPSIS"},{"location":"next/#description","text":"The next command is used to call implementations of a method by a class, superclass or mixin that are overridden by the current method. It can only be used from within a method. It is also used within filters to indicate the point where a filter calls the actual implementation (the filter may decide to not go along the chain, and may process the results of going along the chain of methods as it chooses). The result of the next command is the result of the next method in the method chain; if there are no further methods in the method chain, the result of next will be an error. The arguments, arg , to next are the arguments to pass to the next method in the chain. The nextto command is the same as the next command, except that it takes an additional class argument that identifies a class whose implementation of the current method chain (see info object call ) should be used; the method implementation selected will be the one provided by the given class, and it must refer to an existing non-filter invocation that lies further along the chain than the current implementation.","title":"DESCRIPTION"},{"location":"next/#the-method-chain","text":"When a method of an object is invoked, things happen in several stages: [1] : The structure of the object, its class, superclasses, filters, and mixins, are examined to build a method chain , which contains a list of method implementations to invoke. [2] : The first method implementation on the chain is invoked. [3] : If that method implementation invokes the next command, the next method implementation is invoked (with its arguments being those that were passed to next ). [4] : The result from the overall method call is the result from the outermost method implementation; inner method implementations return their results through next . [5] : The method chain is cached for future use.","title":"THE METHOD CHAIN"},{"location":"next/#method-search-order","text":"When constructing the method chain, method implementations are searched for in the following order: [1] : In the classes mixed into the object, in class traversal order. The list of mixins is checked in natural order. [2] : In the classes mixed into the classes of the object, with sources of mixing in being searched in class traversal order. Within each class, the list of mixins is processed in natural order. [3] : In the object itself. [4] : In the object\\'s class. [5] : In the superclasses of the class, following each superclass in a depth-first fashion in the natural order of the superclass list. Any particular method implementation always comes as late in the resulting list of implementations as possible; this means that if some class, A, is both mixed into a class, B, and is also a superclass of B, the instances of B will always treat A as a superclass from the perspective of inheritance. This is true even when the multiple inheritance is processed indirectly.","title":"METHOD SEARCH ORDER"},{"location":"next/#filters","text":"When an object has a list of filter names set upon it, or is an instance of a class (or has mixed in a class) that has a list of filter names set upon it, before every invocation of any method the filters are processed. Filter implementations are found in class traversal order, as are the lists of filter names (each of which is traversed in natural list order). Explicitly invoking a method used as a filter will cause that method to be invoked twice, once as a filter and once as a normal method. Each filter should decide for itself whether to permit the execution to go forward to the proper implementation of the method (which it does by invoking the next command as filters are inserted into the front of the method call chain) and is responsible for returning the result of next . Filters are invoked when processing an invocation of the unknown method because of a failure to locate a method implementation, but not when invoking either constructors or destructors. (Note however that the destroy method is a conventional method, and filters are invoked as normal when it is called.)","title":"FILTERS"},{"location":"next/#examples","text":"This example demonstrates how to use the next command to call the (super)class\\'s implementation of a method. The script: oo::class create theSuperclass { method example {args} { puts \\\"in the superclass, args = \\$args\\\" } } oo::class create theSubclass { superclass theSuperclass method example {args} { puts \\\"before chaining from subclass, args = \\$args\\\" next a {*}\\$args b next pureSynthesis puts \\\"after chaining from subclass\\\" } } theSubclass create obj oo::objdefine obj method example args { puts \\\"per-object method, args = \\$args\\\" next x {*}\\$args y next } obj example 1 2 3 prints the following: per-object method, args = 1 2 3 before chaining from subclass, args = x 1 2 3 y in the superclass, args = a x 1 2 3 y b in the superclass, args = pureSynthesis after chaining from subclass before chaining from subclass, args = in the superclass, args = a b in the superclass, args = pureSynthesis after chaining from subclass This example demonstrates how to build a simple cache class that applies memoization to all the method calls of the objects it is mixed into, and shows how it can make a difference to computation times: oo::class create cache { filter Memoize method Memoize args { # Do not filter the core method implementations if {[lindex [self target] 0] eq \\\"::oo::object\\\"} { return [ next {*}\\$args] } # Check if the value is already in the cache my variable ValueCache set key [self target],\\$args if {[info exist ValueCache(\\$key)]} { return \\$ValueCache(\\$key) } # Compute value, insert into cache, and return it return [set ValueCache(\\$key) [ next {*}\\$args]] } method flushCache {} { my variable ValueCache unset ValueCache # Skip the caching return -level 2 \\\"\\\" } } oo::object create demo oo::objdefine demo { mixin cache method compute {a b c} { after 3000 ;# Simulate deep thought return [expr {\\$a + \\$b * \\$c}] } method compute2 {a b c} { after 3000 ;# Simulate deep thought return [expr {\\$a * \\$b + \\$c}] } } puts [demo compute 1 2 3] \u2192 prints \\\"7\\\" after delay puts [demo compute2 4 5 6] \u2192 prints \\\"26\\\" after delay puts [demo compute 1 2 3] \u2192 prints \\\"7\\\" instantly puts [demo compute2 4 5 6] \u2192 prints \\\"26\\\" instantly puts [demo compute 4 5 6] \u2192 prints \\\"34\\\" after delay puts [demo compute 4 5 6] \u2192 prints \\\"34\\\" instantly puts [demo compute 1 2 3] \u2192 prints \\\"7\\\" instantly demo flushCache puts [demo compute 1 2 3] \u2192 prints \\\"7\\\" after delay","title":"EXAMPLES"},{"location":"next/#see-also","text":"oo::class(n), oo::define(n), oo::object(n), self(n)","title":"SEE ALSO"},{"location":"next/#keywords","text":"call, method, method chain","title":"KEYWORDS"},{"location":"open/","text":"NAME open - Open a file-based or command pipeline channel SYNOPSIS open fileName \\ open fileName access \\ open fileName access permissions DESCRIPTION This command opens a file, serial port, or command pipeline and returns a channel identifier that may be used in future invocations of commands like read , puts , and close . If the first character of fileName is not | then the command opens a file: fileName gives the name of the file to open, and it must conform to the conventions described in the filename manual entry. The access argument, if present, indicates the way in which the file (or command pipeline) is to be accessed. In the first form access may have any of the following values: r : Open the file for reading only; the file must already exist. This is the default value if access is not specified. r+ : Open the file for both reading and writing; the file must already exist. w : Open the file for writing only. Truncate it if it exists. If it does not exist, create a new file. w+ : Open the file for reading and writing. Truncate it if it exists. If it does not exist, create a new file. a : Open the file for writing only. If the file does not exist, create a new empty file. Set the file pointer to the end of the file prior to each write. a+ : Open the file for reading and writing. If the file does not exist, create a new empty file. Set the initial access position to the end of the file. All of the legal access values above may have the character b added as the second or third character in the value to indicate that the opened channel should be configured as if with the fconfigure -translation binary option, making the channel suitable for reading or writing of binary data. In the second form, access consists of a list of any of the following flags, most of which have the standard POSIX meanings. One of the flags must be either RDONLY , WRONLY or RDWR . RDONLY : Open the file for reading only. WRONLY : Open the file for writing only. RDWR : Open the file for both reading and writing. APPEND : Set the file pointer to the end of the file prior to each write. BINARY : Configure the opened channel with the -translation binary option. CREAT : Create the file if it does not already exist (without this flag it is an error for the file not to exist). EXCL : If CREAT is also specified, an error is returned if the file already exists. NOCTTY : If the file is a terminal device, this flag prevents the file from becoming the controlling terminal of the process. NONBLOCK : Prevents the process from blocking while opening the file, and possibly in subsequent I/O operations. The exact behavior of this flag is system- and device-dependent; its use is discouraged (it is better to use the fconfigure command to put a file in nonblocking mode). For details refer to your system documentation on the open system call\\'s O_NONBLOCK flag. TRUNC : If the file exists it is truncated to zero length. If a new file is created as part of opening it, permissions (an integer) is used to set the permissions for the new file in conjunction with the process\\'s file mode creation mask. Permissions defaults to 0666. COMMAND PIPELINES If the first character of fileName is then the remaining characters of fileName are treated as a list of arguments that describe a command pipeline to invoke, in the same style as the arguments for exec . In this case, the channel identifier returned by open may be used to write to the command\\'s input pipe or read from its output pipe, depending on the value of access . If write-only access is used (e.g. access is then standard output for the pipeline is directed to the current standard output unless overridden by the command. If read-only access is used (e.g. access is standard input for the pipeline is taken from the current standard input unless overridden by the command. The id of the spawned process is accessible through the pid command, using the channel id returned by open as argument. If the command (or one of the commands) executed in the command pipeline returns an error (according to the definition in exec ), a Tcl error is generated when close is called on the channel unless the pipeline is in non-blocking mode then no exit status is returned (a silent close with -blocking 0). It is often useful to use the fileevent command with pipelines so other processing may happen at the same time as running the command in the background. SERIAL COMMUNICATIONS If fileName refers to a serial port, then the specified serial port is opened and initialized in a platform-dependent manner. Acceptable values for the fileName to use to open a serial port are described in the PORTABILITY ISSUES section. The chan configure and fconfigure commands can be used to query and set additional configuration options specific to serial ports (where supported): -mode baud , parity , data , stop : This option is a set of 4 comma-separated values: the baud rate, parity, number of data bits, and number of stop bits for this serial port. The baud rate is a simple integer that specifies the connection speed. Parity is one of the following letters: n , o , e , m , s ; respectively signifying the parity options of or Data is the number of data bits and should be an integer from 5 to 8, while stop is the number of stop bits and should be the integer 1 or 2. -handshake type : (Windows and Unix). This option is used to setup automatic handshake control. Note that not all handshake types maybe supported by your operating system. The type parameter is case-independent. If *type* is **none** then any handshake is switched off. **rtscts** activates hardware handshake. Hardware handshake signals are described below. For software handshake **xonxoff** the handshake characters can be redefined with **-xchar**. An additional hardware handshake **dtrdsr** is available only under Windows. There is no default handshake configuration, the initial value depends on your operating system settings. The **-handshake** option cannot be queried. -queue : (Windows and Unix). The -queue option can only be queried. It returns a list of two integers representing the current number of bytes in the input and output queue respectively. -timeout msec : (Windows and Unix). This option is used to set the timeout for blocking read operations. It specifies the maximum interval between the reception of two bytes in milliseconds. For Unix systems the granularity is 100 milliseconds. The -timeout option does not affect write operations or nonblocking reads. This option cannot be queried. -ttycontrol {signal boolean signal boolean ...} : (Windows and Unix). This option is used to setup the handshake output lines (see below) permanently or to send a BREAK over the serial line. The signal names are case-independent. {RTS 1 DTR 0} sets the RTS output to high and the DTR output to low. The BREAK condition (see below) is enabled and disabled with {BREAK 1} and {BREAK 0} respectively. It is not a good idea to change the RTS (or DTR ) signal with active hardware handshake rtscts (or dtrdsr ). The result is unpredictable. The -ttycontrol option cannot be queried. -ttystatus : (Windows and Unix). The -ttystatus option can only be queried. It returns the current modem status and handshake input signals (see below). The result is a list of signal,value pairs with a fixed order, e.g. {CTS 1 DSR 0 RING 1 DCD 0} . The signal names are returned upper case. -xchar {xonChar xoffChar} : (Windows and Unix). This option is used to query or change the software handshake characters. Normally the operating system default should be DC1 (0x11) and DC3 (0x13) representing the ASCII standard XON and XOFF characters. -closemode closeMode : (Windows and Unix). This option is used to query or change the close mode of the serial channel, which defines how pending output in operating system buffers is handled when the channel is closed. The following values for closeMode are supported: default : indicates that a system default operation should be used; all serial channels default to this. discard : indicates that the contents of the OS buffers should be discarded. Note that this is not recommended when writing to a POSIX terminal, as it can interact unexpectedly with handling of stderr . drain : indicates that Tcl should wait when closing the channel until all output has been consumed. This may slow down close noticeably. -inputmode inputMode : (Unix only; Windows has the equivalent option on console channels). This option is used to query or change the input mode of the serial channel under the assumption that it is talking to a terminal, which controls how interactive input from users is handled. The following values for inputMode are supported: normal : indicates that normal line-oriented input should be used, with standard terminal editing capabilities enabled. password : indicates that non-echoing input should be used, with standard terminal editing capabilities enabled but no writing of typed characters to the terminal (except for newlines). Some terminals may indicate this specially. raw : indicates that all keyboard input should be given directly to Tcl with the terminal doing no processing at all. It does not echo the keys, leaving it up to the Tcl script to interpret what to do. reset (set only) : indicates that the terminal should be reset to what state it was in when the terminal was opened. Note that setting this option (technically, anything that changes the terminal state from its initial value via this option ) will cause the channel to turn on an automatic reset of the terminal when the channel is closed. -winsize : (Unix only; Windows has the equivalent option on console channels). This option is query only. It retrieves a two-element list with the the current width and height of the terminal. <!-- --> -pollinterval msec : (Windows only). This option is used to set the maximum time between polling for fileevents. This affects the time interval between checking for events throughout the Tcl interpreter (the smallest value always wins). Use this option only if you want to poll the serial port more or less often than 10 msec (the default). -sysbuffer inSize : -sysbuffer {inSize outSize} : (Windows only). This option is used to change the size of Windows system buffers for a serial channel. Especially at higher communication rates the default input buffer size of 4096 bytes can overrun for latent systems. The first form specifies the input buffer size, in the second form both input and output buffers are defined. -lasterror : (Windows only). This option is query only. In case of a serial communication error, read or puts returns a general Tcl file I/O error. fconfigure -lasterror can be called to get a list of error details. See below for an explanation of the various error codes. SERIAL PORT SIGNALS RS-232 is the most commonly used standard electrical interface for serial communications. A negative voltage (-3V..-12V) define a mark (on=1) bit and a positive voltage (+3..+12V) define a space (off=0) bit (RS-232C). The following signals are specified for incoming and outgoing data, status lines and handshaking. Here we are using the terms workstation for your computer and modem for the external device, because some signal names (DCD, RI) come from modems. Of course your external device may use these signal lines for other purposes. TXD(output) : Transmitted Data: Outgoing serial data. RXD(input) : Received Data: Incoming serial data. RTS(output) : Request To Send: This hardware handshake line informs the modem that your workstation is ready to receive data. Your workstation may automatically reset this signal to indicate that the input buffer is full. CTS(input) : Clear To Send: The complement to RTS. Indicates that the modem is ready to receive data. DTR(output) : Data Terminal Ready: This signal tells the modem that the workstation is ready to establish a link. DTR is often enabled automatically whenever a serial port is opened. DSR(input) : Data Set Ready: The complement to DTR. Tells the workstation that the modem is ready to establish a link. DCD(input) : Data Carrier Detect: This line becomes active when a modem detects a signal. RI(input) : Ring Indicator: Goes active when the modem detects an incoming call. BREAK : A BREAK condition is not a hardware signal line, but a logical zero on the TXD or RXD lines for a long period of time, usually 250 to 500 milliseconds. Normally a receive or transmit data signal stays at the mark (on=1) voltage until the next character is transferred. A BREAK is sometimes used to reset the communications line or change the operating mode of communications hardware. ERROR CODES (Windows only) A lot of different errors may occur during serial read operations or during event polling in background. The external device may have been switched off, the data lines may be noisy, system buffers may overrun or your mode settings may be wrong. That is why a reliable software should always catch serial read operations. In cases of an error Tcl returns a general file I/O error. Then fconfigure -lasterror may help to locate the problem. The following error codes may be returned. RXOVER : Windows input buffer overrun. The data comes faster than your scripts reads it or your system is overloaded. Use fconfigure -sysbuffer to avoid a temporary bottleneck and/or make your script faster. TXFULL : Windows output buffer overrun. Complement to RXOVER. This error should practically not happen, because Tcl cares about the output buffer status. OVERRUN : UART buffer overrun (hardware) with data lost. The data comes faster than the system driver receives it. Check your advanced serial port settings to enable the FIFO (16550) buffer and/or setup a lower(1) interrupt threshold value. RXPARITY : A parity error has been detected by your UART. Wrong parity settings with fconfigure -mode or a noisy data line (RXD) may cause this error. FRAME : A stop-bit error has been detected by your UART. Wrong mode settings with fconfigure -mode or a noisy data line (RXD) may cause this error. BREAK : A BREAK condition has been detected by your UART (see above). PORTABILITY ISSUES Windows : Valid values for fileName to open a serial port are of the form com X , where X is a number, generally from 1 to 9. A legacy form accepted as well is com X : . This notation only works for serial ports from 1 to 9. An attempt to open a serial port that does not exist or has a number greater than 9 will fail. An alternate form of opening serial ports is to use the filename //./comX , where X is any number that corresponds to a serial port. When running Tcl interactively, there may be some strange interactions between the real console, if one is present, and a command pipeline that uses standard input or output. If a command pipeline is opened for reading, some of the lines entered at the console will be sent to the command pipeline and some will be sent to the Tcl evaluator. If a command pipeline is opened for writing, keystrokes entered into the console are not visible until the pipe is closed. These problems only occur because both Tcl and the child application are competing for the console at the same time. If the command pipeline is started from a script, so that Tcl is not accessing the console, or if the command pipeline does not use standard input or output, but is redirected from or to a file, then the above problems do not occur. Files opened in the mode or with the APPEND flag set are implemented by seeking immediately before each write, which is not an atomic operation and does not carry the guarantee of strict appending that is present on POSIX platforms. Unix \u2007\u2007\u2007\u2007\u2007\u2007\u2007 : Valid values for fileName to open a serial port are generally of the form /dev/tty X , where X is a or b , but the name of any pseudo-file that maps to a serial port may be used. Advanced configuration options are only supported for serial ports when Tcl is built to use the POSIX serial interface. When running Tcl interactively, there may be some strange interactions between the console, if one is present, and a command pipeline that uses standard input. If a command pipeline is opened for reading, some of the lines entered at the console will be sent to the command pipeline and some will be sent to the Tcl evaluator. This problem only occurs because both Tcl and the child application are competing for the console at the same time. If the command pipeline is started from a script, so that Tcl is not accessing the console, or if the command pipeline does not use standard input, but is redirected from a file, then the above problem does not occur. See the PORTABILITY ISSUES section of the exec command for additional information not specific to command pipelines about executing applications on the various platforms CONSOLE CHANNELS On Windows only, console channels (usually stdin or stdout ) support the following options: -inputmode inputMode : This option is used to query or change the input mode of the console channel, which controls how interactive input from users is handled. The following values for inputMode are supported: **normal** : indicates that normal line-oriented input should be used, with standard console editing capabilities enabled. **password** : indicates that non-echoing input should be used, with standard console editing capabilitied enabled but no writing of typed characters to the terminal (except for newlines). **raw** : indicates that all keyboard input should be given directly to Tcl with the console doing no processing at all. It does not echo the keys, leaving it up to the Tcl script to interpret what to do. **reset** (set only) : indicates that the console should be reset to what state it was in when the console channel was opened. Note that setting this option (technically, anything that changes the console state from its default *via this option*) will cause the channel to turn on an automatic reset of the console when the channel is closed. -winsize : This option is query only. It retrieves a two-element list with the the current width and height of the console that this channel is talking to. Note that the equivalent options exist on Unix, but are on the serial channel type. EXAMPLES Open a file for writing, forcing it to be created and raising an error if it already exists. set myNewFile [ open filename.txt {WRONLY CREAT EXCL}] Open a file for writing as a log file. set myLogFile [ open filename.log \\\"a\\\"] fconfigure \\$myLogFile -buffering line Open a command pipeline and catch any errors: set fl [ open \\\"| ls this_file_does_not_exist\\\"] set data [read \\$fl] if {[catch {close \\$fl} err]} { puts \\\"ls command failed: \\$err\\\" } Open a command pipeline and read binary data from it. Note the unusual form with that handles non-trivial edge cases with arguments that potentially have spaces in. set fl [ open |[list create_image_data \\$input] \\\"rb\\\"] set binData [read \\$fl] close \\$fl Read a password securely from the user (assuming that the script is being run interactively): chan configure stdin -inputmode password try { chan puts -nonewline \\\"Password: \\\" chan flush stdout set thePassword [chan gets stdin] } finally { chan configure stdin -inputmode reset } SEE ALSO file(n), close(n), filename(n), fconfigure(n), gets(n), read(n), puts(n), exec(n), pid(n), fopen(3) KEYWORDS access mode, append, create, file, non-blocking, open, permissions, pipeline, process, serial","title":"NAME"},{"location":"open/#name","text":"open - Open a file-based or command pipeline channel","title":"NAME"},{"location":"open/#synopsis","text":"open fileName \\ open fileName access \\ open fileName access permissions","title":"SYNOPSIS"},{"location":"open/#description","text":"This command opens a file, serial port, or command pipeline and returns a channel identifier that may be used in future invocations of commands like read , puts , and close . If the first character of fileName is not | then the command opens a file: fileName gives the name of the file to open, and it must conform to the conventions described in the filename manual entry. The access argument, if present, indicates the way in which the file (or command pipeline) is to be accessed. In the first form access may have any of the following values: r : Open the file for reading only; the file must already exist. This is the default value if access is not specified. r+ : Open the file for both reading and writing; the file must already exist. w : Open the file for writing only. Truncate it if it exists. If it does not exist, create a new file. w+ : Open the file for reading and writing. Truncate it if it exists. If it does not exist, create a new file. a : Open the file for writing only. If the file does not exist, create a new empty file. Set the file pointer to the end of the file prior to each write. a+ : Open the file for reading and writing. If the file does not exist, create a new empty file. Set the initial access position to the end of the file. All of the legal access values above may have the character b added as the second or third character in the value to indicate that the opened channel should be configured as if with the fconfigure -translation binary option, making the channel suitable for reading or writing of binary data. In the second form, access consists of a list of any of the following flags, most of which have the standard POSIX meanings. One of the flags must be either RDONLY , WRONLY or RDWR . RDONLY : Open the file for reading only. WRONLY : Open the file for writing only. RDWR : Open the file for both reading and writing. APPEND : Set the file pointer to the end of the file prior to each write. BINARY : Configure the opened channel with the -translation binary option. CREAT : Create the file if it does not already exist (without this flag it is an error for the file not to exist). EXCL : If CREAT is also specified, an error is returned if the file already exists. NOCTTY : If the file is a terminal device, this flag prevents the file from becoming the controlling terminal of the process. NONBLOCK : Prevents the process from blocking while opening the file, and possibly in subsequent I/O operations. The exact behavior of this flag is system- and device-dependent; its use is discouraged (it is better to use the fconfigure command to put a file in nonblocking mode). For details refer to your system documentation on the open system call\\'s O_NONBLOCK flag. TRUNC : If the file exists it is truncated to zero length. If a new file is created as part of opening it, permissions (an integer) is used to set the permissions for the new file in conjunction with the process\\'s file mode creation mask. Permissions defaults to 0666.","title":"DESCRIPTION"},{"location":"open/#command-pipelines","text":"If the first character of fileName is then the remaining characters of fileName are treated as a list of arguments that describe a command pipeline to invoke, in the same style as the arguments for exec . In this case, the channel identifier returned by open may be used to write to the command\\'s input pipe or read from its output pipe, depending on the value of access . If write-only access is used (e.g. access is then standard output for the pipeline is directed to the current standard output unless overridden by the command. If read-only access is used (e.g. access is standard input for the pipeline is taken from the current standard input unless overridden by the command. The id of the spawned process is accessible through the pid command, using the channel id returned by open as argument. If the command (or one of the commands) executed in the command pipeline returns an error (according to the definition in exec ), a Tcl error is generated when close is called on the channel unless the pipeline is in non-blocking mode then no exit status is returned (a silent close with -blocking 0). It is often useful to use the fileevent command with pipelines so other processing may happen at the same time as running the command in the background.","title":"COMMAND PIPELINES"},{"location":"open/#serial-communications","text":"If fileName refers to a serial port, then the specified serial port is opened and initialized in a platform-dependent manner. Acceptable values for the fileName to use to open a serial port are described in the PORTABILITY ISSUES section. The chan configure and fconfigure commands can be used to query and set additional configuration options specific to serial ports (where supported): -mode baud , parity , data , stop : This option is a set of 4 comma-separated values: the baud rate, parity, number of data bits, and number of stop bits for this serial port. The baud rate is a simple integer that specifies the connection speed. Parity is one of the following letters: n , o , e , m , s ; respectively signifying the parity options of or Data is the number of data bits and should be an integer from 5 to 8, while stop is the number of stop bits and should be the integer 1 or 2. -handshake type : (Windows and Unix). This option is used to setup automatic handshake control. Note that not all handshake types maybe supported by your operating system. The type parameter is case-independent. If *type* is **none** then any handshake is switched off. **rtscts** activates hardware handshake. Hardware handshake signals are described below. For software handshake **xonxoff** the handshake characters can be redefined with **-xchar**. An additional hardware handshake **dtrdsr** is available only under Windows. There is no default handshake configuration, the initial value depends on your operating system settings. The **-handshake** option cannot be queried. -queue : (Windows and Unix). The -queue option can only be queried. It returns a list of two integers representing the current number of bytes in the input and output queue respectively. -timeout msec : (Windows and Unix). This option is used to set the timeout for blocking read operations. It specifies the maximum interval between the reception of two bytes in milliseconds. For Unix systems the granularity is 100 milliseconds. The -timeout option does not affect write operations or nonblocking reads. This option cannot be queried. -ttycontrol {signal boolean signal boolean ...} : (Windows and Unix). This option is used to setup the handshake output lines (see below) permanently or to send a BREAK over the serial line. The signal names are case-independent. {RTS 1 DTR 0} sets the RTS output to high and the DTR output to low. The BREAK condition (see below) is enabled and disabled with {BREAK 1} and {BREAK 0} respectively. It is not a good idea to change the RTS (or DTR ) signal with active hardware handshake rtscts (or dtrdsr ). The result is unpredictable. The -ttycontrol option cannot be queried. -ttystatus : (Windows and Unix). The -ttystatus option can only be queried. It returns the current modem status and handshake input signals (see below). The result is a list of signal,value pairs with a fixed order, e.g. {CTS 1 DSR 0 RING 1 DCD 0} . The signal names are returned upper case. -xchar {xonChar xoffChar} : (Windows and Unix). This option is used to query or change the software handshake characters. Normally the operating system default should be DC1 (0x11) and DC3 (0x13) representing the ASCII standard XON and XOFF characters. -closemode closeMode : (Windows and Unix). This option is used to query or change the close mode of the serial channel, which defines how pending output in operating system buffers is handled when the channel is closed. The following values for closeMode are supported: default : indicates that a system default operation should be used; all serial channels default to this. discard : indicates that the contents of the OS buffers should be discarded. Note that this is not recommended when writing to a POSIX terminal, as it can interact unexpectedly with handling of stderr . drain : indicates that Tcl should wait when closing the channel until all output has been consumed. This may slow down close noticeably. -inputmode inputMode : (Unix only; Windows has the equivalent option on console channels). This option is used to query or change the input mode of the serial channel under the assumption that it is talking to a terminal, which controls how interactive input from users is handled. The following values for inputMode are supported: normal : indicates that normal line-oriented input should be used, with standard terminal editing capabilities enabled. password : indicates that non-echoing input should be used, with standard terminal editing capabilities enabled but no writing of typed characters to the terminal (except for newlines). Some terminals may indicate this specially. raw : indicates that all keyboard input should be given directly to Tcl with the terminal doing no processing at all. It does not echo the keys, leaving it up to the Tcl script to interpret what to do. reset (set only) : indicates that the terminal should be reset to what state it was in when the terminal was opened. Note that setting this option (technically, anything that changes the terminal state from its initial value via this option ) will cause the channel to turn on an automatic reset of the terminal when the channel is closed. -winsize : (Unix only; Windows has the equivalent option on console channels). This option is query only. It retrieves a two-element list with the the current width and height of the terminal. <!-- --> -pollinterval msec : (Windows only). This option is used to set the maximum time between polling for fileevents. This affects the time interval between checking for events throughout the Tcl interpreter (the smallest value always wins). Use this option only if you want to poll the serial port more or less often than 10 msec (the default). -sysbuffer inSize : -sysbuffer {inSize outSize} : (Windows only). This option is used to change the size of Windows system buffers for a serial channel. Especially at higher communication rates the default input buffer size of 4096 bytes can overrun for latent systems. The first form specifies the input buffer size, in the second form both input and output buffers are defined. -lasterror : (Windows only). This option is query only. In case of a serial communication error, read or puts returns a general Tcl file I/O error. fconfigure -lasterror can be called to get a list of error details. See below for an explanation of the various error codes.","title":"SERIAL COMMUNICATIONS"},{"location":"open/#serial-port-signals","text":"RS-232 is the most commonly used standard electrical interface for serial communications. A negative voltage (-3V..-12V) define a mark (on=1) bit and a positive voltage (+3..+12V) define a space (off=0) bit (RS-232C). The following signals are specified for incoming and outgoing data, status lines and handshaking. Here we are using the terms workstation for your computer and modem for the external device, because some signal names (DCD, RI) come from modems. Of course your external device may use these signal lines for other purposes. TXD(output) : Transmitted Data: Outgoing serial data. RXD(input) : Received Data: Incoming serial data. RTS(output) : Request To Send: This hardware handshake line informs the modem that your workstation is ready to receive data. Your workstation may automatically reset this signal to indicate that the input buffer is full. CTS(input) : Clear To Send: The complement to RTS. Indicates that the modem is ready to receive data. DTR(output) : Data Terminal Ready: This signal tells the modem that the workstation is ready to establish a link. DTR is often enabled automatically whenever a serial port is opened. DSR(input) : Data Set Ready: The complement to DTR. Tells the workstation that the modem is ready to establish a link. DCD(input) : Data Carrier Detect: This line becomes active when a modem detects a signal. RI(input) : Ring Indicator: Goes active when the modem detects an incoming call. BREAK : A BREAK condition is not a hardware signal line, but a logical zero on the TXD or RXD lines for a long period of time, usually 250 to 500 milliseconds. Normally a receive or transmit data signal stays at the mark (on=1) voltage until the next character is transferred. A BREAK is sometimes used to reset the communications line or change the operating mode of communications hardware.","title":"SERIAL PORT SIGNALS"},{"location":"open/#error-codes-windows-only","text":"A lot of different errors may occur during serial read operations or during event polling in background. The external device may have been switched off, the data lines may be noisy, system buffers may overrun or your mode settings may be wrong. That is why a reliable software should always catch serial read operations. In cases of an error Tcl returns a general file I/O error. Then fconfigure -lasterror may help to locate the problem. The following error codes may be returned. RXOVER : Windows input buffer overrun. The data comes faster than your scripts reads it or your system is overloaded. Use fconfigure -sysbuffer to avoid a temporary bottleneck and/or make your script faster. TXFULL : Windows output buffer overrun. Complement to RXOVER. This error should practically not happen, because Tcl cares about the output buffer status. OVERRUN : UART buffer overrun (hardware) with data lost. The data comes faster than the system driver receives it. Check your advanced serial port settings to enable the FIFO (16550) buffer and/or setup a lower(1) interrupt threshold value. RXPARITY : A parity error has been detected by your UART. Wrong parity settings with fconfigure -mode or a noisy data line (RXD) may cause this error. FRAME : A stop-bit error has been detected by your UART. Wrong mode settings with fconfigure -mode or a noisy data line (RXD) may cause this error. BREAK : A BREAK condition has been detected by your UART (see above).","title":"ERROR CODES (Windows only)"},{"location":"open/#portability-issues","text":"Windows : Valid values for fileName to open a serial port are of the form com X , where X is a number, generally from 1 to 9. A legacy form accepted as well is com X : . This notation only works for serial ports from 1 to 9. An attempt to open a serial port that does not exist or has a number greater than 9 will fail. An alternate form of opening serial ports is to use the filename //./comX , where X is any number that corresponds to a serial port. When running Tcl interactively, there may be some strange interactions between the real console, if one is present, and a command pipeline that uses standard input or output. If a command pipeline is opened for reading, some of the lines entered at the console will be sent to the command pipeline and some will be sent to the Tcl evaluator. If a command pipeline is opened for writing, keystrokes entered into the console are not visible until the pipe is closed. These problems only occur because both Tcl and the child application are competing for the console at the same time. If the command pipeline is started from a script, so that Tcl is not accessing the console, or if the command pipeline does not use standard input or output, but is redirected from or to a file, then the above problems do not occur. Files opened in the mode or with the APPEND flag set are implemented by seeking immediately before each write, which is not an atomic operation and does not carry the guarantee of strict appending that is present on POSIX platforms. Unix \u2007\u2007\u2007\u2007\u2007\u2007\u2007 : Valid values for fileName to open a serial port are generally of the form /dev/tty X , where X is a or b , but the name of any pseudo-file that maps to a serial port may be used. Advanced configuration options are only supported for serial ports when Tcl is built to use the POSIX serial interface. When running Tcl interactively, there may be some strange interactions between the console, if one is present, and a command pipeline that uses standard input. If a command pipeline is opened for reading, some of the lines entered at the console will be sent to the command pipeline and some will be sent to the Tcl evaluator. This problem only occurs because both Tcl and the child application are competing for the console at the same time. If the command pipeline is started from a script, so that Tcl is not accessing the console, or if the command pipeline does not use standard input, but is redirected from a file, then the above problem does not occur. See the PORTABILITY ISSUES section of the exec command for additional information not specific to command pipelines about executing applications on the various platforms","title":"PORTABILITY ISSUES"},{"location":"open/#console-channels","text":"On Windows only, console channels (usually stdin or stdout ) support the following options: -inputmode inputMode : This option is used to query or change the input mode of the console channel, which controls how interactive input from users is handled. The following values for inputMode are supported: **normal** : indicates that normal line-oriented input should be used, with standard console editing capabilities enabled. **password** : indicates that non-echoing input should be used, with standard console editing capabilitied enabled but no writing of typed characters to the terminal (except for newlines). **raw** : indicates that all keyboard input should be given directly to Tcl with the console doing no processing at all. It does not echo the keys, leaving it up to the Tcl script to interpret what to do. **reset** (set only) : indicates that the console should be reset to what state it was in when the console channel was opened. Note that setting this option (technically, anything that changes the console state from its default *via this option*) will cause the channel to turn on an automatic reset of the console when the channel is closed. -winsize : This option is query only. It retrieves a two-element list with the the current width and height of the console that this channel is talking to. Note that the equivalent options exist on Unix, but are on the serial channel type.","title":"CONSOLE CHANNELS"},{"location":"open/#examples","text":"Open a file for writing, forcing it to be created and raising an error if it already exists. set myNewFile [ open filename.txt {WRONLY CREAT EXCL}] Open a file for writing as a log file. set myLogFile [ open filename.log \\\"a\\\"] fconfigure \\$myLogFile -buffering line Open a command pipeline and catch any errors: set fl [ open \\\"| ls this_file_does_not_exist\\\"] set data [read \\$fl] if {[catch {close \\$fl} err]} { puts \\\"ls command failed: \\$err\\\" } Open a command pipeline and read binary data from it. Note the unusual form with that handles non-trivial edge cases with arguments that potentially have spaces in. set fl [ open |[list create_image_data \\$input] \\\"rb\\\"] set binData [read \\$fl] close \\$fl Read a password securely from the user (assuming that the script is being run interactively): chan configure stdin -inputmode password try { chan puts -nonewline \\\"Password: \\\" chan flush stdout set thePassword [chan gets stdin] } finally { chan configure stdin -inputmode reset }","title":"EXAMPLES"},{"location":"open/#see-also","text":"file(n), close(n), filename(n), fconfigure(n), gets(n), read(n), puts(n), exec(n), pid(n), fopen(3)","title":"SEE ALSO"},{"location":"open/#keywords","text":"access mode, append, create, file, non-blocking, open, permissions, pipeline, process, serial","title":"KEYWORDS"},{"location":"package/","text":"NAME package - Facilities for package loading and version control SYNOPSIS package files package package forget ?package package ...? package ifneeded package version ?script? package names package present package ?requirement...? package present -exact package version package provide package ?version? package require package ?requirement...? package require -exact package version package unknown ?command? package vcompare version1 version2 package versions package package vsatisfies version requirement... package prefer ?latest|stable? DESCRIPTION This command keeps a simple database of the packages available for use by the current interpreter and how to load them into the interpreter. It supports multiple versions of each package and arranges for the correct version of a package to be loaded based on what is needed by the application. This command also detects and reports version clashes. Typically, only the package require and package provide commands are invoked in normal Tcl scripts; the other commands are used primarily by system scripts that maintain the package database. The behavior of the package command is determined by its first argument. The following forms are permitted: package files package : Lists all files forming part of package . Auto-loaded files are not included in this list, only files which were directly sourced during package initialization. The list order corresponds with the order in which the files were sourced. package forget ? package package ... ? : Removes all information about each specified package from this interpreter, including information provided by both package ifneeded and package provide . package ifneeded package version ? script ? : This command typically appears only in system configuration scripts to set up the package database. It indicates that a particular version of a particular package is available if needed, and that the package can be added to the interpreter by executing script . The script is saved in a database for use by subsequent package require commands; typically, script sets up auto-loading for the commands in the package (or calls load and/or source directly), then invokes package provide to indicate that the package is present. There may be information in the database for several different versions of a single package. If the database already contains information for package and version , the new script replaces the existing one. If the script argument is omitted, the current script for version version of package package is returned, or an empty string if no package ifneeded command has been invoked for this package and version . package names : Returns a list of the names of all packages in the interpreter for which a version has been provided (via package provide ) or for which a package ifneeded script is available. The order of elements in the list is arbitrary. package present ? -exact ? package ? requirement... ? : This command is equivalent to package require except that it does not try and load the package if it is not already loaded. package provide package ? version ? : This command is invoked to indicate that version version of package package is now present in the interpreter. It is typically invoked once as part of an ifneeded script, and again by the package itself when it is finally loaded. An error occurs if a different version of package has been provided by a previous package provide command. If the version argument is omitted, then the command returns the version number that is currently provided, or an empty string if no package provide command has been invoked for package in this interpreter. package require package ? requirement... ? : This command is typically invoked by Tcl code that wishes to use a particular version of a particular package. The arguments indicate which package is wanted, and the command ensures that a suitable version of the package is loaded into the interpreter. If the command succeeds, it returns the version number that is loaded; otherwise it generates an error. A suitable version of the package is any version which satisfies at least one of the requirements, per the rules of **package** vsatisfies. If multiple versions are suitable the implementation with the highest version is chosen. This last part is additionally influenced by the selection mode set with **package prefer**. In the selection mode the command will select the highest stable version satisfying the requirements, if any. If no stable version satisfies the requirements, the highest unstable version satisfying the requirements will be selected. In the selection mode the command will accept the highest version satisfying all the requirements, regardless of its stableness. If a version of *package* has already been provided (by invoking the **package provide** command), then its version number must satisfy the *requirement*s and the command returns immediately. Otherwise, the command searches the database of information provided by previous **package ifneeded** commands to see if an acceptable version of the package is available. If so, the script for the highest acceptable version number is evaluated in the global namespace; it must do whatever is necessary to load the package, including calling **package provide** for the package. If the **package ifneeded** database does not contain an acceptable version of the package and a **package unknown** command has been specified for the interpreter then that command is evaluated in the global namespace; when it completes, Tcl checks again to see if the package is now provided or if there is a **package ifneeded** script for it. If all of these steps fail to provide an acceptable version of the package, then the command returns an error. package require -exact package version : This form of the command is used when only the given version of package is acceptable to the caller. This command is equivalent to package require package version - version . package unknown ? command ? : This command supplies a command to invoke during package require if no suitable version of a package can be found in the package ifneeded database. If the command argument is supplied, it contains the first part of a command; when the command is invoked during a package require command, Tcl appends one or more additional arguments giving the desired package name and requirements. For example, if command is foo bar and later the command package require test 2.4 is invoked, then Tcl will execute the command foo bar test 2.4 to load the package. If no requirements are supplied to the package require command, then only the name will be added to invoked command. If the package unknown command is invoked without a command argument, then the current package unknown script is returned, or an empty string if there is none. If command is specified as an empty string, then the current package unknown script is removed, if there is one. package vcompare version1 version2 : Compares the two version numbers given by version1 and version2 . Returns -1 if version1 is an earlier version than version2 , 0 if they are equal, and 1 if version1 is later than version2 . package versions package : Returns a list of all the version numbers of package for which information has been provided by package ifneeded commands. package vsatisfies version requirement... : Returns 1 if the version satisfies at least one of the given requirements, and 0 otherwise. Each requirement is allowed to have any of the forms: min : This form is called min- : This form is called min-max : This form is called where and are valid version numbers. The legacy syntax is a special case of the extended syntax, keeping backward compatibility. Regarding satisfaction the rules are: \\[1\\] : The *version* has to pass at least one of the listed *requirement*s to be satisfactory. \\[2\\] : A version satisfies a requirement when > \\[a\\] > > : For *min* equal to the *max* if, and only if the *version* is > equal to the *min*. > > \\[b\\] > > : Otherwise if, and only if the *version* is greater than or > equal to the *min*, and less than the *max*, where both *min* > and *max* have been padded internally with > > Note that while the comparison to *min* is inclusive, the > comparison to *max* is exclusive. \\[3\\] : A requirement is a requirement in disguise, with the *max* part implicitly specified as the next higher major version number of the *min* part. A version satisfies it per the rules above. \\[4\\] : A *version* satisfies a requirement if, and only if it is greater than or equal to the *min*, where the *min* has been padded internally with There is no constraint to a maximum. package prefer ? latest | stable ? : With no arguments, the commands returns either or whichever describes the current mode of selection logic used by package require . When passed the argument it sets the selection logic mode to When passed the argument if the mode is already that value is kept. If the mode is already then the attempt to set it back to is ineffective and the mode value remains When passed any other value as an argument, raise an invalid argument error. When an interpreter is created, its initial selection mode value is set to unless the environment variable TCL_PKG_PREFER_LATEST is set (to any value) or the Tcl package itself is unstable. Otherwise the initial (and permanent) selection mode value is set to VERSION NUMBERS Version numbers consist of one or more decimal numbers separated by dots, such as 2 or 1.162 or 3.1.13.1. The first number is called the major version number. Larger numbers correspond to later versions of a package, with leftmost numbers having greater significance. For example, version 2.1 is later than 1.3 and version 3.4.6 is later than 3.3.5. Missing fields are equivalent to zeroes: version 1.3 is the same as version 1.3.0 and 1.3.0.0, so it is earlier than 1.3.1 or 1.3.0.2. In addition, the letters (alpha) and/or (beta) may appear exactly once to replace a dot for separation. These letters semantically add a negative specifier into the version, where is -2, and is -1. Each may be specified only once, and or are mutually exclusive in a specifier. Thus 1.3a1 becomes (semantically) 1.3.-2.1, 1.3b1 is 1.3.-1.1. Negative numbers are not directly allowed in version specifiers. A version number not containing the letters or as specified above is called a stable version, whereas presence of the letters causes the version to be called is unstable . A later version number is assumed to be upwards compatible with an earlier version number as long as both versions have the same major version number. For example, Tcl scripts written for version 2.3 of a package should work unchanged under versions 2.3.2, 2.4, and 2.5.1. Changes in the major version number signify incompatible changes: if code is written to use version 2.1 of a package, it is not guaranteed to work unmodified with either version 1.7.3 or version 3.1. PACKAGE INDICES The recommended way to use packages in Tcl is to invoke package require and package provide commands in scripts, and use the procedure pkg_mkIndex to create package index files. Once you have done this, packages will be loaded automatically in response to package require commands. See the documentation for pkg_mkIndex for details. EXAMPLES To state that a Tcl script requires the Tk and http packages, put this at the top of the script: package require Tk package require http To test to see if the Snack package is available and load if it is (often useful for optional enhancements to programs where the loss of the functionality is not critical) do this: if {[catch { package require Snack}]} { # Error thrown - package not found. # Set up a dummy interface to work around the absence } else { # We have the package, configure the app to use it } SEE ALSO msgcat(n), packagens(n), pkgMkIndex(n) KEYWORDS package, version","title":"NAME"},{"location":"package/#name","text":"package - Facilities for package loading and version control","title":"NAME"},{"location":"package/#synopsis","text":"package files package package forget ?package package ...? package ifneeded package version ?script? package names package present package ?requirement...? package present -exact package version package provide package ?version? package require package ?requirement...? package require -exact package version package unknown ?command? package vcompare version1 version2 package versions package package vsatisfies version requirement... package prefer ?latest|stable?","title":"SYNOPSIS"},{"location":"package/#description","text":"This command keeps a simple database of the packages available for use by the current interpreter and how to load them into the interpreter. It supports multiple versions of each package and arranges for the correct version of a package to be loaded based on what is needed by the application. This command also detects and reports version clashes. Typically, only the package require and package provide commands are invoked in normal Tcl scripts; the other commands are used primarily by system scripts that maintain the package database. The behavior of the package command is determined by its first argument. The following forms are permitted: package files package : Lists all files forming part of package . Auto-loaded files are not included in this list, only files which were directly sourced during package initialization. The list order corresponds with the order in which the files were sourced. package forget ? package package ... ? : Removes all information about each specified package from this interpreter, including information provided by both package ifneeded and package provide . package ifneeded package version ? script ? : This command typically appears only in system configuration scripts to set up the package database. It indicates that a particular version of a particular package is available if needed, and that the package can be added to the interpreter by executing script . The script is saved in a database for use by subsequent package require commands; typically, script sets up auto-loading for the commands in the package (or calls load and/or source directly), then invokes package provide to indicate that the package is present. There may be information in the database for several different versions of a single package. If the database already contains information for package and version , the new script replaces the existing one. If the script argument is omitted, the current script for version version of package package is returned, or an empty string if no package ifneeded command has been invoked for this package and version . package names : Returns a list of the names of all packages in the interpreter for which a version has been provided (via package provide ) or for which a package ifneeded script is available. The order of elements in the list is arbitrary. package present ? -exact ? package ? requirement... ? : This command is equivalent to package require except that it does not try and load the package if it is not already loaded. package provide package ? version ? : This command is invoked to indicate that version version of package package is now present in the interpreter. It is typically invoked once as part of an ifneeded script, and again by the package itself when it is finally loaded. An error occurs if a different version of package has been provided by a previous package provide command. If the version argument is omitted, then the command returns the version number that is currently provided, or an empty string if no package provide command has been invoked for package in this interpreter. package require package ? requirement... ? : This command is typically invoked by Tcl code that wishes to use a particular version of a particular package. The arguments indicate which package is wanted, and the command ensures that a suitable version of the package is loaded into the interpreter. If the command succeeds, it returns the version number that is loaded; otherwise it generates an error. A suitable version of the package is any version which satisfies at least one of the requirements, per the rules of **package** vsatisfies. If multiple versions are suitable the implementation with the highest version is chosen. This last part is additionally influenced by the selection mode set with **package prefer**. In the selection mode the command will select the highest stable version satisfying the requirements, if any. If no stable version satisfies the requirements, the highest unstable version satisfying the requirements will be selected. In the selection mode the command will accept the highest version satisfying all the requirements, regardless of its stableness. If a version of *package* has already been provided (by invoking the **package provide** command), then its version number must satisfy the *requirement*s and the command returns immediately. Otherwise, the command searches the database of information provided by previous **package ifneeded** commands to see if an acceptable version of the package is available. If so, the script for the highest acceptable version number is evaluated in the global namespace; it must do whatever is necessary to load the package, including calling **package provide** for the package. If the **package ifneeded** database does not contain an acceptable version of the package and a **package unknown** command has been specified for the interpreter then that command is evaluated in the global namespace; when it completes, Tcl checks again to see if the package is now provided or if there is a **package ifneeded** script for it. If all of these steps fail to provide an acceptable version of the package, then the command returns an error. package require -exact package version : This form of the command is used when only the given version of package is acceptable to the caller. This command is equivalent to package require package version - version . package unknown ? command ? : This command supplies a command to invoke during package require if no suitable version of a package can be found in the package ifneeded database. If the command argument is supplied, it contains the first part of a command; when the command is invoked during a package require command, Tcl appends one or more additional arguments giving the desired package name and requirements. For example, if command is foo bar and later the command package require test 2.4 is invoked, then Tcl will execute the command foo bar test 2.4 to load the package. If no requirements are supplied to the package require command, then only the name will be added to invoked command. If the package unknown command is invoked without a command argument, then the current package unknown script is returned, or an empty string if there is none. If command is specified as an empty string, then the current package unknown script is removed, if there is one. package vcompare version1 version2 : Compares the two version numbers given by version1 and version2 . Returns -1 if version1 is an earlier version than version2 , 0 if they are equal, and 1 if version1 is later than version2 . package versions package : Returns a list of all the version numbers of package for which information has been provided by package ifneeded commands. package vsatisfies version requirement... : Returns 1 if the version satisfies at least one of the given requirements, and 0 otherwise. Each requirement is allowed to have any of the forms: min : This form is called min- : This form is called min-max : This form is called where and are valid version numbers. The legacy syntax is a special case of the extended syntax, keeping backward compatibility. Regarding satisfaction the rules are: \\[1\\] : The *version* has to pass at least one of the listed *requirement*s to be satisfactory. \\[2\\] : A version satisfies a requirement when > \\[a\\] > > : For *min* equal to the *max* if, and only if the *version* is > equal to the *min*. > > \\[b\\] > > : Otherwise if, and only if the *version* is greater than or > equal to the *min*, and less than the *max*, where both *min* > and *max* have been padded internally with > > Note that while the comparison to *min* is inclusive, the > comparison to *max* is exclusive. \\[3\\] : A requirement is a requirement in disguise, with the *max* part implicitly specified as the next higher major version number of the *min* part. A version satisfies it per the rules above. \\[4\\] : A *version* satisfies a requirement if, and only if it is greater than or equal to the *min*, where the *min* has been padded internally with There is no constraint to a maximum. package prefer ? latest | stable ? : With no arguments, the commands returns either or whichever describes the current mode of selection logic used by package require . When passed the argument it sets the selection logic mode to When passed the argument if the mode is already that value is kept. If the mode is already then the attempt to set it back to is ineffective and the mode value remains When passed any other value as an argument, raise an invalid argument error. When an interpreter is created, its initial selection mode value is set to unless the environment variable TCL_PKG_PREFER_LATEST is set (to any value) or the Tcl package itself is unstable. Otherwise the initial (and permanent) selection mode value is set to","title":"DESCRIPTION"},{"location":"package/#version-numbers","text":"Version numbers consist of one or more decimal numbers separated by dots, such as 2 or 1.162 or 3.1.13.1. The first number is called the major version number. Larger numbers correspond to later versions of a package, with leftmost numbers having greater significance. For example, version 2.1 is later than 1.3 and version 3.4.6 is later than 3.3.5. Missing fields are equivalent to zeroes: version 1.3 is the same as version 1.3.0 and 1.3.0.0, so it is earlier than 1.3.1 or 1.3.0.2. In addition, the letters (alpha) and/or (beta) may appear exactly once to replace a dot for separation. These letters semantically add a negative specifier into the version, where is -2, and is -1. Each may be specified only once, and or are mutually exclusive in a specifier. Thus 1.3a1 becomes (semantically) 1.3.-2.1, 1.3b1 is 1.3.-1.1. Negative numbers are not directly allowed in version specifiers. A version number not containing the letters or as specified above is called a stable version, whereas presence of the letters causes the version to be called is unstable . A later version number is assumed to be upwards compatible with an earlier version number as long as both versions have the same major version number. For example, Tcl scripts written for version 2.3 of a package should work unchanged under versions 2.3.2, 2.4, and 2.5.1. Changes in the major version number signify incompatible changes: if code is written to use version 2.1 of a package, it is not guaranteed to work unmodified with either version 1.7.3 or version 3.1.","title":"VERSION NUMBERS"},{"location":"package/#package-indices","text":"The recommended way to use packages in Tcl is to invoke package require and package provide commands in scripts, and use the procedure pkg_mkIndex to create package index files. Once you have done this, packages will be loaded automatically in response to package require commands. See the documentation for pkg_mkIndex for details.","title":"PACKAGE INDICES"},{"location":"package/#examples","text":"To state that a Tcl script requires the Tk and http packages, put this at the top of the script: package require Tk package require http To test to see if the Snack package is available and load if it is (often useful for optional enhancements to programs where the loss of the functionality is not critical) do this: if {[catch { package require Snack}]} { # Error thrown - package not found. # Set up a dummy interface to work around the absence } else { # We have the package, configure the app to use it }","title":"EXAMPLES"},{"location":"package/#see-also","text":"msgcat(n), packagens(n), pkgMkIndex(n)","title":"SEE ALSO"},{"location":"package/#keywords","text":"package, version","title":"KEYWORDS"},{"location":"packagens/","text":"NAME pkg::create - Construct an appropriate \\'package ifneeded\\' command for a given package specification SYNOPSIS ::pkg::create -name packageName -version packageVersion ? -load filespec ? ... ? -source filespec ? ... DESCRIPTION ::pkg::create is a utility procedure that is part of the standard Tcl library. It is used to create an appropriate package ifneeded command for a given package specification. It can be used to construct a pkgIndex.tcl file for use with the package mechanism. OPTIONS The parameters supported are: -name packageName : This parameter specifies the name of the package. It is required. -version packageVersion : This parameter specifies the version of the package. It is required. -load filespec : This parameter specifies a library that must be loaded with the load command. filespec is a list with two elements. The first element is the name of the file to load. The second, optional element is a list of commands supplied by loading that file. If the list of procedures is empty or omitted, ::pkg::create will set up the library for direct loading (see pkg_mkIndex ). Any number of -load parameters may be specified. -source filespec : This parameter is similar to the -load parameter, except that it specifies a Tcl library that must be loaded with the source command. Any number of -source parameters may be specified. At least one -load or -source parameter must be given. SEE ALSO package(n) KEYWORDS auto-load, index, package, version","title":"NAME"},{"location":"packagens/#name","text":"pkg::create - Construct an appropriate \\'package ifneeded\\' command for a given package specification","title":"NAME"},{"location":"packagens/#synopsis","text":"::pkg::create -name packageName -version packageVersion ? -load filespec ? ... ? -source filespec ? ...","title":"SYNOPSIS"},{"location":"packagens/#description","text":"::pkg::create is a utility procedure that is part of the standard Tcl library. It is used to create an appropriate package ifneeded command for a given package specification. It can be used to construct a pkgIndex.tcl file for use with the package mechanism.","title":"DESCRIPTION"},{"location":"packagens/#options","text":"The parameters supported are: -name packageName : This parameter specifies the name of the package. It is required. -version packageVersion : This parameter specifies the version of the package. It is required. -load filespec : This parameter specifies a library that must be loaded with the load command. filespec is a list with two elements. The first element is the name of the file to load. The second, optional element is a list of commands supplied by loading that file. If the list of procedures is empty or omitted, ::pkg::create will set up the library for direct loading (see pkg_mkIndex ). Any number of -load parameters may be specified. -source filespec : This parameter is similar to the -load parameter, except that it specifies a Tcl library that must be loaded with the source command. Any number of -source parameters may be specified. At least one -load or -source parameter must be given.","title":"OPTIONS"},{"location":"packagens/#see-also","text":"package(n)","title":"SEE ALSO"},{"location":"packagens/#keywords","text":"auto-load, index, package, version","title":"KEYWORDS"},{"location":"pid/","text":"NAME pid - Retrieve process identifiers SYNOPSIS pid ? fileId ? DESCRIPTION If the fileId argument is given then it should normally refer to a process pipeline created with the open command. In this case the pid command will return a list whose elements are the process identifiers of all the processes in the pipeline, in order. The list will be empty if fileId refers to an open file that is not a process pipeline. If no fileId argument is given then pid returns the process identifier of the current process. All process identifiers are returned as decimal strings. EXAMPLE Print process information about the processes in a pipeline using the SysV ps program before reading the output of that pipeline: set pipeline [open \\\"| zcat somefile.gz | grep foobar | sort -u\\\"] # Print process information exec ps -fp [ pid \\$pipeline] >@stdout # Print a separator and then the output of the pipeline puts [string repeat - 70] puts [read \\$pipeline] close \\$pipeline SEE ALSO exec(n), open(n) KEYWORDS file, pipeline, process identifier","title":"NAME"},{"location":"pid/#name","text":"pid - Retrieve process identifiers","title":"NAME"},{"location":"pid/#synopsis","text":"pid ? fileId ?","title":"SYNOPSIS"},{"location":"pid/#description","text":"If the fileId argument is given then it should normally refer to a process pipeline created with the open command. In this case the pid command will return a list whose elements are the process identifiers of all the processes in the pipeline, in order. The list will be empty if fileId refers to an open file that is not a process pipeline. If no fileId argument is given then pid returns the process identifier of the current process. All process identifiers are returned as decimal strings.","title":"DESCRIPTION"},{"location":"pid/#example","text":"Print process information about the processes in a pipeline using the SysV ps program before reading the output of that pipeline: set pipeline [open \\\"| zcat somefile.gz | grep foobar | sort -u\\\"] # Print process information exec ps -fp [ pid \\$pipeline] >@stdout # Print a separator and then the output of the pipeline puts [string repeat - 70] puts [read \\$pipeline] close \\$pipeline","title":"EXAMPLE"},{"location":"pid/#see-also","text":"exec(n), open(n)","title":"SEE ALSO"},{"location":"pid/#keywords","text":"file, pipeline, process identifier","title":"KEYWORDS"},{"location":"pkgMkIndex/","text":"NAME pkg_mkIndex - Build an index for automatic loading of packages SYNOPSIS pkg_mkIndex ?options...? dir ?pattern pattern ...? DESCRIPTION Pkg_mkIndex is a utility procedure that is part of the standard Tcl library. It is used to create index files that allow packages to be loaded automatically when package require commands are executed. To use pkg_mkIndex , follow these steps: [1] : Create the package(s). Each package may consist of one or more Tcl script files or binary files. Binary files must be suitable for loading with the load command with a single argument; for example, if the file is test.so it must be possible to load this file with the command load test.so . Each script file must contain a package provide command to declare the package and version number, and each binary file must contain a call to Tcl_PkgProvide . [2] : Create the index by invoking pkg_mkIndex . The dir argument gives the name of a directory and each pattern argument is a glob -style pattern that selects script or binary files in dir . The default pattern is *.tcl and *.[info sharedlibextension] . **Pkg_mkIndex** will create a file **pkgIndex.tcl** in *dir* with package information about all the files given by the *pattern* arguments. It does this by loading each file into a child interpreter and seeing what packages and new commands appear (this is why it is essential to have **package provide** commands or **Tcl_PkgProvide** calls in the files, as described above). If you have a package split among scripts and binary files, or if you have dependencies among files, you may have to use the **-load** option or adjust the order in which **pkg_mkIndex** processes the files. See **COMPLEX CASES** below. [3] : Install the package as a subdirectory of one of the directories given by the tcl_pkgPath variable. If \\$tcl_pkgPath contains more than one directory, machine-dependent packages (e.g., those that contain binary shared libraries) should normally be installed under the first directory and machine-independent packages (e.g., those that contain only Tcl scripts) should be installed under the second directory. The subdirectory should include the package\\'s script and/or binary files as well as the pkgIndex.tcl file. As long as the package is installed as a subdirectory of a directory in \\$tcl_pkgPath it will automatically be found during package require commands. If you install the package anywhere else, then you must ensure that the directory containing the package is in the **auto_path** global variable or an immediate subdirectory of one of the directories in **auto_path**. **Auto_path** contains a list of directories that are searched by both the auto-loader and the package loader; by default it includes **\\$tcl_pkgPath**. The package loader also checks all of the subdirectories of the directories in **auto_path**. You can add a directory to **auto_path** explicitly in your application, or you can add the directory to your **TCLLIBPATH** environment variable: if this environment variable is present, Tcl initializes **auto_path** from it during application startup. [4] : Once the above steps have been taken, all you need to do to use a package is to invoke package require . For example, if versions 2.1, 2.3, and 3.1 of package Test have been indexed by pkg_mkIndex , the command package require Test will make version 3.1 available and the command package require -exact Test 2.1 will make version 2.1 available. There may be many versions of a package in the various index files in auto_path , but only one will actually be loaded in a given interpreter, based on the first call to package require . Different versions of a package may be loaded in different interpreters. OPTIONS The optional switches are: -direct : The generated index will implement direct loading of the package upon package require . This is the default. -lazy : The generated index will manage to delay loading the package until the use of one of the commands provided by the package, instead of loading it immediately upon package require . This is not compatible with the use of auto_reset , and therefore its use is discouraged. -load pkgPat : The index process will preload any packages that exist in the current interpreter and match pkgPat into the child interpreter used to generate the index. The pattern match uses string match rules, but without making case distinctions. See COMPLEX CASES below. -verbose : Generate output during the indexing process. Output is via the tclLog procedure, which by default prints to stderr. -- : End of the flags, in case dir begins with a dash. PACKAGES AND THE AUTO-LOADER The package management facilities overlap somewhat with the auto-loader, in that both arrange for files to be loaded on-demand. However, package management is a higher-level mechanism that uses the auto-loader for the last step in the loading process. It is generally better to index a package with pkg_mkIndex rather than auto_mkindex because the package mechanism provides version control: several versions of a package can be made available in the index files, with different applications using different versions based on package require commands. In contrast, auto_mkindex does not understand versions so it can only handle a single version of each package. It is probably not a good idea to index a given package with both pkg_mkIndex and auto_mkindex . If you use pkg_mkIndex to index a package, its commands cannot be invoked until package require has been used to select a version; in contrast, packages indexed with auto_mkindex can be used immediately since there is no version control. HOW IT WORKS Pkg_mkIndex depends on the package unknown command, the package ifneeded command, and the auto-loader. The first time a package require command is invoked, the package unknown script is invoked. This is set by Tcl initialization to a script that evaluates all of the pkgIndex.tcl files in the auto_path . The pkgIndex.tcl files contain package ifneeded commands for each version of each available package; these commands invoke package provide commands to announce the availability of the package, and they setup auto-loader information to load the files of the package. If the -lazy flag was provided when the pkgIndex.tcl was generated, a given file of a given version of a given package is not actually loaded until the first time one of its commands is invoked. Thus, after invoking package require you may not see the package\\'s commands in the interpreter, but you will be able to invoke the commands and they will be auto-loaded. DIRECT LOADING Some packages, for instance packages which use namespaces and export commands or those which require special initialization, might select that their package files be loaded immediately upon package require instead of delaying the actual loading to the first use of one of the package\\'s command. This is the default mode when generating the package index. It can be overridden by specifying the -lazy argument. COMPLEX CASES Most complex cases of dependencies among scripts and binary files, and packages being split among scripts and binary files are handled OK. However, you may have to adjust the order in which files are processed by pkg_mkIndex . These issues are described in detail below. If each script or file contains one package, and packages are only contained in one file, then things are easy. You simply specify all files to be indexed in any order with some glob patterns. In general, it is OK for scripts to have dependencies on other packages. If scripts contain package require commands, these are stubbed out in the interpreter used to process the scripts, so these do not cause problems. If scripts call into other packages in global code, these calls are handled by a stub unknown command. However, if scripts make variable references to other package\\'s variables in global code, these will cause errors. That is also bad coding style. If binary files have dependencies on other packages, things can become tricky because it is not possible to stub out C-level APIs such as Tcl_PkgRequire API when loading a binary file. For example, suppose the BLT package requires Tk, and expresses this with a call to Tcl_PkgRequire in its Blt_Init routine. To support this, you must run pkg_mkIndex in an interpreter that has Tk loaded. You can achieve this with the -load pkgPat option. If you specify this option, pkg_mkIndex will load any packages listed by info loaded and that match pkgPat into the interpreter used to process files. In most cases this will satisfy the Tcl_PkgRequire calls made by binary files. If you are indexing two binary files and one depends on the other, you should specify the one that has dependencies last. This way the one without dependencies will get loaded and indexed, and then the package it provides will be available when the second file is processed. You may also need to load the first package into the temporary interpreter used to create the index by using the -load flag; it will not hurt to specify package patterns that are not yet loaded. If you have a package that is split across scripts and a binary file, then you should avoid the -load flag. The problem is that if you load a package before computing the index it masks any other files that provide part of the same package. If you must use -load , then you must specify the scripts first; otherwise the package loaded from the binary file may mask the package defined by the scripts. SEE ALSO package(n) KEYWORDS auto-load, index, package, version","title":"NAME"},{"location":"pkgMkIndex/#name","text":"pkg_mkIndex - Build an index for automatic loading of packages","title":"NAME"},{"location":"pkgMkIndex/#synopsis","text":"pkg_mkIndex ?options...? dir ?pattern pattern ...?","title":"SYNOPSIS"},{"location":"pkgMkIndex/#description","text":"Pkg_mkIndex is a utility procedure that is part of the standard Tcl library. It is used to create index files that allow packages to be loaded automatically when package require commands are executed. To use pkg_mkIndex , follow these steps: [1] : Create the package(s). Each package may consist of one or more Tcl script files or binary files. Binary files must be suitable for loading with the load command with a single argument; for example, if the file is test.so it must be possible to load this file with the command load test.so . Each script file must contain a package provide command to declare the package and version number, and each binary file must contain a call to Tcl_PkgProvide . [2] : Create the index by invoking pkg_mkIndex . The dir argument gives the name of a directory and each pattern argument is a glob -style pattern that selects script or binary files in dir . The default pattern is *.tcl and *.[info sharedlibextension] . **Pkg_mkIndex** will create a file **pkgIndex.tcl** in *dir* with package information about all the files given by the *pattern* arguments. It does this by loading each file into a child interpreter and seeing what packages and new commands appear (this is why it is essential to have **package provide** commands or **Tcl_PkgProvide** calls in the files, as described above). If you have a package split among scripts and binary files, or if you have dependencies among files, you may have to use the **-load** option or adjust the order in which **pkg_mkIndex** processes the files. See **COMPLEX CASES** below. [3] : Install the package as a subdirectory of one of the directories given by the tcl_pkgPath variable. If \\$tcl_pkgPath contains more than one directory, machine-dependent packages (e.g., those that contain binary shared libraries) should normally be installed under the first directory and machine-independent packages (e.g., those that contain only Tcl scripts) should be installed under the second directory. The subdirectory should include the package\\'s script and/or binary files as well as the pkgIndex.tcl file. As long as the package is installed as a subdirectory of a directory in \\$tcl_pkgPath it will automatically be found during package require commands. If you install the package anywhere else, then you must ensure that the directory containing the package is in the **auto_path** global variable or an immediate subdirectory of one of the directories in **auto_path**. **Auto_path** contains a list of directories that are searched by both the auto-loader and the package loader; by default it includes **\\$tcl_pkgPath**. The package loader also checks all of the subdirectories of the directories in **auto_path**. You can add a directory to **auto_path** explicitly in your application, or you can add the directory to your **TCLLIBPATH** environment variable: if this environment variable is present, Tcl initializes **auto_path** from it during application startup. [4] : Once the above steps have been taken, all you need to do to use a package is to invoke package require . For example, if versions 2.1, 2.3, and 3.1 of package Test have been indexed by pkg_mkIndex , the command package require Test will make version 3.1 available and the command package require -exact Test 2.1 will make version 2.1 available. There may be many versions of a package in the various index files in auto_path , but only one will actually be loaded in a given interpreter, based on the first call to package require . Different versions of a package may be loaded in different interpreters.","title":"DESCRIPTION"},{"location":"pkgMkIndex/#options","text":"The optional switches are: -direct : The generated index will implement direct loading of the package upon package require . This is the default. -lazy : The generated index will manage to delay loading the package until the use of one of the commands provided by the package, instead of loading it immediately upon package require . This is not compatible with the use of auto_reset , and therefore its use is discouraged. -load pkgPat : The index process will preload any packages that exist in the current interpreter and match pkgPat into the child interpreter used to generate the index. The pattern match uses string match rules, but without making case distinctions. See COMPLEX CASES below. -verbose : Generate output during the indexing process. Output is via the tclLog procedure, which by default prints to stderr. -- : End of the flags, in case dir begins with a dash.","title":"OPTIONS"},{"location":"pkgMkIndex/#packages-and-the-auto-loader","text":"The package management facilities overlap somewhat with the auto-loader, in that both arrange for files to be loaded on-demand. However, package management is a higher-level mechanism that uses the auto-loader for the last step in the loading process. It is generally better to index a package with pkg_mkIndex rather than auto_mkindex because the package mechanism provides version control: several versions of a package can be made available in the index files, with different applications using different versions based on package require commands. In contrast, auto_mkindex does not understand versions so it can only handle a single version of each package. It is probably not a good idea to index a given package with both pkg_mkIndex and auto_mkindex . If you use pkg_mkIndex to index a package, its commands cannot be invoked until package require has been used to select a version; in contrast, packages indexed with auto_mkindex can be used immediately since there is no version control.","title":"PACKAGES AND THE AUTO-LOADER"},{"location":"pkgMkIndex/#how-it-works","text":"Pkg_mkIndex depends on the package unknown command, the package ifneeded command, and the auto-loader. The first time a package require command is invoked, the package unknown script is invoked. This is set by Tcl initialization to a script that evaluates all of the pkgIndex.tcl files in the auto_path . The pkgIndex.tcl files contain package ifneeded commands for each version of each available package; these commands invoke package provide commands to announce the availability of the package, and they setup auto-loader information to load the files of the package. If the -lazy flag was provided when the pkgIndex.tcl was generated, a given file of a given version of a given package is not actually loaded until the first time one of its commands is invoked. Thus, after invoking package require you may not see the package\\'s commands in the interpreter, but you will be able to invoke the commands and they will be auto-loaded.","title":"HOW IT WORKS"},{"location":"pkgMkIndex/#direct-loading","text":"Some packages, for instance packages which use namespaces and export commands or those which require special initialization, might select that their package files be loaded immediately upon package require instead of delaying the actual loading to the first use of one of the package\\'s command. This is the default mode when generating the package index. It can be overridden by specifying the -lazy argument.","title":"DIRECT LOADING"},{"location":"pkgMkIndex/#complex-cases","text":"Most complex cases of dependencies among scripts and binary files, and packages being split among scripts and binary files are handled OK. However, you may have to adjust the order in which files are processed by pkg_mkIndex . These issues are described in detail below. If each script or file contains one package, and packages are only contained in one file, then things are easy. You simply specify all files to be indexed in any order with some glob patterns. In general, it is OK for scripts to have dependencies on other packages. If scripts contain package require commands, these are stubbed out in the interpreter used to process the scripts, so these do not cause problems. If scripts call into other packages in global code, these calls are handled by a stub unknown command. However, if scripts make variable references to other package\\'s variables in global code, these will cause errors. That is also bad coding style. If binary files have dependencies on other packages, things can become tricky because it is not possible to stub out C-level APIs such as Tcl_PkgRequire API when loading a binary file. For example, suppose the BLT package requires Tk, and expresses this with a call to Tcl_PkgRequire in its Blt_Init routine. To support this, you must run pkg_mkIndex in an interpreter that has Tk loaded. You can achieve this with the -load pkgPat option. If you specify this option, pkg_mkIndex will load any packages listed by info loaded and that match pkgPat into the interpreter used to process files. In most cases this will satisfy the Tcl_PkgRequire calls made by binary files. If you are indexing two binary files and one depends on the other, you should specify the one that has dependencies last. This way the one without dependencies will get loaded and indexed, and then the package it provides will be available when the second file is processed. You may also need to load the first package into the temporary interpreter used to create the index by using the -load flag; it will not hurt to specify package patterns that are not yet loaded. If you have a package that is split across scripts and a binary file, then you should avoid the -load flag. The problem is that if you load a package before computing the index it masks any other files that provide part of the same package. If you must use -load , then you must specify the scripts first; otherwise the package loaded from the binary file may mask the package defined by the scripts.","title":"COMPLEX CASES"},{"location":"pkgMkIndex/#see-also","text":"package(n)","title":"SEE ALSO"},{"location":"pkgMkIndex/#keywords","text":"auto-load, index, package, version","title":"KEYWORDS"},{"location":"platform/","text":"NAME platform - System identification support code and utilities SYNOPSIS package require platform ?1.0.10? platform::generic platform::identify platform::patterns identifier DESCRIPTION The platform package provides several utility commands useful for the identification of the architecture of a machine running Tcl. Whilst Tcl provides the tcl_platform array for identifying the current architecture (in particular, the platform and machine elements) this is not always sufficient. This is because (on Unix machines) tcl_platform reflects the values returned by the uname command and these are not standardized across platforms and architectures. In addition, on at least one platform (AIX) the tcl_platform(machine) contains the CPU serial number. Consequently, individual applications need to manipulate the values in tcl_platform (along with the output of system specific utilities) - which is both inconvenient for developers, and introduces the potential for inconsistencies in identifying architectures and in naming conventions. The platform package prevents such fragmentation - i.e., it establishes a standard naming convention for architectures running Tcl and makes it more convenient for developers to identify the current architecture a Tcl program is running on. COMMANDS platform::identify : This command returns an identifier describing the platform the Tcl core is running on. The returned identifier has the general format OS - CPU . The OS part of the identifier may contain details like kernel version, libc version, etc., and this information may contain dashes as well. The CPU part will not contain dashes, making the preceding dash the last dash in the result. platform::generic : This command returns a simplified identifier describing the platform the Tcl core is running on. In contrast to platform::identify it leaves out details like kernel version, libc version, etc. The returned identifier has the general format OS - CPU . platform::patterns identifier : This command takes an identifier as returned by platform::identify and returns a list of identifiers describing compatible architectures. EXAMPLE This can be used to allow an application to be shipped with multiple builds of a shared library, so that the same package works on many versions of an operating system. For example: package require platform # Assume that app script is .../theapp/bin/theapp.tcl set binDir [file dirname [file normalize [info script]]] set libDir [file join \\$binDir .. lib] set platLibDir [file join \\$libDir [ platform::identify ]] load [file join \\$platLibDir support[info sharedlibextension]] KEYWORDS operating system, cpu architecture, platform, architecture","title":"NAME"},{"location":"platform/#name","text":"platform - System identification support code and utilities","title":"NAME"},{"location":"platform/#synopsis","text":"package require platform ?1.0.10? platform::generic platform::identify platform::patterns identifier","title":"SYNOPSIS"},{"location":"platform/#description","text":"The platform package provides several utility commands useful for the identification of the architecture of a machine running Tcl. Whilst Tcl provides the tcl_platform array for identifying the current architecture (in particular, the platform and machine elements) this is not always sufficient. This is because (on Unix machines) tcl_platform reflects the values returned by the uname command and these are not standardized across platforms and architectures. In addition, on at least one platform (AIX) the tcl_platform(machine) contains the CPU serial number. Consequently, individual applications need to manipulate the values in tcl_platform (along with the output of system specific utilities) - which is both inconvenient for developers, and introduces the potential for inconsistencies in identifying architectures and in naming conventions. The platform package prevents such fragmentation - i.e., it establishes a standard naming convention for architectures running Tcl and makes it more convenient for developers to identify the current architecture a Tcl program is running on.","title":"DESCRIPTION"},{"location":"platform/#commands","text":"platform::identify : This command returns an identifier describing the platform the Tcl core is running on. The returned identifier has the general format OS - CPU . The OS part of the identifier may contain details like kernel version, libc version, etc., and this information may contain dashes as well. The CPU part will not contain dashes, making the preceding dash the last dash in the result. platform::generic : This command returns a simplified identifier describing the platform the Tcl core is running on. In contrast to platform::identify it leaves out details like kernel version, libc version, etc. The returned identifier has the general format OS - CPU . platform::patterns identifier : This command takes an identifier as returned by platform::identify and returns a list of identifiers describing compatible architectures.","title":"COMMANDS"},{"location":"platform/#example","text":"This can be used to allow an application to be shipped with multiple builds of a shared library, so that the same package works on many versions of an operating system. For example: package require platform # Assume that app script is .../theapp/bin/theapp.tcl set binDir [file dirname [file normalize [info script]]] set libDir [file join \\$binDir .. lib] set platLibDir [file join \\$libDir [ platform::identify ]] load [file join \\$platLibDir support[info sharedlibextension]]","title":"EXAMPLE"},{"location":"platform/#keywords","text":"operating system, cpu architecture, platform, architecture","title":"KEYWORDS"},{"location":"platform_shell/","text":"NAME platform::shell - System identification support code and utilities SYNOPSIS package require platform::shell ?1.1.4? platform::shell::generic shell platform::shell::identify shell platform::shell::platform shell DESCRIPTION The platform::shell package provides several utility commands useful for the identification of the architecture of a specific Tcl shell. This package allows the identification of the architecture of a specific Tcl shell different from the shell running the package. The only requirement is that the other shell (identified by its path), is actually executable on the current machine. While for most platform this means that the architecture of the interrogated shell is identical to the architecture of the running shell this is not generally true. A counter example are all platforms which have 32 and 64 bit variants and where a 64bit system is able to run 32bit code. For these running and interrogated shell may have different 32/64 bit settings and thus different identifiers. For applications like a code repository it is important to identify the architecture of the shell which will actually run the installed packages, versus the architecture of the shell running the repository software. COMMANDS platform::shell::identify shell : This command does the same identification as platform::identify , for the specified Tcl shell, in contrast to the running shell. platform::shell::generic shell : This command does the same identification as platform::generic , for the specified Tcl shell, in contrast to the running shell. platform::shell::platform shell : This command returns the contents of tcl_platform(platform) for the specified Tcl shell. KEYWORDS operating system, cpu architecture, platform, architecture","title":"NAME"},{"location":"platform_shell/#name","text":"platform::shell - System identification support code and utilities","title":"NAME"},{"location":"platform_shell/#synopsis","text":"package require platform::shell ?1.1.4? platform::shell::generic shell platform::shell::identify shell platform::shell::platform shell","title":"SYNOPSIS"},{"location":"platform_shell/#description","text":"The platform::shell package provides several utility commands useful for the identification of the architecture of a specific Tcl shell. This package allows the identification of the architecture of a specific Tcl shell different from the shell running the package. The only requirement is that the other shell (identified by its path), is actually executable on the current machine. While for most platform this means that the architecture of the interrogated shell is identical to the architecture of the running shell this is not generally true. A counter example are all platforms which have 32 and 64 bit variants and where a 64bit system is able to run 32bit code. For these running and interrogated shell may have different 32/64 bit settings and thus different identifiers. For applications like a code repository it is important to identify the architecture of the shell which will actually run the installed packages, versus the architecture of the shell running the repository software.","title":"DESCRIPTION"},{"location":"platform_shell/#commands","text":"platform::shell::identify shell : This command does the same identification as platform::identify , for the specified Tcl shell, in contrast to the running shell. platform::shell::generic shell : This command does the same identification as platform::generic , for the specified Tcl shell, in contrast to the running shell. platform::shell::platform shell : This command returns the contents of tcl_platform(platform) for the specified Tcl shell.","title":"COMMANDS"},{"location":"platform_shell/#keywords","text":"operating system, cpu architecture, platform, architecture","title":"KEYWORDS"},{"location":"prefix/","text":"NAME tcl::prefix - facilities for prefix matching SYNOPSIS ::tcl::prefix all table string ::tcl::prefix longest table string ::tcl::prefix match ?option ...? table string DESCRIPTION This document describes commands looking up a prefix in a list of strings. The following commands are supported: ::tcl::prefix all table string : Returns a list of all elements in table that begin with the prefix string . ::tcl::prefix longest table string : Returns the longest common prefix of all elements in table that begin with the prefix string . ::tcl::prefix match ? options ? table string : If string equals one element in table or is a prefix to exactly one element, the matched element is returned. If not, the result depends on the -error option. (It is recommended that the table be sorted before use with this subcommand, so that the list of matches presented in the error message also becomes sorted, though this is not strictly necessary for the operation of this subcommand itself.) **-exact** : Accept only exact matches. **-message\u2007***string* : Use *string* in the error message at a mismatch. Default is **-error\u2007***options* : The *options* are used when no match is found. If *options* is empty, no error is generated and an empty string is returned. Otherwise the *options* are used as **return** options when generating the error message. The default corresponds to setting Example: If is used, an error would be generated as: > return -errorcode MyError -level 1 -code error \\\\ \\\"ambiguous > option \\...\\\" EXAMPLES Basic use: namespace import ::tcl::prefix prefix match {apa bepa cepa} apa \u2192 apa prefix match {apa bepa cepa} a \u2192 apa prefix match -exact {apa bepa cepa} a \u2192 bad option \\\"a\\\": must be apa, bepa, or cepa prefix match -message \\\"switch\\\" {apa ada bepa cepa} a \u2192 ambiguous switch \\\"a\\\": must be apa, ada, bepa, or cepa prefix longest {fblocked fconfigure fcopy file fileevent flush} fc \u2192 fco prefix all {fblocked fconfigure fcopy file fileevent flush} fc \u2192 fconfigure fcopy Simplifying option matching: array set opts {-apa 1 -bepa \\\"\\\" -cepa 0} foreach {arg val} \\$args { set opts([ prefix match {-apa -bepa -cepa} \\$arg]) \\$val } Creating a switch that supports prefixes: switch [ prefix match {apa bepa cepa} \\$arg] { apa { } bepa { } cepa { } } SEE ALSO lsearch(n), namespace(n), string(n), Tcl_GetIndexFromObj(3) KEYWORDS prefix, table lookup","title":"NAME"},{"location":"prefix/#name","text":"tcl::prefix - facilities for prefix matching","title":"NAME"},{"location":"prefix/#synopsis","text":"::tcl::prefix all table string ::tcl::prefix longest table string ::tcl::prefix match ?option ...? table string","title":"SYNOPSIS"},{"location":"prefix/#description","text":"This document describes commands looking up a prefix in a list of strings. The following commands are supported: ::tcl::prefix all table string : Returns a list of all elements in table that begin with the prefix string . ::tcl::prefix longest table string : Returns the longest common prefix of all elements in table that begin with the prefix string . ::tcl::prefix match ? options ? table string : If string equals one element in table or is a prefix to exactly one element, the matched element is returned. If not, the result depends on the -error option. (It is recommended that the table be sorted before use with this subcommand, so that the list of matches presented in the error message also becomes sorted, though this is not strictly necessary for the operation of this subcommand itself.) **-exact** : Accept only exact matches. **-message\u2007***string* : Use *string* in the error message at a mismatch. Default is **-error\u2007***options* : The *options* are used when no match is found. If *options* is empty, no error is generated and an empty string is returned. Otherwise the *options* are used as **return** options when generating the error message. The default corresponds to setting Example: If is used, an error would be generated as: > return -errorcode MyError -level 1 -code error \\\\ \\\"ambiguous > option \\...\\\"","title":"DESCRIPTION"},{"location":"prefix/#examples","text":"Basic use: namespace import ::tcl::prefix prefix match {apa bepa cepa} apa \u2192 apa prefix match {apa bepa cepa} a \u2192 apa prefix match -exact {apa bepa cepa} a \u2192 bad option \\\"a\\\": must be apa, bepa, or cepa prefix match -message \\\"switch\\\" {apa ada bepa cepa} a \u2192 ambiguous switch \\\"a\\\": must be apa, ada, bepa, or cepa prefix longest {fblocked fconfigure fcopy file fileevent flush} fc \u2192 fco prefix all {fblocked fconfigure fcopy file fileevent flush} fc \u2192 fconfigure fcopy Simplifying option matching: array set opts {-apa 1 -bepa \\\"\\\" -cepa 0} foreach {arg val} \\$args { set opts([ prefix match {-apa -bepa -cepa} \\$arg]) \\$val } Creating a switch that supports prefixes: switch [ prefix match {apa bepa cepa} \\$arg] { apa { } bepa { } cepa { } }","title":"EXAMPLES"},{"location":"prefix/#see-also","text":"lsearch(n), namespace(n), string(n), Tcl_GetIndexFromObj(3)","title":"SEE ALSO"},{"location":"prefix/#keywords","text":"prefix, table lookup","title":"KEYWORDS"},{"location":"proc/","text":"NAME proc - Create a Tcl procedure SYNOPSIS proc name args body DESCRIPTION The proc command creates a new Tcl procedure named name , replacing any existing command or procedure there may have been by that name. Whenever the new command is invoked, the contents of body will be executed by the Tcl interpreter. Normally, name is unqualified (does not include the names of any containing namespaces), and the new procedure is created in the current namespace. If name includes any namespace qualifiers, the procedure is created in the specified namespace. Args specifies the formal arguments to the procedure. It consists of a list, possibly empty, each of whose elements specifies one argument. Each argument specifier is also a list with either one or two fields. If there is only a single field in the specifier then it is the name of the argument; if there are two fields, then the first is the argument name and the second is its default value. Arguments with default values that are followed by non-defaulted arguments become required arguments; enough actual arguments must be supplied to allow all arguments up to and including the last required formal argument. When name is invoked a local variable will be created for each of the formal arguments to the procedure; its value will be the value of corresponding argument in the invoking command or the argument\\'s default value. Actual arguments are assigned to formal arguments strictly in order. Arguments with default values need not be specified in a procedure invocation. However, there must be enough actual arguments for all the formal arguments that do not have defaults, and there must not be any extra actual arguments. Arguments with default values that are followed by non-defaulted arguments become de-facto required arguments, though this may change in a future version of Tcl; portable code should ensure that all optional arguments come after all required arguments. There is one special case to permit procedures with variable numbers of arguments. If the last formal argument has the name then a call to the procedure may contain more actual arguments than the procedure has formal arguments. In this case, all of the actual arguments starting at the one that would be assigned to args are combined into a list (as if the list command had been used); this combined value is assigned to the local variable args . When body is being executed, variable names normally refer to local variables, which are created automatically when referenced and deleted when the procedure returns. One local variable is automatically created for each of the procedure\\'s arguments. Other variables can only be accessed by invoking one of the global , variable , upvar or namespace upvar commands. The current namespace when body is executed will be the namespace that the procedure\\'s name exists in, which will be the namespace that it was created in unless it has been changed with rename . The proc command returns an empty string. When a procedure is invoked, the procedure\\'s return value is the value specified in a return command. If the procedure does not execute an explicit return , then its return value is the value of the last command executed in the procedure\\'s body. If an error occurs while executing the procedure body, then the procedure-as-a-whole will return that same error. EXAMPLES This is a procedure that takes two arguments and prints both their sum and their product. It also returns the string to the caller as an explicit result. proc printSumProduct {x y} { set sum [expr {\\$x + \\$y}] set prod [expr {\\$x * \\$y}] puts \\\"sum is \\$sum, product is \\$prod\\\" return \\\"OK\\\" } This is a procedure that accepts arbitrarily many arguments and prints them out, one by one. proc printArguments args { foreach arg \\$args { puts \\$arg } } This procedure is a bit like the incr command, except it multiplies the contents of the named variable by the value, which defaults to 2 : proc mult {varName {multiplier 2}} { upvar 1 \\$varName var set var [expr {\\$var * \\$multiplier}] } SEE ALSO info(n), unknown(n) KEYWORDS argument, procedure","title":"NAME"},{"location":"proc/#name","text":"proc - Create a Tcl procedure","title":"NAME"},{"location":"proc/#synopsis","text":"proc name args body","title":"SYNOPSIS"},{"location":"proc/#description","text":"The proc command creates a new Tcl procedure named name , replacing any existing command or procedure there may have been by that name. Whenever the new command is invoked, the contents of body will be executed by the Tcl interpreter. Normally, name is unqualified (does not include the names of any containing namespaces), and the new procedure is created in the current namespace. If name includes any namespace qualifiers, the procedure is created in the specified namespace. Args specifies the formal arguments to the procedure. It consists of a list, possibly empty, each of whose elements specifies one argument. Each argument specifier is also a list with either one or two fields. If there is only a single field in the specifier then it is the name of the argument; if there are two fields, then the first is the argument name and the second is its default value. Arguments with default values that are followed by non-defaulted arguments become required arguments; enough actual arguments must be supplied to allow all arguments up to and including the last required formal argument. When name is invoked a local variable will be created for each of the formal arguments to the procedure; its value will be the value of corresponding argument in the invoking command or the argument\\'s default value. Actual arguments are assigned to formal arguments strictly in order. Arguments with default values need not be specified in a procedure invocation. However, there must be enough actual arguments for all the formal arguments that do not have defaults, and there must not be any extra actual arguments. Arguments with default values that are followed by non-defaulted arguments become de-facto required arguments, though this may change in a future version of Tcl; portable code should ensure that all optional arguments come after all required arguments. There is one special case to permit procedures with variable numbers of arguments. If the last formal argument has the name then a call to the procedure may contain more actual arguments than the procedure has formal arguments. In this case, all of the actual arguments starting at the one that would be assigned to args are combined into a list (as if the list command had been used); this combined value is assigned to the local variable args . When body is being executed, variable names normally refer to local variables, which are created automatically when referenced and deleted when the procedure returns. One local variable is automatically created for each of the procedure\\'s arguments. Other variables can only be accessed by invoking one of the global , variable , upvar or namespace upvar commands. The current namespace when body is executed will be the namespace that the procedure\\'s name exists in, which will be the namespace that it was created in unless it has been changed with rename . The proc command returns an empty string. When a procedure is invoked, the procedure\\'s return value is the value specified in a return command. If the procedure does not execute an explicit return , then its return value is the value of the last command executed in the procedure\\'s body. If an error occurs while executing the procedure body, then the procedure-as-a-whole will return that same error.","title":"DESCRIPTION"},{"location":"proc/#examples","text":"This is a procedure that takes two arguments and prints both their sum and their product. It also returns the string to the caller as an explicit result. proc printSumProduct {x y} { set sum [expr {\\$x + \\$y}] set prod [expr {\\$x * \\$y}] puts \\\"sum is \\$sum, product is \\$prod\\\" return \\\"OK\\\" } This is a procedure that accepts arbitrarily many arguments and prints them out, one by one. proc printArguments args { foreach arg \\$args { puts \\$arg } } This procedure is a bit like the incr command, except it multiplies the contents of the named variable by the value, which defaults to 2 : proc mult {varName {multiplier 2}} { upvar 1 \\$varName var set var [expr {\\$var * \\$multiplier}] }","title":"EXAMPLES"},{"location":"proc/#see-also","text":"info(n), unknown(n)","title":"SEE ALSO"},{"location":"proc/#keywords","text":"argument, procedure","title":"KEYWORDS"},{"location":"process/","text":"NAME tcl::process - Subprocess management SYNOPSIS ::tcl::process option ? arg arg ... ? DESCRIPTION This command provides a way to manage subprocesses created by the open and exec commands, as identified by the process identifiers (PIDs) of those subprocesses. The legal options (which may be abbreviated) are: ::tcl::process autopurge ? flag ? : Automatic purge facility. If flag is specified as a boolean value then it activates or deactivate autopurge. In all cases it returns the current status as a boolean value. When autopurge is active, Tcl_ReapDetachedProcs is called each time the exec command is executed or a pipe channel created by open is closed. When autopurge is inactive, ::tcl::process purge must be called explicitly. By default autopurge is active. ::tcl::process list : Returns the list of subprocess PIDs. This includes all currently executing subprocesses and all terminated subprocesses that have not yet had their corresponding process table entries purged. ::tcl::process purge ? pids ? : Cleans up all data associated with terminated subprocesses. If pids is specified as a list of PIDs then the command only cleanup data for the matching subprocesses if they exist, and raises an error otherwise. If a process listed is still active, this command does nothing to that process. ::tcl::process status ? switches ? ? pids ? : Returns a dictionary mapping subprocess PIDs to their respective status. If pids is specified as a list of PIDs then the command only returns the status of the matching subprocesses if they exist, and raises an error otherwise. For active processes, the status is an empty value. For terminated processes, the status is a list with the following format: where: code \u2007 : is a standard Tcl return code, i.e., 0 for TCL_OK and 1 for TCL_ERROR, msg \u2007 : is the human-readable error message, errorCode \u2007 : uses the same format as the errorCode global variable Note that msg and errorCode are only present for abnormally terminated processes (i.e. those where the code is nonzero). Under the hood this command calls Tcl_WaitPid with the WNOHANG flag set for non-blocking behavior, unless the -wait switch is set (see below). Additionally, ::tcl::process status accepts the following switches: -wait \u2007 : By default the command returns immediately (the underlying Tcl_WaitPid is called with the WNOHANG flag set) unless this switch is set. If pids is specified as a list of PIDs then the command waits until the status of the matching subprocesses are available. If pids was not specified, this command will wait for all known subprocesses. -\u2006- : Marks the end of switches. The argument following this one will be treated as the first arg even if it starts with a - . EXAMPLES These show the use of ::tcl::process . Some of the results from ::tcl::process status are split over multiple lines for readability. ::tcl::process autopurge \u2192 true ::tcl::process autopurge false \u2192 false set pid1 [exec command1 a b c | command2 d e f &] \u2192 123 456 set chan [open \\\"|command1 a b c | command2 d e f\\\"] \u2192 file123 set pid2 [pid \\$chan] \u2192 789 1011 ::tcl::process list \u2192 123 456 789 1011 ::tcl::process status \u2192 123 0 456 {1 \\\"child killed: write on pipe with no readers\\\" { CHILDKILLED 456 SIGPIPE \\\"write on pipe with no readers\\\"}} 789 {1 \\\"child suspended: background tty read\\\" { CHILDSUSP 789 SIGTTIN \\\"background tty read\\\"}} 1011 {} ::tcl::process status 123 \u2192 123 0 ::tcl::process status 1011 \u2192 1011 {} ::tcl::process status -wait \u2192 123 0 456 {1 \\\"child killed: write on pipe with no readers\\\" { CHILDKILLED 456 SIGPIPE \\\"write on pipe with no readers\\\"}} 789 {1 \\\"child suspended: background tty read\\\" { CHILDSUSP 789 SIGTTIN \\\"background tty read\\\"}} 1011 {1 \\\"child process exited abnormally\\\" { CHILDSTATUS 1011 -1}} ::tcl::process status 1011 \u2192 1011 {1 \\\"child process exited abnormally\\\" { CHILDSTATUS 1011 -1}} ::tcl::process purge exec command1 1 2 3 & \u2192 1213 ::tcl::process list \u2192 1213 SEE ALSO exec(n), open(n), pid(n), Tcl_DetachPids(3), Tcl_WaitPid(3), Tcl_ReapDetachedProcs(3) KEYWORDS background, child, detach, process, wait","title":"NAME"},{"location":"process/#name","text":"tcl::process - Subprocess management","title":"NAME"},{"location":"process/#synopsis","text":"::tcl::process option ? arg arg ... ?","title":"SYNOPSIS"},{"location":"process/#description","text":"This command provides a way to manage subprocesses created by the open and exec commands, as identified by the process identifiers (PIDs) of those subprocesses. The legal options (which may be abbreviated) are: ::tcl::process autopurge ? flag ? : Automatic purge facility. If flag is specified as a boolean value then it activates or deactivate autopurge. In all cases it returns the current status as a boolean value. When autopurge is active, Tcl_ReapDetachedProcs is called each time the exec command is executed or a pipe channel created by open is closed. When autopurge is inactive, ::tcl::process purge must be called explicitly. By default autopurge is active. ::tcl::process list : Returns the list of subprocess PIDs. This includes all currently executing subprocesses and all terminated subprocesses that have not yet had their corresponding process table entries purged. ::tcl::process purge ? pids ? : Cleans up all data associated with terminated subprocesses. If pids is specified as a list of PIDs then the command only cleanup data for the matching subprocesses if they exist, and raises an error otherwise. If a process listed is still active, this command does nothing to that process. ::tcl::process status ? switches ? ? pids ? : Returns a dictionary mapping subprocess PIDs to their respective status. If pids is specified as a list of PIDs then the command only returns the status of the matching subprocesses if they exist, and raises an error otherwise. For active processes, the status is an empty value. For terminated processes, the status is a list with the following format: where: code \u2007 : is a standard Tcl return code, i.e., 0 for TCL_OK and 1 for TCL_ERROR, msg \u2007 : is the human-readable error message, errorCode \u2007 : uses the same format as the errorCode global variable Note that msg and errorCode are only present for abnormally terminated processes (i.e. those where the code is nonzero). Under the hood this command calls Tcl_WaitPid with the WNOHANG flag set for non-blocking behavior, unless the -wait switch is set (see below). Additionally, ::tcl::process status accepts the following switches: -wait \u2007 : By default the command returns immediately (the underlying Tcl_WaitPid is called with the WNOHANG flag set) unless this switch is set. If pids is specified as a list of PIDs then the command waits until the status of the matching subprocesses are available. If pids was not specified, this command will wait for all known subprocesses. -\u2006- : Marks the end of switches. The argument following this one will be treated as the first arg even if it starts with a - .","title":"DESCRIPTION"},{"location":"process/#examples","text":"These show the use of ::tcl::process . Some of the results from ::tcl::process status are split over multiple lines for readability. ::tcl::process autopurge \u2192 true ::tcl::process autopurge false \u2192 false set pid1 [exec command1 a b c | command2 d e f &] \u2192 123 456 set chan [open \\\"|command1 a b c | command2 d e f\\\"] \u2192 file123 set pid2 [pid \\$chan] \u2192 789 1011 ::tcl::process list \u2192 123 456 789 1011 ::tcl::process status \u2192 123 0 456 {1 \\\"child killed: write on pipe with no readers\\\" { CHILDKILLED 456 SIGPIPE \\\"write on pipe with no readers\\\"}} 789 {1 \\\"child suspended: background tty read\\\" { CHILDSUSP 789 SIGTTIN \\\"background tty read\\\"}} 1011 {} ::tcl::process status 123 \u2192 123 0 ::tcl::process status 1011 \u2192 1011 {} ::tcl::process status -wait \u2192 123 0 456 {1 \\\"child killed: write on pipe with no readers\\\" { CHILDKILLED 456 SIGPIPE \\\"write on pipe with no readers\\\"}} 789 {1 \\\"child suspended: background tty read\\\" { CHILDSUSP 789 SIGTTIN \\\"background tty read\\\"}} 1011 {1 \\\"child process exited abnormally\\\" { CHILDSTATUS 1011 -1}} ::tcl::process status 1011 \u2192 1011 {1 \\\"child process exited abnormally\\\" { CHILDSTATUS 1011 -1}} ::tcl::process purge exec command1 1 2 3 & \u2192 1213 ::tcl::process list \u2192 1213","title":"EXAMPLES"},{"location":"process/#see-also","text":"exec(n), open(n), pid(n), Tcl_DetachPids(3), Tcl_WaitPid(3), Tcl_ReapDetachedProcs(3)","title":"SEE ALSO"},{"location":"process/#keywords","text":"background, child, detach, process, wait","title":"KEYWORDS"},{"location":"puts/","text":"NAME puts - Write to a channel SYNOPSIS puts ? -nonewline ? ? channelId ? string DESCRIPTION Writes the characters given by string to the channel given by channelId . ChannelId must be an identifier for an open channel such as a Tcl standard channel ( stdout or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. The channel must have been opened for output. If no channelId is specified then it defaults to stdout . Puts normally outputs a newline character after string , but this feature may be suppressed by specifying the -nonewline switch. Newline characters in the output are translated by puts to platform-specific end-of-line sequences according to the current value of the -translation option for the channel (for example, on PCs newlines are normally replaced with carriage-return-linefeed sequences. See the fconfigure manual entry for a discussion on ways in which fconfigure will alter output. Tcl buffers output internally, so characters written with puts may not appear immediately on the output file or device; Tcl will normally delay output until the buffer is full or the channel is closed. You can force output to appear immediately with the flush command. When the output buffer fills up, the puts command will normally block until all the buffered data has been accepted for output by the operating system. If channelId is in nonblocking mode then the puts command will not block even if the operating system cannot accept the data. Instead, Tcl continues to buffer the data and writes it in the background as fast as the underlying file or device can accept it. The application must use the Tcl event loop for nonblocking output to work; otherwise Tcl never finds out that the file or device is ready for more output data. It is possible for an arbitrarily large amount of data to be buffered for a channel in nonblocking mode, which could consume a large amount of memory. To avoid wasting memory, nonblocking I/O should normally be used in an event-driven fashion with the fileevent command (do not invoke puts unless you have recently been notified via a file event that the channel is ready for more output data). EXAMPLES Write a short message to the console (or wherever stdout is directed): puts \\\"Hello, World!\\\" Print a message in several parts: puts -nonewline \\\"Hello, \\\" puts \\\"World!\\\" Print a message to the standard error channel: puts stderr \\\"Hello, World!\\\" Append a log message to a file: set chan [open my.log a] set timestamp [clock format [clock seconds]] puts \\$chan \\\"\\$timestamp - Hello, World!\\\" close \\$chan SEE ALSO file(n), fileevent(n), Tcl_StandardChannels(3) KEYWORDS channel, newline, output, write","title":"NAME"},{"location":"puts/#name","text":"puts - Write to a channel","title":"NAME"},{"location":"puts/#synopsis","text":"puts ? -nonewline ? ? channelId ? string","title":"SYNOPSIS"},{"location":"puts/#description","text":"Writes the characters given by string to the channel given by channelId . ChannelId must be an identifier for an open channel such as a Tcl standard channel ( stdout or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. The channel must have been opened for output. If no channelId is specified then it defaults to stdout . Puts normally outputs a newline character after string , but this feature may be suppressed by specifying the -nonewline switch. Newline characters in the output are translated by puts to platform-specific end-of-line sequences according to the current value of the -translation option for the channel (for example, on PCs newlines are normally replaced with carriage-return-linefeed sequences. See the fconfigure manual entry for a discussion on ways in which fconfigure will alter output. Tcl buffers output internally, so characters written with puts may not appear immediately on the output file or device; Tcl will normally delay output until the buffer is full or the channel is closed. You can force output to appear immediately with the flush command. When the output buffer fills up, the puts command will normally block until all the buffered data has been accepted for output by the operating system. If channelId is in nonblocking mode then the puts command will not block even if the operating system cannot accept the data. Instead, Tcl continues to buffer the data and writes it in the background as fast as the underlying file or device can accept it. The application must use the Tcl event loop for nonblocking output to work; otherwise Tcl never finds out that the file or device is ready for more output data. It is possible for an arbitrarily large amount of data to be buffered for a channel in nonblocking mode, which could consume a large amount of memory. To avoid wasting memory, nonblocking I/O should normally be used in an event-driven fashion with the fileevent command (do not invoke puts unless you have recently been notified via a file event that the channel is ready for more output data).","title":"DESCRIPTION"},{"location":"puts/#examples","text":"Write a short message to the console (or wherever stdout is directed): puts \\\"Hello, World!\\\" Print a message in several parts: puts -nonewline \\\"Hello, \\\" puts \\\"World!\\\" Print a message to the standard error channel: puts stderr \\\"Hello, World!\\\" Append a log message to a file: set chan [open my.log a] set timestamp [clock format [clock seconds]] puts \\$chan \\\"\\$timestamp - Hello, World!\\\" close \\$chan","title":"EXAMPLES"},{"location":"puts/#see-also","text":"file(n), fileevent(n), Tcl_StandardChannels(3)","title":"SEE ALSO"},{"location":"puts/#keywords","text":"channel, newline, output, write","title":"KEYWORDS"},{"location":"pwd/","text":"NAME pwd - Return the absolute path of the current working directory SYNOPSIS pwd DESCRIPTION Returns the absolute path name of the current working directory. EXAMPLE Sometimes it is useful to change to a known directory when running some external command using exec , but it is important to keep the application usually running in the directory that it was started in (unless the user specifies otherwise) since that minimizes user confusion. The way to do this is to save the current directory while the external command is being run: set tarFile [file normalize somefile.tar] set savedDir [ pwd ] cd /tmp exec tar -xf \\$tarFile cd \\$savedDir SEE ALSO file(n), cd(n), glob(n), filename(n) KEYWORDS working directory","title":"NAME"},{"location":"pwd/#name","text":"pwd - Return the absolute path of the current working directory","title":"NAME"},{"location":"pwd/#synopsis","text":"pwd","title":"SYNOPSIS"},{"location":"pwd/#description","text":"Returns the absolute path name of the current working directory.","title":"DESCRIPTION"},{"location":"pwd/#example","text":"Sometimes it is useful to change to a known directory when running some external command using exec , but it is important to keep the application usually running in the directory that it was started in (unless the user specifies otherwise) since that minimizes user confusion. The way to do this is to save the current directory while the external command is being run: set tarFile [file normalize somefile.tar] set savedDir [ pwd ] cd /tmp exec tar -xf \\$tarFile cd \\$savedDir","title":"EXAMPLE"},{"location":"pwd/#see-also","text":"file(n), cd(n), glob(n), filename(n)","title":"SEE ALSO"},{"location":"pwd/#keywords","text":"working directory","title":"KEYWORDS"},{"location":"re_syntax/","text":"NAME re_syntax - Syntax of Tcl regular expressions DESCRIPTION A regular expression describes strings of characters. It\\'s a pattern that matches certain strings and does not match others. DIFFERENT FLAVORS OF REs Regular expressions as defined by POSIX, come in two flavors: extended REs and basic REs EREs are roughly those of the traditional egrep , while BREs are roughly those of the traditional ed . This implementation adds a third flavor, advanced REs basically EREs with some significant extensions. This manual page primarily describes AREs. BREs mostly exist for backward compatibility in some old programs; they will be discussed at the end. POSIX EREs are almost an exact subset of AREs. Features of AREs that are not present in EREs will be indicated. REGULAR EXPRESSION SYNTAX Tcl regular expressions are implemented using the package written by Henry Spencer, based on the 1003.2 spec and some (not quite all) of the Perl5 extensions (thanks, Henry!). Much of the description of regular expressions below is copied verbatim from his manual entry. An ARE is one or more branches , separated by matching anything that matches any of the branches. A branch is zero or more constraints or quantified atoms , concatenated. It matches a match for the first, followed by a match for the second, etc; an empty branch matches the empty string. QUANTIFIERS A quantified atom is an atom possibly followed by a single quantifier . Without a quantifier, it matches a single match for the atom. The quantifiers, and what a so-quantified atom matches, are: * : a sequence of 0 or more matches of the atom + : a sequence of 1 or more matches of the atom ? : a sequence of 0 or 1 matches of the atom { m } : a sequence of exactly m matches of the atom { m ,} : a sequence of m or more matches of the atom { m , n } : a sequence of m through n (inclusive) matches of the atom; m may not exceed n *? +? ?? { m }? { m ,}? { m , n }? : non-greedy quantifiers, which match the same possibilities, but prefer the smallest number rather than the largest number of matches (see MATCHING ) The forms using { and } are known as bound s. The numbers m and n are unsigned decimal integers with permissible values from 0 to 255 inclusive. ATOMS An atom is one of: (re) : matches a match for re ( re is any regular expression) with the match noted for possible reporting (?:re) : as previous, but does no reporting (a set of parentheses) () : matches an empty string, noted for possible reporting (?:) : matches an empty string, without reporting [chars] : a bracket expression , matching any one of the chars (see BRACKET EXPRESSIONS for more detail) . : matches any single character \\k : matches the non-alphanumeric character k taken as an ordinary character, e.g. \\\\ matches a backslash character \\c : where c is alphanumeric (possibly followed by other characters), an escape (AREs only), see ESCAPES below { : when followed by a character other than a digit, matches the left-brace character when followed by a digit, it is the beginning of a bound (see above) x. where x is a single character with no other significance, matches that character. CONSTRAINTS A constraint matches an empty string when specific conditions are met. A constraint may not be followed by a quantifier. The simple constraints are as follows; some more constraints are described later, under ESCAPES . \\^ : matches at the beginning of the string or a line (according to whether matching is newline-sensitive or not, as described in MATCHING , below). \\$ : matches at the end of the string or a line (according to whether matching is newline-sensitive or not, as described in MATCHING , below). The difference between string and line matching modes is immaterial when the string does not contain a newline character. The **\\\\A** and **\\\\Z** constraint escapes have a similar purpose but are always constraints for the overall string. The default newline-sensitivity depends on the command that uses the regular expression, and can be overridden as described in **METASYNTAX**, below. (?= re ) : positive lookahead (AREs only), matches at any point where a substring matching re begins (?! re ) : negative lookahead (AREs only), matches at any point where no substring matching re begins The lookahead constraints may not contain back references (see later), and all parentheses within them are considered non-capturing. An RE may not end with BRACKET EXPRESSIONS A bracket expression is a list of characters enclosed in It normally matches any single character from the list (but see below). If the list begins with it matches any single character (but see below) not from the rest of the list. If two characters in the list are separated by this is shorthand for the full range of characters between those two (inclusive) in the collating sequence, e.g. in Unicode matches any conventional decimal digit. Two ranges may not share an endpoint, so e.g. is illegal. Ranges in Tcl always use the Unicode collating sequence, but other programs may use other collating sequences and this can be a source of incompatibility between programs. To include a literal ] or - in the list, the simplest method is to enclose it in [. and .] to make it a collating element (see below). Alternatively, make it the first character (following a possible or (AREs only) precede it with Alternatively, for make it the last character, or the second endpoint of a range. To use a literal - as the first endpoint of a range, make it a collating element or (AREs only) precede it with With the exception of these, some combinations using [ (see next paragraphs), and escapes, all other special characters lose their special significance within a bracket expression. CHARACTER CLASSES Within a bracket expression, the name of a character class enclosed in [: and :] stands for the list of all characters (not all collating elements!) belonging to that class. Standard character classes are: alpha : A letter. upper : An upper-case letter. lower : A lower-case letter. digit : A decimal digit. xdigit : A hexadecimal digit. alnum : An alphanumeric (letter or digit). print : A \\\"printable\\\" (same as graph, except also including space). blank : A space or tab character. space : A character producing white space in displayed text. punct : A punctuation character. graph : A character with a visible representation (includes both alnum and punct ). cntrl : A control character. A locale may provide others. A character class may not be used as an endpoint of a range. ( Note: the current Tcl implementation has only one locale, the Unicode locale, which supports exactly the above classes.) BRACKETED CONSTRAINTS There are two special cases of bracket expressions: the bracket expressions and are constraints, matching empty strings at the beginning and end of a word respectively. A word is defined as a sequence of word characters that is neither preceded nor followed by word characters. A word character is an alnum character or an underscore These special bracket expressions are deprecated; users of AREs should use constraint escapes instead (see below). COLLATING ELEMENTS Within a bracket expression, a collating element (a character, a multi-character sequence that collates as if it were a single character, or a collating-sequence name for either) enclosed in [. and .] stands for the sequence of characters of that collating element. The sequence is a single element of the bracket expression\\'s list. A bracket expression in a locale that has multi-character collating elements can thus match more than one character. So (insidiously), a bracket expression that starts with \\^ can match multi-character collating elements even if none of them appear in the bracket expression! ( Note: Tcl has no multi-character collating elements. This information is only for illustration.) For example, assume the collating sequence includes a ch multi-character collating element. Then the RE (zero or more followed by matches the first five characters of Also, the RE matches all of (because matches the multi-character EQUIVALENCE CLASSES Within a bracket expression, a collating element enclosed in [= and =] is an equivalence class, standing for the sequences of characters of all collating elements equivalent to that one, including itself. (If there are no other equivalent collating elements, the treatment is as if the enclosing delimiters were and For example, if o and \u00f4 are the members of an equivalence class, then and are all synonymous. An equivalence class may not be an endpoint of a range. ( Note: Tcl implements only the Unicode locale. It does not define any equivalence classes. The examples above are just illustrations.) ESCAPES Escapes (AREs only), which begin with a \\ followed by an alphanumeric character, come in several varieties: character entry, class shorthands, constraint escapes, and back references. A \\ followed by an alphanumeric character but not constituting a valid escape is illegal in AREs. In EREs, there are no escapes: outside a bracket expression, a \\ followed by an alphanumeric character merely stands for that character as an ordinary character, and inside a bracket expression, \\ is an ordinary character. (The latter is the one actual incompatibility between EREs and AREs.) CHARACTER-ENTRY ESCAPES Character-entry escapes (AREs only) exist to make it easier to specify non-printing and otherwise inconvenient characters in REs: \\a : alert (bell) character, as in C \\b : backspace, as in C \\B : synonym for \\ to help reduce backslash doubling in some applications where there are multiple levels of backslash processing \\c X : (where X is any character) the character whose low-order 5 bits are the same as those of X , and whose other bits are all zero \\e : the character whose collating-sequence name is or failing that, the character with octal value 033 \\f : formfeed, as in C \\n : newline, as in C \\r : carriage return, as in C \\t : horizontal tab, as in C \\u wxyz : (where wxyz is one up to four hexadecimal digits) the Unicode character U+ wxyz in the local byte ordering \\U stuvwxyz : (where stuvwxyz is one up to eight hexadecimal digits) reserved for a Unicode extension up to 21 bits. The digits are parsed until the first non-hexadecimal character is encountered, the maximun of eight hexadecimal digits are reached, or an overflow would occur in the maximum value of U+ 10ffff . \\v : vertical tab, as in C \\x hh : (where hh is one or two hexadecimal digits) the character whose hexadecimal value is 0x hh . \\0 : the character whose value is 0 \\ xyz : (where xyz is exactly three octal digits, and is not a back reference (see below)) the character whose octal value is 0 xyz . The first digit must be in the range 0-3, otherwise the two-digit form is assumed. \\ xy : (where xy is exactly two octal digits, and is not a back reference (see below)) the character whose octal value is 0 xy Hexadecimal digits are and Octal digits are The character-entry escapes are always taken as ordinary characters. For example, \\135 is ] in Unicode, but \\135 does not terminate a bracket expression. Beware, however, that some applications (e.g., C compilers and the Tcl interpreter if the regular expression is not quoted with braces) interpret such sequences themselves before the regular-expression package gets to see them, which may require doubling (quadrupling, etc.) the CLASS-SHORTHAND ESCAPES Class-shorthand escapes (AREs only) provide shorthands for certain commonly-used character classes: \\d : [[:digit:]] \\s : [[:space:]] \\w : [[:alnum:]_\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D\\uFE4E\\uFE4F\\uFF3F] (including punctuation connector characters) \\D : [\\^[:digit:]] \\S : [\\^[:space:]] \\W : [\\^[:alnum:]_\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D\\uFE4E\\uFE4F\\uFF3F] (including punctuation connector characters) Within bracket expressions, and lose their outer brackets, and and are illegal. (So, for example, is equivalent to Also, which is equivalent to is illegal.) CONSTRAINT ESCAPES A constraint escape (AREs only) is a constraint, matching the empty string if specific conditions are met, written as an escape: \\A : matches only at the beginning of the string (see MATCHING , below, for how this differs from {=html} <!-- --> \\m : matches only at the beginning of a word \\M : matches only at the end of a word \\y : matches only at the beginning or end of a word \\Y : matches only at a point that is not the beginning or end of a word \\Z : matches only at the end of the string (see MATCHING , below, for how this differs from {=html} <!-- --> \\ m : (where m is a nonzero digit) a back reference , see below \\ mnn : (where m is a nonzero digit, and nn is some more digits, and the decimal value mnn is not greater than the number of closing capturing parentheses seen so far) a back reference , see below A word is defined as in the specification of and above. Constraint escapes are illegal within bracket expressions. BACK REFERENCES A back reference (AREs only) matches the same string matched by the parenthesized subexpression specified by the number, so that (e.g.) matches or but not The subexpression must entirely precede the back reference in the RE. Subexpressions are numbered in the order of their leading parentheses. Non-capturing parentheses do not define subexpressions. There is an inherent historical ambiguity between octal character-entry escapes and back references, which is resolved by heuristics, as hinted at above. A leading zero always indicates an octal escape. A single non-zero digit, not followed by another digit, is always taken as a back reference. A multi-digit sequence not starting with a zero is taken as a back reference if it comes after a suitable subexpression (i.e. the number is in the legal range for a back reference), and otherwise is taken as octal. METASYNTAX In addition to the main syntax described above, there are some special forms and miscellaneous syntactic facilities available. Normally the flavor of RE being used is specified by application-dependent means. However, this can be overridden by a director . If an RE of any flavor begins with the rest of the RE is an ARE. If an RE of any flavor begins with the rest of the RE is taken to be a literal string, with all characters considered ordinary characters. An ARE may begin with embedded options : a sequence (? xyz ) (where xyz is one or more alphabetic characters) specifies options affecting the rest of the RE. These supplement, and can override, any options specified by the application. The available option letters are: b : rest of RE is a BRE c : case-sensitive matching (usual default) e : rest of RE is an ERE i : case-insensitive matching (see MATCHING , below) m : historical synonym for n n : newline-sensitive matching (see MATCHING , below) p : partial newline-sensitive matching (see MATCHING , below) q : rest of RE is a literal string, all ordinary characters s : non-newline-sensitive matching (usual default) t : tight syntax (usual default; see below) w : inverse partial newline-sensitive matching (see MATCHING , below) x : expanded syntax (see below) Embedded options take effect at the ) terminating the sequence. They are available only at the start of an ARE, and may not be used later within it. In addition to the usual ( tight ) RE syntax, in which all characters are significant, there is an expanded syntax, available in all flavors of RE with the -expanded switch, or in AREs with the embedded x option. In the expanded syntax, white-space characters are ignored and all characters between a # and the following newline (or the end of the RE) are ignored, permitting paragraphing and commenting a complex RE. There are three exceptions to that basic rule: a white-space character or preceded by is retained white space or within a bracket expression is retained white space and comments are illegal within multi-character symbols like the ARE or the BRE Expanded-syntax white-space characters are blank, tab, newline, and any character that belongs to the space character class. Finally, in an ARE, outside bracket expressions, the sequence (where ttt is any text not containing a is a comment, completely ignored. Again, this is not allowed between the characters of multi-character symbols like Such comments are more a historical artifact than a useful facility, and their use is deprecated; use the expanded syntax instead. None of these metasyntax extensions is available if the application (or an initial director) has specified that the user\\'s input be treated as a literal string rather than as an RE. MATCHING In the event that an RE could match more than one substring of a given string, the RE matches the one starting earliest in the string. If the RE could match more than one substring starting at that point, its choice is determined by its preference : either the longest substring, or the shortest. Most atoms, and all constraints, have no preference. A parenthesized RE has the same preference (possibly none) as the RE. A quantified atom with quantifier { m } or { m }? has the same preference (possibly none) as the atom itself. A quantified atom with other normal quantifiers (including { m , n } with m equal to n ) prefers longest match. A quantified atom with other non-greedy quantifiers (including { m , n }? with m equal to n ) prefers shortest match. A branch has the same preference as the first quantified atom in it which has a preference. An RE consisting of two or more branches connected by the | operator prefers longest match. Subject to the constraints imposed by the rules for matching the whole RE, subexpressions also match the longest or shortest possible substrings, based on their preferences, with subexpressions starting earlier in the RE taking priority over ones starting later. Note that outer subexpressions thus take priority over their component subexpressions. The quantifiers {1,1} and {1,1}? can be used to force longest and shortest preference, respectively, on a subexpression or a whole RE. NOTE: This means that you can usually make a RE be non-greedy overall by putting {1,1}? after one of the first non-constraint atoms or parenthesized sub-expressions in it. It pays to experiment with the placing of this non-greediness override on a suitable range of input texts when you are writing a RE if you are using this level of complexity. For example, this regular expression is non-greedy, and will match the shortest substring possible given that will be matched as early as possible (the quantifier does not change that): ab{1,1}?c.*x.*cba The atom has no greediness preference, we explicitly give one for and the remaining quantifiers are overridden to be non-greedy by the preceding non-greedy quantifier. Match lengths are measured in characters, not collating elements. An empty string is considered longer than no match at all. For example, matches the three middle characters of matches all ten characters of when is matched against the parenthesized subexpression matches all three characters, and when is matched against both the whole RE and the parenthesized subexpression match an empty string. If case-independent matching is specified, the effect is much as if all case distinctions had vanished from the alphabet. When an alphabetic that exists in multiple cases appears as an ordinary character outside a bracket expression, it is effectively transformed into a bracket expression containing both cases, so that x becomes When it appears inside a bracket expression, all case counterparts of it are added to the bracket expression, so that becomes and becomes If newline-sensitive matching is specified, . and bracket expressions using \\^ will never match the newline character (so that matches will never cross newlines unless the RE explicitly arranges it) and \\^ and \\$ will match the empty string after and before a newline respectively, in addition to matching at beginning and end of string respectively. ARE \\A and \\Z continue to match beginning or end of string only . If partial newline-sensitive matching is specified, this affects . and bracket expressions as with newline-sensitive matching, but not \\^ and \\$ . If inverse partial newline-sensitive matching is specified, this affects \\^ and \\$ as with newline-sensitive matching, but not . and bracket expressions. This is not very useful but is provided for symmetry. LIMITS AND COMPATIBILITY No particular limit is imposed on the length of REs. Programs intended to be highly portable should not employ REs longer than 256 bytes, as a POSIX-compliant implementation can refuse to accept such REs. The only feature of AREs that is actually incompatible with POSIX EREs is that \\ does not lose its special significance inside bracket expressions. All other ARE features use syntax which is illegal or has undefined or unspecified effects in POSIX EREs; the *** syntax of directors likewise is outside the POSIX syntax for both BREs and EREs. Many of the ARE extensions are borrowed from Perl, but some have been changed to clean them up, and a few Perl extensions are not present. Incompatibilities of note include the lack of special treatment for a trailing newline, the addition of complemented bracket expressions to the things affected by newline-sensitive matching, the restrictions on parentheses and back references in lookahead constraints, and the longest/shortest-match (rather than first-match) matching semantics. The matching rules for REs containing both normal and non-greedy quantifiers have changed since early beta-test versions of this package. (The new rules are much simpler and cleaner, but do not work as hard at guessing the user\\'s real intentions.) Henry Spencer\\'s original 1986 regexp package, still in widespread use (e.g., in pre-8.1 releases of Tcl), implemented an early version of today\\'s EREs. There are four incompatibilities between regexp \\'s near-EREs and AREs. In roughly increasing order of significance: In AREs, \\ followed by an alphanumeric character is either an escape or an error, while in RREs, it was just another way of writing the alphanumeric. This should not be a problem because there was no reason to write such a sequence in RREs. { followed by a digit in an ARE is the beginning of a bound, while in RREs, { was always an ordinary character. Such sequences should be rare, and will often result in an error because following characters will not look like a valid bound. In AREs, \\ remains a special character within so a literal \\ within [\u2006] must be written \\\\ also gives a literal \\ within [\u2006] in RREs, but only truly paranoid programmers routinely doubled the backslash. AREs report the longest/shortest match for the RE, rather than the first found in a specified search order. This may affect some RREs which were written in the expectation that the first match would be reported. (The careful crafting of RREs to optimize the search order for fast matching is obsolete (AREs examine all possible matches in parallel, and their performance is largely insensitive to their complexity) but cases where the search order was exploited to deliberately find a match which was not the longest/shortest will need rewriting.) BASIC REGULAR EXPRESSIONS BREs differ from EREs in several respects. and ? are ordinary characters and there is no equivalent for their functionality. The delimiters for bounds are \\{ and with { and } by themselves ordinary characters. The parentheses for nested subexpressions are \\( and with ( and ) by themselves ordinary characters. \\^ is an ordinary character except at the beginning of the RE or the beginning of a parenthesized subexpression, \\$ is an ordinary character except at the end of the RE or the end of a parenthesized subexpression, and * is an ordinary character if it appears at the beginning of the RE or the beginning of a parenthesized subexpression (after a possible leading Finally, single-digit back references are available, and \\\\< and \\> are synonyms for and respectively; no other escapes are available. SEE ALSO RegExp(3), regexp(n), regsub(n), lsearch(n), switch(n), text(n) KEYWORDS match, regular expression, string","title":"NAME"},{"location":"re_syntax/#name","text":"re_syntax - Syntax of Tcl regular expressions","title":"NAME"},{"location":"re_syntax/#description","text":"A regular expression describes strings of characters. It\\'s a pattern that matches certain strings and does not match others.","title":"DESCRIPTION"},{"location":"re_syntax/#different-flavors-of-res","text":"Regular expressions as defined by POSIX, come in two flavors: extended REs and basic REs EREs are roughly those of the traditional egrep , while BREs are roughly those of the traditional ed . This implementation adds a third flavor, advanced REs basically EREs with some significant extensions. This manual page primarily describes AREs. BREs mostly exist for backward compatibility in some old programs; they will be discussed at the end. POSIX EREs are almost an exact subset of AREs. Features of AREs that are not present in EREs will be indicated.","title":"DIFFERENT FLAVORS OF REs"},{"location":"re_syntax/#regular-expression-syntax","text":"Tcl regular expressions are implemented using the package written by Henry Spencer, based on the 1003.2 spec and some (not quite all) of the Perl5 extensions (thanks, Henry!). Much of the description of regular expressions below is copied verbatim from his manual entry. An ARE is one or more branches , separated by matching anything that matches any of the branches. A branch is zero or more constraints or quantified atoms , concatenated. It matches a match for the first, followed by a match for the second, etc; an empty branch matches the empty string.","title":"REGULAR EXPRESSION SYNTAX"},{"location":"re_syntax/#quantifiers","text":"A quantified atom is an atom possibly followed by a single quantifier . Without a quantifier, it matches a single match for the atom. The quantifiers, and what a so-quantified atom matches, are: * : a sequence of 0 or more matches of the atom + : a sequence of 1 or more matches of the atom ? : a sequence of 0 or 1 matches of the atom { m } : a sequence of exactly m matches of the atom { m ,} : a sequence of m or more matches of the atom { m , n } : a sequence of m through n (inclusive) matches of the atom; m may not exceed n *? +? ?? { m }? { m ,}? { m , n }? : non-greedy quantifiers, which match the same possibilities, but prefer the smallest number rather than the largest number of matches (see MATCHING ) The forms using { and } are known as bound s. The numbers m and n are unsigned decimal integers with permissible values from 0 to 255 inclusive.","title":"QUANTIFIERS"},{"location":"re_syntax/#atoms","text":"An atom is one of: (re) : matches a match for re ( re is any regular expression) with the match noted for possible reporting (?:re) : as previous, but does no reporting (a set of parentheses) () : matches an empty string, noted for possible reporting (?:) : matches an empty string, without reporting [chars] : a bracket expression , matching any one of the chars (see BRACKET EXPRESSIONS for more detail) . : matches any single character \\k : matches the non-alphanumeric character k taken as an ordinary character, e.g. \\\\ matches a backslash character \\c : where c is alphanumeric (possibly followed by other characters), an escape (AREs only), see ESCAPES below { : when followed by a character other than a digit, matches the left-brace character when followed by a digit, it is the beginning of a bound (see above) x. where x is a single character with no other significance, matches that character.","title":"ATOMS"},{"location":"re_syntax/#constraints","text":"A constraint matches an empty string when specific conditions are met. A constraint may not be followed by a quantifier. The simple constraints are as follows; some more constraints are described later, under ESCAPES . \\^ : matches at the beginning of the string or a line (according to whether matching is newline-sensitive or not, as described in MATCHING , below). \\$ : matches at the end of the string or a line (according to whether matching is newline-sensitive or not, as described in MATCHING , below). The difference between string and line matching modes is immaterial when the string does not contain a newline character. The **\\\\A** and **\\\\Z** constraint escapes have a similar purpose but are always constraints for the overall string. The default newline-sensitivity depends on the command that uses the regular expression, and can be overridden as described in **METASYNTAX**, below. (?= re ) : positive lookahead (AREs only), matches at any point where a substring matching re begins (?! re ) : negative lookahead (AREs only), matches at any point where no substring matching re begins The lookahead constraints may not contain back references (see later), and all parentheses within them are considered non-capturing. An RE may not end with","title":"CONSTRAINTS"},{"location":"re_syntax/#bracket-expressions","text":"A bracket expression is a list of characters enclosed in It normally matches any single character from the list (but see below). If the list begins with it matches any single character (but see below) not from the rest of the list. If two characters in the list are separated by this is shorthand for the full range of characters between those two (inclusive) in the collating sequence, e.g. in Unicode matches any conventional decimal digit. Two ranges may not share an endpoint, so e.g. is illegal. Ranges in Tcl always use the Unicode collating sequence, but other programs may use other collating sequences and this can be a source of incompatibility between programs. To include a literal ] or - in the list, the simplest method is to enclose it in [. and .] to make it a collating element (see below). Alternatively, make it the first character (following a possible or (AREs only) precede it with Alternatively, for make it the last character, or the second endpoint of a range. To use a literal - as the first endpoint of a range, make it a collating element or (AREs only) precede it with With the exception of these, some combinations using [ (see next paragraphs), and escapes, all other special characters lose their special significance within a bracket expression.","title":"BRACKET EXPRESSIONS"},{"location":"re_syntax/#character-classes","text":"Within a bracket expression, the name of a character class enclosed in [: and :] stands for the list of all characters (not all collating elements!) belonging to that class. Standard character classes are: alpha : A letter. upper : An upper-case letter. lower : A lower-case letter. digit : A decimal digit. xdigit : A hexadecimal digit. alnum : An alphanumeric (letter or digit). print : A \\\"printable\\\" (same as graph, except also including space). blank : A space or tab character. space : A character producing white space in displayed text. punct : A punctuation character. graph : A character with a visible representation (includes both alnum and punct ). cntrl : A control character. A locale may provide others. A character class may not be used as an endpoint of a range. ( Note: the current Tcl implementation has only one locale, the Unicode locale, which supports exactly the above classes.)","title":"CHARACTER CLASSES"},{"location":"re_syntax/#bracketed-constraints","text":"There are two special cases of bracket expressions: the bracket expressions and are constraints, matching empty strings at the beginning and end of a word respectively. A word is defined as a sequence of word characters that is neither preceded nor followed by word characters. A word character is an alnum character or an underscore These special bracket expressions are deprecated; users of AREs should use constraint escapes instead (see below).","title":"BRACKETED CONSTRAINTS"},{"location":"re_syntax/#collating-elements","text":"Within a bracket expression, a collating element (a character, a multi-character sequence that collates as if it were a single character, or a collating-sequence name for either) enclosed in [. and .] stands for the sequence of characters of that collating element. The sequence is a single element of the bracket expression\\'s list. A bracket expression in a locale that has multi-character collating elements can thus match more than one character. So (insidiously), a bracket expression that starts with \\^ can match multi-character collating elements even if none of them appear in the bracket expression! ( Note: Tcl has no multi-character collating elements. This information is only for illustration.) For example, assume the collating sequence includes a ch multi-character collating element. Then the RE (zero or more followed by matches the first five characters of Also, the RE matches all of (because matches the multi-character","title":"COLLATING ELEMENTS"},{"location":"re_syntax/#equivalence-classes","text":"Within a bracket expression, a collating element enclosed in [= and =] is an equivalence class, standing for the sequences of characters of all collating elements equivalent to that one, including itself. (If there are no other equivalent collating elements, the treatment is as if the enclosing delimiters were and For example, if o and \u00f4 are the members of an equivalence class, then and are all synonymous. An equivalence class may not be an endpoint of a range. ( Note: Tcl implements only the Unicode locale. It does not define any equivalence classes. The examples above are just illustrations.)","title":"EQUIVALENCE CLASSES"},{"location":"re_syntax/#escapes","text":"Escapes (AREs only), which begin with a \\ followed by an alphanumeric character, come in several varieties: character entry, class shorthands, constraint escapes, and back references. A \\ followed by an alphanumeric character but not constituting a valid escape is illegal in AREs. In EREs, there are no escapes: outside a bracket expression, a \\ followed by an alphanumeric character merely stands for that character as an ordinary character, and inside a bracket expression, \\ is an ordinary character. (The latter is the one actual incompatibility between EREs and AREs.)","title":"ESCAPES"},{"location":"re_syntax/#character-entry-escapes","text":"Character-entry escapes (AREs only) exist to make it easier to specify non-printing and otherwise inconvenient characters in REs: \\a : alert (bell) character, as in C \\b : backspace, as in C \\B : synonym for \\ to help reduce backslash doubling in some applications where there are multiple levels of backslash processing \\c X : (where X is any character) the character whose low-order 5 bits are the same as those of X , and whose other bits are all zero \\e : the character whose collating-sequence name is or failing that, the character with octal value 033 \\f : formfeed, as in C \\n : newline, as in C \\r : carriage return, as in C \\t : horizontal tab, as in C \\u wxyz : (where wxyz is one up to four hexadecimal digits) the Unicode character U+ wxyz in the local byte ordering \\U stuvwxyz : (where stuvwxyz is one up to eight hexadecimal digits) reserved for a Unicode extension up to 21 bits. The digits are parsed until the first non-hexadecimal character is encountered, the maximun of eight hexadecimal digits are reached, or an overflow would occur in the maximum value of U+ 10ffff . \\v : vertical tab, as in C \\x hh : (where hh is one or two hexadecimal digits) the character whose hexadecimal value is 0x hh . \\0 : the character whose value is 0 \\ xyz : (where xyz is exactly three octal digits, and is not a back reference (see below)) the character whose octal value is 0 xyz . The first digit must be in the range 0-3, otherwise the two-digit form is assumed. \\ xy : (where xy is exactly two octal digits, and is not a back reference (see below)) the character whose octal value is 0 xy Hexadecimal digits are and Octal digits are The character-entry escapes are always taken as ordinary characters. For example, \\135 is ] in Unicode, but \\135 does not terminate a bracket expression. Beware, however, that some applications (e.g., C compilers and the Tcl interpreter if the regular expression is not quoted with braces) interpret such sequences themselves before the regular-expression package gets to see them, which may require doubling (quadrupling, etc.) the","title":"CHARACTER-ENTRY ESCAPES"},{"location":"re_syntax/#class-shorthand-escapes","text":"Class-shorthand escapes (AREs only) provide shorthands for certain commonly-used character classes: \\d : [[:digit:]] \\s : [[:space:]] \\w : [[:alnum:]_\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D\\uFE4E\\uFE4F\\uFF3F] (including punctuation connector characters) \\D : [\\^[:digit:]] \\S : [\\^[:space:]] \\W : [\\^[:alnum:]_\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D\\uFE4E\\uFE4F\\uFF3F] (including punctuation connector characters) Within bracket expressions, and lose their outer brackets, and and are illegal. (So, for example, is equivalent to Also, which is equivalent to is illegal.)","title":"CLASS-SHORTHAND ESCAPES"},{"location":"re_syntax/#constraint-escapes","text":"A constraint escape (AREs only) is a constraint, matching the empty string if specific conditions are met, written as an escape: \\A : matches only at the beginning of the string (see MATCHING , below, for how this differs from {=html} <!-- --> \\m : matches only at the beginning of a word \\M : matches only at the end of a word \\y : matches only at the beginning or end of a word \\Y : matches only at a point that is not the beginning or end of a word \\Z : matches only at the end of the string (see MATCHING , below, for how this differs from {=html} <!-- --> \\ m : (where m is a nonzero digit) a back reference , see below \\ mnn : (where m is a nonzero digit, and nn is some more digits, and the decimal value mnn is not greater than the number of closing capturing parentheses seen so far) a back reference , see below A word is defined as in the specification of and above. Constraint escapes are illegal within bracket expressions.","title":"CONSTRAINT ESCAPES"},{"location":"re_syntax/#back-references","text":"A back reference (AREs only) matches the same string matched by the parenthesized subexpression specified by the number, so that (e.g.) matches or but not The subexpression must entirely precede the back reference in the RE. Subexpressions are numbered in the order of their leading parentheses. Non-capturing parentheses do not define subexpressions. There is an inherent historical ambiguity between octal character-entry escapes and back references, which is resolved by heuristics, as hinted at above. A leading zero always indicates an octal escape. A single non-zero digit, not followed by another digit, is always taken as a back reference. A multi-digit sequence not starting with a zero is taken as a back reference if it comes after a suitable subexpression (i.e. the number is in the legal range for a back reference), and otherwise is taken as octal.","title":"BACK REFERENCES"},{"location":"re_syntax/#metasyntax","text":"In addition to the main syntax described above, there are some special forms and miscellaneous syntactic facilities available. Normally the flavor of RE being used is specified by application-dependent means. However, this can be overridden by a director . If an RE of any flavor begins with the rest of the RE is an ARE. If an RE of any flavor begins with the rest of the RE is taken to be a literal string, with all characters considered ordinary characters. An ARE may begin with embedded options : a sequence (? xyz ) (where xyz is one or more alphabetic characters) specifies options affecting the rest of the RE. These supplement, and can override, any options specified by the application. The available option letters are: b : rest of RE is a BRE c : case-sensitive matching (usual default) e : rest of RE is an ERE i : case-insensitive matching (see MATCHING , below) m : historical synonym for n n : newline-sensitive matching (see MATCHING , below) p : partial newline-sensitive matching (see MATCHING , below) q : rest of RE is a literal string, all ordinary characters s : non-newline-sensitive matching (usual default) t : tight syntax (usual default; see below) w : inverse partial newline-sensitive matching (see MATCHING , below) x : expanded syntax (see below) Embedded options take effect at the ) terminating the sequence. They are available only at the start of an ARE, and may not be used later within it. In addition to the usual ( tight ) RE syntax, in which all characters are significant, there is an expanded syntax, available in all flavors of RE with the -expanded switch, or in AREs with the embedded x option. In the expanded syntax, white-space characters are ignored and all characters between a # and the following newline (or the end of the RE) are ignored, permitting paragraphing and commenting a complex RE. There are three exceptions to that basic rule: a white-space character or preceded by is retained white space or within a bracket expression is retained white space and comments are illegal within multi-character symbols like the ARE or the BRE Expanded-syntax white-space characters are blank, tab, newline, and any character that belongs to the space character class. Finally, in an ARE, outside bracket expressions, the sequence (where ttt is any text not containing a is a comment, completely ignored. Again, this is not allowed between the characters of multi-character symbols like Such comments are more a historical artifact than a useful facility, and their use is deprecated; use the expanded syntax instead. None of these metasyntax extensions is available if the application (or an initial director) has specified that the user\\'s input be treated as a literal string rather than as an RE.","title":"METASYNTAX"},{"location":"re_syntax/#matching","text":"In the event that an RE could match more than one substring of a given string, the RE matches the one starting earliest in the string. If the RE could match more than one substring starting at that point, its choice is determined by its preference : either the longest substring, or the shortest. Most atoms, and all constraints, have no preference. A parenthesized RE has the same preference (possibly none) as the RE. A quantified atom with quantifier { m } or { m }? has the same preference (possibly none) as the atom itself. A quantified atom with other normal quantifiers (including { m , n } with m equal to n ) prefers longest match. A quantified atom with other non-greedy quantifiers (including { m , n }? with m equal to n ) prefers shortest match. A branch has the same preference as the first quantified atom in it which has a preference. An RE consisting of two or more branches connected by the | operator prefers longest match. Subject to the constraints imposed by the rules for matching the whole RE, subexpressions also match the longest or shortest possible substrings, based on their preferences, with subexpressions starting earlier in the RE taking priority over ones starting later. Note that outer subexpressions thus take priority over their component subexpressions. The quantifiers {1,1} and {1,1}? can be used to force longest and shortest preference, respectively, on a subexpression or a whole RE. NOTE: This means that you can usually make a RE be non-greedy overall by putting {1,1}? after one of the first non-constraint atoms or parenthesized sub-expressions in it. It pays to experiment with the placing of this non-greediness override on a suitable range of input texts when you are writing a RE if you are using this level of complexity. For example, this regular expression is non-greedy, and will match the shortest substring possible given that will be matched as early as possible (the quantifier does not change that): ab{1,1}?c.*x.*cba The atom has no greediness preference, we explicitly give one for and the remaining quantifiers are overridden to be non-greedy by the preceding non-greedy quantifier. Match lengths are measured in characters, not collating elements. An empty string is considered longer than no match at all. For example, matches the three middle characters of matches all ten characters of when is matched against the parenthesized subexpression matches all three characters, and when is matched against both the whole RE and the parenthesized subexpression match an empty string. If case-independent matching is specified, the effect is much as if all case distinctions had vanished from the alphabet. When an alphabetic that exists in multiple cases appears as an ordinary character outside a bracket expression, it is effectively transformed into a bracket expression containing both cases, so that x becomes When it appears inside a bracket expression, all case counterparts of it are added to the bracket expression, so that becomes and becomes If newline-sensitive matching is specified, . and bracket expressions using \\^ will never match the newline character (so that matches will never cross newlines unless the RE explicitly arranges it) and \\^ and \\$ will match the empty string after and before a newline respectively, in addition to matching at beginning and end of string respectively. ARE \\A and \\Z continue to match beginning or end of string only . If partial newline-sensitive matching is specified, this affects . and bracket expressions as with newline-sensitive matching, but not \\^ and \\$ . If inverse partial newline-sensitive matching is specified, this affects \\^ and \\$ as with newline-sensitive matching, but not . and bracket expressions. This is not very useful but is provided for symmetry.","title":"MATCHING"},{"location":"re_syntax/#limits-and-compatibility","text":"No particular limit is imposed on the length of REs. Programs intended to be highly portable should not employ REs longer than 256 bytes, as a POSIX-compliant implementation can refuse to accept such REs. The only feature of AREs that is actually incompatible with POSIX EREs is that \\ does not lose its special significance inside bracket expressions. All other ARE features use syntax which is illegal or has undefined or unspecified effects in POSIX EREs; the *** syntax of directors likewise is outside the POSIX syntax for both BREs and EREs. Many of the ARE extensions are borrowed from Perl, but some have been changed to clean them up, and a few Perl extensions are not present. Incompatibilities of note include the lack of special treatment for a trailing newline, the addition of complemented bracket expressions to the things affected by newline-sensitive matching, the restrictions on parentheses and back references in lookahead constraints, and the longest/shortest-match (rather than first-match) matching semantics. The matching rules for REs containing both normal and non-greedy quantifiers have changed since early beta-test versions of this package. (The new rules are much simpler and cleaner, but do not work as hard at guessing the user\\'s real intentions.) Henry Spencer\\'s original 1986 regexp package, still in widespread use (e.g., in pre-8.1 releases of Tcl), implemented an early version of today\\'s EREs. There are four incompatibilities between regexp \\'s near-EREs and AREs. In roughly increasing order of significance: In AREs, \\ followed by an alphanumeric character is either an escape or an error, while in RREs, it was just another way of writing the alphanumeric. This should not be a problem because there was no reason to write such a sequence in RREs. { followed by a digit in an ARE is the beginning of a bound, while in RREs, { was always an ordinary character. Such sequences should be rare, and will often result in an error because following characters will not look like a valid bound. In AREs, \\ remains a special character within so a literal \\ within [\u2006] must be written \\\\ also gives a literal \\ within [\u2006] in RREs, but only truly paranoid programmers routinely doubled the backslash. AREs report the longest/shortest match for the RE, rather than the first found in a specified search order. This may affect some RREs which were written in the expectation that the first match would be reported. (The careful crafting of RREs to optimize the search order for fast matching is obsolete (AREs examine all possible matches in parallel, and their performance is largely insensitive to their complexity) but cases where the search order was exploited to deliberately find a match which was not the longest/shortest will need rewriting.)","title":"LIMITS AND COMPATIBILITY"},{"location":"re_syntax/#basic-regular-expressions","text":"BREs differ from EREs in several respects. and ? are ordinary characters and there is no equivalent for their functionality. The delimiters for bounds are \\{ and with { and } by themselves ordinary characters. The parentheses for nested subexpressions are \\( and with ( and ) by themselves ordinary characters. \\^ is an ordinary character except at the beginning of the RE or the beginning of a parenthesized subexpression, \\$ is an ordinary character except at the end of the RE or the end of a parenthesized subexpression, and * is an ordinary character if it appears at the beginning of the RE or the beginning of a parenthesized subexpression (after a possible leading Finally, single-digit back references are available, and \\\\< and \\> are synonyms for and respectively; no other escapes are available.","title":"BASIC REGULAR EXPRESSIONS"},{"location":"re_syntax/#see-also","text":"RegExp(3), regexp(n), regsub(n), lsearch(n), switch(n), text(n)","title":"SEE ALSO"},{"location":"re_syntax/#keywords","text":"match, regular expression, string","title":"KEYWORDS"},{"location":"read/","text":"NAME read - Read from a channel SYNOPSIS read ? -nonewline ? channelId read channelId numChars DESCRIPTION In the first form, the read command reads all of the data from channelId up to the end of the file. If the -nonewline switch is specified then the last character of the file is discarded if it is a newline. In the second form, the extra argument specifies how many characters to read. Exactly that many characters will be read and returned, unless there are fewer than numChars left in the file; in this case all the remaining characters are returned. If the channel is configured to use a multi-byte encoding, then the number of characters read may not be the same as the number of bytes read. ChannelId must be an identifier for an open channel such as the Tcl standard input channel ( stdin ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. The channel must have been opened for input. If channelId is in nonblocking mode, the command may not read as many characters as requested: once all available input has been read, the command will return the data that is available rather than blocking for more input. If the channel is configured to use a multi-byte encoding, then there may actually be some bytes remaining in the internal buffers that do not form a complete character. These bytes will not be returned until a complete character is available or end-of-file is reached. The -nonewline switch is ignored if the command returns before reaching the end of the file. Read translates end-of-line sequences in the input into newline characters according to the -translation option for the channel. See the fconfigure manual entry for a discussion on ways in which fconfigure will alter input. USE WITH SERIAL PORTS For most applications a channel connected to a serial port should be configured to be nonblocking: fconfigure channelId -blocking 0 . Then read behaves much like described above. Care must be taken when using read on blocking serial ports: read channelId numChars : In this form read blocks until numChars have been received from the serial port. read channelId : In this form read blocks until the reception of the end-of-file character, see fconfigure -eofchar . If there no end-of-file character has been configured for the channel, then read will block forever. EXAMPLE This example code reads a file all at once, and splits it into a list, with each line in the file corresponding to an element in the list: set fl [open /proc/meminfo] set data [ read \\$fl] close \\$fl set lines [split \\$data \\n] SEE ALSO file(n), eof(n), fblocked(n), fconfigure(n), Tcl_StandardChannels(3) KEYWORDS blocking, channel, end of line, end of file, nonblocking, read, translation, encoding","title":"NAME"},{"location":"read/#name","text":"read - Read from a channel","title":"NAME"},{"location":"read/#synopsis","text":"read ? -nonewline ? channelId read channelId numChars","title":"SYNOPSIS"},{"location":"read/#description","text":"In the first form, the read command reads all of the data from channelId up to the end of the file. If the -nonewline switch is specified then the last character of the file is discarded if it is a newline. In the second form, the extra argument specifies how many characters to read. Exactly that many characters will be read and returned, unless there are fewer than numChars left in the file; in this case all the remaining characters are returned. If the channel is configured to use a multi-byte encoding, then the number of characters read may not be the same as the number of bytes read. ChannelId must be an identifier for an open channel such as the Tcl standard input channel ( stdin ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. The channel must have been opened for input. If channelId is in nonblocking mode, the command may not read as many characters as requested: once all available input has been read, the command will return the data that is available rather than blocking for more input. If the channel is configured to use a multi-byte encoding, then there may actually be some bytes remaining in the internal buffers that do not form a complete character. These bytes will not be returned until a complete character is available or end-of-file is reached. The -nonewline switch is ignored if the command returns before reaching the end of the file. Read translates end-of-line sequences in the input into newline characters according to the -translation option for the channel. See the fconfigure manual entry for a discussion on ways in which fconfigure will alter input.","title":"DESCRIPTION"},{"location":"read/#use-with-serial-ports","text":"For most applications a channel connected to a serial port should be configured to be nonblocking: fconfigure channelId -blocking 0 . Then read behaves much like described above. Care must be taken when using read on blocking serial ports: read channelId numChars : In this form read blocks until numChars have been received from the serial port. read channelId : In this form read blocks until the reception of the end-of-file character, see fconfigure -eofchar . If there no end-of-file character has been configured for the channel, then read will block forever.","title":"USE WITH SERIAL PORTS"},{"location":"read/#example","text":"This example code reads a file all at once, and splits it into a list, with each line in the file corresponding to an element in the list: set fl [open /proc/meminfo] set data [ read \\$fl] close \\$fl set lines [split \\$data \\n]","title":"EXAMPLE"},{"location":"read/#see-also","text":"file(n), eof(n), fblocked(n), fconfigure(n), Tcl_StandardChannels(3)","title":"SEE ALSO"},{"location":"read/#keywords","text":"blocking, channel, end of line, end of file, nonblocking, read, translation, encoding","title":"KEYWORDS"},{"location":"refchan/","text":"NAME refchan - command handler API of reflected channels SYNOPSIS cmdPrefix option ? arg arg ... ? DESCRIPTION The Tcl-level handler for a reflected channel has to be a command with subcommands (termed an ensemble , as it is a command such as that created by namespace ensemble create , though the implementation of handlers for reflected channel is not tied to namespace ensembles in any way; see EXAMPLE below for how to build an oo::class that supports the API). Note that cmdPrefix is whatever was specified in the call to chan create , and may consist of multiple arguments; this will be expanded to multiple words in place of the prefix. Of all the possible subcommands, the handler must support initialize , finalize , and watch . Support for the other subcommands is optional. MANDATORY SUBCOMMANDS cmdPrefix initialize channelId mode : An invocation of this subcommand will be the first call the cmdPrefix will receive for the specified new channelId . It is the responsibility of this subcommand to set up any internal data structures required to keep track of the channel and its state. The return value of the method has to be a list containing the names of all subcommands supported by the *cmdPrefix*. This also tells the Tcl core which version of the API for reflected channels is used by this command handler. Any error thrown by the method will abort the creation of the channel and no channel will be created. The thrown error will appear as error thrown by **chan create**. Any exception other than an **error** (e.g., **break**, etc.) is treated as (and converted to) an error. **Note:** If the creation of the channel was aborted due to failures here, then the **finalize** subcommand will not be called. The *mode* argument tells the handler whether the channel was opened for reading, writing, or both. It is a list containing any of the strings **read** or **write**. The list may be empty, but will usually contain at least one element. The subcommand must throw an error if the chosen mode is not supported by the *cmdPrefix*. cmdPrefix finalize channelId : An invocation of this subcommand will be the last call the cmdPrefix will receive for the specified channelId . It will be generated just before the destruction of the data structures of the channel held by the Tcl core. The command handler must not access the channelId anymore in no way. Upon this subcommand being called, any internal resources allocated to this channel must be cleaned up. The return value of this subcommand is ignored. If the subcommand throws an error the command which caused its invocation (usually **chan close**) will appear to have thrown this error. Any exception beyond **error** (e.g., **break**, etc.) is treated as (and converted to) an error. This subcommand is not invoked if the creation of the channel was aborted during **initialize** (See above). cmdPrefix watch channelId eventspec : This subcommand notifies the cmdPrefix that the specified channelId is interested in the events listed in the eventspec . This argument is a list containing any of read and write . The list may be empty, which signals that the channel does not wish to be notified of any events. In that situation, the handler should disable event generation completely. **Warning:** Any return value of the subcommand is ignored. This includes all errors thrown by the subcommand, **break**, **continue**, and custom return codes. This subcommand interacts with **chan postevent**. Trying to post an event which was not listed in the last call to **watch** will cause **chan postevent** to throw an error. OPTIONAL SUBCOMMANDS cmdPrefix read channelId count : This optional subcommand is called when the user requests data from the channel channelId . count specifies how many bytes have been requested. If the subcommand is not supported then it is not possible to read from the channel handled by the command. The return value of this subcommand is taken as the requested data *bytes*. If the returned data contains more bytes than requested, an error will be signaled and later thrown by the command which performed the read (usually **gets** or **read**). However, returning fewer bytes than requested is acceptable. Note that returning nothing (0 bytes) is a signal to the higher layers that **EOF** has been reached on the channel. To signal that the channel is out of data right now, but has not yet reached **EOF**, it is necessary to throw the error \\\"EAGAIN\\\", i.e. to either return -code error EAGAIN or error EAGAIN For extensibility any error whose value is a negative integer number will cause the higher layers to set the C-level variable \\\"**errno**\\\" to the absolute value of this number, signaling a system error. However, note that the exact mapping between these error numbers and their meanings is operating system dependent. For example, while on Linux both return -code error -11 and error -11 are equivalent to the examples above, using the more readable string \\\"EAGAIN\\\", this is not true for BSD, where the equivalent number is -35. The symbolic string however is the same across systems, and internally translated to the correct number. No other error value has such a mapping to a symbolic string. If the subcommand throws any other error, the command which caused its invocation (usually **gets**, or **read**) will appear to have thrown this error. Any exception beyond **error**, (e.g., **break**, etc.) is treated as and converted to an error. cmdPrefix write channelId data : This optional subcommand is called when the user writes data to the channel channelId . The data argument contains bytes , not characters. Any type of transformation (EOL, encoding) configured for the channel has already been applied at this point. If this subcommand is not supported then it is not possible to write to the channel handled by the command. The return value of the subcommand is taken as the number of bytes written by the channel. Anything non-numeric will cause an error to be signaled and later thrown by the command which performed the write. A negative value implies that the write failed. Returning a value greater than the number of bytes given to the handler, or zero, is forbidden and will cause the Tcl core to throw an error. To signal that the channel is not able to accept data for writing right now, it is necessary to throw the error \\\"EAGAIN\\\", i.e. to either return -code error EAGAIN or error EAGAIN For extensibility any error whose value is a negative integer number will cause the higher layers to set the C-level variable \\\"**errno**\\\" to the absolute value of this number, signaling a system error. However, note that the exact mapping between these error numbers and their meanings is operating system dependent. For example, while on Linux both return -code error -11 and error -11 are equivalent to the examples above, using the more readable string \\\"EAGAIN\\\", this is not true for BSD, where the equivalent number is -35. The symbolic string however is the same across systems, and internally translated to the correct number. No other error value has such a mapping to a symbolic string. If the subcommand throws any other error the command which caused its invocation (usually **puts**) will appear to have thrown this error. Any exception beyond **error** (e.g., **break**, etc.) is treated as and converted to an error. cmdPrefix seek channelId offset base : This optional subcommand is responsible for the handling of chan seek and chan tell requests on the channel channelId . If it is not supported then seeking will not be possible for the channel. The *base* argument is the same as the equivalent argument of the builtin **chan seek**, namely: **start** : Seeking is relative to the beginning of the channel. **current** : Seeking is relative to the current seek position. **end** : Seeking is relative to the end of the channel. The *offset* is an integer number specifying the amount of **bytes** to seek forward or backward. A positive number should seek forward, and a negative number should seek backward. A channel may provide only limited seeking. For example sockets can seek forward, but not backward. The return value of the subcommand is taken as the (new) location of the channel, counted from the start. This has to be an integer number greater than or equal to zero. If the subcommand throws an error the command which caused its invocation (usually **chan seek**, or **chan tell**) will appear to have thrown this error. Any exception beyond **error** (e.g., **break**, etc.) is treated as and converted to an error. The offset/base combination of 0/**current** signals a **chan tell** request, i.e., seek nothing relative to the current location, making the new location identical to the current one, which is then returned. cmdPrefix configure channelId option value : This optional subcommand is for setting the type-specific options of channel channelId . The option argument indicates the option to be written, and the value argument indicates the value to set the option to. This subcommand will never try to update more than one option at a time; that is behavior implemented in the Tcl channel core. The return value of the subcommand is ignored. If the subcommand throws an error the command which performed the (re)configuration or query (usually **fconfigure** or **chan configure**) will appear to have thrown this error. Any exception beyond **error** (e.g., **break**, etc.) is treated as and converted to an error. cmdPrefix cget channelId option : This optional subcommand is used when reading a single type-specific option of channel channelId . If this subcommand is supported then the subcommand cgetall must be supported as well. The subcommand should return the value of the specified *option*. If the subcommand throws an error, the command which performed the (re)configuration or query (usually **fconfigure** or **chan configure**) will appear to have thrown this error. Any exception beyond *error* (e.g., **break**, etc.) is treated as and converted to an error. cmdPrefix cgetall channelId : This optional subcommand is used for reading all type-specific options of channel channelId . If this subcommand is supported then the subcommand cget has to be supported as well. The subcommand should return a list of all options and their values. This list must have an even number of elements. If the subcommand throws an error the command which performed the (re)configuration or query (usually **fconfigure** or **chan configure**) will appear to have thrown this error. Any exception beyond **error** (e.g., **break**, etc.) is treated as and converted to an error. cmdPrefix blocking channelId mode : This optional subcommand handles changes to the blocking mode of the channel channelId . The mode is a boolean flag. A true value means that the channel has to be set to blocking, and a false value means that the channel should be non-blocking. The return value of the subcommand is ignored. If the subcommand throws an error the command which caused its invocation (usually **fconfigure** or **chan configure**) will appear to have thrown this error. Any exception beyond **error** (e.g., **break**, etc.) is treated as and converted to an error. cmdPrefix truncate channelId length : This optional subcommand handles changing the length of the underlying data stream for the channel channelId . Its length gets set to length . If the subcommand throws an error the command which caused its invocation (usually **chan truncate**) will appear to have thrown this error. Any exception beyond **error** (e.g., **break**, etc.) is treated as and converted to an error. NOTES Some of the functions supported in channels defined in Tcl\\'s C interface are not available to channels reflected to the Tcl level. The function Tcl_DriverGetHandleProc is not supported; i.e., reflected channels do not have OS specific handles. The function Tcl_DriverHandlerProc is not supported. This driver function is relevant only for stacked channels, i.e., transformations. Reflected channels are always base channels, not transformations. The function Tcl_DriverFlushProc is not supported. This is because the current generic I/O layer of Tcl does not use this function anywhere at all. Therefore support at the Tcl level makes no sense either. This may be altered in the future (through extending the API defined here and changing its version number) should the function be used at some time in the future. EXAMPLE This demonstrates how to make a channel that reads from a string. oo::class create stringchan { variable data pos constructor {string {encoding {}}} { if {\\$encoding eq \\\"\\\"} {set encoding [encoding system]} set data [encoding convertto \\$encoding \\$string] set pos 0 } method initialize {ch mode} { return \\\"initialize finalize watch read seek\\\" } method finalize {ch} { my destroy } method watch {ch events} { # Must be present but we ignore it because we do not # post any events } # Must be present on a readable channel method read {ch count} { set d [string range \\$data \\$pos [expr {\\$pos+\\$count-1}]] incr pos [string length \\$d] return \\$d } # This method is optional, but useful for the example below method seek {ch offset base} { switch \\$base { start { set pos \\$offset } current { incr pos \\$offset } end { set pos [string length \\$data] incr pos \\$offset } } if {\\$pos \\< 0} { set pos 0 } elseif {\\$pos > [string length \\$data]} { set pos [string length \\$data] } return \\$pos } } # Now we create an instance... set string \\\"The quick brown fox jumps over the lazy dog.\\n\\\" set ch [ chan create read [stringchan new \\$string]] puts [gets \\$ch]; # Prints the whole string seek \\$ch -5 end; puts [read \\$ch]; # Prints just the last word SEE ALSO chan(n), transchan(n) KEYWORDS API, channel, ensemble, prefix, reflection","title":"NAME"},{"location":"refchan/#name","text":"refchan - command handler API of reflected channels","title":"NAME"},{"location":"refchan/#synopsis","text":"cmdPrefix option ? arg arg ... ?","title":"SYNOPSIS"},{"location":"refchan/#description","text":"The Tcl-level handler for a reflected channel has to be a command with subcommands (termed an ensemble , as it is a command such as that created by namespace ensemble create , though the implementation of handlers for reflected channel is not tied to namespace ensembles in any way; see EXAMPLE below for how to build an oo::class that supports the API). Note that cmdPrefix is whatever was specified in the call to chan create , and may consist of multiple arguments; this will be expanded to multiple words in place of the prefix. Of all the possible subcommands, the handler must support initialize , finalize , and watch . Support for the other subcommands is optional.","title":"DESCRIPTION"},{"location":"refchan/#mandatory-subcommands","text":"cmdPrefix initialize channelId mode : An invocation of this subcommand will be the first call the cmdPrefix will receive for the specified new channelId . It is the responsibility of this subcommand to set up any internal data structures required to keep track of the channel and its state. The return value of the method has to be a list containing the names of all subcommands supported by the *cmdPrefix*. This also tells the Tcl core which version of the API for reflected channels is used by this command handler. Any error thrown by the method will abort the creation of the channel and no channel will be created. The thrown error will appear as error thrown by **chan create**. Any exception other than an **error** (e.g., **break**, etc.) is treated as (and converted to) an error. **Note:** If the creation of the channel was aborted due to failures here, then the **finalize** subcommand will not be called. The *mode* argument tells the handler whether the channel was opened for reading, writing, or both. It is a list containing any of the strings **read** or **write**. The list may be empty, but will usually contain at least one element. The subcommand must throw an error if the chosen mode is not supported by the *cmdPrefix*. cmdPrefix finalize channelId : An invocation of this subcommand will be the last call the cmdPrefix will receive for the specified channelId . It will be generated just before the destruction of the data structures of the channel held by the Tcl core. The command handler must not access the channelId anymore in no way. Upon this subcommand being called, any internal resources allocated to this channel must be cleaned up. The return value of this subcommand is ignored. If the subcommand throws an error the command which caused its invocation (usually **chan close**) will appear to have thrown this error. Any exception beyond **error** (e.g., **break**, etc.) is treated as (and converted to) an error. This subcommand is not invoked if the creation of the channel was aborted during **initialize** (See above). cmdPrefix watch channelId eventspec : This subcommand notifies the cmdPrefix that the specified channelId is interested in the events listed in the eventspec . This argument is a list containing any of read and write . The list may be empty, which signals that the channel does not wish to be notified of any events. In that situation, the handler should disable event generation completely. **Warning:** Any return value of the subcommand is ignored. This includes all errors thrown by the subcommand, **break**, **continue**, and custom return codes. This subcommand interacts with **chan postevent**. Trying to post an event which was not listed in the last call to **watch** will cause **chan postevent** to throw an error.","title":"MANDATORY SUBCOMMANDS"},{"location":"refchan/#optional-subcommands","text":"cmdPrefix read channelId count : This optional subcommand is called when the user requests data from the channel channelId . count specifies how many bytes have been requested. If the subcommand is not supported then it is not possible to read from the channel handled by the command. The return value of this subcommand is taken as the requested data *bytes*. If the returned data contains more bytes than requested, an error will be signaled and later thrown by the command which performed the read (usually **gets** or **read**). However, returning fewer bytes than requested is acceptable. Note that returning nothing (0 bytes) is a signal to the higher layers that **EOF** has been reached on the channel. To signal that the channel is out of data right now, but has not yet reached **EOF**, it is necessary to throw the error \\\"EAGAIN\\\", i.e. to either return -code error EAGAIN or error EAGAIN For extensibility any error whose value is a negative integer number will cause the higher layers to set the C-level variable \\\"**errno**\\\" to the absolute value of this number, signaling a system error. However, note that the exact mapping between these error numbers and their meanings is operating system dependent. For example, while on Linux both return -code error -11 and error -11 are equivalent to the examples above, using the more readable string \\\"EAGAIN\\\", this is not true for BSD, where the equivalent number is -35. The symbolic string however is the same across systems, and internally translated to the correct number. No other error value has such a mapping to a symbolic string. If the subcommand throws any other error, the command which caused its invocation (usually **gets**, or **read**) will appear to have thrown this error. Any exception beyond **error**, (e.g., **break**, etc.) is treated as and converted to an error. cmdPrefix write channelId data : This optional subcommand is called when the user writes data to the channel channelId . The data argument contains bytes , not characters. Any type of transformation (EOL, encoding) configured for the channel has already been applied at this point. If this subcommand is not supported then it is not possible to write to the channel handled by the command. The return value of the subcommand is taken as the number of bytes written by the channel. Anything non-numeric will cause an error to be signaled and later thrown by the command which performed the write. A negative value implies that the write failed. Returning a value greater than the number of bytes given to the handler, or zero, is forbidden and will cause the Tcl core to throw an error. To signal that the channel is not able to accept data for writing right now, it is necessary to throw the error \\\"EAGAIN\\\", i.e. to either return -code error EAGAIN or error EAGAIN For extensibility any error whose value is a negative integer number will cause the higher layers to set the C-level variable \\\"**errno**\\\" to the absolute value of this number, signaling a system error. However, note that the exact mapping between these error numbers and their meanings is operating system dependent. For example, while on Linux both return -code error -11 and error -11 are equivalent to the examples above, using the more readable string \\\"EAGAIN\\\", this is not true for BSD, where the equivalent number is -35. The symbolic string however is the same across systems, and internally translated to the correct number. No other error value has such a mapping to a symbolic string. If the subcommand throws any other error the command which caused its invocation (usually **puts**) will appear to have thrown this error. Any exception beyond **error** (e.g., **break**, etc.) is treated as and converted to an error. cmdPrefix seek channelId offset base : This optional subcommand is responsible for the handling of chan seek and chan tell requests on the channel channelId . If it is not supported then seeking will not be possible for the channel. The *base* argument is the same as the equivalent argument of the builtin **chan seek**, namely: **start** : Seeking is relative to the beginning of the channel. **current** : Seeking is relative to the current seek position. **end** : Seeking is relative to the end of the channel. The *offset* is an integer number specifying the amount of **bytes** to seek forward or backward. A positive number should seek forward, and a negative number should seek backward. A channel may provide only limited seeking. For example sockets can seek forward, but not backward. The return value of the subcommand is taken as the (new) location of the channel, counted from the start. This has to be an integer number greater than or equal to zero. If the subcommand throws an error the command which caused its invocation (usually **chan seek**, or **chan tell**) will appear to have thrown this error. Any exception beyond **error** (e.g., **break**, etc.) is treated as and converted to an error. The offset/base combination of 0/**current** signals a **chan tell** request, i.e., seek nothing relative to the current location, making the new location identical to the current one, which is then returned. cmdPrefix configure channelId option value : This optional subcommand is for setting the type-specific options of channel channelId . The option argument indicates the option to be written, and the value argument indicates the value to set the option to. This subcommand will never try to update more than one option at a time; that is behavior implemented in the Tcl channel core. The return value of the subcommand is ignored. If the subcommand throws an error the command which performed the (re)configuration or query (usually **fconfigure** or **chan configure**) will appear to have thrown this error. Any exception beyond **error** (e.g., **break**, etc.) is treated as and converted to an error. cmdPrefix cget channelId option : This optional subcommand is used when reading a single type-specific option of channel channelId . If this subcommand is supported then the subcommand cgetall must be supported as well. The subcommand should return the value of the specified *option*. If the subcommand throws an error, the command which performed the (re)configuration or query (usually **fconfigure** or **chan configure**) will appear to have thrown this error. Any exception beyond *error* (e.g., **break**, etc.) is treated as and converted to an error. cmdPrefix cgetall channelId : This optional subcommand is used for reading all type-specific options of channel channelId . If this subcommand is supported then the subcommand cget has to be supported as well. The subcommand should return a list of all options and their values. This list must have an even number of elements. If the subcommand throws an error the command which performed the (re)configuration or query (usually **fconfigure** or **chan configure**) will appear to have thrown this error. Any exception beyond **error** (e.g., **break**, etc.) is treated as and converted to an error. cmdPrefix blocking channelId mode : This optional subcommand handles changes to the blocking mode of the channel channelId . The mode is a boolean flag. A true value means that the channel has to be set to blocking, and a false value means that the channel should be non-blocking. The return value of the subcommand is ignored. If the subcommand throws an error the command which caused its invocation (usually **fconfigure** or **chan configure**) will appear to have thrown this error. Any exception beyond **error** (e.g., **break**, etc.) is treated as and converted to an error. cmdPrefix truncate channelId length : This optional subcommand handles changing the length of the underlying data stream for the channel channelId . Its length gets set to length . If the subcommand throws an error the command which caused its invocation (usually **chan truncate**) will appear to have thrown this error. Any exception beyond **error** (e.g., **break**, etc.) is treated as and converted to an error.","title":"OPTIONAL SUBCOMMANDS"},{"location":"refchan/#notes","text":"Some of the functions supported in channels defined in Tcl\\'s C interface are not available to channels reflected to the Tcl level. The function Tcl_DriverGetHandleProc is not supported; i.e., reflected channels do not have OS specific handles. The function Tcl_DriverHandlerProc is not supported. This driver function is relevant only for stacked channels, i.e., transformations. Reflected channels are always base channels, not transformations. The function Tcl_DriverFlushProc is not supported. This is because the current generic I/O layer of Tcl does not use this function anywhere at all. Therefore support at the Tcl level makes no sense either. This may be altered in the future (through extending the API defined here and changing its version number) should the function be used at some time in the future.","title":"NOTES"},{"location":"refchan/#example","text":"This demonstrates how to make a channel that reads from a string. oo::class create stringchan { variable data pos constructor {string {encoding {}}} { if {\\$encoding eq \\\"\\\"} {set encoding [encoding system]} set data [encoding convertto \\$encoding \\$string] set pos 0 } method initialize {ch mode} { return \\\"initialize finalize watch read seek\\\" } method finalize {ch} { my destroy } method watch {ch events} { # Must be present but we ignore it because we do not # post any events } # Must be present on a readable channel method read {ch count} { set d [string range \\$data \\$pos [expr {\\$pos+\\$count-1}]] incr pos [string length \\$d] return \\$d } # This method is optional, but useful for the example below method seek {ch offset base} { switch \\$base { start { set pos \\$offset } current { incr pos \\$offset } end { set pos [string length \\$data] incr pos \\$offset } } if {\\$pos \\< 0} { set pos 0 } elseif {\\$pos > [string length \\$data]} { set pos [string length \\$data] } return \\$pos } } # Now we create an instance... set string \\\"The quick brown fox jumps over the lazy dog.\\n\\\" set ch [ chan create read [stringchan new \\$string]] puts [gets \\$ch]; # Prints the whole string seek \\$ch -5 end; puts [read \\$ch]; # Prints just the last word","title":"EXAMPLE"},{"location":"refchan/#see-also","text":"chan(n), transchan(n)","title":"SEE ALSO"},{"location":"refchan/#keywords","text":"API, channel, ensemble, prefix, reflection","title":"KEYWORDS"},{"location":"registry/","text":"NAME registry - Manipulate the Windows registry SYNOPSIS package require registry 1.3 registry ? -mode ? option keyName ? arg arg ... ? DESCRIPTION The registry package provides a general set of operations for manipulating the Windows registry. The package implements the registry Tcl command. This command is only supported on the Windows platform. Warning: this command should be used with caution as a corrupted registry can leave your system in an unusable state. KeyName is the name of a registry key. Registry keys must be one of the following forms: \\\\ hostname \\ rootname \\ keypath rootname \\ keypath rootname Hostname specifies the name of any valid Windows host that exports its registry. The rootname component must be one of HKEY_LOCAL_MACHINE , HKEY_USERS , HKEY_CLASSES_ROOT , HKEY_CURRENT_USER , HKEY_CURRENT_CONFIG , HKEY_PERFORMANCE_DATA , or HKEY_DYN_DATA . The keypath can be one or more registry key names separated by backslash ( \\ ) characters. The optional -mode argument indicates which registry to work with; when it is -32bit the 32-bit registry will be used, and when it is -64bit the 64-bit registry will be used. If this argument is omitted, the system\\'s default registry will be the subject of the requested operation. Option indicates what to do with the registry key name. Any unique abbreviation for option is acceptable. The valid options are: registry broadcast keyName ? -timeout milliseconds ? : Sends a broadcast message to the system and running programs to notify them of certain updates. This is necessary to propagate changes to key registry keys like Environment. The timeout specifies the amount of time, in milliseconds, to wait for applications to respond to the broadcast message. It defaults to 3000. The following example demonstrates how to add a path to the global Environment and notify applications of the change without requiring a logoff/logon step (assumes admin privileges): set regPath \\[join { HKEY_LOCAL_MACHINE SYSTEM CurrentControlSet Control {Session Manager} Environment } \\\"\\\\\\\\\\\"\\] set curPath \\[**registry get** \\$regPath \\\"Path\\\"\\] **registry set** \\$regPath \\\"Path\\\" \\\"\\$curPath;\\$addPath\\\" **registry broadcast** \\\"Environment\\\" registry delete keyName ? valueName ? : If the optional valueName argument is present, the specified value under keyName will be deleted from the registry. If the optional valueName is omitted, the specified key and any subkeys or values beneath it in the registry hierarchy will be deleted. If the key could not be deleted then an error is generated. If the key did not exist, the command has no effect. registry get keyName valueName : Returns the data associated with the value valueName under the key keyName . If either the key or the value does not exist, then an error is generated. For more details on the format of the returned data, see SUPPORTED TYPES , below. registry keys keyName ? pattern ? : If pattern is not specified, returns a list of names of all the subkeys of keyName . If pattern is specified, only those names matching pattern are returned. Matching is determined using the same rules as for string match . If the specified keyName does not exist, then an error is generated. registry set keyName ? valueName data ? type ?? : If valueName is not specified, creates the key keyName if it does not already exist. If valueName is specified, creates the key keyName and value valueName if necessary. The contents of valueName are set to data with the type indicated by type . If type is not specified, the type sz is assumed. For more details on the data and type arguments, see SUPPORTED TYPES below. registry type keyName valueName : Returns the type of the value valueName in the key keyName . For more information on the possible types, see SUPPORTED TYPES , below. registry values keyName ? pattern ? : If pattern is not specified, returns a list of names of all the values of keyName . If pattern is specified, only those names matching pattern are returned. Matching is determined using the same rules as for string match . SUPPORTED TYPES Each value under a key in the registry contains some data of a particular type in a type-specific representation. The registry command converts between this internal representation and one that can be manipulated by Tcl scripts. In most cases, the data is simply returned as a Tcl string. The type indicates the intended use for the data, but does not actually change the representation. For some types, the registry command returns the data in a different form to make it easier to manipulate. The following types are recognized by the registry command: binary : The registry value contains arbitrary binary data. The data is represented exactly in Tcl, including any embedded nulls. none : The registry value contains arbitrary binary data with no defined type. The data is represented exactly in Tcl, including any embedded nulls. sz : The registry value contains a null-terminated string. The data is represented in Tcl as a string. expand_sz : The registry value contains a null-terminated string that contains unexpanded references to environment variables in the normal Windows style (for example, The data is represented in Tcl as a string. dword : The registry value contains a little-endian 32-bit number. The data is represented in Tcl as a decimal string. dword_big_endian : The registry value contains a big-endian 32-bit number. The data is represented in Tcl as a decimal string. link : The registry value contains a symbolic link. The data is represented exactly in Tcl, including any embedded nulls. multi_sz : The registry value contains an array of null-terminated strings. The data is represented in Tcl as a list of strings. resource_list : The registry value contains a device-driver resource list. The data is represented exactly in Tcl, including any embedded nulls. In addition to the symbolically named types listed above, unknown types are identified using a 32-bit integer that corresponds to the type code returned by the system interfaces. In this case, the data is represented exactly in Tcl, including any embedded nulls. PORTABILITY ISSUES The registry command is only available on Windows. EXAMPLE Print out how double-clicking on a Tcl script file will invoke a Tcl interpreter: package require registry set ext .tcl # Read the type name set type [ registry get HKEY_CLASSES_ROOT\\\\\\$ext {}] # Work out where to look for the command set path HKEY_CLASSES_ROOT\\\\\\$type\\\\Shell\\\\Open\\\\command # Read the command! set command [ registry get \\$path {}] puts \\\"\\$ext opens with \\$command\\\" KEYWORDS registry","title":"NAME"},{"location":"registry/#name","text":"registry - Manipulate the Windows registry","title":"NAME"},{"location":"registry/#synopsis","text":"package require registry 1.3 registry ? -mode ? option keyName ? arg arg ... ?","title":"SYNOPSIS"},{"location":"registry/#description","text":"The registry package provides a general set of operations for manipulating the Windows registry. The package implements the registry Tcl command. This command is only supported on the Windows platform. Warning: this command should be used with caution as a corrupted registry can leave your system in an unusable state. KeyName is the name of a registry key. Registry keys must be one of the following forms: \\\\ hostname \\ rootname \\ keypath rootname \\ keypath rootname Hostname specifies the name of any valid Windows host that exports its registry. The rootname component must be one of HKEY_LOCAL_MACHINE , HKEY_USERS , HKEY_CLASSES_ROOT , HKEY_CURRENT_USER , HKEY_CURRENT_CONFIG , HKEY_PERFORMANCE_DATA , or HKEY_DYN_DATA . The keypath can be one or more registry key names separated by backslash ( \\ ) characters. The optional -mode argument indicates which registry to work with; when it is -32bit the 32-bit registry will be used, and when it is -64bit the 64-bit registry will be used. If this argument is omitted, the system\\'s default registry will be the subject of the requested operation. Option indicates what to do with the registry key name. Any unique abbreviation for option is acceptable. The valid options are: registry broadcast keyName ? -timeout milliseconds ? : Sends a broadcast message to the system and running programs to notify them of certain updates. This is necessary to propagate changes to key registry keys like Environment. The timeout specifies the amount of time, in milliseconds, to wait for applications to respond to the broadcast message. It defaults to 3000. The following example demonstrates how to add a path to the global Environment and notify applications of the change without requiring a logoff/logon step (assumes admin privileges): set regPath \\[join { HKEY_LOCAL_MACHINE SYSTEM CurrentControlSet Control {Session Manager} Environment } \\\"\\\\\\\\\\\"\\] set curPath \\[**registry get** \\$regPath \\\"Path\\\"\\] **registry set** \\$regPath \\\"Path\\\" \\\"\\$curPath;\\$addPath\\\" **registry broadcast** \\\"Environment\\\" registry delete keyName ? valueName ? : If the optional valueName argument is present, the specified value under keyName will be deleted from the registry. If the optional valueName is omitted, the specified key and any subkeys or values beneath it in the registry hierarchy will be deleted. If the key could not be deleted then an error is generated. If the key did not exist, the command has no effect. registry get keyName valueName : Returns the data associated with the value valueName under the key keyName . If either the key or the value does not exist, then an error is generated. For more details on the format of the returned data, see SUPPORTED TYPES , below. registry keys keyName ? pattern ? : If pattern is not specified, returns a list of names of all the subkeys of keyName . If pattern is specified, only those names matching pattern are returned. Matching is determined using the same rules as for string match . If the specified keyName does not exist, then an error is generated. registry set keyName ? valueName data ? type ?? : If valueName is not specified, creates the key keyName if it does not already exist. If valueName is specified, creates the key keyName and value valueName if necessary. The contents of valueName are set to data with the type indicated by type . If type is not specified, the type sz is assumed. For more details on the data and type arguments, see SUPPORTED TYPES below. registry type keyName valueName : Returns the type of the value valueName in the key keyName . For more information on the possible types, see SUPPORTED TYPES , below. registry values keyName ? pattern ? : If pattern is not specified, returns a list of names of all the values of keyName . If pattern is specified, only those names matching pattern are returned. Matching is determined using the same rules as for string match .","title":"DESCRIPTION"},{"location":"registry/#supported-types","text":"Each value under a key in the registry contains some data of a particular type in a type-specific representation. The registry command converts between this internal representation and one that can be manipulated by Tcl scripts. In most cases, the data is simply returned as a Tcl string. The type indicates the intended use for the data, but does not actually change the representation. For some types, the registry command returns the data in a different form to make it easier to manipulate. The following types are recognized by the registry command: binary : The registry value contains arbitrary binary data. The data is represented exactly in Tcl, including any embedded nulls. none : The registry value contains arbitrary binary data with no defined type. The data is represented exactly in Tcl, including any embedded nulls. sz : The registry value contains a null-terminated string. The data is represented in Tcl as a string. expand_sz : The registry value contains a null-terminated string that contains unexpanded references to environment variables in the normal Windows style (for example, The data is represented in Tcl as a string. dword : The registry value contains a little-endian 32-bit number. The data is represented in Tcl as a decimal string. dword_big_endian : The registry value contains a big-endian 32-bit number. The data is represented in Tcl as a decimal string. link : The registry value contains a symbolic link. The data is represented exactly in Tcl, including any embedded nulls. multi_sz : The registry value contains an array of null-terminated strings. The data is represented in Tcl as a list of strings. resource_list : The registry value contains a device-driver resource list. The data is represented exactly in Tcl, including any embedded nulls. In addition to the symbolically named types listed above, unknown types are identified using a 32-bit integer that corresponds to the type code returned by the system interfaces. In this case, the data is represented exactly in Tcl, including any embedded nulls.","title":"SUPPORTED TYPES"},{"location":"registry/#portability-issues","text":"The registry command is only available on Windows.","title":"PORTABILITY ISSUES"},{"location":"registry/#example","text":"Print out how double-clicking on a Tcl script file will invoke a Tcl interpreter: package require registry set ext .tcl # Read the type name set type [ registry get HKEY_CLASSES_ROOT\\\\\\$ext {}] # Work out where to look for the command set path HKEY_CLASSES_ROOT\\\\\\$type\\\\Shell\\\\Open\\\\command # Read the command! set command [ registry get \\$path {}] puts \\\"\\$ext opens with \\$command\\\"","title":"EXAMPLE"},{"location":"registry/#keywords","text":"registry","title":"KEYWORDS"},{"location":"regsub/","text":"NAME regsub - Perform substitutions based on regular expression pattern matching SYNOPSIS regsub ? switches ? exp string subSpec ? varName ? DESCRIPTION This command matches the regular expression exp against string , and either copies string to the variable whose name is given by varName or returns string if varName is not present. (Regular expression matching is described in the re_syntax reference page.) If there is a match, then while copying string to varName (or to the result of this command if varName is not present) the portion of string that matched exp is replaced with subSpec . If subSpec contains a or then it is replaced in the substitution with the portion of string that matched exp . If subSpec contains a where n is a digit between 1 and 9, then it is replaced in the substitution with the portion of string that matched the n \\'th parenthesized subexpression of exp . Additional backslashes may be used in subSpec to prevent special interpretation of and backslashes. The use of backslashes in subSpec tends to interact badly with the Tcl parser\\'s use of backslashes, so it is generally safest to enclose subSpec in braces if it includes backslashes. If the initial arguments to regsub start with - then they are treated as switches. The following switches are currently supported: -all : All ranges in string that match exp are found and substitution is performed for each of these ranges. Without this switch only the first matching range is found and substituted. If -all is specified, then and sequences are handled for each substitution using the information from the corresponding match. -command : Changes the handling of subSpec so that it is not treated as a template for a substitution string and the substrings and no longer have special meaning. Instead subSpec must be a command prefix, that is, a non-empty list. The substring of string that matches exp , and then each substring that matches each capturing sub-RE within exp are appended as additional elements to that list. (The items appended to the list are much like what regexp -inline would return). The completed list is then evaluated as a Tcl command, and the result of that command is the substitution string. Any error or exception from command evaluation becomes an error or exception from the regsub command. If -all is not also given, the command callback will be invoked at most once (exactly when the regular expression matches). If -all is given, the command callback will be invoked for each matched location, in sequence. The exact location indices that matched are not made available to the script. See EXAMPLES below for illustrative cases. -expanded : Enables use of the expanded regular expression syntax where whitespace and comments are ignored. This is the same as specifying the (?x) embedded option (see the re_syntax manual page). -line : Enables newline-sensitive matching. By default, newline is a completely ordinary character with no special meaning. With this flag, bracket expressions and never match newline, matches an empty string after any newline in addition to its normal function, and matches an empty string before any newline in addition to its normal function. This flag is equivalent to specifying both -linestop and -lineanchor , or the (?n) embedded option (see the re_syntax manual page). -linestop : Changes the behavior of bracket expressions and so that they stop at newlines. This is the same as specifying the (?p) embedded option (see the re_syntax manual page). -lineanchor : Changes the behavior of and (the so they match the beginning and end of a line respectively. This is the same as specifying the (?w) embedded option (see the re_syntax manual page). -nocase : Upper-case characters in string will be converted to lower-case before matching against exp ; however, substitutions specified by subSpec use the original unconverted form of string . -start index : Specifies a character index offset into the string to start matching the regular expression at. The index value is interpreted in the same manner as the index argument to string index . When using this switch, will not match the beginning of the line, and \\A will still match the start of the string at index . index will be constrained to the bounds of the input string. -\u2006- : Marks the end of switches. The argument following this one will be treated as exp even if it starts with a - . If varName is supplied, the command returns a count of the number of matching ranges that were found and replaced, otherwise the string after replacement is returned. See the manual entry for regexp for details on the interpretation of regular expressions. EXAMPLES Replace (in the string in variable string ) every instance of foo which is a word by itself with bar : regsub -all {\\mfoo\\M} \\$string bar string or (using the syntax): regsub -all {(?b)\\\\<foo\\>} \\$string bar string Insert double-quotes around the first instance of the word interesting , however it is capitalized. regsub -nocase {\\yinteresting\\y} \\$string {\\\"&\\\"} string Convert all non-ASCII and Tcl-significant characters into \\u escape sequences by using regsub and subst in combination: # This RE is just a character class for almost everything \\\"bad\\\" set RE {[][{};#\\\\\\\\$ \\r\\t\\u0080-\\uffff]} # We will substitute with a fragment of Tcl script in brackets set substitution {[format \\\\\\\\u%04x [scan \\\"\\\\&\\\" %c]]} # Now we apply the substitution to get a subst-string that # will perform the computational parts of the conversion. Note # that newline is handled specially through string map since # backslash-newline is a special sequence. set quoted [subst [string map {\\n {\\\\u000a}} \\ [ regsub -all \\$RE \\$string \\$substitution]]] The above operation can be done using regsub -command instead, which is often faster. (A full pre-computed string map would be faster still, but the cost of computing the map for a transformation as complex as this can be quite large.) # This RE is just a character class for everything \\\"bad\\\" set RE {[][{};#\\\\\\\\$\\s\\u0080-\\uffff]} # This encodes what the RE described above matches proc encodeChar {ch} { # newline is handled specially since backslash-newline is a # special sequence. if {\\$ch eq \\\"\\n\\\"} { return \\\"\\\\u000a\\\" } # No point in writing this as a one-liner scan \\$ch %c charNumber format \\\"\\\\u%04x\\\" \\$charNumber } set quoted [ regsub -all -command \\$RE \\$string encodeChar] Decoding a URL-encoded string using regsub -command , a lambda term and the apply command. # Match one of the sequences in a URL-encoded string that needs # fixing, converting + to space and %XX to the right character # (e.g., %7e becomes \\~) set RE {(\\+)|%([0-9A-Fa-f]{2})} # Note that -command uses a command prefix, not a command name set decoded [ regsub -all -command \\$RE \\$string {apply {{- p h} { # + is a special case; handle directly if {\\$p eq \\\"+\\\"} { return \\\" \\\" } # convert hex to a char scan \\$h %x charNumber format %c \\$charNumber }}}] SEE ALSO regexp(n), re_syntax(n), subst(n), string(n) KEYWORDS match, pattern, quoting, regular expression, substitution","title":"NAME"},{"location":"regsub/#name","text":"regsub - Perform substitutions based on regular expression pattern matching","title":"NAME"},{"location":"regsub/#synopsis","text":"regsub ? switches ? exp string subSpec ? varName ?","title":"SYNOPSIS"},{"location":"regsub/#description","text":"This command matches the regular expression exp against string , and either copies string to the variable whose name is given by varName or returns string if varName is not present. (Regular expression matching is described in the re_syntax reference page.) If there is a match, then while copying string to varName (or to the result of this command if varName is not present) the portion of string that matched exp is replaced with subSpec . If subSpec contains a or then it is replaced in the substitution with the portion of string that matched exp . If subSpec contains a where n is a digit between 1 and 9, then it is replaced in the substitution with the portion of string that matched the n \\'th parenthesized subexpression of exp . Additional backslashes may be used in subSpec to prevent special interpretation of and backslashes. The use of backslashes in subSpec tends to interact badly with the Tcl parser\\'s use of backslashes, so it is generally safest to enclose subSpec in braces if it includes backslashes. If the initial arguments to regsub start with - then they are treated as switches. The following switches are currently supported: -all : All ranges in string that match exp are found and substitution is performed for each of these ranges. Without this switch only the first matching range is found and substituted. If -all is specified, then and sequences are handled for each substitution using the information from the corresponding match. -command : Changes the handling of subSpec so that it is not treated as a template for a substitution string and the substrings and no longer have special meaning. Instead subSpec must be a command prefix, that is, a non-empty list. The substring of string that matches exp , and then each substring that matches each capturing sub-RE within exp are appended as additional elements to that list. (The items appended to the list are much like what regexp -inline would return). The completed list is then evaluated as a Tcl command, and the result of that command is the substitution string. Any error or exception from command evaluation becomes an error or exception from the regsub command. If -all is not also given, the command callback will be invoked at most once (exactly when the regular expression matches). If -all is given, the command callback will be invoked for each matched location, in sequence. The exact location indices that matched are not made available to the script. See EXAMPLES below for illustrative cases. -expanded : Enables use of the expanded regular expression syntax where whitespace and comments are ignored. This is the same as specifying the (?x) embedded option (see the re_syntax manual page). -line : Enables newline-sensitive matching. By default, newline is a completely ordinary character with no special meaning. With this flag, bracket expressions and never match newline, matches an empty string after any newline in addition to its normal function, and matches an empty string before any newline in addition to its normal function. This flag is equivalent to specifying both -linestop and -lineanchor , or the (?n) embedded option (see the re_syntax manual page). -linestop : Changes the behavior of bracket expressions and so that they stop at newlines. This is the same as specifying the (?p) embedded option (see the re_syntax manual page). -lineanchor : Changes the behavior of and (the so they match the beginning and end of a line respectively. This is the same as specifying the (?w) embedded option (see the re_syntax manual page). -nocase : Upper-case characters in string will be converted to lower-case before matching against exp ; however, substitutions specified by subSpec use the original unconverted form of string . -start index : Specifies a character index offset into the string to start matching the regular expression at. The index value is interpreted in the same manner as the index argument to string index . When using this switch, will not match the beginning of the line, and \\A will still match the start of the string at index . index will be constrained to the bounds of the input string. -\u2006- : Marks the end of switches. The argument following this one will be treated as exp even if it starts with a - . If varName is supplied, the command returns a count of the number of matching ranges that were found and replaced, otherwise the string after replacement is returned. See the manual entry for regexp for details on the interpretation of regular expressions.","title":"DESCRIPTION"},{"location":"regsub/#examples","text":"Replace (in the string in variable string ) every instance of foo which is a word by itself with bar : regsub -all {\\mfoo\\M} \\$string bar string or (using the syntax): regsub -all {(?b)\\\\<foo\\>} \\$string bar string Insert double-quotes around the first instance of the word interesting , however it is capitalized. regsub -nocase {\\yinteresting\\y} \\$string {\\\"&\\\"} string Convert all non-ASCII and Tcl-significant characters into \\u escape sequences by using regsub and subst in combination: # This RE is just a character class for almost everything \\\"bad\\\" set RE {[][{};#\\\\\\\\$ \\r\\t\\u0080-\\uffff]} # We will substitute with a fragment of Tcl script in brackets set substitution {[format \\\\\\\\u%04x [scan \\\"\\\\&\\\" %c]]} # Now we apply the substitution to get a subst-string that # will perform the computational parts of the conversion. Note # that newline is handled specially through string map since # backslash-newline is a special sequence. set quoted [subst [string map {\\n {\\\\u000a}} \\ [ regsub -all \\$RE \\$string \\$substitution]]] The above operation can be done using regsub -command instead, which is often faster. (A full pre-computed string map would be faster still, but the cost of computing the map for a transformation as complex as this can be quite large.) # This RE is just a character class for everything \\\"bad\\\" set RE {[][{};#\\\\\\\\$\\s\\u0080-\\uffff]} # This encodes what the RE described above matches proc encodeChar {ch} { # newline is handled specially since backslash-newline is a # special sequence. if {\\$ch eq \\\"\\n\\\"} { return \\\"\\\\u000a\\\" } # No point in writing this as a one-liner scan \\$ch %c charNumber format \\\"\\\\u%04x\\\" \\$charNumber } set quoted [ regsub -all -command \\$RE \\$string encodeChar] Decoding a URL-encoded string using regsub -command , a lambda term and the apply command. # Match one of the sequences in a URL-encoded string that needs # fixing, converting + to space and %XX to the right character # (e.g., %7e becomes \\~) set RE {(\\+)|%([0-9A-Fa-f]{2})} # Note that -command uses a command prefix, not a command name set decoded [ regsub -all -command \\$RE \\$string {apply {{- p h} { # + is a special case; handle directly if {\\$p eq \\\"+\\\"} { return \\\" \\\" } # convert hex to a char scan \\$h %x charNumber format %c \\$charNumber }}}]","title":"EXAMPLES"},{"location":"regsub/#see-also","text":"regexp(n), re_syntax(n), subst(n), string(n)","title":"SEE ALSO"},{"location":"regsub/#keywords","text":"match, pattern, quoting, regular expression, substitution","title":"KEYWORDS"},{"location":"rename/","text":"NAME rename - Rename or delete a command SYNOPSIS rename oldName newName DESCRIPTION Rename the command that used to be called oldName so that it is now called newName . If newName is an empty string then oldName is deleted. oldName and newName may include namespace qualifiers (names of containing namespaces). If a command is renamed into a different namespace, future invocations of it will execute in the new namespace. The rename command returns an empty string as result. EXAMPLE The rename command can be used to wrap the standard Tcl commands with your own monitoring machinery. For example, you might wish to count how often the source command is called: rename ::source ::theRealSource set sourceCount 0 proc ::source args { global sourceCount puts \\\"called source for the [incr sourceCount]\\'th time\\\" uplevel 1 ::theRealSource \\$args } SEE ALSO namespace(n), proc(n) KEYWORDS command, delete, namespace, rename","title":"NAME"},{"location":"rename/#name","text":"rename - Rename or delete a command","title":"NAME"},{"location":"rename/#synopsis","text":"rename oldName newName","title":"SYNOPSIS"},{"location":"rename/#description","text":"Rename the command that used to be called oldName so that it is now called newName . If newName is an empty string then oldName is deleted. oldName and newName may include namespace qualifiers (names of containing namespaces). If a command is renamed into a different namespace, future invocations of it will execute in the new namespace. The rename command returns an empty string as result.","title":"DESCRIPTION"},{"location":"rename/#example","text":"The rename command can be used to wrap the standard Tcl commands with your own monitoring machinery. For example, you might wish to count how often the source command is called: rename ::source ::theRealSource set sourceCount 0 proc ::source args { global sourceCount puts \\\"called source for the [incr sourceCount]\\'th time\\\" uplevel 1 ::theRealSource \\$args }","title":"EXAMPLE"},{"location":"rename/#see-also","text":"namespace(n), proc(n)","title":"SEE ALSO"},{"location":"rename/#keywords","text":"command, delete, namespace, rename","title":"KEYWORDS"},{"location":"return/","text":"NAME return - Return from a procedure, or set return code of a script SYNOPSIS return ? result ? return ? -code code ? ? result ? return ? option value ...? ? result ? DESCRIPTION In its simplest usage, the return command is used without options in the body of a procedure to immediately return control to the caller of the procedure. If a result argument is provided, its value becomes the result of the procedure passed back to the caller. If result is not specified then an empty string will be returned to the caller as the result of the procedure. The return command serves a similar function within script files that are evaluated by the source command. When source evaluates the contents of a file as a script, an invocation of the return command will cause script evaluation to immediately cease, and the value result (or an empty string) will be returned as the result of the source command. EXCEPTIONAL RETURN CODES In addition to the result of a procedure, the return code of a procedure may also be set by return through use of the -code option. In the usual case where the -code option is not specified the procedure will return normally. However, the -code option may be used to generate an exceptional return from the procedure. Code may have any of the following values: ok (or 0 ) : Normal return: same as if the option is omitted. The return code of the procedure is 0 ( TCL_OK ). error (or 1 ) : Error return: the return code of the procedure is 1 ( TCL_ERROR ). The procedure command behaves in its calling context as if it were the command error result . See below for additional options. return (or 2 ) : The return code of the procedure is 2 ( TCL_RETURN ). The procedure command behaves in its calling context as if it were the command return (with no arguments). break (or 3 ) : The return code of the procedure is 3 ( TCL_BREAK ). The procedure command behaves in its calling context as if it were the command break . continue (or 4 ) : The return code of the procedure is 4 ( TCL_CONTINUE ). The procedure command behaves in its calling context as if it were the command continue . value : Value must be an integer; it will be returned as the return code for the current procedure. When a procedure wants to signal that it has received invalid arguments from its caller, it may use return -code error with result set to a suitable error message. Otherwise usage of the return -code option is mostly limited to procedures that implement a new control structure. The return -code command acts similarly within script files that are evaluated by the source command. During the evaluation of the contents of a file as a script by source , an invocation of the return -code code command will cause the return code of source to be code . RETURN OPTIONS In addition to a result and a return code, evaluation of a command in Tcl also produces a dictionary of return options. In general usage, all option value pairs given as arguments to return become entries in the return options dictionary, and any values at all are acceptable except as noted below. The catch command may be used to capture all of this information --- the return code, the result, and the return options dictionary --- that arise from evaluation of a script. As documented above, the -code entry in the return options dictionary receives special treatment by Tcl. There are other return options also recognized and treated specially by Tcl. They are: -errorcode list : The -errorcode option receives special treatment only when the value of the -code option is TCL_ERROR . Then the list value is meant to be additional information about the error, presented as a Tcl list for further processing by programs. If no -errorcode option is provided to return when the -code error option is provided, Tcl will set the value of the -errorcode entry in the return options dictionary to the default value of NONE . The -errorcode return option will also be stored in the global variable errorCode . -errorinfo info : The -errorinfo option receives special treatment only when the value of the -code option is TCL_ERROR . Then info is the initial stack trace, meant to provide to a human reader additional information about the context in which the error occurred. The stack trace will also be stored in the global variable errorInfo . If no -errorinfo option is provided to return when the -code error option is provided, Tcl will provide its own initial stack trace value in the entry for -errorinfo . Tcl\\'s initial stack trace will include only the call to the procedure, and stack unwinding will append information about higher stack levels, but there will be no information about the context of the error within the procedure. Typically the info value is supplied from the value of -errorinfo in a return options dictionary captured by the catch command (or from the copy of that information stored in the global variable errorInfo ). -errorstack list : The -errorstack option receives special treatment only when the value of the -code option is TCL_ERROR . Then list is the initial error stack, recording actual argument values passed to each proc level. The error stack will also be reachable through info errorstack . If no -errorstack option is provided to return when the -code error option is provided, Tcl will provide its own initial error stack in the entry for -errorstack . Tcl\\'s initial error stack will include only the call to the procedure, and stack unwinding will append information about higher stack levels, but there will be no information about the context of the error within the procedure. Typically the list value is supplied from the value of -errorstack in a return options dictionary captured by the catch command (or from the copy of that information from info errorstack ). -level level : The -level and -code options work together to set the return code to be returned by one of the commands currently being evaluated. The level value must be a non-negative integer representing a number of levels on the call stack. It defines the number of levels up the stack at which the return code of a command currently being evaluated should be code . If no -level option is provided, the default value of level is 1, so that return sets the return code that the current procedure returns to its caller, 1 level up the call stack. The mechanism by which these options work is described in more detail below. -options options : The value options must be a valid dictionary. The entries of that dictionary are treated as additional option value pairs for the return command. RETURN CODE HANDLING MECHANISMS Return codes are used in Tcl to control program flow. A Tcl script is a sequence of Tcl commands. So long as each command evaluation returns a return code of TCL_OK , evaluation will continue to the next command in the script. Any exceptional return code (non- TCL_OK ) returned by a command evaluation causes the flow on to the next command to be interrupted. Script evaluation ceases, and the exceptional return code from the command becomes the return code of the full script evaluation. This is the mechanism by which errors during script evaluation cause an interruption and unwinding of the call stack. It is also the mechanism by which commands like break , continue , and return cause script evaluation to terminate without evaluating all commands in sequence. Some of Tcl\\'s built-in commands evaluate scripts as part of their functioning. These commands can make use of exceptional return codes to enable special features. For example, the built-in Tcl commands that provide loops --- such as while , for , and foreach --- evaluate a script that is the body of the loop. If evaluation of the loop body returns the return code of TCL_BREAK or TCL_CONTINUE , the loop command can react in such a way as to give the break and continue commands their documented interpretation in loops. Procedure invocation also involves evaluation of a script, the body of the procedure. Procedure invocation provides special treatment when evaluation of the procedure body returns the return code TCL_RETURN . In that circumstance, the -level entry in the return options dictionary is decremented. If after decrementing, the value of the -level entry is 0, then the value of the -code entry becomes the return code of the procedure. If after decrementing, the value of the -level entry is greater than zero, then the return code of the procedure is TCL_RETURN . If the procedure invocation occurred during the evaluation of the body of another procedure, the process will repeat itself up the call stack, decrementing the value of the -level entry at each level, so that the code will be the return code of the current command level levels up the call stack. The source command performs the same handling of the TCL_RETURN return code, which explains the similarity of return invocation during a source to return invocation within a procedure. The return code of the return command itself triggers this special handling by procedure invocation. If return is provided the option -level 0 , then the return code of the return command itself will be the value code of the -code option (or TCL_OK by default). Any other value for the -level option (including the default value of 1) will cause the return code of the return command itself to be TCL_RETURN , triggering a return from the enclosing procedure. EXAMPLES First, a simple example of using return to return from a procedure, interrupting the procedure body. proc printOneLine {} { puts \\\"line 1\\\" ;# This line will be printed. return puts \\\"line 2\\\" ;# This line will not be printed. } Next, an example of using return to set the value returned by the procedure. proc returnX {} { return X} puts [returnX] ;# prints \\\"X\\\" Next, a more complete example, using return -code error to report invalid arguments. proc factorial {n} { if {![string is integer \\$n] || (\\$n \\< 0)} { return -code error \\ \\\"expected non-negative integer,\\ but got \\\\\"\\$n\\\\\"\\\" } if {\\$n \\< 2} { return 1 } set m [expr {\\$n - 1}] set code [catch {factorial \\$m} factor] if {\\$code != 0} { return -code \\$code \\$factor } set product [expr {\\$n * \\$factor}] if {\\$product \\< 0} { return -code error \\ \\\"overflow computing factorial of \\$n\\\" } return \\$product } Next, a procedure replacement for break . proc myBreak {} { return -code break } With the -level 0 option, return itself can serve as a replacement for break , with the help of interp alias . interp alias {} Break {} return -level 0 -code break An example of using catch and return -options to re-raise a caught error: proc doSomething {} { set resource [allocate] catch { # Long script of operations # that might raise an error } result options deallocate \\$resource return -options \\$options \\$result } Finally an example of advanced use of the return options to create a procedure replacement for return itself: proc myReturn {args} { set result \\\"\\\" if {[llength \\$args] % 2} { set result [lindex \\$args end] set args [lrange \\$args 0 end-1] } set options [dict merge {-level 1} \\$args] dict incr options -level return -options \\$options \\$result } SEE ALSO break(n), catch(n), continue(n), dict(n), error(n), errorCode(n), errorInfo(n), proc(n), source(n), throw(n), try(n) KEYWORDS break, catch, continue, error, exception, procedure, result, return","title":"NAME"},{"location":"return/#name","text":"return - Return from a procedure, or set return code of a script","title":"NAME"},{"location":"return/#synopsis","text":"return ? result ? return ? -code code ? ? result ? return ? option value ...? ? result ?","title":"SYNOPSIS"},{"location":"return/#description","text":"In its simplest usage, the return command is used without options in the body of a procedure to immediately return control to the caller of the procedure. If a result argument is provided, its value becomes the result of the procedure passed back to the caller. If result is not specified then an empty string will be returned to the caller as the result of the procedure. The return command serves a similar function within script files that are evaluated by the source command. When source evaluates the contents of a file as a script, an invocation of the return command will cause script evaluation to immediately cease, and the value result (or an empty string) will be returned as the result of the source command.","title":"DESCRIPTION"},{"location":"return/#exceptional-return-codes","text":"In addition to the result of a procedure, the return code of a procedure may also be set by return through use of the -code option. In the usual case where the -code option is not specified the procedure will return normally. However, the -code option may be used to generate an exceptional return from the procedure. Code may have any of the following values: ok (or 0 ) : Normal return: same as if the option is omitted. The return code of the procedure is 0 ( TCL_OK ). error (or 1 ) : Error return: the return code of the procedure is 1 ( TCL_ERROR ). The procedure command behaves in its calling context as if it were the command error result . See below for additional options. return (or 2 ) : The return code of the procedure is 2 ( TCL_RETURN ). The procedure command behaves in its calling context as if it were the command return (with no arguments). break (or 3 ) : The return code of the procedure is 3 ( TCL_BREAK ). The procedure command behaves in its calling context as if it were the command break . continue (or 4 ) : The return code of the procedure is 4 ( TCL_CONTINUE ). The procedure command behaves in its calling context as if it were the command continue . value : Value must be an integer; it will be returned as the return code for the current procedure. When a procedure wants to signal that it has received invalid arguments from its caller, it may use return -code error with result set to a suitable error message. Otherwise usage of the return -code option is mostly limited to procedures that implement a new control structure. The return -code command acts similarly within script files that are evaluated by the source command. During the evaluation of the contents of a file as a script by source , an invocation of the return -code code command will cause the return code of source to be code .","title":"EXCEPTIONAL RETURN CODES"},{"location":"return/#return-options","text":"In addition to a result and a return code, evaluation of a command in Tcl also produces a dictionary of return options. In general usage, all option value pairs given as arguments to return become entries in the return options dictionary, and any values at all are acceptable except as noted below. The catch command may be used to capture all of this information --- the return code, the result, and the return options dictionary --- that arise from evaluation of a script. As documented above, the -code entry in the return options dictionary receives special treatment by Tcl. There are other return options also recognized and treated specially by Tcl. They are: -errorcode list : The -errorcode option receives special treatment only when the value of the -code option is TCL_ERROR . Then the list value is meant to be additional information about the error, presented as a Tcl list for further processing by programs. If no -errorcode option is provided to return when the -code error option is provided, Tcl will set the value of the -errorcode entry in the return options dictionary to the default value of NONE . The -errorcode return option will also be stored in the global variable errorCode . -errorinfo info : The -errorinfo option receives special treatment only when the value of the -code option is TCL_ERROR . Then info is the initial stack trace, meant to provide to a human reader additional information about the context in which the error occurred. The stack trace will also be stored in the global variable errorInfo . If no -errorinfo option is provided to return when the -code error option is provided, Tcl will provide its own initial stack trace value in the entry for -errorinfo . Tcl\\'s initial stack trace will include only the call to the procedure, and stack unwinding will append information about higher stack levels, but there will be no information about the context of the error within the procedure. Typically the info value is supplied from the value of -errorinfo in a return options dictionary captured by the catch command (or from the copy of that information stored in the global variable errorInfo ). -errorstack list : The -errorstack option receives special treatment only when the value of the -code option is TCL_ERROR . Then list is the initial error stack, recording actual argument values passed to each proc level. The error stack will also be reachable through info errorstack . If no -errorstack option is provided to return when the -code error option is provided, Tcl will provide its own initial error stack in the entry for -errorstack . Tcl\\'s initial error stack will include only the call to the procedure, and stack unwinding will append information about higher stack levels, but there will be no information about the context of the error within the procedure. Typically the list value is supplied from the value of -errorstack in a return options dictionary captured by the catch command (or from the copy of that information from info errorstack ). -level level : The -level and -code options work together to set the return code to be returned by one of the commands currently being evaluated. The level value must be a non-negative integer representing a number of levels on the call stack. It defines the number of levels up the stack at which the return code of a command currently being evaluated should be code . If no -level option is provided, the default value of level is 1, so that return sets the return code that the current procedure returns to its caller, 1 level up the call stack. The mechanism by which these options work is described in more detail below. -options options : The value options must be a valid dictionary. The entries of that dictionary are treated as additional option value pairs for the return command.","title":"RETURN OPTIONS"},{"location":"return/#return-code-handling-mechanisms","text":"Return codes are used in Tcl to control program flow. A Tcl script is a sequence of Tcl commands. So long as each command evaluation returns a return code of TCL_OK , evaluation will continue to the next command in the script. Any exceptional return code (non- TCL_OK ) returned by a command evaluation causes the flow on to the next command to be interrupted. Script evaluation ceases, and the exceptional return code from the command becomes the return code of the full script evaluation. This is the mechanism by which errors during script evaluation cause an interruption and unwinding of the call stack. It is also the mechanism by which commands like break , continue , and return cause script evaluation to terminate without evaluating all commands in sequence. Some of Tcl\\'s built-in commands evaluate scripts as part of their functioning. These commands can make use of exceptional return codes to enable special features. For example, the built-in Tcl commands that provide loops --- such as while , for , and foreach --- evaluate a script that is the body of the loop. If evaluation of the loop body returns the return code of TCL_BREAK or TCL_CONTINUE , the loop command can react in such a way as to give the break and continue commands their documented interpretation in loops. Procedure invocation also involves evaluation of a script, the body of the procedure. Procedure invocation provides special treatment when evaluation of the procedure body returns the return code TCL_RETURN . In that circumstance, the -level entry in the return options dictionary is decremented. If after decrementing, the value of the -level entry is 0, then the value of the -code entry becomes the return code of the procedure. If after decrementing, the value of the -level entry is greater than zero, then the return code of the procedure is TCL_RETURN . If the procedure invocation occurred during the evaluation of the body of another procedure, the process will repeat itself up the call stack, decrementing the value of the -level entry at each level, so that the code will be the return code of the current command level levels up the call stack. The source command performs the same handling of the TCL_RETURN return code, which explains the similarity of return invocation during a source to return invocation within a procedure. The return code of the return command itself triggers this special handling by procedure invocation. If return is provided the option -level 0 , then the return code of the return command itself will be the value code of the -code option (or TCL_OK by default). Any other value for the -level option (including the default value of 1) will cause the return code of the return command itself to be TCL_RETURN , triggering a return from the enclosing procedure.","title":"RETURN CODE HANDLING MECHANISMS"},{"location":"return/#examples","text":"First, a simple example of using return to return from a procedure, interrupting the procedure body. proc printOneLine {} { puts \\\"line 1\\\" ;# This line will be printed. return puts \\\"line 2\\\" ;# This line will not be printed. } Next, an example of using return to set the value returned by the procedure. proc returnX {} { return X} puts [returnX] ;# prints \\\"X\\\" Next, a more complete example, using return -code error to report invalid arguments. proc factorial {n} { if {![string is integer \\$n] || (\\$n \\< 0)} { return -code error \\ \\\"expected non-negative integer,\\ but got \\\\\"\\$n\\\\\"\\\" } if {\\$n \\< 2} { return 1 } set m [expr {\\$n - 1}] set code [catch {factorial \\$m} factor] if {\\$code != 0} { return -code \\$code \\$factor } set product [expr {\\$n * \\$factor}] if {\\$product \\< 0} { return -code error \\ \\\"overflow computing factorial of \\$n\\\" } return \\$product } Next, a procedure replacement for break . proc myBreak {} { return -code break } With the -level 0 option, return itself can serve as a replacement for break , with the help of interp alias . interp alias {} Break {} return -level 0 -code break An example of using catch and return -options to re-raise a caught error: proc doSomething {} { set resource [allocate] catch { # Long script of operations # that might raise an error } result options deallocate \\$resource return -options \\$options \\$result } Finally an example of advanced use of the return options to create a procedure replacement for return itself: proc myReturn {args} { set result \\\"\\\" if {[llength \\$args] % 2} { set result [lindex \\$args end] set args [lrange \\$args 0 end-1] } set options [dict merge {-level 1} \\$args] dict incr options -level return -options \\$options \\$result }","title":"EXAMPLES"},{"location":"return/#see-also","text":"break(n), catch(n), continue(n), dict(n), error(n), errorCode(n), errorInfo(n), proc(n), source(n), throw(n), try(n)","title":"SEE ALSO"},{"location":"return/#keywords","text":"break, catch, continue, error, exception, procedure, result, return","title":"KEYWORDS"},{"location":"safe/","text":"NAME safe - Creating and manipulating safe interpreters SYNOPSIS ::safe::interpCreate ? child ? ? options... ? ::safe::interpInit child ? options... ? ::safe::interpConfigure child ? options... ? ::safe::interpDelete child ::safe::interpAddToAccessPath child directory ::safe::interpFindInAccessPath child directory ::safe::setSyncMode ? newValue ? ::safe::setLogCmd ? cmd arg... ? OPTIONS ? -accessPath pathList ? ? -autoPath pathList ? ? -statics boolean ? ? -noStatics ? ? -nested boolean ? ? -nestedLoadOk ? ? -deleteHook script ? DESCRIPTION Safe Tcl is a mechanism for executing untrusted Tcl scripts safely and for providing mediated access by such scripts to potentially dangerous functionality. Safe Tcl ensures that untrusted Tcl scripts cannot harm the hosting application. It prevents integrity and privacy attacks. Untrusted Tcl scripts are prevented from corrupting the state of the hosting application or computer. Untrusted scripts are also prevented from disclosing information stored on the hosting computer or in the hosting application to any party. Safe Tcl allows a parent interpreter to create safe, restricted interpreters that contain a set of predefined aliases for the source , load , file , encoding , and exit commands and are able to use the auto-loading and package mechanisms. No knowledge of the file system structure is leaked to the safe interpreter, because it has access only to a virtualized path containing tokens. When the safe interpreter requests to source a file, it uses the token in the virtual path as part of the file name to source; the parent interpreter transparently translates the token into a real directory name and executes the requested operation (see the section SECURITY below for details). Different levels of security can be selected by using the optional flags of the commands described below. All commands provided in the parent interpreter by Safe Tcl reside in the safe namespace. COMMANDS The following commands are provided in the parent interpreter: ::safe::interpCreate ? child ? ? options... ? : Creates a safe interpreter, installs the aliases described in the section ALIASES and initializes the auto-loading and package mechanism as specified by the supplied options . See the OPTIONS section below for a description of the optional arguments. If the child argument is omitted, a name will be generated. ::safe::interpCreate always returns the interpreter name. The interpreter name child may include namespace separators, but may not have leading or trailing namespace separators, or excess colon characters in namespace separators. The interpreter name is qualified relative to the global namespace ::, not the namespace in which the ::safe::interpCreate command is evaluated. ::safe::interpInit child ? options... ? : This command is similar to interpCreate except it that does not create the safe interpreter. child must have been created by some other means, like interp create -safe . The interpreter name child may include namespace separators, subject to the same restrictions as for interpCreate . ::safe::interpConfigure child ? options... ? : If no options are given, returns the settings for all options for the named safe interpreter as a list of options and their current values for that child . If a single additional argument is provided, it will return a list of 2 elements name and value where name is the full name of that option and value the current value for that option and the child . If more than two additional arguments are provided, it will reconfigure the safe interpreter and change each and only the provided options. See the section on OPTIONS below for options description. Example of use: \\# Create new interp with the same configuration as \\\"\\$i0\\\": set i1 \\[safe::interpCreate {\\*}\\[safe::interpConfigure \\$i0\\]\\] \\# Get the current deleteHook set dh \\[safe::interpConfigure \\$i0 -del\\] \\# Change (only) the statics loading ok attribute of an \\# interp and its deleteHook (leaving the rest unchanged): safe::interpConfigure \\$i0 -delete {foo bar} -statics 0 ::safe::interpDelete child : Deletes the safe interpreter and cleans up the corresponding parent interpreter data structures. If a deleteHook script was specified for this interpreter it is evaluated before the interpreter is deleted, with the name of the interpreter as an additional argument. ::safe::interpFindInAccessPath child directory : This command finds and returns the token for the real directory directory in the safe interpreter\\'s current virtual access path. It generates an error if the directory is not found. Example of use: \\$child eval \\[list set tk_library \\\\ \\[::safe::interpFindInAccessPath \\$name \\$tk_library\\]\\] ::safe::interpAddToAccessPath child directory : This command adds directory to the virtual path maintained for the safe interpreter in the parent, and returns the token that can be used in the safe interpreter to obtain access to files in that directory. If the directory is already in the virtual path, it only returns the token without adding the directory to the virtual path again. Example of use: \\$child eval \\[list set tk_library \\\\ \\[::safe::interpAddToAccessPath \\$name \\$tk_library\\]\\] ::safe::setSyncMode ? newValue ? : This command is used to get or set the \\\"Sync Mode\\\" of the Safe Base. When an argument is supplied, the command returns an error if the argument is not a boolean value, or if any Safe Base interpreters exist. Typically the value will be set as part of initialization - boolean true for \\\"Sync Mode\\\" on (the default), false for \\\"Sync Mode\\\" off. With \\\"Sync Mode\\\" on, the Safe Base keeps each child interpreter\\'s ::auto_path synchronized with its access path. See the section SYNC MODE below for details. ::safe::setLogCmd ? cmd arg... ? : This command installs a script that will be called when interesting life cycle events occur for a safe interpreter. When called with no arguments, it returns the currently installed script. When called with one argument, an empty string, the currently installed script is removed and logging is turned off. The script will be invoked with one additional argument, a string describing the event of interest. The main purpose is to help in debugging safe interpreters. Using this facility you can get complete error messages while the safe interpreter gets only generic error messages. This prevents a safe interpreter from seeing messages about failures and other events that might contain sensitive information such as real directory names. Example of use: ::safe::setLogCmd puts stderr Below is the output of a sample session in which a safe interpreter attempted to source a file not found in its virtual access path. Note that the safe interpreter only received an error message saying that the file was not found: NOTICE for child interp10 : Created NOTICE for child interp10 : Setting accessPath=(/foo/bar) staticsok=1 nestedok=0 deletehook=() NOTICE for child interp10 : auto_path in interp10 has been set to {\\$p(:0:)} ERROR for child interp10 : /foo/bar/init.tcl: no such file or directory OPTIONS The following options are common to ::safe::interpCreate , ::safe::interpInit , and ::safe::interpConfigure . Any option name can be abbreviated to its minimal non-ambiguous name. Option names are not case sensitive. -accessPath directoryList : This option sets the list of directories from which the safe interpreter can source and load files. If this option is not specified, or if it is given as the empty list, the safe interpreter will use the same directories as its parent for auto-loading. See the section SECURITY below for more detail about virtual paths, tokens and access control. -autoPath directoryList : This option sets the list of directories in the safe interpreter\\'s ::auto_path. The option is undefined if the Safe Base has \\\"Sync Mode\\\" on - in that case the safe interpreter\\'s ::auto_path is managed by the Safe Base and is a tokenized form of its access path. See the section SYNC MODE below for details. -statics boolean : This option specifies if the safe interpreter will be allowed to load statically linked packages (like load {} Tk ). The default value is true : safe interpreters are allowed to load statically linked packages. -noStatics : This option is a convenience shortcut for -statics false and thus specifies that the safe interpreter will not be allowed to load statically linked packages. -nested boolean : This option specifies if the safe interpreter will be allowed to load packages into its own sub-interpreters. The default value is false : safe interpreters are not allowed to load packages into their own sub-interpreters. -nestedLoadOk : This option is a convenience shortcut for -nested true and thus specifies the safe interpreter will be allowed to load packages into its own sub-interpreters. -deleteHook script : When this option is given a non-empty script , it will be evaluated in the parent with the name of the safe interpreter as an additional argument just before actually deleting the safe interpreter. Giving an empty value removes any currently installed deletion hook script for that safe interpreter. The default value ( {} ) is not to have any deletion call back. ALIASES The following aliases are provided in a safe interpreter: source fileName : The requested file, a Tcl source file, is sourced into the safe interpreter if it is found. The source alias can only source files from directories in the virtual path for the safe interpreter. The source alias requires the safe interpreter to use one of the token names in its virtual path to denote the directory in which the file to be sourced can be found. See the section on SECURITY for more discussion of restrictions on valid filenames. load fileName : The requested file, a shared object file, is dynamically loaded into the safe interpreter if it is found. The filename must contain a token name mentioned in the virtual path for the safe interpreter for it to be found successfully. Additionally, the shared object file must contain a safe entry point; see the manual page for the load command for more details. file ? subCmd args... ? : The file alias provides access to a safe subset of the subcommands of the file command; it allows only dirname , join , extension , root , tail , pathname and split subcommands. For more details on what these subcommands do see the manual page for the file command. encoding ? subCmd args... ? : The encoding alias provides access to a safe subset of the subcommands of the encoding command; it disallows setting of the system encoding, but allows all other subcommands including system to check the current encoding. exit : The calling interpreter is deleted and its computation is stopped, but the Tcl process in which this interpreter exists is not terminated. SECURITY Safe Tcl does not attempt to completely prevent annoyance and denial of service attacks. These forms of attack prevent the application or user from temporarily using the computer to perform useful work, for example by consuming all available CPU time or all available screen real estate. These attacks, while aggravating, are deemed to be of lesser importance in general than integrity and privacy attacks that Safe Tcl is to prevent. The commands available in a safe interpreter, in addition to the safe set as defined in interp manual page, are mediated aliases for source , load , exit , and safe subsets of file and encoding . The safe interpreter can also auto-load code and it can request that packages be loaded. Because some of these commands access the local file system, there is a potential for information leakage about its directory structure. To prevent this, commands that take file names as arguments in a safe interpreter use tokens instead of the real directory names. These tokens are translated to the real directory name while a request to, e.g., source a file is mediated by the parent interpreter. This virtual path system is maintained in the parent interpreter for each safe interpreter created by ::safe::interpCreate or initialized by ::safe::interpInit and the path maps tokens accessible in the safe interpreter into real path names on the local file system thus preventing safe interpreters from gaining knowledge about the structure of the file system of the host on which the interpreter is executing. The only valid file names arguments for the source and load aliases provided to the child are path in the form of [file join token filename ] (i.e. when using the native file path formats: token / filename on Unix and token \\ filename on Windows), where token is representing one of the directories of the accessPath list and filename is one file in that directory (no sub directories access are allowed). When a token is used in a safe interpreter in a request to source or load a file, the token is checked and translated to a real path name and the file to be sourced or loaded is located on the file system. The safe interpreter never gains knowledge of the actual path name under which the file is stored on the file system. To further prevent potential information leakage from sensitive files that are accidentally included in the set of files that can be sourced by a safe interpreter, the source alias restricts access to files meeting the following constraints: the file name must fourteen characters or shorter, must not contain more than one dot must end up with the extension or be called Each element of the initial access path list will be assigned a token that will be set in the child auto_path and the first element of that list will be set as the tcl_library for that child. If the access path argument is not given to ::safe::interpCreate or ::safe::interpInit or is the empty list, the default behavior is to let the child access the same packages as the parent has access to (Or to be more precise: only packages written in Tcl (which by definition cannot be dangerous as they run in the child interpreter) and C extensions that provides a _SafeInit entry point). For that purpose, the parent\\'s auto_path will be used to construct the child access path. In order that the child successfully loads the Tcl library files (which includes the auto-loading mechanism itself) the tcl_library will be added or moved to the first position if necessary, in the child access path, so the child tcl_library will be the same as the parent\\'s (its real path will still be invisible to the child though). In order that auto-loading works the same for the child and the parent in this by default case, the first-level sub directories of each directory in the parent auto_path will also be added (if not already included) to the child access path. You can always specify a more restrictive path for which sub directories will never be searched by explicitly specifying your directory list with the -accessPath flag instead of relying on this default mechanism. When the accessPath is changed after the first creation or initialization (i.e. through interpConfigure -accessPath list ), an auto_reset is automatically evaluated in the safe interpreter to synchronize its auto_index with the new token list. TYPICAL USE In many cases, the properties of a Safe Base interpreter can be specified when the interpreter is created, and then left unchanged for the lifetime of the interpreter. If you wish to use Safe Base interpreters with \\\"Sync Mode\\\" off, evaluate the command safe::setSyncMode 0 Use ::safe::interpCreate or ::safe::interpInit to create an interpreter with the properties that you require. The simplest way is not to specify -accessPath or -autoPath , which means the safe interpreter will use the same paths as the parent interpreter. However, if -accessPath is specified, then -autoPath must also be specified, or else it will be set to {}. The value of -autoPath will be that required to access tclIndex and pkgIndex.tcl files according to the same rules as an unsafe interpreter (see pkg_mkIndex(n) and library(n)). With \\\"Sync Mode\\\" on, the option -autoPath is undefined, and the Safe Base sets the child\\'s ::auto_path to a tokenized form of the access path. In addition to the directories present if \\\"Safe Mode\\\" is off, the ::auto_path includes the numerous subdirectories and module paths that belong to the access path. SYNC MODE Before Tcl version 8.7, the Safe Base kept each safe interpreter\\'s ::auto_path synchronized with a tokenized form of its access path. Limitations of Tcl 8.4 and earlier made this feature necessary. This definition of ::auto_path did not conform its specification in library(n) and pkg_mkIndex(n), but nevertheless worked perfectly well for the discovery and loading of packages. The introduction of Tcl modules in Tcl 8.5 added a large number of directories to the access path, and it is inconvenient to have these additional directories unnecessarily appended to the ::auto_path. In order to preserve compatibility with existing code, this synchronization of the ::auto_path and access path (\\\"Sync Mode\\\" on) is still the default. However, the Safe Base offers the option of limiting the safe interpreter\\'s ::auto_path to the much shorter list of directories that is necessary for it to perform its function (\\\"Sync Mode\\\" off). Use the command ::safe::setSyncMode to choose the mode before creating any Safe Base interpreters. In either mode, the most convenient way to initialize a safe interpreter is to call ::safe::interpCreate or ::safe::interpInit without the -accessPath or -autoPath options (or with the -accessPath option set to the empty list), which will give the safe interpreter the same access as the parent interpreter to packages, modules, and autoloader files. With \\\"Sync Mode\\\" off, the Safe Base will set the value of -autoPath to the parent\\'s ::auto_path, and will set the child\\'s ::auto_path to a tokenized form of the parent\\'s ::auto_path. With \\\"Sync Mode\\\" off, if a value is specified for -autoPath , even the empty list, in a call to ::safe::interpCreate , ::safe::interpInit , or ::safe::interpConfigure , it will be tokenized and used as the safe interpreter\\'s ::auto_path. Any directories that do not also belong to the access path cannot be tokenized and will be silently ignored. However, the value of -autoPath will remain as specified, and will be used to re-tokenize the child\\'s ::auto_path if ::safe::interpConfigure is called to change the value of -accessPath . With \\\"Sync Mode\\\" off, if the access path is reset to the values in the parent interpreter by calling ::safe::interpConfigure with arguments -accessPath {}, then the ::auto_path will also be reset unless the argument -autoPath is supplied to specify a different value. With \\\"Sync Mode\\\" off, if a non-empty value of -accessPath is supplied, the safe interpreter\\'s ::auto_path will be set to {} (by ::safe::interpCreate , ::safe::interpInit ) or left unchanged (by ::safe::interpConfigure ). If the same command specifies a new value for -autoPath , it will be applied after the -accessPath argument has been processed. Examples of use with \\\"Sync Mode\\\" off: any of these commands will set the ::auto_path to a tokenized form of its value in the parent interpreter: safe::interpCreate foo safe::interpCreate foo -accessPath {} safe::interpInit bar safe::interpInit bar -accessPath {} safe::interpConfigure foo -accessPath {} Example of use with \\\"Sync Mode\\\" off: when initializing a safe interpreter with a non-empty access path, the ::auto_path will be set to {} unless its own value is also specified: safe::interpCreate foo -accessPath { /usr/local/TclHome/lib/tcl8.6 /usr/local/TclHome/lib/tcl8.6/http1.0 /usr/local/TclHome/lib/tcl8.6/opt0.4 /usr/local/TclHome/lib/tcl8.6/msgs /usr/local/TclHome/lib/tcl8.6/encoding /usr/local/TclHome/lib } # The child\\'s ::auto_path must be given a suitable value: safe::interpConfigure foo -autoPath { /usr/local/TclHome/lib/tcl8.6 /usr/local/TclHome/lib } # The two commands can be combined: safe::interpCreate foo -accessPath { /usr/local/TclHome/lib/tcl8.6 /usr/local/TclHome/lib/tcl8.6/http1.0 /usr/local/TclHome/lib/tcl8.6/opt0.4 /usr/local/TclHome/lib/tcl8.6/msgs /usr/local/TclHome/lib/tcl8.6/encoding /usr/local/TclHome/lib } -autoPath { /usr/local/TclHome/lib/tcl8.6 /usr/local/TclHome/lib } Example of use with \\\"Sync Mode\\\" off: the command safe::interpAddToAccessPath does not change the safe interpreter\\'s ::auto_path, and so any necessary change must be made by the script: safe::interpAddToAccessPath foo /usr/local/TclHome/lib/extras/Img1.4.11 lassign [safe::interpConfigure foo -autoPath] DUM childAutoPath lappend childAutoPath /usr/local/TclHome/lib/extras/Img1.4.11 safe::interpConfigure foo -autoPath \\$childAutoPath SEE ALSO interp(n), library(n), load(n), package(n), pkg_mkIndex(n), source(n), tm(n), unknown(n) KEYWORDS alias, auto-loading, auto_mkindex, load, parent interpreter, safe interpreter, child interpreter, source","title":"NAME"},{"location":"safe/#name","text":"safe - Creating and manipulating safe interpreters","title":"NAME"},{"location":"safe/#synopsis","text":"::safe::interpCreate ? child ? ? options... ? ::safe::interpInit child ? options... ? ::safe::interpConfigure child ? options... ? ::safe::interpDelete child ::safe::interpAddToAccessPath child directory ::safe::interpFindInAccessPath child directory ::safe::setSyncMode ? newValue ? ::safe::setLogCmd ? cmd arg... ?","title":"SYNOPSIS"},{"location":"safe/#options","text":"? -accessPath pathList ? ? -autoPath pathList ? ? -statics boolean ? ? -noStatics ? ? -nested boolean ? ? -nestedLoadOk ? ? -deleteHook script ?","title":"OPTIONS"},{"location":"safe/#description","text":"Safe Tcl is a mechanism for executing untrusted Tcl scripts safely and for providing mediated access by such scripts to potentially dangerous functionality. Safe Tcl ensures that untrusted Tcl scripts cannot harm the hosting application. It prevents integrity and privacy attacks. Untrusted Tcl scripts are prevented from corrupting the state of the hosting application or computer. Untrusted scripts are also prevented from disclosing information stored on the hosting computer or in the hosting application to any party. Safe Tcl allows a parent interpreter to create safe, restricted interpreters that contain a set of predefined aliases for the source , load , file , encoding , and exit commands and are able to use the auto-loading and package mechanisms. No knowledge of the file system structure is leaked to the safe interpreter, because it has access only to a virtualized path containing tokens. When the safe interpreter requests to source a file, it uses the token in the virtual path as part of the file name to source; the parent interpreter transparently translates the token into a real directory name and executes the requested operation (see the section SECURITY below for details). Different levels of security can be selected by using the optional flags of the commands described below. All commands provided in the parent interpreter by Safe Tcl reside in the safe namespace.","title":"DESCRIPTION"},{"location":"safe/#commands","text":"The following commands are provided in the parent interpreter: ::safe::interpCreate ? child ? ? options... ? : Creates a safe interpreter, installs the aliases described in the section ALIASES and initializes the auto-loading and package mechanism as specified by the supplied options . See the OPTIONS section below for a description of the optional arguments. If the child argument is omitted, a name will be generated. ::safe::interpCreate always returns the interpreter name. The interpreter name child may include namespace separators, but may not have leading or trailing namespace separators, or excess colon characters in namespace separators. The interpreter name is qualified relative to the global namespace ::, not the namespace in which the ::safe::interpCreate command is evaluated. ::safe::interpInit child ? options... ? : This command is similar to interpCreate except it that does not create the safe interpreter. child must have been created by some other means, like interp create -safe . The interpreter name child may include namespace separators, subject to the same restrictions as for interpCreate . ::safe::interpConfigure child ? options... ? : If no options are given, returns the settings for all options for the named safe interpreter as a list of options and their current values for that child . If a single additional argument is provided, it will return a list of 2 elements name and value where name is the full name of that option and value the current value for that option and the child . If more than two additional arguments are provided, it will reconfigure the safe interpreter and change each and only the provided options. See the section on OPTIONS below for options description. Example of use: \\# Create new interp with the same configuration as \\\"\\$i0\\\": set i1 \\[safe::interpCreate {\\*}\\[safe::interpConfigure \\$i0\\]\\] \\# Get the current deleteHook set dh \\[safe::interpConfigure \\$i0 -del\\] \\# Change (only) the statics loading ok attribute of an \\# interp and its deleteHook (leaving the rest unchanged): safe::interpConfigure \\$i0 -delete {foo bar} -statics 0 ::safe::interpDelete child : Deletes the safe interpreter and cleans up the corresponding parent interpreter data structures. If a deleteHook script was specified for this interpreter it is evaluated before the interpreter is deleted, with the name of the interpreter as an additional argument. ::safe::interpFindInAccessPath child directory : This command finds and returns the token for the real directory directory in the safe interpreter\\'s current virtual access path. It generates an error if the directory is not found. Example of use: \\$child eval \\[list set tk_library \\\\ \\[::safe::interpFindInAccessPath \\$name \\$tk_library\\]\\] ::safe::interpAddToAccessPath child directory : This command adds directory to the virtual path maintained for the safe interpreter in the parent, and returns the token that can be used in the safe interpreter to obtain access to files in that directory. If the directory is already in the virtual path, it only returns the token without adding the directory to the virtual path again. Example of use: \\$child eval \\[list set tk_library \\\\ \\[::safe::interpAddToAccessPath \\$name \\$tk_library\\]\\] ::safe::setSyncMode ? newValue ? : This command is used to get or set the \\\"Sync Mode\\\" of the Safe Base. When an argument is supplied, the command returns an error if the argument is not a boolean value, or if any Safe Base interpreters exist. Typically the value will be set as part of initialization - boolean true for \\\"Sync Mode\\\" on (the default), false for \\\"Sync Mode\\\" off. With \\\"Sync Mode\\\" on, the Safe Base keeps each child interpreter\\'s ::auto_path synchronized with its access path. See the section SYNC MODE below for details. ::safe::setLogCmd ? cmd arg... ? : This command installs a script that will be called when interesting life cycle events occur for a safe interpreter. When called with no arguments, it returns the currently installed script. When called with one argument, an empty string, the currently installed script is removed and logging is turned off. The script will be invoked with one additional argument, a string describing the event of interest. The main purpose is to help in debugging safe interpreters. Using this facility you can get complete error messages while the safe interpreter gets only generic error messages. This prevents a safe interpreter from seeing messages about failures and other events that might contain sensitive information such as real directory names. Example of use: ::safe::setLogCmd puts stderr Below is the output of a sample session in which a safe interpreter attempted to source a file not found in its virtual access path. Note that the safe interpreter only received an error message saying that the file was not found: NOTICE for child interp10 : Created NOTICE for child interp10 : Setting accessPath=(/foo/bar) staticsok=1 nestedok=0 deletehook=() NOTICE for child interp10 : auto_path in interp10 has been set to {\\$p(:0:)} ERROR for child interp10 : /foo/bar/init.tcl: no such file or directory","title":"COMMANDS"},{"location":"safe/#options_1","text":"The following options are common to ::safe::interpCreate , ::safe::interpInit , and ::safe::interpConfigure . Any option name can be abbreviated to its minimal non-ambiguous name. Option names are not case sensitive. -accessPath directoryList : This option sets the list of directories from which the safe interpreter can source and load files. If this option is not specified, or if it is given as the empty list, the safe interpreter will use the same directories as its parent for auto-loading. See the section SECURITY below for more detail about virtual paths, tokens and access control. -autoPath directoryList : This option sets the list of directories in the safe interpreter\\'s ::auto_path. The option is undefined if the Safe Base has \\\"Sync Mode\\\" on - in that case the safe interpreter\\'s ::auto_path is managed by the Safe Base and is a tokenized form of its access path. See the section SYNC MODE below for details. -statics boolean : This option specifies if the safe interpreter will be allowed to load statically linked packages (like load {} Tk ). The default value is true : safe interpreters are allowed to load statically linked packages. -noStatics : This option is a convenience shortcut for -statics false and thus specifies that the safe interpreter will not be allowed to load statically linked packages. -nested boolean : This option specifies if the safe interpreter will be allowed to load packages into its own sub-interpreters. The default value is false : safe interpreters are not allowed to load packages into their own sub-interpreters. -nestedLoadOk : This option is a convenience shortcut for -nested true and thus specifies the safe interpreter will be allowed to load packages into its own sub-interpreters. -deleteHook script : When this option is given a non-empty script , it will be evaluated in the parent with the name of the safe interpreter as an additional argument just before actually deleting the safe interpreter. Giving an empty value removes any currently installed deletion hook script for that safe interpreter. The default value ( {} ) is not to have any deletion call back.","title":"OPTIONS"},{"location":"safe/#aliases","text":"The following aliases are provided in a safe interpreter: source fileName : The requested file, a Tcl source file, is sourced into the safe interpreter if it is found. The source alias can only source files from directories in the virtual path for the safe interpreter. The source alias requires the safe interpreter to use one of the token names in its virtual path to denote the directory in which the file to be sourced can be found. See the section on SECURITY for more discussion of restrictions on valid filenames. load fileName : The requested file, a shared object file, is dynamically loaded into the safe interpreter if it is found. The filename must contain a token name mentioned in the virtual path for the safe interpreter for it to be found successfully. Additionally, the shared object file must contain a safe entry point; see the manual page for the load command for more details. file ? subCmd args... ? : The file alias provides access to a safe subset of the subcommands of the file command; it allows only dirname , join , extension , root , tail , pathname and split subcommands. For more details on what these subcommands do see the manual page for the file command. encoding ? subCmd args... ? : The encoding alias provides access to a safe subset of the subcommands of the encoding command; it disallows setting of the system encoding, but allows all other subcommands including system to check the current encoding. exit : The calling interpreter is deleted and its computation is stopped, but the Tcl process in which this interpreter exists is not terminated.","title":"ALIASES"},{"location":"safe/#security","text":"Safe Tcl does not attempt to completely prevent annoyance and denial of service attacks. These forms of attack prevent the application or user from temporarily using the computer to perform useful work, for example by consuming all available CPU time or all available screen real estate. These attacks, while aggravating, are deemed to be of lesser importance in general than integrity and privacy attacks that Safe Tcl is to prevent. The commands available in a safe interpreter, in addition to the safe set as defined in interp manual page, are mediated aliases for source , load , exit , and safe subsets of file and encoding . The safe interpreter can also auto-load code and it can request that packages be loaded. Because some of these commands access the local file system, there is a potential for information leakage about its directory structure. To prevent this, commands that take file names as arguments in a safe interpreter use tokens instead of the real directory names. These tokens are translated to the real directory name while a request to, e.g., source a file is mediated by the parent interpreter. This virtual path system is maintained in the parent interpreter for each safe interpreter created by ::safe::interpCreate or initialized by ::safe::interpInit and the path maps tokens accessible in the safe interpreter into real path names on the local file system thus preventing safe interpreters from gaining knowledge about the structure of the file system of the host on which the interpreter is executing. The only valid file names arguments for the source and load aliases provided to the child are path in the form of [file join token filename ] (i.e. when using the native file path formats: token / filename on Unix and token \\ filename on Windows), where token is representing one of the directories of the accessPath list and filename is one file in that directory (no sub directories access are allowed). When a token is used in a safe interpreter in a request to source or load a file, the token is checked and translated to a real path name and the file to be sourced or loaded is located on the file system. The safe interpreter never gains knowledge of the actual path name under which the file is stored on the file system. To further prevent potential information leakage from sensitive files that are accidentally included in the set of files that can be sourced by a safe interpreter, the source alias restricts access to files meeting the following constraints: the file name must fourteen characters or shorter, must not contain more than one dot must end up with the extension or be called Each element of the initial access path list will be assigned a token that will be set in the child auto_path and the first element of that list will be set as the tcl_library for that child. If the access path argument is not given to ::safe::interpCreate or ::safe::interpInit or is the empty list, the default behavior is to let the child access the same packages as the parent has access to (Or to be more precise: only packages written in Tcl (which by definition cannot be dangerous as they run in the child interpreter) and C extensions that provides a _SafeInit entry point). For that purpose, the parent\\'s auto_path will be used to construct the child access path. In order that the child successfully loads the Tcl library files (which includes the auto-loading mechanism itself) the tcl_library will be added or moved to the first position if necessary, in the child access path, so the child tcl_library will be the same as the parent\\'s (its real path will still be invisible to the child though). In order that auto-loading works the same for the child and the parent in this by default case, the first-level sub directories of each directory in the parent auto_path will also be added (if not already included) to the child access path. You can always specify a more restrictive path for which sub directories will never be searched by explicitly specifying your directory list with the -accessPath flag instead of relying on this default mechanism. When the accessPath is changed after the first creation or initialization (i.e. through interpConfigure -accessPath list ), an auto_reset is automatically evaluated in the safe interpreter to synchronize its auto_index with the new token list.","title":"SECURITY"},{"location":"safe/#typical-use","text":"In many cases, the properties of a Safe Base interpreter can be specified when the interpreter is created, and then left unchanged for the lifetime of the interpreter. If you wish to use Safe Base interpreters with \\\"Sync Mode\\\" off, evaluate the command safe::setSyncMode 0 Use ::safe::interpCreate or ::safe::interpInit to create an interpreter with the properties that you require. The simplest way is not to specify -accessPath or -autoPath , which means the safe interpreter will use the same paths as the parent interpreter. However, if -accessPath is specified, then -autoPath must also be specified, or else it will be set to {}. The value of -autoPath will be that required to access tclIndex and pkgIndex.tcl files according to the same rules as an unsafe interpreter (see pkg_mkIndex(n) and library(n)). With \\\"Sync Mode\\\" on, the option -autoPath is undefined, and the Safe Base sets the child\\'s ::auto_path to a tokenized form of the access path. In addition to the directories present if \\\"Safe Mode\\\" is off, the ::auto_path includes the numerous subdirectories and module paths that belong to the access path.","title":"TYPICAL USE"},{"location":"safe/#sync-mode","text":"Before Tcl version 8.7, the Safe Base kept each safe interpreter\\'s ::auto_path synchronized with a tokenized form of its access path. Limitations of Tcl 8.4 and earlier made this feature necessary. This definition of ::auto_path did not conform its specification in library(n) and pkg_mkIndex(n), but nevertheless worked perfectly well for the discovery and loading of packages. The introduction of Tcl modules in Tcl 8.5 added a large number of directories to the access path, and it is inconvenient to have these additional directories unnecessarily appended to the ::auto_path. In order to preserve compatibility with existing code, this synchronization of the ::auto_path and access path (\\\"Sync Mode\\\" on) is still the default. However, the Safe Base offers the option of limiting the safe interpreter\\'s ::auto_path to the much shorter list of directories that is necessary for it to perform its function (\\\"Sync Mode\\\" off). Use the command ::safe::setSyncMode to choose the mode before creating any Safe Base interpreters. In either mode, the most convenient way to initialize a safe interpreter is to call ::safe::interpCreate or ::safe::interpInit without the -accessPath or -autoPath options (or with the -accessPath option set to the empty list), which will give the safe interpreter the same access as the parent interpreter to packages, modules, and autoloader files. With \\\"Sync Mode\\\" off, the Safe Base will set the value of -autoPath to the parent\\'s ::auto_path, and will set the child\\'s ::auto_path to a tokenized form of the parent\\'s ::auto_path. With \\\"Sync Mode\\\" off, if a value is specified for -autoPath , even the empty list, in a call to ::safe::interpCreate , ::safe::interpInit , or ::safe::interpConfigure , it will be tokenized and used as the safe interpreter\\'s ::auto_path. Any directories that do not also belong to the access path cannot be tokenized and will be silently ignored. However, the value of -autoPath will remain as specified, and will be used to re-tokenize the child\\'s ::auto_path if ::safe::interpConfigure is called to change the value of -accessPath . With \\\"Sync Mode\\\" off, if the access path is reset to the values in the parent interpreter by calling ::safe::interpConfigure with arguments -accessPath {}, then the ::auto_path will also be reset unless the argument -autoPath is supplied to specify a different value. With \\\"Sync Mode\\\" off, if a non-empty value of -accessPath is supplied, the safe interpreter\\'s ::auto_path will be set to {} (by ::safe::interpCreate , ::safe::interpInit ) or left unchanged (by ::safe::interpConfigure ). If the same command specifies a new value for -autoPath , it will be applied after the -accessPath argument has been processed. Examples of use with \\\"Sync Mode\\\" off: any of these commands will set the ::auto_path to a tokenized form of its value in the parent interpreter: safe::interpCreate foo safe::interpCreate foo -accessPath {} safe::interpInit bar safe::interpInit bar -accessPath {} safe::interpConfigure foo -accessPath {} Example of use with \\\"Sync Mode\\\" off: when initializing a safe interpreter with a non-empty access path, the ::auto_path will be set to {} unless its own value is also specified: safe::interpCreate foo -accessPath { /usr/local/TclHome/lib/tcl8.6 /usr/local/TclHome/lib/tcl8.6/http1.0 /usr/local/TclHome/lib/tcl8.6/opt0.4 /usr/local/TclHome/lib/tcl8.6/msgs /usr/local/TclHome/lib/tcl8.6/encoding /usr/local/TclHome/lib } # The child\\'s ::auto_path must be given a suitable value: safe::interpConfigure foo -autoPath { /usr/local/TclHome/lib/tcl8.6 /usr/local/TclHome/lib } # The two commands can be combined: safe::interpCreate foo -accessPath { /usr/local/TclHome/lib/tcl8.6 /usr/local/TclHome/lib/tcl8.6/http1.0 /usr/local/TclHome/lib/tcl8.6/opt0.4 /usr/local/TclHome/lib/tcl8.6/msgs /usr/local/TclHome/lib/tcl8.6/encoding /usr/local/TclHome/lib } -autoPath { /usr/local/TclHome/lib/tcl8.6 /usr/local/TclHome/lib } Example of use with \\\"Sync Mode\\\" off: the command safe::interpAddToAccessPath does not change the safe interpreter\\'s ::auto_path, and so any necessary change must be made by the script: safe::interpAddToAccessPath foo /usr/local/TclHome/lib/extras/Img1.4.11 lassign [safe::interpConfigure foo -autoPath] DUM childAutoPath lappend childAutoPath /usr/local/TclHome/lib/extras/Img1.4.11 safe::interpConfigure foo -autoPath \\$childAutoPath","title":"SYNC MODE"},{"location":"safe/#see-also","text":"interp(n), library(n), load(n), package(n), pkg_mkIndex(n), source(n), tm(n), unknown(n)","title":"SEE ALSO"},{"location":"safe/#keywords","text":"alias, auto-loading, auto_mkindex, load, parent interpreter, safe interpreter, child interpreter, source","title":"KEYWORDS"},{"location":"scan/","text":"NAME scan - Parse string using conversion specifiers in the style of sscanf SYNOPSIS scan string format ? varName varName ... ? INTRODUCTION This command parses substrings from an input string in a fashion similar to the ANSI C sscanf procedure and returns a count of the number of conversions performed, or -1 if the end of the input string is reached before any conversions have been performed. String gives the input to be parsed and format indicates how to parse it, using % conversion specifiers as in sscanf . Each varName gives the name of a variable; when a substring is scanned from string that matches a conversion specifier, the substring is assigned to the corresponding variable. If no varName variables are specified, then scan works in an inline manner, returning the data that would otherwise be stored in the variables as a list. In the inline case, an empty string is returned when the end of the input string is reached before any conversions have been performed. DETAILS ON SCANNING Scan operates by scanning string and format together. If the next character in format is a blank or tab then it matches any number of white space characters in string (including zero). Otherwise, if it is not a % character then it must match the next character of string . When a % is encountered in format , it indicates the start of a conversion specifier. A conversion specifier contains up to four fields after the % : a XPG3 position specifier (or a * to indicate the converted value is to be discarded instead of assigned to any variable); a number indicating a maximum substring width; a size modifier; and a conversion character. All of these fields are optional except for the conversion character. The fields that are present must appear in the order given above. When scan finds a conversion specifier in format , it first skips any white-space characters in string (unless the conversion character is [ or c ). Then it converts the next input characters according to the conversion specifier and stores the result in the variable given by the next argument to scan . OPTIONAL POSITIONAL SPECIFIER If the % is followed by a decimal number and a \\$ , as in then the variable to use is not taken from the next sequential argument. Instead, it is taken from the argument indicated by the number, where 1 corresponds to the first varName . If there are any positional specifiers in format then all of the specifiers must be positional. Every varName on the argument list must correspond to exactly one conversion specifier or an error is generated, or in the inline case, any position can be specified at most once and the empty positions will be filled in with empty strings. OPTIONAL SIZE MODIFIER The size modifier field is used only when scanning a substring into one of Tcl\\'s integer values. The size modifier field dictates the integer range acceptable to be stored in a variable, or, for the inline case, in a position in the result list. The syntactically valid values for the size modifier are h , L , l , and ll . The h size modifier value is equivalent to the absence of a size modifier in the the conversion specifier. Either one indicates the integer range to be stored is limited to the same range produced by the int() function of the expr command. The L size modifier is equivalent to the l size modifier. Either one indicates the integer range to be stored is limited to the same range produced by the wide() function of the expr command. The ll size modifier indicates that the integer range to be stored is unlimited. MANDATORY CONVERSION CHARACTER The following conversion characters are supported: d : The input substring must be a decimal integer. It is read in and the integer value is stored in the variable, truncated as required by the size modifier value. o : The input substring must be an octal integer. It is read in and the integer value is stored in the variable, truncated as required by the size modifier value. x or X : The input substring must be a hexadecimal integer. It is read in and the integer value is stored in the variable, truncated as required by the size modifier value. b : The input substring must be a binary integer. It is read in and the integer value is stored in the variable, truncated as required by the size modifier value. u : The input substring must be a decimal integer. The integer value is truncated as required by the size modifier value, and the corresponding unsigned value for that truncated range is computed and stored in the variable as a decimal string. The conversion makes no sense without reference to a truncation range, so the size modifier ll is not permitted in combination with conversion character u . i : The input substring must be an integer. The base (i.e. decimal, octal, or hexadecimal) is determined by the C convention (leading 0 for octal; prefix 0x for hexadecimal). The integer value is stored in the variable, truncated as required by the size modifier value. c : A single character is read in and its Unicode value is stored in the variable as an integer value. Initial white space is not skipped in this case, so the input substring may be a white-space character. s : The input substring consists of all the characters up to the next white-space character; the characters are copied to the variable. e or f or g or E or G : The input substring must be a floating-point number consisting of an optional sign, a string of decimal digits possibly containing a decimal point, and an optional exponent consisting of an e or E followed by an optional sign and a string of decimal digits. It is read in and stored in the variable as a floating-point value. [ chars ] : The input substring consists of one or more characters in chars . The matching string is stored in the variable. If the first character between the brackets is a ] then it is treated as part of chars rather than the closing bracket for the set. If chars contains a sequence of the form a - b then any character between a and b (inclusive) will match. If the first or last character between the brackets is a - , then it is treated as part of chars rather than indicating a range. [\\^ chars ] : The input substring consists of one or more characters not in chars . The matching string is stored in the variable. If the character immediately following the \\^ is a ] then it is treated as part of the set rather than the closing bracket for the set. If chars contains a sequence of the form a - b then any character between a and b (inclusive) will be excluded from the set. If the first or last character between the brackets is a - , then it is treated as part of chars rather than indicating a range value. n : No input is consumed from the input string. Instead, the total number of characters scanned from the input string so far is stored in the variable. The number of characters read from the input for a conversion is the largest number that makes sense for that particular conversion (e.g. as many decimal digits as possible for %d , as many octal digits as possible for %o , and so on). The input substring for a given conversion terminates either when a white-space character is encountered or when the maximum substring width has been reached, whichever comes first. If a * is present in the conversion specifier then no variable is assigned and the next scan argument is not consumed. DIFFERENCES FROM ANSI SSCANF The behavior of the scan command is the same as the behavior of the ANSI C sscanf procedure except for the following differences: [1] : %p conversion specifier is not supported. [2] : For %c conversions a single character value is converted to a decimal string, which is then assigned to the corresponding varName ; no substring width may be specified for this conversion. [3] : The h modifier is always ignored and the l and L modifiers are ignored when converting real values (i.e. type double is used for the internal representation). The ll modifier has no sscanf counterpart. [4] : If the end of the input string is reached before any conversions have been performed and no variables are given, an empty string is returned. EXAMPLES Convert a UNICODE character to its numeric value: set char \\\"x\\\" set value [ scan \\$char %c] Parse a simple color specification of the form #RRGGBB using hexadecimal conversions with substring sizes: set string \\\"#08D03F\\\" scan \\$string \\\"#%2x%2x%2x\\\" r g b Parse a HH:MM time string: set string \\\"08:08\\\" if {[ scan \\$string \\\"%d:%d\\\" hours minutes] != 2} { error \\\"not a valid time string\\\" } # We have to understand numeric ranges ourselves... if {\\$minutes \\< 0 || \\$minutes > 59} { error \\\"invalid number of minutes\\\" } Break a string up into sequences of non-whitespace characters (note the use of the %n conversion so that we get skipping over leading whitespace correct): set string \\\" a string {with braced words} + leading space \\\" set words {} while {[ scan \\$string %s%n word length] == 2} { lappend words \\$word set string [string range \\$string \\$length end] } Parse a simple coordinate string, checking that it is complete by looking for the terminating character explicitly: set string \\\"(5.2,-4e-2)\\\" # Note that the spaces before the literal parts of # the scan pattern are significant, and that \\\")\\\" is # the Unicode character \\u0029 if { [ scan \\$string \\\" (%f ,%f %c\\\" x y last] != 3 || \\$last != 0x0029 } then { error \\\"invalid coordinate string\\\" } puts \\\"X=\\$x, Y=\\$y\\\" An interactive session demonstrating the truncation of integer values determined by size modifiers: % set tcl_platform(wordSize) 4 % scan 20000000000000000000 %d 2147483647 % scan 20000000000000000000 %ld 9223372036854775807 % scan 20000000000000000000 %lld 20000000000000000000 SEE ALSO format(n), sscanf(3) KEYWORDS conversion specifier, parse, scan","title":"NAME"},{"location":"scan/#name","text":"scan - Parse string using conversion specifiers in the style of sscanf","title":"NAME"},{"location":"scan/#synopsis","text":"scan string format ? varName varName ... ?","title":"SYNOPSIS"},{"location":"scan/#introduction","text":"This command parses substrings from an input string in a fashion similar to the ANSI C sscanf procedure and returns a count of the number of conversions performed, or -1 if the end of the input string is reached before any conversions have been performed. String gives the input to be parsed and format indicates how to parse it, using % conversion specifiers as in sscanf . Each varName gives the name of a variable; when a substring is scanned from string that matches a conversion specifier, the substring is assigned to the corresponding variable. If no varName variables are specified, then scan works in an inline manner, returning the data that would otherwise be stored in the variables as a list. In the inline case, an empty string is returned when the end of the input string is reached before any conversions have been performed.","title":"INTRODUCTION"},{"location":"scan/#details-on-scanning","text":"Scan operates by scanning string and format together. If the next character in format is a blank or tab then it matches any number of white space characters in string (including zero). Otherwise, if it is not a % character then it must match the next character of string . When a % is encountered in format , it indicates the start of a conversion specifier. A conversion specifier contains up to four fields after the % : a XPG3 position specifier (or a * to indicate the converted value is to be discarded instead of assigned to any variable); a number indicating a maximum substring width; a size modifier; and a conversion character. All of these fields are optional except for the conversion character. The fields that are present must appear in the order given above. When scan finds a conversion specifier in format , it first skips any white-space characters in string (unless the conversion character is [ or c ). Then it converts the next input characters according to the conversion specifier and stores the result in the variable given by the next argument to scan .","title":"DETAILS ON SCANNING"},{"location":"scan/#optional-positional-specifier","text":"If the % is followed by a decimal number and a \\$ , as in then the variable to use is not taken from the next sequential argument. Instead, it is taken from the argument indicated by the number, where 1 corresponds to the first varName . If there are any positional specifiers in format then all of the specifiers must be positional. Every varName on the argument list must correspond to exactly one conversion specifier or an error is generated, or in the inline case, any position can be specified at most once and the empty positions will be filled in with empty strings.","title":"OPTIONAL POSITIONAL SPECIFIER"},{"location":"scan/#optional-size-modifier","text":"The size modifier field is used only when scanning a substring into one of Tcl\\'s integer values. The size modifier field dictates the integer range acceptable to be stored in a variable, or, for the inline case, in a position in the result list. The syntactically valid values for the size modifier are h , L , l , and ll . The h size modifier value is equivalent to the absence of a size modifier in the the conversion specifier. Either one indicates the integer range to be stored is limited to the same range produced by the int() function of the expr command. The L size modifier is equivalent to the l size modifier. Either one indicates the integer range to be stored is limited to the same range produced by the wide() function of the expr command. The ll size modifier indicates that the integer range to be stored is unlimited.","title":"OPTIONAL SIZE MODIFIER"},{"location":"scan/#mandatory-conversion-character","text":"The following conversion characters are supported: d : The input substring must be a decimal integer. It is read in and the integer value is stored in the variable, truncated as required by the size modifier value. o : The input substring must be an octal integer. It is read in and the integer value is stored in the variable, truncated as required by the size modifier value. x or X : The input substring must be a hexadecimal integer. It is read in and the integer value is stored in the variable, truncated as required by the size modifier value. b : The input substring must be a binary integer. It is read in and the integer value is stored in the variable, truncated as required by the size modifier value. u : The input substring must be a decimal integer. The integer value is truncated as required by the size modifier value, and the corresponding unsigned value for that truncated range is computed and stored in the variable as a decimal string. The conversion makes no sense without reference to a truncation range, so the size modifier ll is not permitted in combination with conversion character u . i : The input substring must be an integer. The base (i.e. decimal, octal, or hexadecimal) is determined by the C convention (leading 0 for octal; prefix 0x for hexadecimal). The integer value is stored in the variable, truncated as required by the size modifier value. c : A single character is read in and its Unicode value is stored in the variable as an integer value. Initial white space is not skipped in this case, so the input substring may be a white-space character. s : The input substring consists of all the characters up to the next white-space character; the characters are copied to the variable. e or f or g or E or G : The input substring must be a floating-point number consisting of an optional sign, a string of decimal digits possibly containing a decimal point, and an optional exponent consisting of an e or E followed by an optional sign and a string of decimal digits. It is read in and stored in the variable as a floating-point value. [ chars ] : The input substring consists of one or more characters in chars . The matching string is stored in the variable. If the first character between the brackets is a ] then it is treated as part of chars rather than the closing bracket for the set. If chars contains a sequence of the form a - b then any character between a and b (inclusive) will match. If the first or last character between the brackets is a - , then it is treated as part of chars rather than indicating a range. [\\^ chars ] : The input substring consists of one or more characters not in chars . The matching string is stored in the variable. If the character immediately following the \\^ is a ] then it is treated as part of the set rather than the closing bracket for the set. If chars contains a sequence of the form a - b then any character between a and b (inclusive) will be excluded from the set. If the first or last character between the brackets is a - , then it is treated as part of chars rather than indicating a range value. n : No input is consumed from the input string. Instead, the total number of characters scanned from the input string so far is stored in the variable. The number of characters read from the input for a conversion is the largest number that makes sense for that particular conversion (e.g. as many decimal digits as possible for %d , as many octal digits as possible for %o , and so on). The input substring for a given conversion terminates either when a white-space character is encountered or when the maximum substring width has been reached, whichever comes first. If a * is present in the conversion specifier then no variable is assigned and the next scan argument is not consumed.","title":"MANDATORY CONVERSION CHARACTER"},{"location":"scan/#differences-from-ansi-sscanf","text":"The behavior of the scan command is the same as the behavior of the ANSI C sscanf procedure except for the following differences: [1] : %p conversion specifier is not supported. [2] : For %c conversions a single character value is converted to a decimal string, which is then assigned to the corresponding varName ; no substring width may be specified for this conversion. [3] : The h modifier is always ignored and the l and L modifiers are ignored when converting real values (i.e. type double is used for the internal representation). The ll modifier has no sscanf counterpart. [4] : If the end of the input string is reached before any conversions have been performed and no variables are given, an empty string is returned.","title":"DIFFERENCES FROM ANSI SSCANF"},{"location":"scan/#examples","text":"Convert a UNICODE character to its numeric value: set char \\\"x\\\" set value [ scan \\$char %c] Parse a simple color specification of the form #RRGGBB using hexadecimal conversions with substring sizes: set string \\\"#08D03F\\\" scan \\$string \\\"#%2x%2x%2x\\\" r g b Parse a HH:MM time string: set string \\\"08:08\\\" if {[ scan \\$string \\\"%d:%d\\\" hours minutes] != 2} { error \\\"not a valid time string\\\" } # We have to understand numeric ranges ourselves... if {\\$minutes \\< 0 || \\$minutes > 59} { error \\\"invalid number of minutes\\\" } Break a string up into sequences of non-whitespace characters (note the use of the %n conversion so that we get skipping over leading whitespace correct): set string \\\" a string {with braced words} + leading space \\\" set words {} while {[ scan \\$string %s%n word length] == 2} { lappend words \\$word set string [string range \\$string \\$length end] } Parse a simple coordinate string, checking that it is complete by looking for the terminating character explicitly: set string \\\"(5.2,-4e-2)\\\" # Note that the spaces before the literal parts of # the scan pattern are significant, and that \\\")\\\" is # the Unicode character \\u0029 if { [ scan \\$string \\\" (%f ,%f %c\\\" x y last] != 3 || \\$last != 0x0029 } then { error \\\"invalid coordinate string\\\" } puts \\\"X=\\$x, Y=\\$y\\\" An interactive session demonstrating the truncation of integer values determined by size modifiers: % set tcl_platform(wordSize) 4 % scan 20000000000000000000 %d 2147483647 % scan 20000000000000000000 %ld 9223372036854775807 % scan 20000000000000000000 %lld 20000000000000000000","title":"EXAMPLES"},{"location":"scan/#see-also","text":"format(n), sscanf(3)","title":"SEE ALSO"},{"location":"scan/#keywords","text":"conversion specifier, parse, scan","title":"KEYWORDS"},{"location":"seek/","text":"NAME seek - Change the access position for an open channel SYNOPSIS seek channelId offset ? origin ? DESCRIPTION Changes the current access position for channelId . ChannelId must be an identifier for an open channel such as a Tcl standard channel ( stdin , stdout , or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. The offset and origin arguments specify the position at which the next read or write will occur for channelId . Offset must be an integer (which may be negative) and origin must be one of the following: start : The new access position will be offset bytes from the start of the underlying file or device. current : The new access position will be offset bytes from the current access position; a negative offset moves the access position backwards in the underlying file or device. end : The new access position will be offset bytes from the end of the file or device. A negative offset places the access position before the end of file, and a positive offset places the access position after the end of file. The origin argument defaults to start . The command flushes all buffered output for the channel before the command returns, even if the channel is in non-blocking mode. It also discards any buffered and unread input. This command returns an empty string. An error occurs if this command is applied to channels whose underlying file or device does not support seeking. Note that offset values are byte offsets, not character offsets. Both seek and tell operate in terms of bytes, not characters, unlike read . EXAMPLES Read a file twice: set f [open file.txt] set data1 [read \\$f] seek \\$f 0 set data2 [read \\$f] close \\$f # \\$data1 eq \\$data2 if the file wasn\\'t updated Read the last 10 bytes from a file: set f [open file.data] # This is guaranteed to work with binary data but # may fail with other encodings... fconfigure \\$f -translation binary seek \\$f -10 end set data [read \\$f 10] close \\$f SEE ALSO file(n), open(n), close(n), gets(n), tell(n), Tcl_StandardChannels(3) KEYWORDS access position, file, seek","title":"NAME"},{"location":"seek/#name","text":"seek - Change the access position for an open channel","title":"NAME"},{"location":"seek/#synopsis","text":"seek channelId offset ? origin ?","title":"SYNOPSIS"},{"location":"seek/#description","text":"Changes the current access position for channelId . ChannelId must be an identifier for an open channel such as a Tcl standard channel ( stdin , stdout , or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. The offset and origin arguments specify the position at which the next read or write will occur for channelId . Offset must be an integer (which may be negative) and origin must be one of the following: start : The new access position will be offset bytes from the start of the underlying file or device. current : The new access position will be offset bytes from the current access position; a negative offset moves the access position backwards in the underlying file or device. end : The new access position will be offset bytes from the end of the file or device. A negative offset places the access position before the end of file, and a positive offset places the access position after the end of file. The origin argument defaults to start . The command flushes all buffered output for the channel before the command returns, even if the channel is in non-blocking mode. It also discards any buffered and unread input. This command returns an empty string. An error occurs if this command is applied to channels whose underlying file or device does not support seeking. Note that offset values are byte offsets, not character offsets. Both seek and tell operate in terms of bytes, not characters, unlike read .","title":"DESCRIPTION"},{"location":"seek/#examples","text":"Read a file twice: set f [open file.txt] set data1 [read \\$f] seek \\$f 0 set data2 [read \\$f] close \\$f # \\$data1 eq \\$data2 if the file wasn\\'t updated Read the last 10 bytes from a file: set f [open file.data] # This is guaranteed to work with binary data but # may fail with other encodings... fconfigure \\$f -translation binary seek \\$f -10 end set data [read \\$f 10] close \\$f","title":"EXAMPLES"},{"location":"seek/#see-also","text":"file(n), open(n), close(n), gets(n), tell(n), Tcl_StandardChannels(3)","title":"SEE ALSO"},{"location":"seek/#keywords","text":"access position, file, seek","title":"KEYWORDS"},{"location":"self/","text":"NAME self - method call internal introspection SYNOPSIS package require tcl::oo self ?subcommand? DESCRIPTION The self command, which should only be used from within the context of a call to a method (i.e. inside a method, constructor or destructor body) is used to allow the method to discover information about how it was called. It takes an argument, subcommand , that tells it what sort of information is actually desired; if omitted the result will be the same as if self object was invoked. The supported subcommands are: self call : This returns a two-element list describing the method implementations used to implement the current call chain. The first element is the same as would be reported by info object call for the current method (except that this also reports useful values from within constructors and destructors, whose names are reported as \\<constructor> and \\<destructor> respectively, and for private methods, which are described as being private instead of being a method ), and the second element is an index into the first element\\'s list that indicates which actual implementation is currently executing (the first implementation to execute is always at index 0). self caller : When the method was invoked from inside another object method, this subcommand returns a three element list describing the containing object and method. The first element describes the declaring object or class of the method, the second element is the name of the object on which the containing method was invoked, and the third element is the name of the method (with the strings \\<constructor> and \\<destructor> indicating constructors and destructors respectively). self class : This returns the name of the class that the current method was defined within. Note that this will change as the chain of method implementations is traversed with next , and that if the method was defined on an object then this will fail. If you want the class of the current object, you need to use this other construct: info object class \\[**self object**\\] self filter : When invoked inside a filter, this subcommand returns a three element list describing the filter. The first element gives the name of the object or class that declared the filter (note that this may be different from the object or class that provided the implementation of the filter), the second element is either object or class depending on whether the declaring entity was an object or class, and the third element is the name of the filter. self method : This returns the name of the current method (with the strings \\<constructor> and \\<destructor> indicating constructors and destructors respectively). self namespace : This returns the name of the unique namespace of the object that the method was invoked upon. self next : When invoked from a method that is not at the end of a call chain (i.e. where the next command will invoke an actual method implementation), this subcommand returns a two element list describing the next element in the method call chain; the first element is the name of the class or object that declares the next part of the call chain, and the second element is the name of the method (with the strings \\<constructor> and \\<destructor> indicating constructors and destructors respectively). If invoked from a method that is at the end of a call chain, this subcommand returns the empty string. self object : This returns the name of the object that the method was invoked upon. self target : When invoked inside a filter implementation, this subcommand returns a two element list describing the method being filtered. The first element will be the name of the declarer of the method, and the second element will be the actual name of the method. EXAMPLES This example shows basic use of self to provide information about the current object: oo::class create c { method foo {} { puts \\\"this is the [ self ] object\\\" } } c create a c create b a foo \u2192 prints \\\"this is the ::a object\\\" b foo \u2192 prints \\\"this is the ::b object\\\" This demonstrates what a method call chain looks like, and how traversing along it changes the index into it: oo::class create c { method x {} { puts \\\"Cls: [ self call ]\\\" } } c create a oo::objdefine a { method x {} { puts \\\"Obj: [ self call ]\\\" next puts \\\"Obj: [ self call ]\\\" } } a x \u2192 Obj: {{method x object method} {method x ::c method}} 0 \u2192 Cls: {{method x object method} {method x ::c method}} 1 \u2192 Obj: {{method x object method} {method x ::c method}} 0 SEE ALSO info(n), next(n) KEYWORDS call, introspection, object","title":"NAME"},{"location":"self/#name","text":"self - method call internal introspection","title":"NAME"},{"location":"self/#synopsis","text":"package require tcl::oo self ?subcommand?","title":"SYNOPSIS"},{"location":"self/#description","text":"The self command, which should only be used from within the context of a call to a method (i.e. inside a method, constructor or destructor body) is used to allow the method to discover information about how it was called. It takes an argument, subcommand , that tells it what sort of information is actually desired; if omitted the result will be the same as if self object was invoked. The supported subcommands are: self call : This returns a two-element list describing the method implementations used to implement the current call chain. The first element is the same as would be reported by info object call for the current method (except that this also reports useful values from within constructors and destructors, whose names are reported as \\<constructor> and \\<destructor> respectively, and for private methods, which are described as being private instead of being a method ), and the second element is an index into the first element\\'s list that indicates which actual implementation is currently executing (the first implementation to execute is always at index 0). self caller : When the method was invoked from inside another object method, this subcommand returns a three element list describing the containing object and method. The first element describes the declaring object or class of the method, the second element is the name of the object on which the containing method was invoked, and the third element is the name of the method (with the strings \\<constructor> and \\<destructor> indicating constructors and destructors respectively). self class : This returns the name of the class that the current method was defined within. Note that this will change as the chain of method implementations is traversed with next , and that if the method was defined on an object then this will fail. If you want the class of the current object, you need to use this other construct: info object class \\[**self object**\\] self filter : When invoked inside a filter, this subcommand returns a three element list describing the filter. The first element gives the name of the object or class that declared the filter (note that this may be different from the object or class that provided the implementation of the filter), the second element is either object or class depending on whether the declaring entity was an object or class, and the third element is the name of the filter. self method : This returns the name of the current method (with the strings \\<constructor> and \\<destructor> indicating constructors and destructors respectively). self namespace : This returns the name of the unique namespace of the object that the method was invoked upon. self next : When invoked from a method that is not at the end of a call chain (i.e. where the next command will invoke an actual method implementation), this subcommand returns a two element list describing the next element in the method call chain; the first element is the name of the class or object that declares the next part of the call chain, and the second element is the name of the method (with the strings \\<constructor> and \\<destructor> indicating constructors and destructors respectively). If invoked from a method that is at the end of a call chain, this subcommand returns the empty string. self object : This returns the name of the object that the method was invoked upon. self target : When invoked inside a filter implementation, this subcommand returns a two element list describing the method being filtered. The first element will be the name of the declarer of the method, and the second element will be the actual name of the method.","title":"DESCRIPTION"},{"location":"self/#examples","text":"This example shows basic use of self to provide information about the current object: oo::class create c { method foo {} { puts \\\"this is the [ self ] object\\\" } } c create a c create b a foo \u2192 prints \\\"this is the ::a object\\\" b foo \u2192 prints \\\"this is the ::b object\\\" This demonstrates what a method call chain looks like, and how traversing along it changes the index into it: oo::class create c { method x {} { puts \\\"Cls: [ self call ]\\\" } } c create a oo::objdefine a { method x {} { puts \\\"Obj: [ self call ]\\\" next puts \\\"Obj: [ self call ]\\\" } } a x \u2192 Obj: {{method x object method} {method x ::c method}} 0 \u2192 Cls: {{method x object method} {method x ::c method}} 1 \u2192 Obj: {{method x object method} {method x ::c method}} 0","title":"EXAMPLES"},{"location":"self/#see-also","text":"info(n), next(n)","title":"SEE ALSO"},{"location":"self/#keywords","text":"call, introspection, object","title":"KEYWORDS"},{"location":"set/","text":"NAME set - Read and write variables SYNOPSIS set varName ? value ? DESCRIPTION Returns the value of variable varName . If value is specified, then set the value of varName to value , creating a new variable if one does not already exist, and return its value. If varName contains an open parenthesis and ends with a close parenthesis, then it refers to an array element: the characters before the first open parenthesis are the name of the array, and the characters between the parentheses are the index within the array. Otherwise varName refers to a scalar variable. If varName includes namespace qualifiers (in the array name if it refers to an array element), or if varName is unqualified (does not include the names of any containing namespaces) but no procedure is active, varName refers to a namespace variable resolved according to the rules described under NAME RESOLUTION in the namespace manual page. If a procedure is active and varName is unqualified, then varName refers to a parameter or local variable of the procedure, unless varName was declared to resolve differently through one of the global , variable or upvar commands. EXAMPLES Store a random number in the variable r : set r [expr {rand()}] Store a short message in an array element: set anAry(msg) \\\"Hello, World!\\\" Store a short message in an array element specified by a variable: set elemName \\\"msg\\\" set anAry(\\$elemName) \\\"Hello, World!\\\" Copy a value into the variable out from a variable whose name is stored in the vbl (note that it is often easier to use arrays in practice instead of doing double-dereferencing): set in0 \\\"small random\\\" set in1 \\\"large random\\\" set vbl in[expr {rand() >= 0.5}] set out [ set \\$vbl] SEE ALSO expr(n), global(n), namespace(n), proc(n), trace(n), unset(n), upvar(n), variable(n) KEYWORDS read, write, variable","title":"NAME"},{"location":"set/#name","text":"set - Read and write variables","title":"NAME"},{"location":"set/#synopsis","text":"set varName ? value ?","title":"SYNOPSIS"},{"location":"set/#description","text":"Returns the value of variable varName . If value is specified, then set the value of varName to value , creating a new variable if one does not already exist, and return its value. If varName contains an open parenthesis and ends with a close parenthesis, then it refers to an array element: the characters before the first open parenthesis are the name of the array, and the characters between the parentheses are the index within the array. Otherwise varName refers to a scalar variable. If varName includes namespace qualifiers (in the array name if it refers to an array element), or if varName is unqualified (does not include the names of any containing namespaces) but no procedure is active, varName refers to a namespace variable resolved according to the rules described under NAME RESOLUTION in the namespace manual page. If a procedure is active and varName is unqualified, then varName refers to a parameter or local variable of the procedure, unless varName was declared to resolve differently through one of the global , variable or upvar commands.","title":"DESCRIPTION"},{"location":"set/#examples","text":"Store a random number in the variable r : set r [expr {rand()}] Store a short message in an array element: set anAry(msg) \\\"Hello, World!\\\" Store a short message in an array element specified by a variable: set elemName \\\"msg\\\" set anAry(\\$elemName) \\\"Hello, World!\\\" Copy a value into the variable out from a variable whose name is stored in the vbl (note that it is often easier to use arrays in practice instead of doing double-dereferencing): set in0 \\\"small random\\\" set in1 \\\"large random\\\" set vbl in[expr {rand() >= 0.5}] set out [ set \\$vbl]","title":"EXAMPLES"},{"location":"set/#see-also","text":"expr(n), global(n), namespace(n), proc(n), trace(n), unset(n), upvar(n), variable(n)","title":"SEE ALSO"},{"location":"set/#keywords","text":"read, write, variable","title":"KEYWORDS"},{"location":"singleton/","text":"NAME oo::singleton - a class that does only allows one instance of itself SYNOPSIS package require tcl::oo oo::singleton method ?arg ...? CLASS HIERARCHY oo::object \u2192 oo::class \u2192 oo::singleton DESCRIPTION Singleton classes are classes that only permit at most one instance of themselves to exist. They unexport the create and createWithNamespace methods entirely, and override the new method so that it only makes a new instance if there is no existing instance. It is not recommended to inherit from a singleton class; singleton-ness is not inherited. It is not recommended that a singleton class\\'s constructor take any arguments. Instances have their destroy method overridden with a method that always returns an error in order to discourage destruction of the object, but destruction remains possible if strictly necessary (e.g., by destroying the class or using rename to delete it). They also have a (non-exported) \\<cloned> method defined on them that similarly always returns errors to make attempts to use the singleton instance with oo::copy fail. CONSTRUCTOR The oo::singleton class does not define an explicit constructor; this means that it is effectively the same as the constructor of the oo::class class. DESTRUCTOR The oo::singleton class does not define an explicit destructor; destroying an instance of it is just like destroying an ordinary class (and will destroy the singleton object). EXPORTED METHODS cls new ? arg ... ? : This returns the current instance of the singleton class, if one exists, and creates a new instance only if there is no existing instance. The additional arguments, arg ... , are only used if a new instance is actually manufactured; that construction is via the oo::class class\\'s new method. This is an override of the behaviour of a superclass\\'s method with an identical call signature to the superclass\\'s implementation. NON-EXPORTED METHODS The oo::singleton class explicitly states that create and createWithNamespace are unexported; callers should not assume that they have control over either the name or the namespace name of the singleton instance. EXAMPLE This example demonstrates that there is only one instance even though the new method is called three times. oo::singleton create Highlander { method say {} { puts \\\"there can be only one\\\" } } set h1 [Highlander new] set h2 [Highlander new] if {\\$h1 eq \\$h2} { puts \\\"equal objects\\\" \u2192 prints \\\"equal objects\\\" } set h3 [Highlander new] if {\\$h1 eq \\$h3} { puts \\\"equal objects\\\" \u2192 prints \\\"equal objects\\\" } Note that the name of the instance of the singleton is not guaranteed to be anything in particular. SEE ALSO oo::class(n) KEYWORDS class, metaclass, object, single instance","title":"NAME"},{"location":"singleton/#name","text":"oo::singleton - a class that does only allows one instance of itself","title":"NAME"},{"location":"singleton/#synopsis","text":"package require tcl::oo oo::singleton method ?arg ...?","title":"SYNOPSIS"},{"location":"singleton/#class-hierarchy","text":"oo::object \u2192 oo::class \u2192 oo::singleton","title":"CLASS HIERARCHY"},{"location":"singleton/#description","text":"Singleton classes are classes that only permit at most one instance of themselves to exist. They unexport the create and createWithNamespace methods entirely, and override the new method so that it only makes a new instance if there is no existing instance. It is not recommended to inherit from a singleton class; singleton-ness is not inherited. It is not recommended that a singleton class\\'s constructor take any arguments. Instances have their destroy method overridden with a method that always returns an error in order to discourage destruction of the object, but destruction remains possible if strictly necessary (e.g., by destroying the class or using rename to delete it). They also have a (non-exported) \\<cloned> method defined on them that similarly always returns errors to make attempts to use the singleton instance with oo::copy fail.","title":"DESCRIPTION"},{"location":"singleton/#constructor","text":"The oo::singleton class does not define an explicit constructor; this means that it is effectively the same as the constructor of the oo::class class.","title":"CONSTRUCTOR"},{"location":"singleton/#destructor","text":"The oo::singleton class does not define an explicit destructor; destroying an instance of it is just like destroying an ordinary class (and will destroy the singleton object).","title":"DESTRUCTOR"},{"location":"singleton/#exported-methods","text":"cls new ? arg ... ? : This returns the current instance of the singleton class, if one exists, and creates a new instance only if there is no existing instance. The additional arguments, arg ... , are only used if a new instance is actually manufactured; that construction is via the oo::class class\\'s new method. This is an override of the behaviour of a superclass\\'s method with an identical call signature to the superclass\\'s implementation.","title":"EXPORTED METHODS"},{"location":"singleton/#non-exported-methods","text":"The oo::singleton class explicitly states that create and createWithNamespace are unexported; callers should not assume that they have control over either the name or the namespace name of the singleton instance.","title":"NON-EXPORTED METHODS"},{"location":"singleton/#example","text":"This example demonstrates that there is only one instance even though the new method is called three times. oo::singleton create Highlander { method say {} { puts \\\"there can be only one\\\" } } set h1 [Highlander new] set h2 [Highlander new] if {\\$h1 eq \\$h2} { puts \\\"equal objects\\\" \u2192 prints \\\"equal objects\\\" } set h3 [Highlander new] if {\\$h1 eq \\$h3} { puts \\\"equal objects\\\" \u2192 prints \\\"equal objects\\\" } Note that the name of the instance of the singleton is not guaranteed to be anything in particular.","title":"EXAMPLE"},{"location":"singleton/#see-also","text":"oo::class(n)","title":"SEE ALSO"},{"location":"singleton/#keywords","text":"class, metaclass, object, single instance","title":"KEYWORDS"},{"location":"socket/","text":"NAME socket - Open a TCP network connection SYNOPSIS socket ? options ? host port socket -server command ? options ? port DESCRIPTION This command opens a network socket and returns a channel identifier that may be used in future invocations of commands like read , puts and flush . At present only the TCP network protocol is supported over IPv4 and IPv6; future releases may include support for additional protocols. The socket command may be used to open either the client or server side of a connection, depending on whether the -server switch is specified. Note that the default encoding for all sockets is the system encoding, as returned by encoding system . Most of the time, you will need to use chan configure to alter this to something else, such as utf-8 (ideal for communicating with other Tcl processes) or iso8859-1 (useful for many network protocols, especially the older ones). CLIENT SOCKETS If the -server option is not specified, then the client side of a connection is opened and the command returns a channel identifier that can be used for both reading and writing. Port and host specify a port to connect to; there must be a server accepting connections on this port. Port is an integer port number (or service name, where supported and understood by the host operating system) and host is either a domain-style name such as www.tcl.tk or a numerical IPv4 or IPv6 address such as 127.0.0.1 or 2001:DB8::1 . Use localhost to refer to the host on which the command is invoked. The following options may also be present before host to specify additional information about the connection: -myaddr addr : Addr gives the domain-style name or numerical IP address of the client-side network interface to use for the connection. This option may be useful if the client machine has multiple network interfaces. If the option is omitted then the client-side interface will be chosen by the system software. -myport port : Port specifies an integer port number (or service name, where supported and understood by the host operating system) to use for the client\\'s side of the connection. If this option is omitted, the client\\'s port number will be chosen at random by the system software. -async : This option will cause the client socket to be connected asynchronously. This means that the socket will be created immediately but may not yet be connected to the server, when the call to socket returns. When a **gets** or **flush** is done on the socket before the connection attempt succeeds or fails, if the socket is in blocking mode, the operation will wait until the connection is completed or fails. If the socket is in nonblocking mode and a **gets** or **flush** is done on the socket before the connection attempt succeeds or fails, the operation returns immediately and **fblocked** on the socket returns 1. Synchronous client sockets may be switched (after they have connected) to operating in asynchronous mode using: **chan configure ***chan ***-blocking 0** See the **chan configure** command for more details. The Tcl event loop should be running while an asynchronous connection is in progress, because it may have to do several connection attempts in the background. Running the event loop also allows you to set up a writable channel event on the socket to get notified when the asynchronous connection has succeeded or failed. See the **vwait** and the **chan** commands for more details on the event loop and channel events. The **chan configure** option **-connecting** may be used to check if the connect is still running. To verify a successful connect, the option **-error** may be checked when **-connecting** returned 0. Operation without the event queue requires at the moment calls to **chan configure** to advance the internal state machine. SERVER SOCKETS If the -server option is specified then the new socket will be a server that listens on the given port (either an integer or a service name, where supported and understood by the host operating system; if port is zero, the operating system will allocate a free port to the server socket which may be discovered by using chan configure to read the -sockname option). If the host supports both, IPv4 and IPv6, the socket will listen on both address families. Tcl will automatically accept connections to the given port. For each connection Tcl will create a new channel that may be used to communicate with the client. Tcl then invokes command (properly a command prefix list, see the EXAMPLES below) with three additional arguments: the name of the new channel, the address, in network address notation, of the client\\'s host, and the client\\'s port number. The following additional option may also be specified before port : -myaddr addr : Addr gives the domain-style name or numerical IP address of the server-side network interface to use for the connection. This option may be useful if the server machine has multiple network interfaces. If the option is omitted then the server socket is bound to the wildcard address so that it can accept connections from any interface. If addr is a domain name that resolves to multiple IP addresses that are available on the local machine, the socket will listen on all of them. -reuseaddr boolean : Tells the kernel whether to reuse the local address if there is no socket actively listening on it. This is the default on Windows. -reuseport boolean : Tells the kernel whether to allow the binding of multiple sockets to the same address and port. Server channels cannot be used for input or output; their sole use is to accept new client connections. The channels created for each incoming client connection are opened for input and output. Closing the server channel shuts down the server so that no new connections will be accepted; however, existing connections will be unaffected. Server sockets depend on the Tcl event mechanism to find out when new connections are opened. If the application does not enter the event loop, for example by invoking the vwait command or calling the C procedure Tcl_DoOneEvent , then no connections will be accepted. If port is specified as zero, the operating system will allocate an unused port for use as a server socket. The port number actually allocated may be retrieved from the created server socket using the chan configure command to retrieve the -sockname option as described below. CONFIGURATION OPTIONS The chan configure command can be used to query several readonly configuration options for socket channels or in some cases to set alternative properties on socket channels: -error : This option gets the current error status of the given socket. This is useful when you need to determine if an asynchronous connect operation succeeded. If there was an error, the error message is returned. If there was no error, an empty string is returned. Note that the error status is reset by the read operation; this mimics the underlying getsockopt(SO_ERROR) call. -sockname : For client sockets (including the channels that get created when a client connects to a server socket) this option returns a list of three elements, the address, the host name and the port number for the socket. If the host name cannot be computed, the second element is identical to the address, the first element of the list. For server sockets this option returns a list of a multiple of three elements each group of which have the same meaning as described above. The list contains more than one group when the server socket was created without **-myaddr** or with the argument to **-myaddr** being a domain name that resolves multiple IP addresses that are local to the invoking host. -peername : This option is not supported by server sockets. For client and accepted sockets, this option returns a list of three elements; these are the address, the host name and the port to which the peer socket is connected or bound. If the host name cannot be computed, the second element of the list is identical to the address, its first element. -connecting : This option is not supported by server sockets. For client sockets, this option returns 1 if an asyncroneous connect is still in progress, 0 otherwise. -keepalive : This option sets or queries the TCP keepalive option on the socket as 1 if keepalive is turned on, 0 otherwise. -nodelay : This option sets or queries the TCP nodelay option on the socket as 1 if nodelay is turned on, 0 otherwise. EXAMPLES Here is a very simple time server: proc Server {startTime channel clientaddr clientport} { puts \\\"Connection from \\$clientaddr registered\\\" set now [clock seconds] puts \\$channel [clock format \\$now] puts \\$channel \\\"[expr {\\$now - \\$startTime}] since start\\\" close \\$channel } socket -server [list Server [clock seconds]] 9900 vwait forever And here is the corresponding client to talk to the server and extract some information: set server localhost set sockChan [ socket \\$server 9900] gets \\$sockChan line1 gets \\$sockChan line2 close \\$sockChan puts \\\"The time on \\$server is \\$line1\\\" puts \\\"That is [lindex \\$line2 0]s since the server started\\\" HISTORY Support for IPv6 was added in Tcl 8.6. SEE ALSO chan(n), flush(n), open(n), read(n) KEYWORDS asynchronous I/O, bind, channel, connection, domain name, host, network address, socket, tcp","title":"NAME"},{"location":"socket/#name","text":"socket - Open a TCP network connection","title":"NAME"},{"location":"socket/#synopsis","text":"socket ? options ? host port socket -server command ? options ? port","title":"SYNOPSIS"},{"location":"socket/#description","text":"This command opens a network socket and returns a channel identifier that may be used in future invocations of commands like read , puts and flush . At present only the TCP network protocol is supported over IPv4 and IPv6; future releases may include support for additional protocols. The socket command may be used to open either the client or server side of a connection, depending on whether the -server switch is specified. Note that the default encoding for all sockets is the system encoding, as returned by encoding system . Most of the time, you will need to use chan configure to alter this to something else, such as utf-8 (ideal for communicating with other Tcl processes) or iso8859-1 (useful for many network protocols, especially the older ones).","title":"DESCRIPTION"},{"location":"socket/#client-sockets","text":"If the -server option is not specified, then the client side of a connection is opened and the command returns a channel identifier that can be used for both reading and writing. Port and host specify a port to connect to; there must be a server accepting connections on this port. Port is an integer port number (or service name, where supported and understood by the host operating system) and host is either a domain-style name such as www.tcl.tk or a numerical IPv4 or IPv6 address such as 127.0.0.1 or 2001:DB8::1 . Use localhost to refer to the host on which the command is invoked. The following options may also be present before host to specify additional information about the connection: -myaddr addr : Addr gives the domain-style name or numerical IP address of the client-side network interface to use for the connection. This option may be useful if the client machine has multiple network interfaces. If the option is omitted then the client-side interface will be chosen by the system software. -myport port : Port specifies an integer port number (or service name, where supported and understood by the host operating system) to use for the client\\'s side of the connection. If this option is omitted, the client\\'s port number will be chosen at random by the system software. -async : This option will cause the client socket to be connected asynchronously. This means that the socket will be created immediately but may not yet be connected to the server, when the call to socket returns. When a **gets** or **flush** is done on the socket before the connection attempt succeeds or fails, if the socket is in blocking mode, the operation will wait until the connection is completed or fails. If the socket is in nonblocking mode and a **gets** or **flush** is done on the socket before the connection attempt succeeds or fails, the operation returns immediately and **fblocked** on the socket returns 1. Synchronous client sockets may be switched (after they have connected) to operating in asynchronous mode using: **chan configure ***chan ***-blocking 0** See the **chan configure** command for more details. The Tcl event loop should be running while an asynchronous connection is in progress, because it may have to do several connection attempts in the background. Running the event loop also allows you to set up a writable channel event on the socket to get notified when the asynchronous connection has succeeded or failed. See the **vwait** and the **chan** commands for more details on the event loop and channel events. The **chan configure** option **-connecting** may be used to check if the connect is still running. To verify a successful connect, the option **-error** may be checked when **-connecting** returned 0. Operation without the event queue requires at the moment calls to **chan configure** to advance the internal state machine.","title":"CLIENT SOCKETS"},{"location":"socket/#server-sockets","text":"If the -server option is specified then the new socket will be a server that listens on the given port (either an integer or a service name, where supported and understood by the host operating system; if port is zero, the operating system will allocate a free port to the server socket which may be discovered by using chan configure to read the -sockname option). If the host supports both, IPv4 and IPv6, the socket will listen on both address families. Tcl will automatically accept connections to the given port. For each connection Tcl will create a new channel that may be used to communicate with the client. Tcl then invokes command (properly a command prefix list, see the EXAMPLES below) with three additional arguments: the name of the new channel, the address, in network address notation, of the client\\'s host, and the client\\'s port number. The following additional option may also be specified before port : -myaddr addr : Addr gives the domain-style name or numerical IP address of the server-side network interface to use for the connection. This option may be useful if the server machine has multiple network interfaces. If the option is omitted then the server socket is bound to the wildcard address so that it can accept connections from any interface. If addr is a domain name that resolves to multiple IP addresses that are available on the local machine, the socket will listen on all of them. -reuseaddr boolean : Tells the kernel whether to reuse the local address if there is no socket actively listening on it. This is the default on Windows. -reuseport boolean : Tells the kernel whether to allow the binding of multiple sockets to the same address and port. Server channels cannot be used for input or output; their sole use is to accept new client connections. The channels created for each incoming client connection are opened for input and output. Closing the server channel shuts down the server so that no new connections will be accepted; however, existing connections will be unaffected. Server sockets depend on the Tcl event mechanism to find out when new connections are opened. If the application does not enter the event loop, for example by invoking the vwait command or calling the C procedure Tcl_DoOneEvent , then no connections will be accepted. If port is specified as zero, the operating system will allocate an unused port for use as a server socket. The port number actually allocated may be retrieved from the created server socket using the chan configure command to retrieve the -sockname option as described below.","title":"SERVER SOCKETS"},{"location":"socket/#configuration-options","text":"The chan configure command can be used to query several readonly configuration options for socket channels or in some cases to set alternative properties on socket channels: -error : This option gets the current error status of the given socket. This is useful when you need to determine if an asynchronous connect operation succeeded. If there was an error, the error message is returned. If there was no error, an empty string is returned. Note that the error status is reset by the read operation; this mimics the underlying getsockopt(SO_ERROR) call. -sockname : For client sockets (including the channels that get created when a client connects to a server socket) this option returns a list of three elements, the address, the host name and the port number for the socket. If the host name cannot be computed, the second element is identical to the address, the first element of the list. For server sockets this option returns a list of a multiple of three elements each group of which have the same meaning as described above. The list contains more than one group when the server socket was created without **-myaddr** or with the argument to **-myaddr** being a domain name that resolves multiple IP addresses that are local to the invoking host. -peername : This option is not supported by server sockets. For client and accepted sockets, this option returns a list of three elements; these are the address, the host name and the port to which the peer socket is connected or bound. If the host name cannot be computed, the second element of the list is identical to the address, its first element. -connecting : This option is not supported by server sockets. For client sockets, this option returns 1 if an asyncroneous connect is still in progress, 0 otherwise. -keepalive : This option sets or queries the TCP keepalive option on the socket as 1 if keepalive is turned on, 0 otherwise. -nodelay : This option sets or queries the TCP nodelay option on the socket as 1 if nodelay is turned on, 0 otherwise.","title":"CONFIGURATION OPTIONS"},{"location":"socket/#examples","text":"Here is a very simple time server: proc Server {startTime channel clientaddr clientport} { puts \\\"Connection from \\$clientaddr registered\\\" set now [clock seconds] puts \\$channel [clock format \\$now] puts \\$channel \\\"[expr {\\$now - \\$startTime}] since start\\\" close \\$channel } socket -server [list Server [clock seconds]] 9900 vwait forever And here is the corresponding client to talk to the server and extract some information: set server localhost set sockChan [ socket \\$server 9900] gets \\$sockChan line1 gets \\$sockChan line2 close \\$sockChan puts \\\"The time on \\$server is \\$line1\\\" puts \\\"That is [lindex \\$line2 0]s since the server started\\\"","title":"EXAMPLES"},{"location":"socket/#history","text":"Support for IPv6 was added in Tcl 8.6.","title":"HISTORY"},{"location":"socket/#see-also","text":"chan(n), flush(n), open(n), read(n)","title":"SEE ALSO"},{"location":"socket/#keywords","text":"asynchronous I/O, bind, channel, connection, domain name, host, network address, socket, tcp","title":"KEYWORDS"},{"location":"split/","text":"NAME split - Split a string into a proper Tcl list SYNOPSIS split string ? splitChars ? DESCRIPTION Returns a list created by splitting string at each character that is in the splitChars argument. Each element of the result list will consist of the characters from string that lie between instances of the characters in splitChars . Empty list elements will be generated if string contains adjacent characters in splitChars , or if the first or last character of string is in splitChars . If splitChars is an empty string then each character of string becomes a separate element of the result list. SplitChars defaults to the standard white-space characters. EXAMPLES Divide up a USENET group name into its hierarchical components: split \\\"comp.lang.tcl\\\" . \u2192 comp lang tcl See how the split command splits on every character in splitChars , which can result in information loss if you are not careful: split \\\"alpha beta gamma\\\" \\\"temp\\\" \u2192 al {ha b} {} {a ga} {} a Extract the list words from a string that is not a well-formed list: split \\\"Example with {unbalanced brace character\\\" \u2192 Example with \\{unbalanced brace character Split a string into its constituent characters split \\\"Hello world\\\" {} \u2192 H e l l o { } w o r l d PARSING RECORD-ORIENTED FILES Parse a Unix /etc/passwd file, which consists of one entry per line, with each line consisting of a colon-separated list of fields: ## Read the file set fid [open /etc/passwd] set content [read \\$fid] close \\$fid ## Split into records on newlines set records [ split \\$content \\\"\\n\\\"] ## Iterate over the records foreach rec \\$records { ## Split into fields on colons set fields [ split \\$rec \\\":\\\"] ## Assign fields to variables and print some out... lassign \\$fields \\ userName password uid grp longName homeDir shell puts \\\"\\$longName uses [file tail \\$shell] for a login shell\\\" } SEE ALSO join(n), list(n), string(n) KEYWORDS list, split, string","title":"NAME"},{"location":"split/#name","text":"split - Split a string into a proper Tcl list","title":"NAME"},{"location":"split/#synopsis","text":"split string ? splitChars ?","title":"SYNOPSIS"},{"location":"split/#description","text":"Returns a list created by splitting string at each character that is in the splitChars argument. Each element of the result list will consist of the characters from string that lie between instances of the characters in splitChars . Empty list elements will be generated if string contains adjacent characters in splitChars , or if the first or last character of string is in splitChars . If splitChars is an empty string then each character of string becomes a separate element of the result list. SplitChars defaults to the standard white-space characters.","title":"DESCRIPTION"},{"location":"split/#examples","text":"Divide up a USENET group name into its hierarchical components: split \\\"comp.lang.tcl\\\" . \u2192 comp lang tcl See how the split command splits on every character in splitChars , which can result in information loss if you are not careful: split \\\"alpha beta gamma\\\" \\\"temp\\\" \u2192 al {ha b} {} {a ga} {} a Extract the list words from a string that is not a well-formed list: split \\\"Example with {unbalanced brace character\\\" \u2192 Example with \\{unbalanced brace character Split a string into its constituent characters split \\\"Hello world\\\" {} \u2192 H e l l o { } w o r l d","title":"EXAMPLES"},{"location":"split/#parsing-record-oriented-files","text":"Parse a Unix /etc/passwd file, which consists of one entry per line, with each line consisting of a colon-separated list of fields: ## Read the file set fid [open /etc/passwd] set content [read \\$fid] close \\$fid ## Split into records on newlines set records [ split \\$content \\\"\\n\\\"] ## Iterate over the records foreach rec \\$records { ## Split into fields on colons set fields [ split \\$rec \\\":\\\"] ## Assign fields to variables and print some out... lassign \\$fields \\ userName password uid grp longName homeDir shell puts \\\"\\$longName uses [file tail \\$shell] for a login shell\\\" }","title":"PARSING RECORD-ORIENTED FILES"},{"location":"split/#see-also","text":"join(n), list(n), string(n)","title":"SEE ALSO"},{"location":"split/#keywords","text":"list, split, string","title":"KEYWORDS"},{"location":"string/","text":"NAME string - Manipulate strings SYNOPSIS string option arg ? arg ... ? DESCRIPTION Performs one of several string operations, depending on option . The legal option s (which may be abbreviated) are: string cat ? string1 ? ? string2... ? : Concatenate the given string s just like placing them directly next to each other and return the resulting compound string. If no string s are present, the result is an empty string. This primitive is occasionally handier than juxtaposition of strings when mixed quoting is wanted, or when the aim is to return the result of a concatenation without resorting to **return** **-level 0**, and is more efficient than building a list of arguments and using **join** with an empty join string. string compare ? -nocase ? ? -length length ? string1 string2 : Perform a character-by-character comparison of strings string1 and string2 . Returns -1, 0, or 1, depending on whether string1 is lexicographically less than, equal to, or greater than string2 . If -length is specified, then only the first length characters are used in the comparison. If -length is negative, it is ignored. If -nocase is specified, then the strings are compared in a case-insensitive manner. string equal ? -nocase ? ? -length length ? string1 string2 : Perform a character-by-character comparison of strings string1 and string2 . Returns 1 if string1 and string2 are identical, or 0 when not. If -length is specified, then only the first length characters are used in the comparison. If -length is negative, it is ignored. If -nocase is specified, then the strings are compared in a case-insensitive manner. string first needleString haystackString ? startIndex ? : Search haystackString for a sequence of characters that exactly match the characters in needleString . If found, return the index of the first character in the first such match within haystackString . If not found, return -1. If startIndex is specified (in any of the forms described in STRING INDICES ), then the search is constrained to start with the character in haystackString specified by the index. For example, **string first a 0a23456789abcdef 5** will return **10**, but **string first a 0123456789abcdef 11** will return **-1**. string index string charIndex : Returns the charIndex \\'th character of the string argument. A charIndex of 0 corresponds to the first character of the string. charIndex may be specified as described in the STRING INDICES section. If *charIndex* is less than 0 or greater than or equal to the length of the string then this command returns an empty string. string insert string index insertString : Returns a copy of string with insertString inserted at the index \\'th character. The index may be specified as described in the STRING INDICES section. If index is start-relative, the first character inserted in the returned string will be at the specified index. If index is end-relative, the last character inserted in the returned string will be at the specified index. If index is at or before the start of string (e.g., index is 0 ), insertString is prepended to string . If index is at or after the end of string (e.g., index is end ), insertString is appended to string . string is class ? -strict ? ? -failindex varname ? string : Returns 1 if string is a valid member of the specified character class, otherwise returns 0. If -strict is specified, then an empty string returns 0, otherwise an empty string will return 1 on any class. If -failindex is specified, then if the function returns 0, the index in the string where the class was no longer valid will be stored in the variable named varname . The varname will not be set if string is returns 1. The following character classes are recognized (the class name can be abbreviated): alnum : Any Unicode alphabet or digit character. alpha : Any Unicode alphabet character. ascii : Any character with a value less than \\\\u0080 (those that are in the 7-bit ascii range). boolean : Any of the forms allowed to **Tcl_GetBoolean**. control : Any Unicode control character. dict : Any proper dict structure, with optional surrounding whitespace. In case of improper dict structure, 0 is returned and the *varname* will contain the index of the where the dict parsing fails, or -1 if this cannot be determined. digit : Any Unicode digit character. Note that this includes characters outside of the \\[0-9\\] range. double : Any of the forms allowed to **Tcl_GetDoubleFromObj**. entier : Any of the valid string formats for an integer value of arbitrary size in Tcl, with optional surrounding whitespace. The formats accepted are exactly those accepted by the C routine **Tcl_GetBignumFromObj**. false : Any of the forms allowed to **Tcl_GetBoolean** where the value is false. graph : Any Unicode printing character, except space. integer : Any of the valid string formats for a 32-bit integer value in Tcl, with optional surrounding whitespace. In case of overflow in the value, 0 is returned and the *varname* will contain -1. list : Any proper list structure, with optional surrounding whitespace. In case of improper list structure, 0 is returned and the *varname* will contain the index of the where the list parsing fails, or -1 if this cannot be determined. lower : Any Unicode lower case alphabet character. print : Any Unicode printing character, including space. punct : Any Unicode punctuation character. space : Any Unicode whitespace character, mongolian vowel separator (U+180e), zero width space (U+200b), word joiner (U+2060) or zero width no-break space (U+feff) (=BOM). true : Any of the forms allowed to **Tcl_GetBoolean** where the value is true. upper : Any upper case alphabet character in the Unicode character set. wideinteger : Any of the valid forms for a wide integer in Tcl, with optional surrounding whitespace. In case of overflow in the value, 0 is returned and the *varname* will contain -1. wordchar : Any Unicode word character. That is any alphanumeric character, and any Unicode connector punctuation characters (e.g. underscore). xdigit : Any hexadecimal digit character (\\[0-9A-Fa-f\\]). In the case of **boolean**, **true** and **false**, if the function will return 0, then the *varname* will always be set to 0, due to the varied nature of a valid boolean value. string last needleString haystackString ? lastIndex ? : Search haystackString for a sequence of characters that exactly match the characters in needleString . If found, return the index of the first character in the last such match within haystackString . If there is no match, then return -1. If lastIndex is specified (in any of the forms described in STRING INDICES ), then only the characters in haystackString at or before the specified lastIndex will be considered by the search. For example, **string last a 0a23456789abcdef 15** will return **10**, but **string last a 0a23456789abcdef 9** will return **1**. string length string : Returns a decimal string giving the number of characters in string . Note that this is not necessarily the same as the number of bytes used to store the string. If the value is a byte array value (such as those returned from reading a binary encoded channel), then this will return the actual byte length of the value. string map ? -nocase ? mapping string : Replaces substrings in string based on the key-value pairs in mapping . mapping is a list of key value key value ... as in the form returned by array get . Each instance of a key in the string will be replaced with its corresponding value. If -nocase is specified, then matching is done without regard to case differences. Both key and value may be multiple characters. Replacement is done in an ordered manner, so the key appearing first in the list will be checked first, and so on. string is only iterated over once, so earlier key replacements will have no affect for later key matches. For example, **string map {abc 1 ab 2 a 3 1 0} 1abcaababcabababc** will return the string **01321221**. Note that if an earlier *key* is a prefix of a later one, it will completely mask the later one. So if the previous example is reordered like this, **string map {1 0 ab 2 a 3 abc 1} 1abcaababcabababc** it will return the string **02c322c222c**. string match ? -nocase ? pattern string : See if pattern matches string ; return 1 if it does, 0 if it does not. If -nocase is specified, then the pattern attempts to match against the string in a case insensitive manner. For the two strings to match, their contents must be identical except that the following special sequences may appear in pattern : - Matches any sequence of characters in *string*, including a null string. ? : Matches any single character in *string*. \\[chars\\] : Matches any character in the set given by *chars*. If a sequence of the form *x***-***y* appears in *chars*, then any character between *x* and *y*, inclusive, will match. When used with **-nocase**, the end points of the range are converted to lower case first. Whereas {\\[A-z\\]} matches when matching case-sensitively (since falls between the and with **-nocase** this is considered like {\\[A-Za-z\\]} (and probably what was meant in the first place). \\\\x : Matches the single character *x*. This provides a way of avoiding the special interpretation of the characters **\\*?\\[\\]\\\\** in *pattern*. string range string first last : Returns a range of consecutive characters from string , starting with the character whose index is first and ending with the character whose index is last (using the forms described in STRING INDICES ). An index of 0 refers to the first character of the string; an index of end refers to last character of the string. first and last may be specified as for the index method. If first is less than zero then it is treated as if it were zero, and if last is greater than or equal to the length of the string then it is treated as if it were end . If first is greater than last then an empty string is returned. string repeat string count : Returns a string consisting of string concatenated with itself count times. If count is 0, the empty string will be returned. string replace string first last ? newstring ? : Removes a range of consecutive characters from string , starting with the character whose index is first and ending with the character whose index is last (using the forms described in STRING INDICES ). An index of 0 refers to the first character of the string. First and last may be specified as for the index method. If newstring is specified, then it is placed in the removed character range. If first is less than zero then it is treated as if it were zero, and if last is greater than or equal to the length of the string then it is treated as if it were end . The initial string is returned untouched, if first is greater than last , or if first is equal to or greater than the length of the initial string, or last is less than 0. string reverse string : Returns a string that is the same length as string but with its characters in the reverse order. string tolower string ? first ? ? last ? : Returns a value equal to string except that all upper (or title) case letters have been converted to lower case. If first is specified, it refers to the first char index in the string to start modifying. If last is specified, it refers to the char index in the string to stop at (inclusive). first and last may be specified using the forms described in STRING INDICES . string totitle string ? first ? ? last ? : Returns a value equal to string except that the first character in string is converted to its Unicode title case variant (or upper case if there is no title case variant) and the rest of the string is converted to lower case. If first is specified, it refers to the first char index in the string to start modifying. If last is specified, it refers to the char index in the string to stop at (inclusive). first and last may be specified using the forms described in STRING INDICES . string toupper string ? first ? ? last ? : Returns a value equal to string except that all lower (or title) case letters have been converted to upper case. If first is specified, it refers to the first char index in the string to start modifying. If last is specified, it refers to the char index in the string to stop at (inclusive). first and last may be specified using the forms described in STRING INDICES . string trim string ? chars ? : Returns a value equal to string except that any leading or trailing characters present in the string given by chars are removed. If chars is not specified then white space is removed (any character for which string is space returns 1, and \\\"\\0\\\"). string trimleft string ? chars ? : Returns a value equal to string except that any leading characters present in the string given by chars are removed. If chars is not specified then white space is removed (any character for which string is space returns 1, and \\\"\\0\\\"). string trimright string ? chars ? : Returns a value equal to string except that any trailing characters present in the string given by chars are removed. If chars is not specified then white space is removed (any character for which string is space returns 1, and \\\"\\0\\\"). OBSOLETE SUBCOMMANDS These subcommands are currently supported, but are likely to go away in a future release as their functionality is either virtually never used or highly misleading. string length [encoding convertto utf-8 \\$theString] string wordend string charIndex : Returns the index of the character just after the last one in the word containing character charIndex of string . charIndex may be specified using the forms in STRING INDICES . A word is considered to be any contiguous range of alphanumeric (Unicode letters or decimal digits) or underscore (Unicode connector punctuation) characters, or any single character other than these. string wordstart string charIndex : Returns the index of the first character in the word containing character charIndex of string . charIndex may be specified using the forms in STRING INDICES . A word is considered to be any contiguous range of alphanumeric (Unicode letters or decimal digits) or underscore (Unicode connector punctuation) characters, or any single character other than these. STRING INDICES When referring to indices into a string (e.g., for string index or string range ) the following formats are supported: integer : For any index value that passes string is integer -strict , the char specified at this integral index (e.g., 2 would refer to the in end : The last char of the string (e.g., end would refer to the in end-N : The last char of the string minus the specified integer offset N (e.g., would refer to the in end+N : The last char of the string plus the specified integer offset N (e.g., would refer to the in M+N : The char specified at the integral index that is the sum of integer values M and N (e.g., would refer to the in M-N : The char specified at the integral index that is the difference of integer values M and N (e.g., would refer to the in In the specifications above, the integer value M contains no trailing whitespace and the integer value N contains no leading whitespace. EXAMPLE Test if the string in the variable string is a proper non-empty prefix of the string foobar . set length [ string length \\$string] if {\\$length == 0} { set isPrefix 0 } else { set isPrefix [ string equal -length \\$length \\$string \\\"foobar\\\"] } SEE ALSO expr(n), list(n) KEYWORDS case conversion, compare, index, integer value, match, pattern, string, word, equal, ctype, character, reverse","title":"NAME"},{"location":"string/#name","text":"string - Manipulate strings","title":"NAME"},{"location":"string/#synopsis","text":"string option arg ? arg ... ?","title":"SYNOPSIS"},{"location":"string/#description","text":"Performs one of several string operations, depending on option . The legal option s (which may be abbreviated) are: string cat ? string1 ? ? string2... ? : Concatenate the given string s just like placing them directly next to each other and return the resulting compound string. If no string s are present, the result is an empty string. This primitive is occasionally handier than juxtaposition of strings when mixed quoting is wanted, or when the aim is to return the result of a concatenation without resorting to **return** **-level 0**, and is more efficient than building a list of arguments and using **join** with an empty join string. string compare ? -nocase ? ? -length length ? string1 string2 : Perform a character-by-character comparison of strings string1 and string2 . Returns -1, 0, or 1, depending on whether string1 is lexicographically less than, equal to, or greater than string2 . If -length is specified, then only the first length characters are used in the comparison. If -length is negative, it is ignored. If -nocase is specified, then the strings are compared in a case-insensitive manner. string equal ? -nocase ? ? -length length ? string1 string2 : Perform a character-by-character comparison of strings string1 and string2 . Returns 1 if string1 and string2 are identical, or 0 when not. If -length is specified, then only the first length characters are used in the comparison. If -length is negative, it is ignored. If -nocase is specified, then the strings are compared in a case-insensitive manner. string first needleString haystackString ? startIndex ? : Search haystackString for a sequence of characters that exactly match the characters in needleString . If found, return the index of the first character in the first such match within haystackString . If not found, return -1. If startIndex is specified (in any of the forms described in STRING INDICES ), then the search is constrained to start with the character in haystackString specified by the index. For example, **string first a 0a23456789abcdef 5** will return **10**, but **string first a 0123456789abcdef 11** will return **-1**. string index string charIndex : Returns the charIndex \\'th character of the string argument. A charIndex of 0 corresponds to the first character of the string. charIndex may be specified as described in the STRING INDICES section. If *charIndex* is less than 0 or greater than or equal to the length of the string then this command returns an empty string. string insert string index insertString : Returns a copy of string with insertString inserted at the index \\'th character. The index may be specified as described in the STRING INDICES section. If index is start-relative, the first character inserted in the returned string will be at the specified index. If index is end-relative, the last character inserted in the returned string will be at the specified index. If index is at or before the start of string (e.g., index is 0 ), insertString is prepended to string . If index is at or after the end of string (e.g., index is end ), insertString is appended to string . string is class ? -strict ? ? -failindex varname ? string : Returns 1 if string is a valid member of the specified character class, otherwise returns 0. If -strict is specified, then an empty string returns 0, otherwise an empty string will return 1 on any class. If -failindex is specified, then if the function returns 0, the index in the string where the class was no longer valid will be stored in the variable named varname . The varname will not be set if string is returns 1. The following character classes are recognized (the class name can be abbreviated): alnum : Any Unicode alphabet or digit character. alpha : Any Unicode alphabet character. ascii : Any character with a value less than \\\\u0080 (those that are in the 7-bit ascii range). boolean : Any of the forms allowed to **Tcl_GetBoolean**. control : Any Unicode control character. dict : Any proper dict structure, with optional surrounding whitespace. In case of improper dict structure, 0 is returned and the *varname* will contain the index of the where the dict parsing fails, or -1 if this cannot be determined. digit : Any Unicode digit character. Note that this includes characters outside of the \\[0-9\\] range. double : Any of the forms allowed to **Tcl_GetDoubleFromObj**. entier : Any of the valid string formats for an integer value of arbitrary size in Tcl, with optional surrounding whitespace. The formats accepted are exactly those accepted by the C routine **Tcl_GetBignumFromObj**. false : Any of the forms allowed to **Tcl_GetBoolean** where the value is false. graph : Any Unicode printing character, except space. integer : Any of the valid string formats for a 32-bit integer value in Tcl, with optional surrounding whitespace. In case of overflow in the value, 0 is returned and the *varname* will contain -1. list : Any proper list structure, with optional surrounding whitespace. In case of improper list structure, 0 is returned and the *varname* will contain the index of the where the list parsing fails, or -1 if this cannot be determined. lower : Any Unicode lower case alphabet character. print : Any Unicode printing character, including space. punct : Any Unicode punctuation character. space : Any Unicode whitespace character, mongolian vowel separator (U+180e), zero width space (U+200b), word joiner (U+2060) or zero width no-break space (U+feff) (=BOM). true : Any of the forms allowed to **Tcl_GetBoolean** where the value is true. upper : Any upper case alphabet character in the Unicode character set. wideinteger : Any of the valid forms for a wide integer in Tcl, with optional surrounding whitespace. In case of overflow in the value, 0 is returned and the *varname* will contain -1. wordchar : Any Unicode word character. That is any alphanumeric character, and any Unicode connector punctuation characters (e.g. underscore). xdigit : Any hexadecimal digit character (\\[0-9A-Fa-f\\]). In the case of **boolean**, **true** and **false**, if the function will return 0, then the *varname* will always be set to 0, due to the varied nature of a valid boolean value. string last needleString haystackString ? lastIndex ? : Search haystackString for a sequence of characters that exactly match the characters in needleString . If found, return the index of the first character in the last such match within haystackString . If there is no match, then return -1. If lastIndex is specified (in any of the forms described in STRING INDICES ), then only the characters in haystackString at or before the specified lastIndex will be considered by the search. For example, **string last a 0a23456789abcdef 15** will return **10**, but **string last a 0a23456789abcdef 9** will return **1**. string length string : Returns a decimal string giving the number of characters in string . Note that this is not necessarily the same as the number of bytes used to store the string. If the value is a byte array value (such as those returned from reading a binary encoded channel), then this will return the actual byte length of the value. string map ? -nocase ? mapping string : Replaces substrings in string based on the key-value pairs in mapping . mapping is a list of key value key value ... as in the form returned by array get . Each instance of a key in the string will be replaced with its corresponding value. If -nocase is specified, then matching is done without regard to case differences. Both key and value may be multiple characters. Replacement is done in an ordered manner, so the key appearing first in the list will be checked first, and so on. string is only iterated over once, so earlier key replacements will have no affect for later key matches. For example, **string map {abc 1 ab 2 a 3 1 0} 1abcaababcabababc** will return the string **01321221**. Note that if an earlier *key* is a prefix of a later one, it will completely mask the later one. So if the previous example is reordered like this, **string map {1 0 ab 2 a 3 abc 1} 1abcaababcabababc** it will return the string **02c322c222c**. string match ? -nocase ? pattern string : See if pattern matches string ; return 1 if it does, 0 if it does not. If -nocase is specified, then the pattern attempts to match against the string in a case insensitive manner. For the two strings to match, their contents must be identical except that the following special sequences may appear in pattern : - Matches any sequence of characters in *string*, including a null string. ? : Matches any single character in *string*. \\[chars\\] : Matches any character in the set given by *chars*. If a sequence of the form *x***-***y* appears in *chars*, then any character between *x* and *y*, inclusive, will match. When used with **-nocase**, the end points of the range are converted to lower case first. Whereas {\\[A-z\\]} matches when matching case-sensitively (since falls between the and with **-nocase** this is considered like {\\[A-Za-z\\]} (and probably what was meant in the first place). \\\\x : Matches the single character *x*. This provides a way of avoiding the special interpretation of the characters **\\*?\\[\\]\\\\** in *pattern*. string range string first last : Returns a range of consecutive characters from string , starting with the character whose index is first and ending with the character whose index is last (using the forms described in STRING INDICES ). An index of 0 refers to the first character of the string; an index of end refers to last character of the string. first and last may be specified as for the index method. If first is less than zero then it is treated as if it were zero, and if last is greater than or equal to the length of the string then it is treated as if it were end . If first is greater than last then an empty string is returned. string repeat string count : Returns a string consisting of string concatenated with itself count times. If count is 0, the empty string will be returned. string replace string first last ? newstring ? : Removes a range of consecutive characters from string , starting with the character whose index is first and ending with the character whose index is last (using the forms described in STRING INDICES ). An index of 0 refers to the first character of the string. First and last may be specified as for the index method. If newstring is specified, then it is placed in the removed character range. If first is less than zero then it is treated as if it were zero, and if last is greater than or equal to the length of the string then it is treated as if it were end . The initial string is returned untouched, if first is greater than last , or if first is equal to or greater than the length of the initial string, or last is less than 0. string reverse string : Returns a string that is the same length as string but with its characters in the reverse order. string tolower string ? first ? ? last ? : Returns a value equal to string except that all upper (or title) case letters have been converted to lower case. If first is specified, it refers to the first char index in the string to start modifying. If last is specified, it refers to the char index in the string to stop at (inclusive). first and last may be specified using the forms described in STRING INDICES . string totitle string ? first ? ? last ? : Returns a value equal to string except that the first character in string is converted to its Unicode title case variant (or upper case if there is no title case variant) and the rest of the string is converted to lower case. If first is specified, it refers to the first char index in the string to start modifying. If last is specified, it refers to the char index in the string to stop at (inclusive). first and last may be specified using the forms described in STRING INDICES . string toupper string ? first ? ? last ? : Returns a value equal to string except that all lower (or title) case letters have been converted to upper case. If first is specified, it refers to the first char index in the string to start modifying. If last is specified, it refers to the char index in the string to stop at (inclusive). first and last may be specified using the forms described in STRING INDICES . string trim string ? chars ? : Returns a value equal to string except that any leading or trailing characters present in the string given by chars are removed. If chars is not specified then white space is removed (any character for which string is space returns 1, and \\\"\\0\\\"). string trimleft string ? chars ? : Returns a value equal to string except that any leading characters present in the string given by chars are removed. If chars is not specified then white space is removed (any character for which string is space returns 1, and \\\"\\0\\\"). string trimright string ? chars ? : Returns a value equal to string except that any trailing characters present in the string given by chars are removed. If chars is not specified then white space is removed (any character for which string is space returns 1, and \\\"\\0\\\").","title":"DESCRIPTION"},{"location":"string/#obsolete-subcommands","text":"These subcommands are currently supported, but are likely to go away in a future release as their functionality is either virtually never used or highly misleading. string length [encoding convertto utf-8 \\$theString] string wordend string charIndex : Returns the index of the character just after the last one in the word containing character charIndex of string . charIndex may be specified using the forms in STRING INDICES . A word is considered to be any contiguous range of alphanumeric (Unicode letters or decimal digits) or underscore (Unicode connector punctuation) characters, or any single character other than these. string wordstart string charIndex : Returns the index of the first character in the word containing character charIndex of string . charIndex may be specified using the forms in STRING INDICES . A word is considered to be any contiguous range of alphanumeric (Unicode letters or decimal digits) or underscore (Unicode connector punctuation) characters, or any single character other than these.","title":"OBSOLETE SUBCOMMANDS"},{"location":"string/#string-indices","text":"When referring to indices into a string (e.g., for string index or string range ) the following formats are supported: integer : For any index value that passes string is integer -strict , the char specified at this integral index (e.g., 2 would refer to the in end : The last char of the string (e.g., end would refer to the in end-N : The last char of the string minus the specified integer offset N (e.g., would refer to the in end+N : The last char of the string plus the specified integer offset N (e.g., would refer to the in M+N : The char specified at the integral index that is the sum of integer values M and N (e.g., would refer to the in M-N : The char specified at the integral index that is the difference of integer values M and N (e.g., would refer to the in In the specifications above, the integer value M contains no trailing whitespace and the integer value N contains no leading whitespace.","title":"STRING INDICES"},{"location":"string/#example","text":"Test if the string in the variable string is a proper non-empty prefix of the string foobar . set length [ string length \\$string] if {\\$length == 0} { set isPrefix 0 } else { set isPrefix [ string equal -length \\$length \\$string \\\"foobar\\\"] }","title":"EXAMPLE"},{"location":"string/#see-also","text":"expr(n), list(n)","title":"SEE ALSO"},{"location":"string/#keywords","text":"case conversion, compare, index, integer value, match, pattern, string, word, equal, ctype, character, reverse","title":"KEYWORDS"},{"location":"subst/","text":"NAME subst - Perform backslash, command, and variable substitutions SYNOPSIS subst ? -nobackslashes ? ? -nocommands ? ? -novariables ? string DESCRIPTION This command performs variable substitutions, command substitutions, and backslash substitutions on its string argument and returns the fully-substituted result. The substitutions are performed in exactly the same way as for Tcl commands. As a result, the string argument is actually substituted twice, once by the Tcl parser in the usual fashion for Tcl commands, and again by the subst command. If any of the -nobackslashes , -nocommands , or -novariables are specified, then the corresponding substitutions are not performed. For example, if -nocommands is specified, command substitution is not performed: open and close brackets are treated as ordinary characters with no special interpretation. Note that the substitution of one kind can include substitution of other kinds. For example, even when the -novariables option is specified, command substitution is performed without restriction. This means that any variable substitution necessary to complete the command substitution will still take place. Likewise, any command substitution necessary to complete a variable substitution will take place, even when -nocommands is specified. See the EXAMPLES below. If an error occurs during substitution, then subst will return that error. If a break exception occurs during command or variable substitution, the result of the whole substitution will be the string (as substituted) up to the start of the substitution that raised the exception. If a continue exception occurs during the evaluation of a command or variable substitution, an empty string will be substituted for that entire command or variable substitution (as long as it is well-formed Tcl.) If a return exception occurs, or any other return code is returned during command or variable substitution, then the returned value is substituted for that substitution. See the EXAMPLES below. In this way, all exceptional return codes are by subst . The subst command itself will either return an error, or will complete successfully. EXAMPLES When it performs its substitutions, subst does not give any special treatment to double quotes or curly braces (except within command substitutions) so the script set a 44 subst {xyz {\\$a}} returns not and the script set a \\\"p\\} q \\{r\\\" subst {xyz {\\$a}} returns not When command substitution is performed, it includes any variable substitution necessary to evaluate the script. set a 44 subst -novariables {\\$a [format \\$a]} returns not Similarly, when variable substitution is performed, it includes any command substitution necessary to retrieve the value of the variable. proc b {} {return c} array set a {c c [b] tricky} subst -nocommands {[b] \\$a([b])} returns not The continue and break exceptions allow command substitutions to prevent substitution of the rest of the command substitution and the rest of string respectively, giving script authors more options when processing text using subst . For example, the script subst {abc,[break],def} returns not and the script subst {abc,[continue;expr {1+2}],def} returns not Other exceptional return codes substitute the returned value subst {abc,[return foo;expr {1+2}],def} returns not and subst {abc,[return -code 10 foo;expr {1+2}],def} also returns not SEE ALSO Tcl(n), eval(n), break(n), continue(n) KEYWORDS backslash substitution, command substitution, quoting, substitution, variable substitution","title":"NAME"},{"location":"subst/#name","text":"subst - Perform backslash, command, and variable substitutions","title":"NAME"},{"location":"subst/#synopsis","text":"subst ? -nobackslashes ? ? -nocommands ? ? -novariables ? string","title":"SYNOPSIS"},{"location":"subst/#description","text":"This command performs variable substitutions, command substitutions, and backslash substitutions on its string argument and returns the fully-substituted result. The substitutions are performed in exactly the same way as for Tcl commands. As a result, the string argument is actually substituted twice, once by the Tcl parser in the usual fashion for Tcl commands, and again by the subst command. If any of the -nobackslashes , -nocommands , or -novariables are specified, then the corresponding substitutions are not performed. For example, if -nocommands is specified, command substitution is not performed: open and close brackets are treated as ordinary characters with no special interpretation. Note that the substitution of one kind can include substitution of other kinds. For example, even when the -novariables option is specified, command substitution is performed without restriction. This means that any variable substitution necessary to complete the command substitution will still take place. Likewise, any command substitution necessary to complete a variable substitution will take place, even when -nocommands is specified. See the EXAMPLES below. If an error occurs during substitution, then subst will return that error. If a break exception occurs during command or variable substitution, the result of the whole substitution will be the string (as substituted) up to the start of the substitution that raised the exception. If a continue exception occurs during the evaluation of a command or variable substitution, an empty string will be substituted for that entire command or variable substitution (as long as it is well-formed Tcl.) If a return exception occurs, or any other return code is returned during command or variable substitution, then the returned value is substituted for that substitution. See the EXAMPLES below. In this way, all exceptional return codes are by subst . The subst command itself will either return an error, or will complete successfully.","title":"DESCRIPTION"},{"location":"subst/#examples","text":"When it performs its substitutions, subst does not give any special treatment to double quotes or curly braces (except within command substitutions) so the script set a 44 subst {xyz {\\$a}} returns not and the script set a \\\"p\\} q \\{r\\\" subst {xyz {\\$a}} returns not When command substitution is performed, it includes any variable substitution necessary to evaluate the script. set a 44 subst -novariables {\\$a [format \\$a]} returns not Similarly, when variable substitution is performed, it includes any command substitution necessary to retrieve the value of the variable. proc b {} {return c} array set a {c c [b] tricky} subst -nocommands {[b] \\$a([b])} returns not The continue and break exceptions allow command substitutions to prevent substitution of the rest of the command substitution and the rest of string respectively, giving script authors more options when processing text using subst . For example, the script subst {abc,[break],def} returns not and the script subst {abc,[continue;expr {1+2}],def} returns not Other exceptional return codes substitute the returned value subst {abc,[return foo;expr {1+2}],def} returns not and subst {abc,[return -code 10 foo;expr {1+2}],def} also returns not","title":"EXAMPLES"},{"location":"subst/#see-also","text":"Tcl(n), eval(n), break(n), continue(n)","title":"SEE ALSO"},{"location":"subst/#keywords","text":"backslash substitution, command substitution, quoting, substitution, variable substitution","title":"KEYWORDS"},{"location":"switch/","text":"NAME switch - Evaluate one of several scripts, depending on a given value SYNOPSIS switch ? options ? string pattern body ? pattern body ...? switch ? options ? string { pattern body ? pattern body ...?} DESCRIPTION The switch command matches its string argument against each of the pattern arguments in order. As soon as it finds a pattern that matches string it evaluates the following body argument by passing it recursively to the Tcl interpreter and returns the result of that evaluation. If the last pattern argument is default then it matches anything. If no pattern argument matches string and no default is given, then the switch command returns an empty string. If the initial arguments to switch start with - then they are treated as options unless there are exactly two arguments to switch (in which case the first must the string and the second must be the pattern / body list). The following options are currently supported: -exact : Use exact matching when comparing string to a pattern. This is the default. -glob : When matching string to the patterns, use glob-style matching (i.e. the same as implemented by the string match command). -regexp : When matching string to the patterns, use regular expression matching (as described in the re_syntax reference page). -nocase : Causes comparisons to be handled in a case-insensitive manner. -matchvar varName : This option (only legal when -regexp is also specified) specifies the name of a variable into which the list of matches found by the regular expression engine will be written. The first element of the list written will be the overall substring of the input string (i.e. the string argument to switch ) matched, the second element of the list will be the substring matched by the first capturing parenthesis in the regular expression that matched, and so on. When a default branch is taken, the variable will have the empty list written to it. This option may be specified at the same time as the -indexvar option. -indexvar varName : This option (only legal when -regexp is also specified) specifies the name of a variable into which the list of indices referring to matching substrings found by the regular expression engine will be written. The first element of the list written will be a two-element list specifying the index of the start and index of the first character after the end of the overall substring of the input string (i.e. the string argument to switch ) matched, in a similar way to the -indices option to the regexp can obtain. Similarly, the second element of the list refers to the first capturing parenthesis in the regular expression that matched, and so on. When a default branch is taken, the variable will have the empty list written to it. This option may be specified at the same time as the -matchvar option. -\u2006- : Marks the end of options. The argument following this one will be treated as string even if it starts with a - . This is not required when the matching patterns and bodies are grouped together in a single argument. Two syntaxes are provided for the pattern and body arguments. The first uses a separate argument for each of the patterns and commands; this form is convenient if substitutions are desired on some of the patterns or commands. The second form places all of the patterns and commands together into a single argument; the argument must have proper list structure, with the elements of the list being the patterns and commands. The second form makes it easy to construct multi-line switch commands, since the braces around the whole list make it unnecessary to include a backslash at the end of each line. Since the pattern arguments are in braces in the second form, no command or variable substitutions are performed on them; this makes the behavior of the second form different than the first form in some cases. If a body is specified as it means that the body for the next pattern should also be used as the body for this pattern (if the next pattern also has a body of then the body after that is used, and so on). This feature makes it possible to share a single body among several patterns. Beware of how you place comments in switch commands. Comments should only be placed inside the execution body of one of the patterns, and not intermingled with the patterns. EXAMPLES The switch command can match against variables and not just literals, as shown here (the result is 2 ): set foo \\\"abc\\\" switch abc a - b {expr {1}} \\$foo {expr {2}} default {expr {3}} Using glob matching and the fall-through body is an alternative to writing regular expressions with alternations, as can be seen here (this returns 1 ): switch -glob aaab { a*b - b {expr {1}} a* {expr {2}} default {expr {3}} } Whenever nothing matches, the default clause (which must be last) is taken. This example has a result of 3 : switch xyz { a - b { # Correct Comment Placement expr {1} } c { expr {2} } default { expr {3} } } When matching against regular expressions, information about what exactly matched is easily obtained using the -matchvar option: switch -regexp -matchvar foo -- \\$bar { a(b*)c { puts \\\"Found [string length [lindex \\$foo 1]] \\'b\\'s\\\" } d(e*)f(g*)h { puts \\\"Found [string length [lindex \\$foo 1]] \\'e\\'s and\\ [string length [lindex \\$foo 2]] \\'g\\'s\\\" } } SEE ALSO for(n), if(n), regexp(n) KEYWORDS switch, match, regular expression","title":"NAME"},{"location":"switch/#name","text":"switch - Evaluate one of several scripts, depending on a given value","title":"NAME"},{"location":"switch/#synopsis","text":"switch ? options ? string pattern body ? pattern body ...? switch ? options ? string { pattern body ? pattern body ...?}","title":"SYNOPSIS"},{"location":"switch/#description","text":"The switch command matches its string argument against each of the pattern arguments in order. As soon as it finds a pattern that matches string it evaluates the following body argument by passing it recursively to the Tcl interpreter and returns the result of that evaluation. If the last pattern argument is default then it matches anything. If no pattern argument matches string and no default is given, then the switch command returns an empty string. If the initial arguments to switch start with - then they are treated as options unless there are exactly two arguments to switch (in which case the first must the string and the second must be the pattern / body list). The following options are currently supported: -exact : Use exact matching when comparing string to a pattern. This is the default. -glob : When matching string to the patterns, use glob-style matching (i.e. the same as implemented by the string match command). -regexp : When matching string to the patterns, use regular expression matching (as described in the re_syntax reference page). -nocase : Causes comparisons to be handled in a case-insensitive manner. -matchvar varName : This option (only legal when -regexp is also specified) specifies the name of a variable into which the list of matches found by the regular expression engine will be written. The first element of the list written will be the overall substring of the input string (i.e. the string argument to switch ) matched, the second element of the list will be the substring matched by the first capturing parenthesis in the regular expression that matched, and so on. When a default branch is taken, the variable will have the empty list written to it. This option may be specified at the same time as the -indexvar option. -indexvar varName : This option (only legal when -regexp is also specified) specifies the name of a variable into which the list of indices referring to matching substrings found by the regular expression engine will be written. The first element of the list written will be a two-element list specifying the index of the start and index of the first character after the end of the overall substring of the input string (i.e. the string argument to switch ) matched, in a similar way to the -indices option to the regexp can obtain. Similarly, the second element of the list refers to the first capturing parenthesis in the regular expression that matched, and so on. When a default branch is taken, the variable will have the empty list written to it. This option may be specified at the same time as the -matchvar option. -\u2006- : Marks the end of options. The argument following this one will be treated as string even if it starts with a - . This is not required when the matching patterns and bodies are grouped together in a single argument. Two syntaxes are provided for the pattern and body arguments. The first uses a separate argument for each of the patterns and commands; this form is convenient if substitutions are desired on some of the patterns or commands. The second form places all of the patterns and commands together into a single argument; the argument must have proper list structure, with the elements of the list being the patterns and commands. The second form makes it easy to construct multi-line switch commands, since the braces around the whole list make it unnecessary to include a backslash at the end of each line. Since the pattern arguments are in braces in the second form, no command or variable substitutions are performed on them; this makes the behavior of the second form different than the first form in some cases. If a body is specified as it means that the body for the next pattern should also be used as the body for this pattern (if the next pattern also has a body of then the body after that is used, and so on). This feature makes it possible to share a single body among several patterns. Beware of how you place comments in switch commands. Comments should only be placed inside the execution body of one of the patterns, and not intermingled with the patterns.","title":"DESCRIPTION"},{"location":"switch/#examples","text":"The switch command can match against variables and not just literals, as shown here (the result is 2 ): set foo \\\"abc\\\" switch abc a - b {expr {1}} \\$foo {expr {2}} default {expr {3}} Using glob matching and the fall-through body is an alternative to writing regular expressions with alternations, as can be seen here (this returns 1 ): switch -glob aaab { a*b - b {expr {1}} a* {expr {2}} default {expr {3}} } Whenever nothing matches, the default clause (which must be last) is taken. This example has a result of 3 : switch xyz { a - b { # Correct Comment Placement expr {1} } c { expr {2} } default { expr {3} } } When matching against regular expressions, information about what exactly matched is easily obtained using the -matchvar option: switch -regexp -matchvar foo -- \\$bar { a(b*)c { puts \\\"Found [string length [lindex \\$foo 1]] \\'b\\'s\\\" } d(e*)f(g*)h { puts \\\"Found [string length [lindex \\$foo 1]] \\'e\\'s and\\ [string length [lindex \\$foo 2]] \\'g\\'s\\\" } }","title":"EXAMPLES"},{"location":"switch/#see-also","text":"for(n), if(n), regexp(n)","title":"SEE ALSO"},{"location":"switch/#keywords","text":"switch, match, regular expression","title":"KEYWORDS"},{"location":"tailcall/","text":"NAME tailcall - Replace the current procedure with another command SYNOPSIS tailcall command ? arg ... ? DESCRIPTION The tailcall command replaces the currently executing procedure, lambda application, or method with another command. The command , which will have arg ... passed as arguments if they are supplied, will be looked up in the current namespace context, not in the caller\\'s. Apart from that difference in resolution, it is equivalent to: return [uplevel 1 [list command ? arg ... ?]] This command may not be invoked from within an uplevel into a procedure or inside a catch inside a procedure or lambda. EXAMPLE Compute the factorial of a number. proc factorial {n {accum 1}} { if {\\$n \\< 2} { return \\$accum } tailcall factorial [expr {\\$n - 1}] [expr {\\$accum * \\$n}] } Print the elements of a list with alternating lines having different indentations. proc printList {theList} { if {[llength \\$theList]} { puts \\\"> [lindex \\$theList 0]\\\" tailcall printList2 [lrange \\$theList 1 end] } } proc printList2 {theList} { if {[llength \\$theList]} { puts \\\"\\< [lindex \\$theList 0]\\\" tailcall printList [lrange \\$theList 1 end] } } SEE ALSO apply(n), proc(n), uplevel(n) KEYWORDS call, recursion, tail recursion","title":"NAME"},{"location":"tailcall/#name","text":"tailcall - Replace the current procedure with another command","title":"NAME"},{"location":"tailcall/#synopsis","text":"tailcall command ? arg ... ?","title":"SYNOPSIS"},{"location":"tailcall/#description","text":"The tailcall command replaces the currently executing procedure, lambda application, or method with another command. The command , which will have arg ... passed as arguments if they are supplied, will be looked up in the current namespace context, not in the caller\\'s. Apart from that difference in resolution, it is equivalent to: return [uplevel 1 [list command ? arg ... ?]] This command may not be invoked from within an uplevel into a procedure or inside a catch inside a procedure or lambda.","title":"DESCRIPTION"},{"location":"tailcall/#example","text":"Compute the factorial of a number. proc factorial {n {accum 1}} { if {\\$n \\< 2} { return \\$accum } tailcall factorial [expr {\\$n - 1}] [expr {\\$accum * \\$n}] } Print the elements of a list with alternating lines having different indentations. proc printList {theList} { if {[llength \\$theList]} { puts \\\"> [lindex \\$theList 0]\\\" tailcall printList2 [lrange \\$theList 1 end] } } proc printList2 {theList} { if {[llength \\$theList]} { puts \\\"\\< [lindex \\$theList 0]\\\" tailcall printList [lrange \\$theList 1 end] } }","title":"EXAMPLE"},{"location":"tailcall/#see-also","text":"apply(n), proc(n), uplevel(n)","title":"SEE ALSO"},{"location":"tailcall/#keywords","text":"call, recursion, tail recursion","title":"KEYWORDS"},{"location":"tclsh/","text":"NAME tclsh - Simple shell containing Tcl interpreter SYNOPSIS tclsh ? -encoding name ? ? fileName arg arg ... ? DESCRIPTION Tclsh is a shell-like application that reads Tcl commands from its standard input or from a file and evaluates them. If invoked with no arguments then it runs interactively, reading Tcl commands from standard input and printing command results and error messages to standard output. It runs until the exit command is invoked or until it reaches end-of-file on its standard input. If there exists a file .tclshrc (or tclshrc.tcl on the Windows platforms) in the home directory of the user, interactive tclsh evaluates the file as a Tcl script just before reading the first command from standard input. SCRIPT FILES If tclsh is invoked with arguments then the first few arguments specify the name of a script file, and, optionally, the encoding of the text data stored in that script file. Any additional arguments are made available to the script as variables (see below). Instead of reading commands from standard input tclsh will read Tcl commands from the named file; tclsh will exit when it reaches the end of the file. The end of the file may be marked either by the physical end of the medium, or by the character, If this character is present in the file, the tclsh application will read text up to but not including the character. An application that requires this character in the file may safely encode it as or may generate it by use of commands such as format or binary . There is no automatic evaluation of .tclshrc when the name of a script file is presented on the tclsh command line, but the script file can always source it if desired. If you create a Tcl script in a file whose first line is #!/usr/local/bin/tclsh then you can invoke the script file directly from your shell if you mark the file as executable. This assumes that tclsh has been installed in the default location in /usr/local/bin; if it is installed somewhere else then you will have to modify the above line to match. Many UNIX systems do not allow the #! line to exceed about 30 characters in length, so be sure that the tclsh executable can be accessed with a short file name. An even better approach is to start your script files with the following three lines: #!/bin/sh # the next line restarts using tclsh \\ exec tclsh \\\"\\$0\\\" \\${1+\\\"\\$@\\\"} This approach has three advantages over the approach in the previous paragraph. First, the location of the tclsh binary does not have to be hard-wired into the script: it can be anywhere in your shell search path. Second, it gets around the 30-character file name limit in the previous approach. Third, this approach will work even if tclsh is itself a shell script (this is done on some systems in order to handle multiple architectures or operating systems: the tclsh script selects one of several binaries to run). The three lines cause both sh and tclsh to process the script, but the exec is only executed by sh . sh processes the script first; it treats the second line as a comment and executes the third line. The exec statement cause the shell to stop processing and instead to start up tclsh to reprocess the entire script. When tclsh starts up, it treats all three lines as comments, since the backslash at the end of the second line causes the third line to be treated as part of the comment on the second line. You should note that it is also common practice to install tclsh with its version number as part of the name. This has the advantage of allowing multiple versions of Tcl to exist on the same system at once, but also the disadvantage of making it harder to write scripts that start up uniformly across different versions of Tcl. VARIABLES Tclsh sets the following global Tcl variables in addition to those created by the Tcl library itself (such as env , which maps environment variables such as PATH into Tcl): argc : Contains a count of the number of arg arguments (0 if none), not including the name of the script file. argv : Contains a Tcl list whose elements are the arg arguments, in order, or an empty string if there are no arg arguments. argv0 : Contains fileName if it was specified. Otherwise, contains the name by which tclsh was invoked. tcl_interactive : Contains 1 if tclsh is running interactively (no fileName was specified and standard input is a terminal-like device), 0 otherwise. PROMPTS When tclsh is invoked interactively it normally prompts for each command with You can change the prompt by setting the global variables tcl_prompt1 and tcl_prompt2 . If variable tcl_prompt1 exists then it must consist of a Tcl script to output a prompt; instead of outputting a prompt tclsh will evaluate the script in tcl_prompt1 . The variable tcl_prompt2 is used in a similar way when a newline is typed but the current command is not yet complete; if tcl_prompt2 is not set then no prompt is output for incomplete commands. STANDARD CHANNELS See Tcl_StandardChannels for more explanations. ZIPVFS When a zipfile is concatenated to the end of a tclsh , on startup the contents of the zip archive will be mounted as the virtual file system /zvfs. If a top level directory tcl8.6 is present in the zip archive, it will become the directory loaded as env(TCL_LIBRARY). If a file named main.tcl is present in the top level directory of the zip archive, it will be sourced instead of the shell\\'s normal command line handing. SEE ALSO auto_path(n), encoding(n), env(n), fconfigure(n) KEYWORDS application, argument, interpreter, prompt, script file, shell","title":"NAME"},{"location":"tclsh/#name","text":"tclsh - Simple shell containing Tcl interpreter","title":"NAME"},{"location":"tclsh/#synopsis","text":"tclsh ? -encoding name ? ? fileName arg arg ... ?","title":"SYNOPSIS"},{"location":"tclsh/#description","text":"Tclsh is a shell-like application that reads Tcl commands from its standard input or from a file and evaluates them. If invoked with no arguments then it runs interactively, reading Tcl commands from standard input and printing command results and error messages to standard output. It runs until the exit command is invoked or until it reaches end-of-file on its standard input. If there exists a file .tclshrc (or tclshrc.tcl on the Windows platforms) in the home directory of the user, interactive tclsh evaluates the file as a Tcl script just before reading the first command from standard input.","title":"DESCRIPTION"},{"location":"tclsh/#script-files","text":"If tclsh is invoked with arguments then the first few arguments specify the name of a script file, and, optionally, the encoding of the text data stored in that script file. Any additional arguments are made available to the script as variables (see below). Instead of reading commands from standard input tclsh will read Tcl commands from the named file; tclsh will exit when it reaches the end of the file. The end of the file may be marked either by the physical end of the medium, or by the character, If this character is present in the file, the tclsh application will read text up to but not including the character. An application that requires this character in the file may safely encode it as or may generate it by use of commands such as format or binary . There is no automatic evaluation of .tclshrc when the name of a script file is presented on the tclsh command line, but the script file can always source it if desired. If you create a Tcl script in a file whose first line is #!/usr/local/bin/tclsh then you can invoke the script file directly from your shell if you mark the file as executable. This assumes that tclsh has been installed in the default location in /usr/local/bin; if it is installed somewhere else then you will have to modify the above line to match. Many UNIX systems do not allow the #! line to exceed about 30 characters in length, so be sure that the tclsh executable can be accessed with a short file name. An even better approach is to start your script files with the following three lines: #!/bin/sh # the next line restarts using tclsh \\ exec tclsh \\\"\\$0\\\" \\${1+\\\"\\$@\\\"} This approach has three advantages over the approach in the previous paragraph. First, the location of the tclsh binary does not have to be hard-wired into the script: it can be anywhere in your shell search path. Second, it gets around the 30-character file name limit in the previous approach. Third, this approach will work even if tclsh is itself a shell script (this is done on some systems in order to handle multiple architectures or operating systems: the tclsh script selects one of several binaries to run). The three lines cause both sh and tclsh to process the script, but the exec is only executed by sh . sh processes the script first; it treats the second line as a comment and executes the third line. The exec statement cause the shell to stop processing and instead to start up tclsh to reprocess the entire script. When tclsh starts up, it treats all three lines as comments, since the backslash at the end of the second line causes the third line to be treated as part of the comment on the second line. You should note that it is also common practice to install tclsh with its version number as part of the name. This has the advantage of allowing multiple versions of Tcl to exist on the same system at once, but also the disadvantage of making it harder to write scripts that start up uniformly across different versions of Tcl.","title":"SCRIPT FILES"},{"location":"tclsh/#variables","text":"Tclsh sets the following global Tcl variables in addition to those created by the Tcl library itself (such as env , which maps environment variables such as PATH into Tcl): argc : Contains a count of the number of arg arguments (0 if none), not including the name of the script file. argv : Contains a Tcl list whose elements are the arg arguments, in order, or an empty string if there are no arg arguments. argv0 : Contains fileName if it was specified. Otherwise, contains the name by which tclsh was invoked. tcl_interactive : Contains 1 if tclsh is running interactively (no fileName was specified and standard input is a terminal-like device), 0 otherwise.","title":"VARIABLES"},{"location":"tclsh/#prompts","text":"When tclsh is invoked interactively it normally prompts for each command with You can change the prompt by setting the global variables tcl_prompt1 and tcl_prompt2 . If variable tcl_prompt1 exists then it must consist of a Tcl script to output a prompt; instead of outputting a prompt tclsh will evaluate the script in tcl_prompt1 . The variable tcl_prompt2 is used in a similar way when a newline is typed but the current command is not yet complete; if tcl_prompt2 is not set then no prompt is output for incomplete commands.","title":"PROMPTS"},{"location":"tclsh/#standard-channels","text":"See Tcl_StandardChannels for more explanations.","title":"STANDARD CHANNELS"},{"location":"tclsh/#zipvfs","text":"When a zipfile is concatenated to the end of a tclsh , on startup the contents of the zip archive will be mounted as the virtual file system /zvfs. If a top level directory tcl8.6 is present in the zip archive, it will become the directory loaded as env(TCL_LIBRARY). If a file named main.tcl is present in the top level directory of the zip archive, it will be sourced instead of the shell\\'s normal command line handing.","title":"ZIPVFS"},{"location":"tclsh/#see-also","text":"auto_path(n), encoding(n), env(n), fconfigure(n)","title":"SEE ALSO"},{"location":"tclsh/#keywords","text":"application, argument, interpreter, prompt, script file, shell","title":"KEYWORDS"},{"location":"tcltest/","text":"NAME tcltest - Test harness support code and utilities SYNOPSIS package require tcltest ?2.5? tcltest::test name description ?-option value ...? tcltest::test name description ?constraints? body result tcltest::loadTestedCommands tcltest::makeDirectory name ?directory? tcltest::removeDirectory name ?directory? tcltest::makeFile contents name ?directory? tcltest::removeFile name ?directory? tcltest::viewFile name ?directory? tcltest::cleanupTests ?runningMultipleTests? tcltest::runAllTests tcltest::configure tcltest::configure -option tcltest::configure -option value ?-option value ...? tcltest::customMatch mode command tcltest::testConstraint constraint ?value? tcltest::outputChannel ?channelID? tcltest::errorChannel ?channelID? tcltest::interpreter ?interp? tcltest::debug ?level? tcltest::errorFile ?filename? tcltest::limitConstraints ?boolean? tcltest::loadFile ?filename? tcltest::loadScript ?script? tcltest::match ?patternList? tcltest::matchDirectories ?patternList? tcltest::matchFiles ?patternList? tcltest::outputFile ?filename? tcltest::preserveCore ?level? tcltest::singleProcess ?boolean? tcltest::skip ?patternList? tcltest::skipDirectories ?patternList? tcltest::skipFiles ?patternList? tcltest::temporaryDirectory ?directory? tcltest::testsDirectory ?directory? tcltest::verbose ?level? tcltest::test name description optionList tcltest::bytestring string tcltest::normalizeMsg msg tcltest::normalizePath pathVar tcltest::workingDirectory ?dir? DESCRIPTION The tcltest package provides several utility commands useful in the construction of test suites for code instrumented to be run by evaluation of Tcl commands. Notably the built-in commands of the Tcl library itself are tested by a test suite using the tcltest package. All the commands provided by the tcltest package are defined in and exported from the ::tcltest namespace, as indicated in the SYNOPSIS above. In the following sections, all commands will be described by their simple names, in the interest of brevity. The central command of tcltest is test that defines and runs a test. Testing with test involves evaluation of a Tcl script and comparing the result to an expected result, as configured and controlled by a number of options. Several other commands provided by tcltest govern the configuration of test and the collection of many test commands into test suites. See CREATING TEST SUITES WITH TCLTEST below for an extended example of how to use the commands of tcltest to produce test suites for your Tcl-enabled code. COMMANDS test name description ? -option value ... ? : Defines and possibly runs a test with the name name and description description . The name and description of a test are used in messages reported by test during the test, as configured by the options of tcltest . The remaining option value arguments to test define the test, including the scripts to run, the conditions under which to run them, the expected result, and the means by which the expected and actual results should be compared. See TESTS below for a complete description of the valid options and how they define a test. The test command returns an empty string. test name description ? constraints ? body result : This form of test is provided to support test suites written for version 1 of the tcltest package, and also a simpler interface for a common usage. It is the same as All other options to test take their default values. When constraints is omitted, this form of test can be distinguished from the first because all option s begin with loadTestedCommands : Evaluates in the caller\\'s context the script specified by configure -load or configure -loadfile . Returns the result of that script evaluation, including any error raised by the script. Use this command and the related configuration options to provide the commands to be tested to the interpreter running the test suite. makeFile contents name ? directory ? : Creates a file named name relative to directory directory and write contents to that file using the encoding encoding system . If contents does not end with a newline, a newline will be appended so that the file named name does end with a newline. Because the system encoding is used, this command is only suitable for making text files. The file will be removed by the next evaluation of cleanupTests , unless it is removed by removeFile first. The default value of directory is the directory configure -tmpdir . Returns the full path of the file created. Use this command to create any text file required by a test with contents as needed. removeFile name ? directory ? : Forces the file referenced by name to be removed. This file name should be relative to directory . The default value of directory is the directory configure -tmpdir . Returns an empty string. Use this command to delete files created by makeFile . makeDirectory name ? directory ? : Creates a directory named name relative to directory directory . The directory will be removed by the next evaluation of cleanupTests , unless it is removed by removeDirectory first. The default value of directory is the directory configure -tmpdir . Returns the full path of the directory created. Use this command to create any directories that are required to exist by a test. removeDirectory name ? directory ? : Forces the directory referenced by name to be removed. This directory should be relative to directory . The default value of directory is the directory configure -tmpdir . Returns an empty string. Use this command to delete any directories created by makeDirectory . viewFile file ? directory ? : Returns the contents of file , except for any final newline, just as read -nonewline would return. This file name should be relative to directory . The default value of directory is the directory configure -tmpdir . Use this command as a convenient way to turn the contents of a file generated by a test into the result of that test for matching against an expected result. The contents of the file are read using the system encoding, so its usefulness is limited to text files. cleanupTests : Intended to clean up and summarize after several tests have been run. Typically called once per test file, at the end of the file after all tests have been completed. For best effectiveness, be sure that the cleanupTests is evaluated even if an error occurs earlier in the test file evaluation. Prints statistics about the tests run and removes files that were created by **makeDirectory** and **makeFile** since the last **cleanupTests**. Names of files and directories in the directory **configure -tmpdir** created since the last **cleanupTests**, but not created by **makeFile** or **makeDirectory** are printed to **outputChannel**. This command also restores the original shell environment, as described by the global **env** array. Returns an empty string. runAllTests : This is a main command meant to run an entire suite of tests, spanning multiple files and/or directories, as governed by the configurable options of tcltest . See RUNNING ALL TESTS below for a complete description of the many variations possible with runAllTests . CONFIGURATION COMMANDS configure : Returns the list of configurable options supported by tcltest . See CONFIGURABLE OPTIONS below for the full list of options, their valid values, and their effect on tcltest operations. configure option : Returns the current value of the supported configurable option option . Raises an error if option is not a supported configurable option. configure option value ? -option value ... ? : Sets the value of each configurable option option to the corresponding value value , in order. Raises an error if an option is not a supported configurable option, or if value is not a valid value for the corresponding option , or if a value is not provided. When an error is raised, the operation of configure is halted, and subsequent option value arguments are not processed. If the environment variable **::env(TCLTEST_OPTIONS)** exists when the **tcltest** package is loaded (by **package require** **tcltest**) then its value is taken as a list of arguments to pass to **configure**. This allows the default values of the configuration options to be set by the environment. customMatch mode script : Registers mode as a new legal value of the -match option to test . When the -match mode option is passed to test , the script script will be evaluated to compare the actual result of evaluating the body of the test to the expected result. To perform the match, the script is completed with two additional words, the expected result, and the actual result, and the completed script is evaluated in the global namespace. The completed script is expected to return a boolean value indicating whether or not the results match. The built-in matching modes of test are exact , glob , and regexp . testConstraint constraint ? boolean ? : Sets or returns the boolean value associated with the named constraint . See TEST CONSTRAINTS below for more information. interpreter ? executableName ? : Sets or returns the name of the executable to be exec ed by runAllTests to run each test file when configure -singleproc is false. The default value for interpreter is the name of the currently running program as returned by info nameofexecutable . outputChannel ? channelID ? : Sets or returns the output channel ID. This defaults to stdout . Any test that prints test related output should send that output to outputChannel rather than letting that output default to stdout . errorChannel ? channelID ? : Sets or returns the error channel ID. This defaults to stderr . Any test that prints error messages should send that output to errorChannel rather than printing directly to stderr . SHORTCUT CONFIGURATION COMMANDS debug ? level ? : Same as <!-- --> errorFile ? filename ? : Same as <!-- --> limitConstraints ? boolean ? : Same as <!-- --> loadFile ? filename ? : Same as <!-- --> loadScript ? script ? : Same as <!-- --> match ? patternList ? : Same as <!-- --> matchDirectories ? patternList ? : Same as <!-- --> matchFiles ? patternList ? : Same as <!-- --> outputFile ? filename ? : Same as <!-- --> preserveCore ? level ? : Same as <!-- --> singleProcess ? boolean ? : Same as <!-- --> skip ? patternList ? : Same as <!-- --> skipDirectories ? patternList ? : Same as <!-- --> skipFiles ? patternList ? : Same as <!-- --> temporaryDirectory ? directory ? : Same as <!-- --> testsDirectory ? directory ? : Same as <!-- --> verbose ? level ? : Same as OTHER COMMANDS The remaining commands provided by tcltest have better alternatives provided by tcltest or Tcl itself. They are retained to support existing test suites, but should be avoided in new code. test name description optionList : This form of test was provided to enable passing many options spanning several lines to test as a single argument quoted by braces, rather than needing to backslash quote the newlines between arguments to test . The optionList argument is expected to be a list with an even number of elements representing option and value arguments to pass to test . However, these values are not passed directly, as in the alternate forms of switch . Instead, this form makes an unfortunate attempt to overthrow Tcl\\'s substitution rules by performing substitutions on some of the list elements as an attempt to implement a interpretation of a brace-enclosed The result is nearly impossible to document clearly, and for that reason this form is not recommended. See the examples in CREATING TEST SUITES WITH TCLTEST below to see that this form is really not necessary to avoid backslash-quoted newlines. If you insist on using this form, examine the source code of tcltest if you want to know the substitution details, or just enclose the third through last argument to test in braces and hope for the best. workingDirectory ? directoryName ? : Sets or returns the current working directory when the test suite is running. The default value for workingDirectory is the directory in which the test suite was launched. The Tcl commands cd and pwd are sufficient replacements. normalizeMsg msg : Returns the result of removing the newlines from msg , where is rather imprecise. Tcl offers plenty of string processing commands to modify strings as you wish, and customMatch allows flexible matching of actual and expected results. normalizePath pathVar : Resolves symlinks in a path, thus creating a path without internal redirection. It is assumed that pathVar is absolute. pathVar is modified in place. The Tcl command file normalize is a sufficient replacement. bytestring string : Construct a string that consists of the requested sequence of bytes, as opposed to a string of properly formed UTF-8 characters using the value supplied in string . This allows the tester to create denormalized or improperly formed strings to pass to C procedures that are supposed to accept strings with embedded NULL types and confirm that a string result has a certain pattern of bytes. This is exactly equivalent to the Tcl command encoding convertfrom identity . TESTS The test command is the heart of the tcltest package. Its essential function is to evaluate a Tcl script and compare the result with an expected result. The options of test define the test script, the environment in which to evaluate it, the expected result, and how the compare the actual result to the expected result. Some configuration options of tcltest also influence how test operates. The valid options for test are summarized: test name description ? -constraints keywordList|expression ? ? -setup setupScript ? ? -body testScript ? ? -cleanup cleanupScript ? ? -result expectedAnswer ? ? -output expectedOutput ? ? -errorOutput expectedError ? ? -returnCodes codeList ? ? -errorCode expectedErrorCode ? ? -match mode ? The name may be any string. It is conventional to choose a name according to the pattern: target - majorNum . minorNum For white-box (regression) tests, the target should be the name of the C function or Tcl procedure being tested. For black-box tests, the target should be the name of the feature being tested. Some conventions call for the names of black-box tests to have the suffix _bb . Related tests should share a major number. As a test suite evolves, it is best to have the same test name continue to correspond to the same test, so that it remains meaningful to say things like During evaluation of test , the name will be compared to the lists of string matching patterns returned by configure -match , and configure -skip . The test will be run only if name matches any of the patterns from configure -match and matches none of the patterns from configure -skip . The description should be a short textual description of the test. The description is included in output produced by the test, typically test failure messages. Good description values should briefly explain the purpose of the test to users of a test suite. The name of a Tcl or C function being tested should be included in the description for regression tests. If the test case exists to reproduce a bug, include the bug ID in the description. Valid attributes and associated values are: -constraints keywordList | expression : The optional -constraints attribute can be list of one or more keywords or an expression. If the -constraints value is a list of keywords, each of these keywords should be the name of a constraint defined by a call to testConstraint . If any of the listed constraints is false or does not exist, the test is skipped. If the -constraints value is an expression, that expression is evaluated. If the expression evaluates to true, then the test is run. Note that the expression form of -constraints may interfere with the operation of configure -constraints and configure -limitconstraints , and is not recommended. Appropriate constraints should be added to any tests that should not always be run. That is, conditional evaluation of a test should be accomplished by the -constraints option, not by conditional evaluation of test . In that way, the same number of tests are always reported by the test suite, though the number skipped may change based on the testing environment. The default value is an empty list. See TEST CONSTRAINTS below for a list of built-in constraints and information on how to add your own constraints. -setup script : The optional -setup attribute indicates a script that will be run before the script indicated by the -body attribute. If evaluation of script raises an error, the test will fail. The default value is an empty script. -body script : The -body attribute indicates the script to run to carry out the test, which must return a result that can be checked for correctness. If evaluation of script raises an error, the test will fail (unless the -returnCodes option is used to state that an error is expected). The default value is an empty script. -cleanup script : The optional -cleanup attribute indicates a script that will be run after the script indicated by the -body attribute. If evaluation of script raises an error, the test will fail. The default value is an empty script. -match mode : The -match attribute determines how expected answers supplied by -result , -output , and -errorOutput are compared. Valid values for mode are regexp , glob , exact , and any value registered by a prior call to customMatch . The default value is exact . -result expectedValue : The -result attribute supplies the expectedValue against which the return value from script will be compared. The default value is an empty string. -output expectedValue : The -output attribute supplies the expectedValue against which any output sent to stdout or outputChannel during evaluation of the script(s) will be compared. Note that only output printed using the global puts command is used for comparison. If -output is not specified, output sent to stdout and outputChannel is not processed for comparison. -errorOutput expectedValue : The -errorOutput attribute supplies the expectedValue against which any output sent to stderr or errorChannel during evaluation of the script(s) will be compared. Note that only output printed using the global puts command is used for comparison. If -errorOutput is not specified, output sent to stderr and errorChannel is not processed for comparison. -returnCodes expectedCodeList : The optional -returnCodes attribute supplies expectedCodeList , a list of return codes that may be accepted from evaluation of the -body script. If evaluation of the -body script returns a code not in the expectedCodeList , the test fails. All return codes known to return , in both numeric and symbolic form, including extended return codes, are acceptable elements in the expectedCodeList . Default value is <!-- --> -errorCode expectedErrorCode : The optional -errorCode attribute supplies expectedErrorCode , a glob pattern that should match the error code reported from evaluation of the -body script. If evaluation of the -body script returns a code not matching expectedErrorCode , the test fails. Default value is If -returnCodes does not include error it is set to error . To pass, a test must successfully evaluate its -setup , -body , and -cleanup scripts. The return code of the -body script and its result must match expected values, and if specified, output and error data from the test must match expected -output and -errorOutput values. If any of these conditions are not met, then the test fails. Note that all scripts are evaluated in the context of the caller of test . As long as test is called with valid syntax and legal values for all attributes, it will not raise an error. Test failures are instead reported as output written to outputChannel . In default operation, a successful test produces no output. The output messages produced by test are controlled by the configure -verbose option as described in CONFIGURABLE OPTIONS below. Any output produced by the test scripts themselves should be produced using puts to outputChannel or errorChannel , so that users of the test suite may easily capture output with the configure -outfile and configure -errfile options, and so that the -output and -errorOutput attributes work properly. TEST CONSTRAINTS Constraints are used to determine whether or not a test should be skipped. Each constraint has a name, which may be any string, and a boolean value. Each test has a -constraints value which is a list of constraint names. There are two modes of constraint control. Most frequently, the default mode is used, indicated by a setting of configure -limitconstraints to false. The test will run only if all constraints in the list are true-valued. Thus, the -constraints option of test is a convenient, symbolic way to define any conditions required for the test to be possible or meaningful. For example, a test with -constraints unix will only be run if the constraint unix is true, which indicates the test suite is being run on a Unix platform. Each test should include whatever -constraints are required to constrain it to run only where appropriate. Several constraints are predefined in the tcltest package, listed below. The registration of user-defined constraints is performed by the testConstraint command. User-defined constraints may appear within a test file, or within the script specified by the configure -load or configure -loadfile options. The following is a list of constraints predefined by the tcltest package itself: singleTestInterp : This test can only be run if all test files are sourced into a single interpreter. unix : This test can only be run on any Unix platform. win : This test can only be run on any Windows platform. nt : This test can only be run on any Windows NT platform. mac : This test can only be run on any Mac platform. unixOrWin : This test can only be run on a Unix or Windows platform. macOrWin : This test can only be run on a Mac or Windows platform. macOrUnix : This test can only be run on a Mac or Unix platform. tempNotWin : This test can not be run on Windows. This flag is used to temporarily disable a test. tempNotMac : This test can not be run on a Mac. This flag is used to temporarily disable a test. unixCrash : This test crashes if it is run on Unix. This flag is used to temporarily disable a test. winCrash : This test crashes if it is run on Windows. This flag is used to temporarily disable a test. macCrash : This test crashes if it is run on a Mac. This flag is used to temporarily disable a test. emptyTest : This test is empty, and so not worth running, but it remains as a place-holder for a test to be written in the future. This constraint has value false to cause tests to be skipped unless the user specifies otherwise. knownBug : This test is known to fail and the bug is not yet fixed. This constraint has value false to cause tests to be skipped unless the user specifies otherwise. nonPortable : This test can only be run in some known development environment. Some tests are inherently non-portable because they depend on things like word length, file system configuration, window manager, etc. This constraint has value false to cause tests to be skipped unless the user specifies otherwise. userInteraction : This test requires interaction from the user. This constraint has value false to causes tests to be skipped unless the user specifies otherwise. interactive : This test can only be run in if the interpreter is in interactive mode (when the global tcl_interactive variable is set to 1). nonBlockFiles : This test can only be run if platform supports setting files into nonblocking mode. asyncPipeClose : This test can only be run if platform supports async flush and async close on a pipe. unixExecs : This test can only be run if this machine has Unix-style commands cat , echo , sh , wc , rm , sleep , fgrep , ps , chmod , and mkdir available. hasIsoLocale : This test can only be run if can switch to an ISO locale. root : This test can only run if Unix user is root. notRoot : This test can only run if Unix user is not root. eformat : This test can only run if app has a working version of sprintf with respect to the format of floating-point numbers. stdio : This test can only be run if interpreter can be open ed as a pipe. The alternative mode of constraint control is enabled by setting configure -limitconstraints to true. With that configuration setting, all existing constraints other than those in the constraint list returned by configure -constraints are set to false. When the value of configure -constraints is set, all those constraints are set to true. The effect is that when both options configure -constraints and configure -limitconstraints are in use, only those tests including only constraints from the configure -constraints list are run; all others are skipped. For example, one might set up a configuration with configure -constraints knownBug \\ -limitconstraints true \\ -verbose pass to run exactly those tests that exercise known bugs, and discover whether any of them pass, indicating the bug had been fixed. RUNNING ALL TESTS The single command runAllTests is evaluated to run an entire test suite, spanning many files and directories. The configuration options of tcltest control the precise operations. The runAllTests command begins by printing a summary of its configuration to outputChannel . Test files to be evaluated are sought in the directory configure -testdir . The list of files in that directory that match any of the patterns in configure -file and match none of the patterns in configure -notfile is generated and sorted. Then each file will be evaluated in turn. If configure -singleproc is true, then each file will be source d in the caller\\'s context. If it is false, then a copy of interpreter will be exec \\'d to evaluate each file. The multi-process operation is useful when testing can cause errors so severe that a process terminates. Although such an error may terminate a child process evaluating one file, the main process can continue with the rest of the test suite. In multi-process operation, the configuration of tcltest in the main process is passed to the child processes as command line arguments, with the exception of configure -outfile . The runAllTests command in the main process collects all output from the child processes and collates their results into one main report. Any reports of individual test failures, or messages requested by a configure -verbose setting are passed directly on to outputChannel by the main process. After evaluating all selected test files, a summary of the results is printed to outputChannel . The summary includes the total number of test s evaluated, broken down into those skipped, those passed, and those failed. The summary also notes the number of files evaluated, and the names of any files with failing tests or errors. A list of the constraints that caused tests to be skipped, and the number of tests skipped for each is also printed. Also, messages are printed if it appears that evaluation of a test file has caused any temporary files to be left behind in configure -tmpdir . Having completed and summarized all selected test files, runAllTests then recursively acts on subdirectories of configure -testdir . All subdirectories that match any of the patterns in configure -relateddir and do not match any of the patterns in configure -asidefromdir are examined. If a file named all.tcl is found in such a directory, it will be source d in the caller\\'s context. Whether or not an examined directory contains an all.tcl file, its subdirectories are also scanned against the configure -relateddir and configure -asidefromdir patterns. In this way, many directories in a directory tree can have all their test files evaluated by a single runAllTests command. CONFIGURABLE OPTIONS The configure command is used to set and query the configurable options of tcltest . The valid options are: -singleproc boolean : Controls whether or not runAllTests spawns a child process for each test file. No spawning when boolean is true. Default value is false. -debug level : Sets the debug level to level , an integer value indicating how much debugging information should be printed to stdout . Note that debug messages always go to stdout , independent of the value of configure -outfile . Default value is 0. Levels are defined as: 0. Do not display any debug information. 1. Display information regarding whether a test is skipped because it does not match any of the tests that were specified using by **configure -match** (userSpecifiedNonMatch) or matches any of the tests specified by **configure -skip** (userSpecifiedSkip). Also print warnings about possible lack of cleanup or balance in test files. Also print warnings about any re-use of test names. 2. Display the flag array parsed by the command line processor, the contents of the global **env** array, and all user-defined variables that exist in the current namespace as they are used. 3. Display information regarding what individual procs in the test harness are doing. -verbose level : Sets the type of output verbosity desired to level , a list of zero or more of the elements body , pass , skip , start , error , line , msec and usec . Default value is Levels are defined as: body (b) : Display the body of failed tests pass (p) : Print output when a test passes skip (s) : Print output when a test is skipped start (t) : Print output whenever a test starts error (e) : Print errorInfo and errorCode, if they exist, when a test return code does not match its expected return code line (l) : Print source file line information of failed tests msec (m) : Print each test\\'s execution time in milliseconds usec (u) : Print each test\\'s execution time in microseconds Note that the msec and usec verbosity levels are provided as indicative measures only. They do not tackle the problem of repeatibility which should be considered in performance tests or benchmarks. To use these verbosity levels to thoroughly track performance degradations, consider wrapping your test bodies with time commands. The single letter abbreviations noted above are also recognized so that is the same as -preservecore level : Sets the core preservation level to level . This level determines how stringent checks for core files are. Default value is 0. Levels are defined as: 0. No checking --- do not check for core files at the end of each test command, but do check for them in **runAllTests** after all test files have been evaluated. 1. Also check for core files at the end of each **test** command. 2. Check for core files at all times described above, and save a copy of each core file produced in **configure -tmpdir**. -limitconstraints boolean : Sets the mode by which test honors constraints as described in TESTS above. Default value is false. -constraints list : Sets all the constraints in list to true. Also used in combination with configure -limitconstraints true to control an alternative constraint mode as described in TESTS above. Default value is an empty list. -tmpdir directory : Sets the temporary directory to be used by makeFile , makeDirectory , viewFile , removeFile , and removeDirectory as the default directory where temporary files and directories created by test files should be created. Default value is workingDirectory . -testdir directory : Sets the directory searched by runAllTests for test files and subdirectories. Default value is workingDirectory . -file patternList : Sets the list of patterns used by runAllTests to determine what test files to evaluate. Default value is <!-- --> -notfile patternList : Sets the list of patterns used by runAllTests to determine what test files to skip. Default value is so that any SCCS lock files are skipped. -relateddir patternList : Sets the list of patterns used by runAllTests to determine what subdirectories to search for an all.tcl file. Default value is <!-- --> -asidefromdir patternList : Sets the list of patterns used by runAllTests to determine what subdirectories to skip when searching for an all.tcl file. Default value is an empty list. -match patternList : Set the list of patterns used by test to determine whether a test should be run. Default value is <!-- --> -skip patternList : Set the list of patterns used by test to determine whether a test should be skipped. Default value is an empty list. -load script : Sets a script to be evaluated by loadTestedCommands . Default value is an empty script. -loadfile filename : Sets the filename from which to read a script to be evaluated by loadTestedCommands . This is an alternative to -load . They cannot be used together. -outfile filename : Sets the file to which all output produced by tcltest should be written. A file named filename will be open ed for writing, and the resulting channel will be set as the value of outputChannel . -errfile filename : Sets the file to which all error output produced by tcltest should be written. A file named filename will be open ed for writing, and the resulting channel will be set as the value of errorChannel . CREATING TEST SUITES WITH TCLTEST The fundamental element of a test suite is the individual test command. We begin with several examples. [1] : Test of a script that returns normally. **test** example-1.0 {normal return} { format %s value } value [2] : Test of a script that requires context setup and cleanup. Note the bracing and indenting style that avoids any need for line continuation. **test** example-1.1 {test file existence} -setup { set file \\[makeFile {} test\\] } -body { file exists \\$file } -cleanup { removeFile test } -result 1 [3] : Test of a script that raises an error. **test** example-1.2 {error return} -body { error message } -returnCodes error -result message [4] : Test with a constraint. **test** example-1.3 {user owns created files} -constraints { unix } -setup { set file \\[makeFile {} test\\] } -body { file attributes \\$file -owner } -cleanup { removeFile test } -result \\$::tcl_platform(user) At the next higher layer of organization, several test commands are gathered together into a single test file. Test files should have names with the extension, because that is the default pattern used by runAllTests to find test files. It is a good rule of thumb to have one test file for each source code file of your project. It is good practice to edit the test file and the source code file together, keeping tests synchronized with code changes. Most of the code in the test file should be the test commands. Use constraints to skip tests, rather than conditional evaluation of test . [5] : Recommended system for writing conditional tests, using constraints to guard: **testConstraint** X \\[expr \\$myRequirement\\] **test** goodConditionalTest {} X { \\# body } result [6] : Discouraged system for writing conditional tests, using if to guard: if \\$myRequirement { **test** badConditionalTest {} { #body } result } Use the -setup and -cleanup options to establish and release all context requirements of the test body. Do not make tests depend on prior tests in the file. Those prior tests might be skipped. If several consecutive tests require the same context, the appropriate setup and cleanup scripts may be stored in variable for passing to each tests -setup and -cleanup options. This is a better solution than performing setup outside of test commands, because the setup will only be done if necessary, and any errors during setup will be reported, and not cause the test file to abort. A test file should be able to be combined with other test files and not interfere with them, even when configure -singleproc 1 causes all files to be evaluated in a common interpreter. A simple way to achieve this is to have your tests define all their commands and variables in a namespace that is deleted when the test file evaluation is complete. A good namespace to use is a child namespace test of the namespace of the module you are testing. A test file should also be able to be evaluated directly as a script, not depending on being called by a main runAllTests . This means that each test file should process command line arguments to give the tester all the configuration control that tcltest provides. After all test s in a test file, the command cleanupTests should be called. [7] : Here is a sketch of a sample test file illustrating those points: package require tcltest 2.5 eval **::tcltest::configure** \\$argv package require example namespace eval ::example::test { namespace import ::tcltest::\\* **testConstraint** X \\[expr {\\...}\\] variable SETUP {#common setup code} variable CLEANUP {#common cleanup code} **test** example-1 {} -setup \\$SETUP -body { \\# First test } -cleanup \\$CLEANUP -result {\\...} **test** example-2 {} -constraints X -setup \\$SETUP -body { \\# Second test; constrained } -cleanup \\$CLEANUP -result {\\...} **test** example-3 {} { \\# Third test; no context required } {\\...} **cleanupTests** } namespace delete ::example::test The next level of organization is a full test suite, made up of several test files. One script is used to control the entire suite. The basic function of this script is to call runAllTests after doing any necessary setup. This script is usually named all.tcl because that is the default name used by runAllTests when combining multiple test suites into one testing run. [8] : Here is a sketch of a sample test suite main script: package require tcltest 2.5 package require example **::tcltest::configure** -testdir \\\\ \\[file dirname \\[file normalize \\[info script\\]\\]\\] eval **::tcltest::configure** \\$argv **::tcltest::runAllTests** COMPATIBILITY A number of commands and variables in the ::tcltest namespace provided by earlier releases of tcltest have not been documented here. They are no longer part of the supported public interface of tcltest and should not be used in new test suites. However, to continue to support existing test suites written to the older interface specifications, many of those deprecated commands and variables still work as before. For example, in many circumstances, configure will be automatically called shortly after package require tcltest 2.1 succeeds with arguments from the variable ::argv . This is to support test suites that depend on the old behavior that tcltest was automatically configured from command line arguments. New test files should not depend on this, but should explicitly include eval ::tcltest::configure \\$::argv or ::tcltest::configure {*}\\$::argv to establish a configuration from command line arguments. KNOWN ISSUES There are two known issues related to nested evaluations of test . The first issue relates to the stack level in which test scripts are executed. Tests nested within other tests may be executed at the same stack level as the outermost test. For example, in the following code: test level-1.1 {level 1} { -body { test level-2.1 {level 2} { } } } any script executed in level-2.1 may be executed at the same stack level as the script defined for level-1.1. In addition, while two test s have been run, results will only be reported by cleanupTests for tests at the same level as test level-1.1. However, test results for all tests run prior to level-1.1 will be available when test level-2.1 runs. What this means is that if you try to access the test results for test level-2.1, it will may say that tests have run, tests have been skipped, tests have passed and tests have failed, where and refer to tests that were run at the same test level as test level-1.1. Implementation of output and error comparison in the test command depends on usage of puts in your application code. Output is intercepted by redefining the global puts command while the defined test script is being run. Errors thrown by C procedures or printed directly from C applications will not be caught by the test command. Therefore, usage of the -output and -errorOutput options to test is useful only for pure Tcl applications that use puts to produce output. KEYWORDS test, test harness, test suite","title":"NAME"},{"location":"tcltest/#name","text":"tcltest - Test harness support code and utilities","title":"NAME"},{"location":"tcltest/#synopsis","text":"package require tcltest ?2.5? tcltest::test name description ?-option value ...? tcltest::test name description ?constraints? body result tcltest::loadTestedCommands tcltest::makeDirectory name ?directory? tcltest::removeDirectory name ?directory? tcltest::makeFile contents name ?directory? tcltest::removeFile name ?directory? tcltest::viewFile name ?directory? tcltest::cleanupTests ?runningMultipleTests? tcltest::runAllTests tcltest::configure tcltest::configure -option tcltest::configure -option value ?-option value ...? tcltest::customMatch mode command tcltest::testConstraint constraint ?value? tcltest::outputChannel ?channelID? tcltest::errorChannel ?channelID? tcltest::interpreter ?interp? tcltest::debug ?level? tcltest::errorFile ?filename? tcltest::limitConstraints ?boolean? tcltest::loadFile ?filename? tcltest::loadScript ?script? tcltest::match ?patternList? tcltest::matchDirectories ?patternList? tcltest::matchFiles ?patternList? tcltest::outputFile ?filename? tcltest::preserveCore ?level? tcltest::singleProcess ?boolean? tcltest::skip ?patternList? tcltest::skipDirectories ?patternList? tcltest::skipFiles ?patternList? tcltest::temporaryDirectory ?directory? tcltest::testsDirectory ?directory? tcltest::verbose ?level? tcltest::test name description optionList tcltest::bytestring string tcltest::normalizeMsg msg tcltest::normalizePath pathVar tcltest::workingDirectory ?dir?","title":"SYNOPSIS"},{"location":"tcltest/#description","text":"The tcltest package provides several utility commands useful in the construction of test suites for code instrumented to be run by evaluation of Tcl commands. Notably the built-in commands of the Tcl library itself are tested by a test suite using the tcltest package. All the commands provided by the tcltest package are defined in and exported from the ::tcltest namespace, as indicated in the SYNOPSIS above. In the following sections, all commands will be described by their simple names, in the interest of brevity. The central command of tcltest is test that defines and runs a test. Testing with test involves evaluation of a Tcl script and comparing the result to an expected result, as configured and controlled by a number of options. Several other commands provided by tcltest govern the configuration of test and the collection of many test commands into test suites. See CREATING TEST SUITES WITH TCLTEST below for an extended example of how to use the commands of tcltest to produce test suites for your Tcl-enabled code.","title":"DESCRIPTION"},{"location":"tcltest/#commands","text":"test name description ? -option value ... ? : Defines and possibly runs a test with the name name and description description . The name and description of a test are used in messages reported by test during the test, as configured by the options of tcltest . The remaining option value arguments to test define the test, including the scripts to run, the conditions under which to run them, the expected result, and the means by which the expected and actual results should be compared. See TESTS below for a complete description of the valid options and how they define a test. The test command returns an empty string. test name description ? constraints ? body result : This form of test is provided to support test suites written for version 1 of the tcltest package, and also a simpler interface for a common usage. It is the same as All other options to test take their default values. When constraints is omitted, this form of test can be distinguished from the first because all option s begin with loadTestedCommands : Evaluates in the caller\\'s context the script specified by configure -load or configure -loadfile . Returns the result of that script evaluation, including any error raised by the script. Use this command and the related configuration options to provide the commands to be tested to the interpreter running the test suite. makeFile contents name ? directory ? : Creates a file named name relative to directory directory and write contents to that file using the encoding encoding system . If contents does not end with a newline, a newline will be appended so that the file named name does end with a newline. Because the system encoding is used, this command is only suitable for making text files. The file will be removed by the next evaluation of cleanupTests , unless it is removed by removeFile first. The default value of directory is the directory configure -tmpdir . Returns the full path of the file created. Use this command to create any text file required by a test with contents as needed. removeFile name ? directory ? : Forces the file referenced by name to be removed. This file name should be relative to directory . The default value of directory is the directory configure -tmpdir . Returns an empty string. Use this command to delete files created by makeFile . makeDirectory name ? directory ? : Creates a directory named name relative to directory directory . The directory will be removed by the next evaluation of cleanupTests , unless it is removed by removeDirectory first. The default value of directory is the directory configure -tmpdir . Returns the full path of the directory created. Use this command to create any directories that are required to exist by a test. removeDirectory name ? directory ? : Forces the directory referenced by name to be removed. This directory should be relative to directory . The default value of directory is the directory configure -tmpdir . Returns an empty string. Use this command to delete any directories created by makeDirectory . viewFile file ? directory ? : Returns the contents of file , except for any final newline, just as read -nonewline would return. This file name should be relative to directory . The default value of directory is the directory configure -tmpdir . Use this command as a convenient way to turn the contents of a file generated by a test into the result of that test for matching against an expected result. The contents of the file are read using the system encoding, so its usefulness is limited to text files. cleanupTests : Intended to clean up and summarize after several tests have been run. Typically called once per test file, at the end of the file after all tests have been completed. For best effectiveness, be sure that the cleanupTests is evaluated even if an error occurs earlier in the test file evaluation. Prints statistics about the tests run and removes files that were created by **makeDirectory** and **makeFile** since the last **cleanupTests**. Names of files and directories in the directory **configure -tmpdir** created since the last **cleanupTests**, but not created by **makeFile** or **makeDirectory** are printed to **outputChannel**. This command also restores the original shell environment, as described by the global **env** array. Returns an empty string. runAllTests : This is a main command meant to run an entire suite of tests, spanning multiple files and/or directories, as governed by the configurable options of tcltest . See RUNNING ALL TESTS below for a complete description of the many variations possible with runAllTests .","title":"COMMANDS"},{"location":"tcltest/#configuration-commands","text":"configure : Returns the list of configurable options supported by tcltest . See CONFIGURABLE OPTIONS below for the full list of options, their valid values, and their effect on tcltest operations. configure option : Returns the current value of the supported configurable option option . Raises an error if option is not a supported configurable option. configure option value ? -option value ... ? : Sets the value of each configurable option option to the corresponding value value , in order. Raises an error if an option is not a supported configurable option, or if value is not a valid value for the corresponding option , or if a value is not provided. When an error is raised, the operation of configure is halted, and subsequent option value arguments are not processed. If the environment variable **::env(TCLTEST_OPTIONS)** exists when the **tcltest** package is loaded (by **package require** **tcltest**) then its value is taken as a list of arguments to pass to **configure**. This allows the default values of the configuration options to be set by the environment. customMatch mode script : Registers mode as a new legal value of the -match option to test . When the -match mode option is passed to test , the script script will be evaluated to compare the actual result of evaluating the body of the test to the expected result. To perform the match, the script is completed with two additional words, the expected result, and the actual result, and the completed script is evaluated in the global namespace. The completed script is expected to return a boolean value indicating whether or not the results match. The built-in matching modes of test are exact , glob , and regexp . testConstraint constraint ? boolean ? : Sets or returns the boolean value associated with the named constraint . See TEST CONSTRAINTS below for more information. interpreter ? executableName ? : Sets or returns the name of the executable to be exec ed by runAllTests to run each test file when configure -singleproc is false. The default value for interpreter is the name of the currently running program as returned by info nameofexecutable . outputChannel ? channelID ? : Sets or returns the output channel ID. This defaults to stdout . Any test that prints test related output should send that output to outputChannel rather than letting that output default to stdout . errorChannel ? channelID ? : Sets or returns the error channel ID. This defaults to stderr . Any test that prints error messages should send that output to errorChannel rather than printing directly to stderr .","title":"CONFIGURATION COMMANDS"},{"location":"tcltest/#shortcut-configuration-commands","text":"debug ? level ? : Same as <!-- --> errorFile ? filename ? : Same as <!-- --> limitConstraints ? boolean ? : Same as <!-- --> loadFile ? filename ? : Same as <!-- --> loadScript ? script ? : Same as <!-- --> match ? patternList ? : Same as <!-- --> matchDirectories ? patternList ? : Same as <!-- --> matchFiles ? patternList ? : Same as <!-- --> outputFile ? filename ? : Same as <!-- --> preserveCore ? level ? : Same as <!-- --> singleProcess ? boolean ? : Same as <!-- --> skip ? patternList ? : Same as <!-- --> skipDirectories ? patternList ? : Same as <!-- --> skipFiles ? patternList ? : Same as <!-- --> temporaryDirectory ? directory ? : Same as <!-- --> testsDirectory ? directory ? : Same as <!-- --> verbose ? level ? : Same as","title":"SHORTCUT CONFIGURATION COMMANDS"},{"location":"tcltest/#other-commands","text":"The remaining commands provided by tcltest have better alternatives provided by tcltest or Tcl itself. They are retained to support existing test suites, but should be avoided in new code. test name description optionList : This form of test was provided to enable passing many options spanning several lines to test as a single argument quoted by braces, rather than needing to backslash quote the newlines between arguments to test . The optionList argument is expected to be a list with an even number of elements representing option and value arguments to pass to test . However, these values are not passed directly, as in the alternate forms of switch . Instead, this form makes an unfortunate attempt to overthrow Tcl\\'s substitution rules by performing substitutions on some of the list elements as an attempt to implement a interpretation of a brace-enclosed The result is nearly impossible to document clearly, and for that reason this form is not recommended. See the examples in CREATING TEST SUITES WITH TCLTEST below to see that this form is really not necessary to avoid backslash-quoted newlines. If you insist on using this form, examine the source code of tcltest if you want to know the substitution details, or just enclose the third through last argument to test in braces and hope for the best. workingDirectory ? directoryName ? : Sets or returns the current working directory when the test suite is running. The default value for workingDirectory is the directory in which the test suite was launched. The Tcl commands cd and pwd are sufficient replacements. normalizeMsg msg : Returns the result of removing the newlines from msg , where is rather imprecise. Tcl offers plenty of string processing commands to modify strings as you wish, and customMatch allows flexible matching of actual and expected results. normalizePath pathVar : Resolves symlinks in a path, thus creating a path without internal redirection. It is assumed that pathVar is absolute. pathVar is modified in place. The Tcl command file normalize is a sufficient replacement. bytestring string : Construct a string that consists of the requested sequence of bytes, as opposed to a string of properly formed UTF-8 characters using the value supplied in string . This allows the tester to create denormalized or improperly formed strings to pass to C procedures that are supposed to accept strings with embedded NULL types and confirm that a string result has a certain pattern of bytes. This is exactly equivalent to the Tcl command encoding convertfrom identity .","title":"OTHER COMMANDS"},{"location":"tcltest/#tests","text":"The test command is the heart of the tcltest package. Its essential function is to evaluate a Tcl script and compare the result with an expected result. The options of test define the test script, the environment in which to evaluate it, the expected result, and how the compare the actual result to the expected result. Some configuration options of tcltest also influence how test operates. The valid options for test are summarized: test name description ? -constraints keywordList|expression ? ? -setup setupScript ? ? -body testScript ? ? -cleanup cleanupScript ? ? -result expectedAnswer ? ? -output expectedOutput ? ? -errorOutput expectedError ? ? -returnCodes codeList ? ? -errorCode expectedErrorCode ? ? -match mode ? The name may be any string. It is conventional to choose a name according to the pattern: target - majorNum . minorNum For white-box (regression) tests, the target should be the name of the C function or Tcl procedure being tested. For black-box tests, the target should be the name of the feature being tested. Some conventions call for the names of black-box tests to have the suffix _bb . Related tests should share a major number. As a test suite evolves, it is best to have the same test name continue to correspond to the same test, so that it remains meaningful to say things like During evaluation of test , the name will be compared to the lists of string matching patterns returned by configure -match , and configure -skip . The test will be run only if name matches any of the patterns from configure -match and matches none of the patterns from configure -skip . The description should be a short textual description of the test. The description is included in output produced by the test, typically test failure messages. Good description values should briefly explain the purpose of the test to users of a test suite. The name of a Tcl or C function being tested should be included in the description for regression tests. If the test case exists to reproduce a bug, include the bug ID in the description. Valid attributes and associated values are: -constraints keywordList | expression : The optional -constraints attribute can be list of one or more keywords or an expression. If the -constraints value is a list of keywords, each of these keywords should be the name of a constraint defined by a call to testConstraint . If any of the listed constraints is false or does not exist, the test is skipped. If the -constraints value is an expression, that expression is evaluated. If the expression evaluates to true, then the test is run. Note that the expression form of -constraints may interfere with the operation of configure -constraints and configure -limitconstraints , and is not recommended. Appropriate constraints should be added to any tests that should not always be run. That is, conditional evaluation of a test should be accomplished by the -constraints option, not by conditional evaluation of test . In that way, the same number of tests are always reported by the test suite, though the number skipped may change based on the testing environment. The default value is an empty list. See TEST CONSTRAINTS below for a list of built-in constraints and information on how to add your own constraints. -setup script : The optional -setup attribute indicates a script that will be run before the script indicated by the -body attribute. If evaluation of script raises an error, the test will fail. The default value is an empty script. -body script : The -body attribute indicates the script to run to carry out the test, which must return a result that can be checked for correctness. If evaluation of script raises an error, the test will fail (unless the -returnCodes option is used to state that an error is expected). The default value is an empty script. -cleanup script : The optional -cleanup attribute indicates a script that will be run after the script indicated by the -body attribute. If evaluation of script raises an error, the test will fail. The default value is an empty script. -match mode : The -match attribute determines how expected answers supplied by -result , -output , and -errorOutput are compared. Valid values for mode are regexp , glob , exact , and any value registered by a prior call to customMatch . The default value is exact . -result expectedValue : The -result attribute supplies the expectedValue against which the return value from script will be compared. The default value is an empty string. -output expectedValue : The -output attribute supplies the expectedValue against which any output sent to stdout or outputChannel during evaluation of the script(s) will be compared. Note that only output printed using the global puts command is used for comparison. If -output is not specified, output sent to stdout and outputChannel is not processed for comparison. -errorOutput expectedValue : The -errorOutput attribute supplies the expectedValue against which any output sent to stderr or errorChannel during evaluation of the script(s) will be compared. Note that only output printed using the global puts command is used for comparison. If -errorOutput is not specified, output sent to stderr and errorChannel is not processed for comparison. -returnCodes expectedCodeList : The optional -returnCodes attribute supplies expectedCodeList , a list of return codes that may be accepted from evaluation of the -body script. If evaluation of the -body script returns a code not in the expectedCodeList , the test fails. All return codes known to return , in both numeric and symbolic form, including extended return codes, are acceptable elements in the expectedCodeList . Default value is <!-- --> -errorCode expectedErrorCode : The optional -errorCode attribute supplies expectedErrorCode , a glob pattern that should match the error code reported from evaluation of the -body script. If evaluation of the -body script returns a code not matching expectedErrorCode , the test fails. Default value is If -returnCodes does not include error it is set to error . To pass, a test must successfully evaluate its -setup , -body , and -cleanup scripts. The return code of the -body script and its result must match expected values, and if specified, output and error data from the test must match expected -output and -errorOutput values. If any of these conditions are not met, then the test fails. Note that all scripts are evaluated in the context of the caller of test . As long as test is called with valid syntax and legal values for all attributes, it will not raise an error. Test failures are instead reported as output written to outputChannel . In default operation, a successful test produces no output. The output messages produced by test are controlled by the configure -verbose option as described in CONFIGURABLE OPTIONS below. Any output produced by the test scripts themselves should be produced using puts to outputChannel or errorChannel , so that users of the test suite may easily capture output with the configure -outfile and configure -errfile options, and so that the -output and -errorOutput attributes work properly.","title":"TESTS"},{"location":"tcltest/#test-constraints","text":"Constraints are used to determine whether or not a test should be skipped. Each constraint has a name, which may be any string, and a boolean value. Each test has a -constraints value which is a list of constraint names. There are two modes of constraint control. Most frequently, the default mode is used, indicated by a setting of configure -limitconstraints to false. The test will run only if all constraints in the list are true-valued. Thus, the -constraints option of test is a convenient, symbolic way to define any conditions required for the test to be possible or meaningful. For example, a test with -constraints unix will only be run if the constraint unix is true, which indicates the test suite is being run on a Unix platform. Each test should include whatever -constraints are required to constrain it to run only where appropriate. Several constraints are predefined in the tcltest package, listed below. The registration of user-defined constraints is performed by the testConstraint command. User-defined constraints may appear within a test file, or within the script specified by the configure -load or configure -loadfile options. The following is a list of constraints predefined by the tcltest package itself: singleTestInterp : This test can only be run if all test files are sourced into a single interpreter. unix : This test can only be run on any Unix platform. win : This test can only be run on any Windows platform. nt : This test can only be run on any Windows NT platform. mac : This test can only be run on any Mac platform. unixOrWin : This test can only be run on a Unix or Windows platform. macOrWin : This test can only be run on a Mac or Windows platform. macOrUnix : This test can only be run on a Mac or Unix platform. tempNotWin : This test can not be run on Windows. This flag is used to temporarily disable a test. tempNotMac : This test can not be run on a Mac. This flag is used to temporarily disable a test. unixCrash : This test crashes if it is run on Unix. This flag is used to temporarily disable a test. winCrash : This test crashes if it is run on Windows. This flag is used to temporarily disable a test. macCrash : This test crashes if it is run on a Mac. This flag is used to temporarily disable a test. emptyTest : This test is empty, and so not worth running, but it remains as a place-holder for a test to be written in the future. This constraint has value false to cause tests to be skipped unless the user specifies otherwise. knownBug : This test is known to fail and the bug is not yet fixed. This constraint has value false to cause tests to be skipped unless the user specifies otherwise. nonPortable : This test can only be run in some known development environment. Some tests are inherently non-portable because they depend on things like word length, file system configuration, window manager, etc. This constraint has value false to cause tests to be skipped unless the user specifies otherwise. userInteraction : This test requires interaction from the user. This constraint has value false to causes tests to be skipped unless the user specifies otherwise. interactive : This test can only be run in if the interpreter is in interactive mode (when the global tcl_interactive variable is set to 1). nonBlockFiles : This test can only be run if platform supports setting files into nonblocking mode. asyncPipeClose : This test can only be run if platform supports async flush and async close on a pipe. unixExecs : This test can only be run if this machine has Unix-style commands cat , echo , sh , wc , rm , sleep , fgrep , ps , chmod , and mkdir available. hasIsoLocale : This test can only be run if can switch to an ISO locale. root : This test can only run if Unix user is root. notRoot : This test can only run if Unix user is not root. eformat : This test can only run if app has a working version of sprintf with respect to the format of floating-point numbers. stdio : This test can only be run if interpreter can be open ed as a pipe. The alternative mode of constraint control is enabled by setting configure -limitconstraints to true. With that configuration setting, all existing constraints other than those in the constraint list returned by configure -constraints are set to false. When the value of configure -constraints is set, all those constraints are set to true. The effect is that when both options configure -constraints and configure -limitconstraints are in use, only those tests including only constraints from the configure -constraints list are run; all others are skipped. For example, one might set up a configuration with configure -constraints knownBug \\ -limitconstraints true \\ -verbose pass to run exactly those tests that exercise known bugs, and discover whether any of them pass, indicating the bug had been fixed.","title":"TEST CONSTRAINTS"},{"location":"tcltest/#running-all-tests","text":"The single command runAllTests is evaluated to run an entire test suite, spanning many files and directories. The configuration options of tcltest control the precise operations. The runAllTests command begins by printing a summary of its configuration to outputChannel . Test files to be evaluated are sought in the directory configure -testdir . The list of files in that directory that match any of the patterns in configure -file and match none of the patterns in configure -notfile is generated and sorted. Then each file will be evaluated in turn. If configure -singleproc is true, then each file will be source d in the caller\\'s context. If it is false, then a copy of interpreter will be exec \\'d to evaluate each file. The multi-process operation is useful when testing can cause errors so severe that a process terminates. Although such an error may terminate a child process evaluating one file, the main process can continue with the rest of the test suite. In multi-process operation, the configuration of tcltest in the main process is passed to the child processes as command line arguments, with the exception of configure -outfile . The runAllTests command in the main process collects all output from the child processes and collates their results into one main report. Any reports of individual test failures, or messages requested by a configure -verbose setting are passed directly on to outputChannel by the main process. After evaluating all selected test files, a summary of the results is printed to outputChannel . The summary includes the total number of test s evaluated, broken down into those skipped, those passed, and those failed. The summary also notes the number of files evaluated, and the names of any files with failing tests or errors. A list of the constraints that caused tests to be skipped, and the number of tests skipped for each is also printed. Also, messages are printed if it appears that evaluation of a test file has caused any temporary files to be left behind in configure -tmpdir . Having completed and summarized all selected test files, runAllTests then recursively acts on subdirectories of configure -testdir . All subdirectories that match any of the patterns in configure -relateddir and do not match any of the patterns in configure -asidefromdir are examined. If a file named all.tcl is found in such a directory, it will be source d in the caller\\'s context. Whether or not an examined directory contains an all.tcl file, its subdirectories are also scanned against the configure -relateddir and configure -asidefromdir patterns. In this way, many directories in a directory tree can have all their test files evaluated by a single runAllTests command.","title":"RUNNING ALL TESTS"},{"location":"tcltest/#configurable-options","text":"The configure command is used to set and query the configurable options of tcltest . The valid options are: -singleproc boolean : Controls whether or not runAllTests spawns a child process for each test file. No spawning when boolean is true. Default value is false. -debug level : Sets the debug level to level , an integer value indicating how much debugging information should be printed to stdout . Note that debug messages always go to stdout , independent of the value of configure -outfile . Default value is 0. Levels are defined as: 0. Do not display any debug information. 1. Display information regarding whether a test is skipped because it does not match any of the tests that were specified using by **configure -match** (userSpecifiedNonMatch) or matches any of the tests specified by **configure -skip** (userSpecifiedSkip). Also print warnings about possible lack of cleanup or balance in test files. Also print warnings about any re-use of test names. 2. Display the flag array parsed by the command line processor, the contents of the global **env** array, and all user-defined variables that exist in the current namespace as they are used. 3. Display information regarding what individual procs in the test harness are doing. -verbose level : Sets the type of output verbosity desired to level , a list of zero or more of the elements body , pass , skip , start , error , line , msec and usec . Default value is Levels are defined as: body (b) : Display the body of failed tests pass (p) : Print output when a test passes skip (s) : Print output when a test is skipped start (t) : Print output whenever a test starts error (e) : Print errorInfo and errorCode, if they exist, when a test return code does not match its expected return code line (l) : Print source file line information of failed tests msec (m) : Print each test\\'s execution time in milliseconds usec (u) : Print each test\\'s execution time in microseconds Note that the msec and usec verbosity levels are provided as indicative measures only. They do not tackle the problem of repeatibility which should be considered in performance tests or benchmarks. To use these verbosity levels to thoroughly track performance degradations, consider wrapping your test bodies with time commands. The single letter abbreviations noted above are also recognized so that is the same as -preservecore level : Sets the core preservation level to level . This level determines how stringent checks for core files are. Default value is 0. Levels are defined as: 0. No checking --- do not check for core files at the end of each test command, but do check for them in **runAllTests** after all test files have been evaluated. 1. Also check for core files at the end of each **test** command. 2. Check for core files at all times described above, and save a copy of each core file produced in **configure -tmpdir**. -limitconstraints boolean : Sets the mode by which test honors constraints as described in TESTS above. Default value is false. -constraints list : Sets all the constraints in list to true. Also used in combination with configure -limitconstraints true to control an alternative constraint mode as described in TESTS above. Default value is an empty list. -tmpdir directory : Sets the temporary directory to be used by makeFile , makeDirectory , viewFile , removeFile , and removeDirectory as the default directory where temporary files and directories created by test files should be created. Default value is workingDirectory . -testdir directory : Sets the directory searched by runAllTests for test files and subdirectories. Default value is workingDirectory . -file patternList : Sets the list of patterns used by runAllTests to determine what test files to evaluate. Default value is <!-- --> -notfile patternList : Sets the list of patterns used by runAllTests to determine what test files to skip. Default value is so that any SCCS lock files are skipped. -relateddir patternList : Sets the list of patterns used by runAllTests to determine what subdirectories to search for an all.tcl file. Default value is <!-- --> -asidefromdir patternList : Sets the list of patterns used by runAllTests to determine what subdirectories to skip when searching for an all.tcl file. Default value is an empty list. -match patternList : Set the list of patterns used by test to determine whether a test should be run. Default value is <!-- --> -skip patternList : Set the list of patterns used by test to determine whether a test should be skipped. Default value is an empty list. -load script : Sets a script to be evaluated by loadTestedCommands . Default value is an empty script. -loadfile filename : Sets the filename from which to read a script to be evaluated by loadTestedCommands . This is an alternative to -load . They cannot be used together. -outfile filename : Sets the file to which all output produced by tcltest should be written. A file named filename will be open ed for writing, and the resulting channel will be set as the value of outputChannel . -errfile filename : Sets the file to which all error output produced by tcltest should be written. A file named filename will be open ed for writing, and the resulting channel will be set as the value of errorChannel .","title":"CONFIGURABLE OPTIONS"},{"location":"tcltest/#creating-test-suites-with-tcltest","text":"The fundamental element of a test suite is the individual test command. We begin with several examples. [1] : Test of a script that returns normally. **test** example-1.0 {normal return} { format %s value } value [2] : Test of a script that requires context setup and cleanup. Note the bracing and indenting style that avoids any need for line continuation. **test** example-1.1 {test file existence} -setup { set file \\[makeFile {} test\\] } -body { file exists \\$file } -cleanup { removeFile test } -result 1 [3] : Test of a script that raises an error. **test** example-1.2 {error return} -body { error message } -returnCodes error -result message [4] : Test with a constraint. **test** example-1.3 {user owns created files} -constraints { unix } -setup { set file \\[makeFile {} test\\] } -body { file attributes \\$file -owner } -cleanup { removeFile test } -result \\$::tcl_platform(user) At the next higher layer of organization, several test commands are gathered together into a single test file. Test files should have names with the extension, because that is the default pattern used by runAllTests to find test files. It is a good rule of thumb to have one test file for each source code file of your project. It is good practice to edit the test file and the source code file together, keeping tests synchronized with code changes. Most of the code in the test file should be the test commands. Use constraints to skip tests, rather than conditional evaluation of test . [5] : Recommended system for writing conditional tests, using constraints to guard: **testConstraint** X \\[expr \\$myRequirement\\] **test** goodConditionalTest {} X { \\# body } result [6] : Discouraged system for writing conditional tests, using if to guard: if \\$myRequirement { **test** badConditionalTest {} { #body } result } Use the -setup and -cleanup options to establish and release all context requirements of the test body. Do not make tests depend on prior tests in the file. Those prior tests might be skipped. If several consecutive tests require the same context, the appropriate setup and cleanup scripts may be stored in variable for passing to each tests -setup and -cleanup options. This is a better solution than performing setup outside of test commands, because the setup will only be done if necessary, and any errors during setup will be reported, and not cause the test file to abort. A test file should be able to be combined with other test files and not interfere with them, even when configure -singleproc 1 causes all files to be evaluated in a common interpreter. A simple way to achieve this is to have your tests define all their commands and variables in a namespace that is deleted when the test file evaluation is complete. A good namespace to use is a child namespace test of the namespace of the module you are testing. A test file should also be able to be evaluated directly as a script, not depending on being called by a main runAllTests . This means that each test file should process command line arguments to give the tester all the configuration control that tcltest provides. After all test s in a test file, the command cleanupTests should be called. [7] : Here is a sketch of a sample test file illustrating those points: package require tcltest 2.5 eval **::tcltest::configure** \\$argv package require example namespace eval ::example::test { namespace import ::tcltest::\\* **testConstraint** X \\[expr {\\...}\\] variable SETUP {#common setup code} variable CLEANUP {#common cleanup code} **test** example-1 {} -setup \\$SETUP -body { \\# First test } -cleanup \\$CLEANUP -result {\\...} **test** example-2 {} -constraints X -setup \\$SETUP -body { \\# Second test; constrained } -cleanup \\$CLEANUP -result {\\...} **test** example-3 {} { \\# Third test; no context required } {\\...} **cleanupTests** } namespace delete ::example::test The next level of organization is a full test suite, made up of several test files. One script is used to control the entire suite. The basic function of this script is to call runAllTests after doing any necessary setup. This script is usually named all.tcl because that is the default name used by runAllTests when combining multiple test suites into one testing run. [8] : Here is a sketch of a sample test suite main script: package require tcltest 2.5 package require example **::tcltest::configure** -testdir \\\\ \\[file dirname \\[file normalize \\[info script\\]\\]\\] eval **::tcltest::configure** \\$argv **::tcltest::runAllTests**","title":"CREATING TEST SUITES WITH TCLTEST"},{"location":"tcltest/#compatibility","text":"A number of commands and variables in the ::tcltest namespace provided by earlier releases of tcltest have not been documented here. They are no longer part of the supported public interface of tcltest and should not be used in new test suites. However, to continue to support existing test suites written to the older interface specifications, many of those deprecated commands and variables still work as before. For example, in many circumstances, configure will be automatically called shortly after package require tcltest 2.1 succeeds with arguments from the variable ::argv . This is to support test suites that depend on the old behavior that tcltest was automatically configured from command line arguments. New test files should not depend on this, but should explicitly include eval ::tcltest::configure \\$::argv or ::tcltest::configure {*}\\$::argv to establish a configuration from command line arguments.","title":"COMPATIBILITY"},{"location":"tcltest/#known-issues","text":"There are two known issues related to nested evaluations of test . The first issue relates to the stack level in which test scripts are executed. Tests nested within other tests may be executed at the same stack level as the outermost test. For example, in the following code: test level-1.1 {level 1} { -body { test level-2.1 {level 2} { } } } any script executed in level-2.1 may be executed at the same stack level as the script defined for level-1.1. In addition, while two test s have been run, results will only be reported by cleanupTests for tests at the same level as test level-1.1. However, test results for all tests run prior to level-1.1 will be available when test level-2.1 runs. What this means is that if you try to access the test results for test level-2.1, it will may say that tests have run, tests have been skipped, tests have passed and tests have failed, where and refer to tests that were run at the same test level as test level-1.1. Implementation of output and error comparison in the test command depends on usage of puts in your application code. Output is intercepted by redefining the global puts command while the defined test script is being run. Errors thrown by C procedures or printed directly from C applications will not be caught by the test command. Therefore, usage of the -output and -errorOutput options to test is useful only for pure Tcl applications that use puts to produce output.","title":"KNOWN ISSUES"},{"location":"tcltest/#keywords","text":"test, test harness, test suite","title":"KEYWORDS"},{"location":"tclvars/","text":"NAME argc, argv, argv0, auto_path, env, errorCode, errorInfo, tcl_interactive, tcl_library, tcl_nonwordchars, tcl_patchLevel, tcl_pkgPath, tcl_platform, tcl_rcFileName, tcl_traceCompile, tcl_traceExec, tcl_wordchars, tcl_version - Variables used by Tcl DESCRIPTION The following global variables are created and managed automatically by the Tcl library. Except where noted below, these variables should normally be treated as read-only by application-specific code and by users. auto_path : If set, then it must contain a valid Tcl list giving directories to search during auto-load operations (including for package index files when using the default package unknown handler). This variable is initialized during startup to contain, in order: the directories listed in the TCLLIBPATH environment variable, the directory named by the tcl_library global variable, the parent directory of tcl_library , the directories listed in the tcl_pkgPath variable. Additional locations to look for files and package indices should normally be added to this variable using lappend . Additional variables relating to package management exist. More details are listed in the **VARIABLES** section of the **library** manual page. env : This variable is maintained by Tcl as an array whose elements are the environment variables for the process. Reading an element will return the value of the corresponding environment variable. Setting an element of the array will modify the corresponding environment variable or create a new one if it does not already exist. Unsetting an element of env will remove the corresponding environment variable. Changes to the env array will affect the environment passed to children by commands like exec . If the entire env array is unset then Tcl will stop monitoring env accesses and will not update environment variables. Under Windows, the environment variables PATH and COMSPEC in any capitalization are converted automatically to upper case. For instance, the PATH variable could be exported by the operating system as etc., causing otherwise simple Tcl code to have to support many special cases. All other environment variables inherited by Tcl are left unmodified. Setting an env array variable to blank is the same as unsetting it as this is the behavior of the underlying Windows OS. It should be noted that relying on an existing and empty environment variable will not work on Windows and is discouraged for cross-platform usage. The following elements of **env** are special to Tcl: **env(HOME)** : This environment variable, if set, gives the location of the directory considered to be the current user\\'s home directory. The value of this variable is returned by the **file home** command. Most platforms set this correctly by default; it does not normally need to be set by user code. On Windows, if not already set, it is set to the value of the **USERPROFILE** environment variable. **env(TCL_LIBRARY)** : If set, then it specifies the location of the directory containing library scripts (the value of this variable will be assigned to the **tcl_library** variable and therefore returned by the command **info library**). If this variable is not set then a default value is used. Note that this environment variable should *not* normally be set. **env(TCLLIBPATH)** : If set, then it must contain a valid Tcl list giving directories to search during auto-load operations. Directories must be specified in Tcl format, using as the path separator, regardless of platform. This variable is only used when initializing the **auto_path** variable. **env(TCL_TZ)**, **env(TZ)** : These specify the default timezone used for parsing and formatting times and dates in the **clock** command. On many platforms, the TZ environment variable is set up by the operating system. **env(LC_ALL)**, **env(LC_MESSAGES)**, **env(LANG)** : These environment variables are used by the **msgcat** package to determine what locale to format messages using. **env(TCL_INTERP_DEBUG_FRAME)** : If existing, it has the same effect as running **interp debug** **{} -frame 1** as the very first command of each new Tcl interpreter. errorCode : This variable holds the value of the -errorcode return option set by the most recent error that occurred in this interpreter. This list value represents additional information about the error in a form that is easy to process with programs. The first element of the list identifies a general class of errors, and determines the format of the rest of the list. The following formats for -errorcode return options are used by the Tcl core; individual applications may define additional formats. **ARITH*** code msg* : This format is used when an arithmetic error occurs (e.g. an attempt to divide zero by zero in the **expr** command). *Code* identifies the precise error and *msg* provides a human-readable description of the error. *Code* will be either DIVZERO (for an attempt to divide by zero), DOMAIN (if an argument is outside the domain of a function, such as acos(-3)), IOVERFLOW (for integer overflow), OVERFLOW (for a floating-point overflow), or UNKNOWN (if the cause of the error cannot be determined). Detection of these errors depends in part on the underlying hardware and system libraries. **CHILDKILLED*** pid sigName msg* : This format is used when a child process has been killed because of a signal. The *pid* element will be the process\\'s identifier (in decimal). The *sigName* element will be the symbolic name of the signal that caused the process to terminate; it will be one of the names from the include file signal.h, such as **SIGPIPE**. The *msg* element will be a short human-readable message describing the signal, such as for **SIGPIPE**. **CHILDSTATUS*** pid code* : This format is used when a child process has exited with a non-zero exit status. The *pid* element will be the process\\'s identifier (in decimal) and the *code* element will be the exit code returned by the process (also in decimal). **CHILDSUSP*** pid sigName msg* : This format is used when a child process has been suspended because of a signal. The *pid* element will be the process\\'s identifier, in decimal. The *sigName* element will be the symbolic name of the signal that caused the process to suspend; this will be one of the names from the include file signal.h, such as **SIGTTIN**. The *msg* element will be a short human-readable message describing the signal, such as for **SIGTTIN**. **NONE** : This format is used for errors where no additional information is available for an error besides the message returned with the error. In these cases the **-errorcode** return option will consist of a list containing a single element whose contents are **NONE**. **POSIX ***errName msg* : If the first element is **POSIX**, then the error occurred during a POSIX kernel call. The *errName* element will contain the symbolic name of the error that occurred, such as **ENOENT**; this will be one of the values defined in the include file errno.h. The *msg* element will be a human-readable message corresponding to *errName*, such as for the **ENOENT** case. **TCL** \\... : Indicates some sort of problem generated in relation to Tcl itself, e.g. a failure to look up a channel or variable. To set the **-errorcode** return option, applications should use library procedures such as **Tcl_SetObjErrorCode**, **Tcl_SetReturnOptions**, and **Tcl_PosixError**, or they may invoke the **-errorcode** option of the **return** command. If none of these methods for setting the error code has been used, the Tcl interpreter will reset the variable to **NONE** after the next error. errorInfo : This variable holds the value of the -errorinfo return option set by the most recent error that occurred in this interpreter. This string value will contain one or more lines identifying the Tcl commands and procedures that were being executed when the most recent error occurred. Its contents take the form of a stack trace showing the various nested Tcl commands that had been invoked at the time of the error. tcl_library : This variable holds the name of a directory containing the system library of Tcl scripts, such as those used for auto-loading. The value of this variable is returned by the info library command. See the library manual entry for details of the facilities provided by the Tcl script library. Normally each application or package will have its own application-specific script library in addition to the Tcl script library; each application should set a global variable with a name like \\$ app _library (where app is the application\\'s name) to hold the network file name for that application\\'s library directory. The initial value of tcl_library is set when an interpreter is created by searching several different directories until one is found that contains an appropriate Tcl startup script. If the TCL_LIBRARY environment variable exists, then the directory it names is checked first. If TCL_LIBRARY is not set or doesn\\'t refer to an appropriate directory, then Tcl checks several other directories based on a compiled-in default location, the location of the binary containing the application, and the current working directory. tcl_patchLevel : When an interpreter is created Tcl initializes this variable to hold a string giving the current patch level for Tcl, such as 8.4.16 for Tcl 8.4 with the first sixteen official patches, or 8.5b3 for the third beta release of Tcl 8.5. The value of this variable is returned by the info patchlevel command. tcl_pkgPath : This variable holds a list of directories indicating where packages are normally installed. It is not used on Windows. It typically contains either one or two entries; if it contains two entries, the first is normally a directory for platform-dependent packages (e.g., shared library binaries) and the second is normally a directory for platform-independent packages (e.g., script files). Typically a package is installed as a subdirectory of one of the entries in the tcl_pkgPath variable. The directories in the tcl_pkgPath variable are included by default in the auto_path variable, so they and their immediate subdirectories are automatically searched for packages during package require commands. Note: tcl_pkgPath is not intended to be modified by the application. Its value is added to auto_path at startup; changes to tcl_pkgPath are not reflected in auto_path . If you want Tcl to search additional directories for packages you should add the names of those directories to auto_path , not tcl_pkgPath . tcl_platform : This is an associative array whose elements contain information about the platform on which the application is running, such as the name of the operating system, its current release number, and the machine\\'s instruction set. The elements listed below will always be defined, but they may have empty strings as values if Tcl could not retrieve any relevant information. In addition, extensions and applications may add additional values to the array. The predefined elements are: **byteOrder** : The native byte order of this machine: either **littleEndian** or **bigEndian**. **debug** : If this variable exists, then the interpreter was compiled with and linked to a debug-enabled C run-time. This variable will only exist on Windows, so extension writers can specify which package to load depending on the C run-time library that is in use. This is not an indication that this core contains symbols. **engine** : The name of the Tcl language implementation. When the interpreter is first created, this is always set to the string **Tcl**. **machine** : The instruction set executed by this machine, such as **intel**, **PPC**, **68k**, or **sun4m**. On UNIX machines, this is the value returned by **uname -m**. **os** : The name of the operating system running on this machine, such as **Windows NT** or **SunOS**. On UNIX machines, this is the value returned by **uname -s**. **osVersion** : The version number for the operating system running on this machine. On UNIX machines, this is the value returned by **uname -r**. **pathSeparator** : The character that should be used to **split** PATH-like environment variables into their corresponding list of directory names. **platform** : Either **windows**, or **unix**. This identifies the general operating environment of the machine. **pointerSize** : This gives the size of the native-machine pointer in bytes (strictly, it is same as the result of evaluating *sizeof(void\\*)* in C.) **threaded** : If this variable exists, then the interpreter was compiled with threads enabled. **user** : This identifies the current user based on the login information available on the platform. This value comes from the getuid() and getpwuid() system calls on Unix, and the value from the GetUserName() system call on Windows. **wordSize** : This gives the size of the native-machine word in bytes (strictly, it is same as the result of evaluating *sizeof(long)* in C.) tcl_traceCompile : The value of this variable can be set to control how much tracing information is displayed during bytecode compilation. By default, tcl_traceCompile is zero and no information is displayed. Setting tcl_traceCompile to 1 generates a one-line summary in stdout whenever a procedure or top-level command is compiled. Setting it to 2 generates a detailed listing in stdout of the bytecode instructions emitted during every compilation. This variable is useful in tracking down suspected problems with the Tcl compiler. This variable and functionality only exist if TCL_COMPILE_DEBUG was defined during Tcl\\'s compilation. tcl_traceExec : The value of this variable can be set to control how much tracing information is displayed during bytecode execution. By default, tcl_traceExec is zero and no information is displayed. Setting tcl_traceExec to 1 generates a one-line trace in stdout on each call to a Tcl procedure. Setting it to 2 generates a line of output whenever any Tcl command is invoked that contains the name of the command and its arguments. Setting it to 3 produces a detailed trace showing the result of executing each bytecode instruction. Note that when tcl_traceExec is 2 or 3, commands such as set and incr that have been entirely replaced by a sequence of bytecode instructions are not shown. Setting this variable is useful in tracking down suspected problems with the bytecode compiler and interpreter. This variable and functionality only exist if TCL_COMPILE_DEBUG was defined during Tcl\\'s compilation. tcl_wordchars : The value of this variable is a regular expression that can be set to control what are considered characters, for instances like selecting a word by double-clicking in text in Tk. It is platform dependent. On Windows, it defaults to \\S , meaning anything but a Unicode space character. Otherwise it defaults to \\w , which is any Unicode word character (number, letter, or underscore). tcl_nonwordchars : The value of this variable is a regular expression that can be set to control what are considered characters, for instances like selecting a word by double-clicking in text in Tk. It is platform dependent. On Windows, it defaults to \\s , meaning any Unicode space character. Otherwise it defaults to \\W , which is anything but a Unicode word character (number, letter, or underscore). tcl_version : When an interpreter is created Tcl initializes this variable to hold the version number for this version of Tcl in the form x.y . Changes to x represent major changes with probable incompatibilities and changes to y represent small enhancements and bug fixes that retain backward compatibility. The value of this variable is returned by the info tclversion command. OTHER GLOBAL VARIABLES The following variables are only guaranteed to exist in tclsh and wish executables; the Tcl library does not define them itself but many Tcl environments do. argc : The number of arguments to tclsh or wish . argv : Tcl list of arguments to tclsh or wish . argv0 : The script that tclsh or wish started executing (if it was specified) or otherwise the name by which tclsh or wish was invoked. tcl_interactive : Contains 1 if tclsh or wish is running interactively (no script was specified and standard input is a terminal-like device), 0 otherwise. EXAMPLES To add a directory to the collection of locations searched by package require , e.g., because of some application-specific packages that are used, the auto_path variable needs to be updated: lappend :: auto_path [file join [pwd] \\\"theLibDir\\\"] A simple though not very robust way to handle command line arguments of the form is to load them into an array having first loaded in the default settings: array set arguments {-foo 0 -bar 0 -grill 0} array set arguments \\$:: argv puts \\\"foo is \\$arguments(-foo)\\\" puts \\\"bar is \\$arguments(-bar)\\\" puts \\\"grill is \\$arguments(-grill)\\\" The argv0 global variable can be used (in conjunction with the info script command) to determine whether the current script is being executed as the main script or loaded as a library. This is useful because it allows a single script to be used as both a library and a demonstration of that library: if {\\$:: argv0 eq [info script]} { # running as: tclsh example.tcl } else { package provide Example 1.0 } SEE ALSO eval(n), library(n), tclsh(1), tkvars(n), wish(1) KEYWORDS arithmetic, bytecode, compiler, error, environment, POSIX, precision, subprocess, user, variables","title":"NAME"},{"location":"tclvars/#name","text":"argc, argv, argv0, auto_path, env, errorCode, errorInfo, tcl_interactive, tcl_library, tcl_nonwordchars, tcl_patchLevel, tcl_pkgPath, tcl_platform, tcl_rcFileName, tcl_traceCompile, tcl_traceExec, tcl_wordchars, tcl_version - Variables used by Tcl","title":"NAME"},{"location":"tclvars/#description","text":"The following global variables are created and managed automatically by the Tcl library. Except where noted below, these variables should normally be treated as read-only by application-specific code and by users. auto_path : If set, then it must contain a valid Tcl list giving directories to search during auto-load operations (including for package index files when using the default package unknown handler). This variable is initialized during startup to contain, in order: the directories listed in the TCLLIBPATH environment variable, the directory named by the tcl_library global variable, the parent directory of tcl_library , the directories listed in the tcl_pkgPath variable. Additional locations to look for files and package indices should normally be added to this variable using lappend . Additional variables relating to package management exist. More details are listed in the **VARIABLES** section of the **library** manual page. env : This variable is maintained by Tcl as an array whose elements are the environment variables for the process. Reading an element will return the value of the corresponding environment variable. Setting an element of the array will modify the corresponding environment variable or create a new one if it does not already exist. Unsetting an element of env will remove the corresponding environment variable. Changes to the env array will affect the environment passed to children by commands like exec . If the entire env array is unset then Tcl will stop monitoring env accesses and will not update environment variables. Under Windows, the environment variables PATH and COMSPEC in any capitalization are converted automatically to upper case. For instance, the PATH variable could be exported by the operating system as etc., causing otherwise simple Tcl code to have to support many special cases. All other environment variables inherited by Tcl are left unmodified. Setting an env array variable to blank is the same as unsetting it as this is the behavior of the underlying Windows OS. It should be noted that relying on an existing and empty environment variable will not work on Windows and is discouraged for cross-platform usage. The following elements of **env** are special to Tcl: **env(HOME)** : This environment variable, if set, gives the location of the directory considered to be the current user\\'s home directory. The value of this variable is returned by the **file home** command. Most platforms set this correctly by default; it does not normally need to be set by user code. On Windows, if not already set, it is set to the value of the **USERPROFILE** environment variable. **env(TCL_LIBRARY)** : If set, then it specifies the location of the directory containing library scripts (the value of this variable will be assigned to the **tcl_library** variable and therefore returned by the command **info library**). If this variable is not set then a default value is used. Note that this environment variable should *not* normally be set. **env(TCLLIBPATH)** : If set, then it must contain a valid Tcl list giving directories to search during auto-load operations. Directories must be specified in Tcl format, using as the path separator, regardless of platform. This variable is only used when initializing the **auto_path** variable. **env(TCL_TZ)**, **env(TZ)** : These specify the default timezone used for parsing and formatting times and dates in the **clock** command. On many platforms, the TZ environment variable is set up by the operating system. **env(LC_ALL)**, **env(LC_MESSAGES)**, **env(LANG)** : These environment variables are used by the **msgcat** package to determine what locale to format messages using. **env(TCL_INTERP_DEBUG_FRAME)** : If existing, it has the same effect as running **interp debug** **{} -frame 1** as the very first command of each new Tcl interpreter. errorCode : This variable holds the value of the -errorcode return option set by the most recent error that occurred in this interpreter. This list value represents additional information about the error in a form that is easy to process with programs. The first element of the list identifies a general class of errors, and determines the format of the rest of the list. The following formats for -errorcode return options are used by the Tcl core; individual applications may define additional formats. **ARITH*** code msg* : This format is used when an arithmetic error occurs (e.g. an attempt to divide zero by zero in the **expr** command). *Code* identifies the precise error and *msg* provides a human-readable description of the error. *Code* will be either DIVZERO (for an attempt to divide by zero), DOMAIN (if an argument is outside the domain of a function, such as acos(-3)), IOVERFLOW (for integer overflow), OVERFLOW (for a floating-point overflow), or UNKNOWN (if the cause of the error cannot be determined). Detection of these errors depends in part on the underlying hardware and system libraries. **CHILDKILLED*** pid sigName msg* : This format is used when a child process has been killed because of a signal. The *pid* element will be the process\\'s identifier (in decimal). The *sigName* element will be the symbolic name of the signal that caused the process to terminate; it will be one of the names from the include file signal.h, such as **SIGPIPE**. The *msg* element will be a short human-readable message describing the signal, such as for **SIGPIPE**. **CHILDSTATUS*** pid code* : This format is used when a child process has exited with a non-zero exit status. The *pid* element will be the process\\'s identifier (in decimal) and the *code* element will be the exit code returned by the process (also in decimal). **CHILDSUSP*** pid sigName msg* : This format is used when a child process has been suspended because of a signal. The *pid* element will be the process\\'s identifier, in decimal. The *sigName* element will be the symbolic name of the signal that caused the process to suspend; this will be one of the names from the include file signal.h, such as **SIGTTIN**. The *msg* element will be a short human-readable message describing the signal, such as for **SIGTTIN**. **NONE** : This format is used for errors where no additional information is available for an error besides the message returned with the error. In these cases the **-errorcode** return option will consist of a list containing a single element whose contents are **NONE**. **POSIX ***errName msg* : If the first element is **POSIX**, then the error occurred during a POSIX kernel call. The *errName* element will contain the symbolic name of the error that occurred, such as **ENOENT**; this will be one of the values defined in the include file errno.h. The *msg* element will be a human-readable message corresponding to *errName*, such as for the **ENOENT** case. **TCL** \\... : Indicates some sort of problem generated in relation to Tcl itself, e.g. a failure to look up a channel or variable. To set the **-errorcode** return option, applications should use library procedures such as **Tcl_SetObjErrorCode**, **Tcl_SetReturnOptions**, and **Tcl_PosixError**, or they may invoke the **-errorcode** option of the **return** command. If none of these methods for setting the error code has been used, the Tcl interpreter will reset the variable to **NONE** after the next error. errorInfo : This variable holds the value of the -errorinfo return option set by the most recent error that occurred in this interpreter. This string value will contain one or more lines identifying the Tcl commands and procedures that were being executed when the most recent error occurred. Its contents take the form of a stack trace showing the various nested Tcl commands that had been invoked at the time of the error. tcl_library : This variable holds the name of a directory containing the system library of Tcl scripts, such as those used for auto-loading. The value of this variable is returned by the info library command. See the library manual entry for details of the facilities provided by the Tcl script library. Normally each application or package will have its own application-specific script library in addition to the Tcl script library; each application should set a global variable with a name like \\$ app _library (where app is the application\\'s name) to hold the network file name for that application\\'s library directory. The initial value of tcl_library is set when an interpreter is created by searching several different directories until one is found that contains an appropriate Tcl startup script. If the TCL_LIBRARY environment variable exists, then the directory it names is checked first. If TCL_LIBRARY is not set or doesn\\'t refer to an appropriate directory, then Tcl checks several other directories based on a compiled-in default location, the location of the binary containing the application, and the current working directory. tcl_patchLevel : When an interpreter is created Tcl initializes this variable to hold a string giving the current patch level for Tcl, such as 8.4.16 for Tcl 8.4 with the first sixteen official patches, or 8.5b3 for the third beta release of Tcl 8.5. The value of this variable is returned by the info patchlevel command. tcl_pkgPath : This variable holds a list of directories indicating where packages are normally installed. It is not used on Windows. It typically contains either one or two entries; if it contains two entries, the first is normally a directory for platform-dependent packages (e.g., shared library binaries) and the second is normally a directory for platform-independent packages (e.g., script files). Typically a package is installed as a subdirectory of one of the entries in the tcl_pkgPath variable. The directories in the tcl_pkgPath variable are included by default in the auto_path variable, so they and their immediate subdirectories are automatically searched for packages during package require commands. Note: tcl_pkgPath is not intended to be modified by the application. Its value is added to auto_path at startup; changes to tcl_pkgPath are not reflected in auto_path . If you want Tcl to search additional directories for packages you should add the names of those directories to auto_path , not tcl_pkgPath . tcl_platform : This is an associative array whose elements contain information about the platform on which the application is running, such as the name of the operating system, its current release number, and the machine\\'s instruction set. The elements listed below will always be defined, but they may have empty strings as values if Tcl could not retrieve any relevant information. In addition, extensions and applications may add additional values to the array. The predefined elements are: **byteOrder** : The native byte order of this machine: either **littleEndian** or **bigEndian**. **debug** : If this variable exists, then the interpreter was compiled with and linked to a debug-enabled C run-time. This variable will only exist on Windows, so extension writers can specify which package to load depending on the C run-time library that is in use. This is not an indication that this core contains symbols. **engine** : The name of the Tcl language implementation. When the interpreter is first created, this is always set to the string **Tcl**. **machine** : The instruction set executed by this machine, such as **intel**, **PPC**, **68k**, or **sun4m**. On UNIX machines, this is the value returned by **uname -m**. **os** : The name of the operating system running on this machine, such as **Windows NT** or **SunOS**. On UNIX machines, this is the value returned by **uname -s**. **osVersion** : The version number for the operating system running on this machine. On UNIX machines, this is the value returned by **uname -r**. **pathSeparator** : The character that should be used to **split** PATH-like environment variables into their corresponding list of directory names. **platform** : Either **windows**, or **unix**. This identifies the general operating environment of the machine. **pointerSize** : This gives the size of the native-machine pointer in bytes (strictly, it is same as the result of evaluating *sizeof(void\\*)* in C.) **threaded** : If this variable exists, then the interpreter was compiled with threads enabled. **user** : This identifies the current user based on the login information available on the platform. This value comes from the getuid() and getpwuid() system calls on Unix, and the value from the GetUserName() system call on Windows. **wordSize** : This gives the size of the native-machine word in bytes (strictly, it is same as the result of evaluating *sizeof(long)* in C.) tcl_traceCompile : The value of this variable can be set to control how much tracing information is displayed during bytecode compilation. By default, tcl_traceCompile is zero and no information is displayed. Setting tcl_traceCompile to 1 generates a one-line summary in stdout whenever a procedure or top-level command is compiled. Setting it to 2 generates a detailed listing in stdout of the bytecode instructions emitted during every compilation. This variable is useful in tracking down suspected problems with the Tcl compiler. This variable and functionality only exist if TCL_COMPILE_DEBUG was defined during Tcl\\'s compilation. tcl_traceExec : The value of this variable can be set to control how much tracing information is displayed during bytecode execution. By default, tcl_traceExec is zero and no information is displayed. Setting tcl_traceExec to 1 generates a one-line trace in stdout on each call to a Tcl procedure. Setting it to 2 generates a line of output whenever any Tcl command is invoked that contains the name of the command and its arguments. Setting it to 3 produces a detailed trace showing the result of executing each bytecode instruction. Note that when tcl_traceExec is 2 or 3, commands such as set and incr that have been entirely replaced by a sequence of bytecode instructions are not shown. Setting this variable is useful in tracking down suspected problems with the bytecode compiler and interpreter. This variable and functionality only exist if TCL_COMPILE_DEBUG was defined during Tcl\\'s compilation. tcl_wordchars : The value of this variable is a regular expression that can be set to control what are considered characters, for instances like selecting a word by double-clicking in text in Tk. It is platform dependent. On Windows, it defaults to \\S , meaning anything but a Unicode space character. Otherwise it defaults to \\w , which is any Unicode word character (number, letter, or underscore). tcl_nonwordchars : The value of this variable is a regular expression that can be set to control what are considered characters, for instances like selecting a word by double-clicking in text in Tk. It is platform dependent. On Windows, it defaults to \\s , meaning any Unicode space character. Otherwise it defaults to \\W , which is anything but a Unicode word character (number, letter, or underscore). tcl_version : When an interpreter is created Tcl initializes this variable to hold the version number for this version of Tcl in the form x.y . Changes to x represent major changes with probable incompatibilities and changes to y represent small enhancements and bug fixes that retain backward compatibility. The value of this variable is returned by the info tclversion command.","title":"DESCRIPTION"},{"location":"tclvars/#other-global-variables","text":"The following variables are only guaranteed to exist in tclsh and wish executables; the Tcl library does not define them itself but many Tcl environments do. argc : The number of arguments to tclsh or wish . argv : Tcl list of arguments to tclsh or wish . argv0 : The script that tclsh or wish started executing (if it was specified) or otherwise the name by which tclsh or wish was invoked. tcl_interactive : Contains 1 if tclsh or wish is running interactively (no script was specified and standard input is a terminal-like device), 0 otherwise.","title":"OTHER GLOBAL VARIABLES"},{"location":"tclvars/#examples","text":"To add a directory to the collection of locations searched by package require , e.g., because of some application-specific packages that are used, the auto_path variable needs to be updated: lappend :: auto_path [file join [pwd] \\\"theLibDir\\\"] A simple though not very robust way to handle command line arguments of the form is to load them into an array having first loaded in the default settings: array set arguments {-foo 0 -bar 0 -grill 0} array set arguments \\$:: argv puts \\\"foo is \\$arguments(-foo)\\\" puts \\\"bar is \\$arguments(-bar)\\\" puts \\\"grill is \\$arguments(-grill)\\\" The argv0 global variable can be used (in conjunction with the info script command) to determine whether the current script is being executed as the main script or loaded as a library. This is useful because it allows a single script to be used as both a library and a demonstration of that library: if {\\$:: argv0 eq [info script]} { # running as: tclsh example.tcl } else { package provide Example 1.0 }","title":"EXAMPLES"},{"location":"tclvars/#see-also","text":"eval(n), library(n), tclsh(1), tkvars(n), wish(1)","title":"SEE ALSO"},{"location":"tclvars/#keywords","text":"arithmetic, bytecode, compiler, error, environment, POSIX, precision, subprocess, user, variables","title":"KEYWORDS"},{"location":"tell/","text":"NAME tell - Return current access position for an open channel SYNOPSIS tell channelId DESCRIPTION Returns an integer giving the current access position in channelId . This value returned is a byte offset that can be passed to seek in order to set the channel to a particular position. Note that this value is in terms of bytes, not characters like read . The value returned is -1 for channels that do not support seeking. ChannelId must be an identifier for an open channel such as a Tcl standard channel ( stdin , stdout , or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension. EXAMPLE Read a line from a file channel only if it starts with foobar : # Save the offset in case we need to undo the read... set offset [ tell \\$chan] if {[read \\$chan 6] eq \\\"foobar\\\"} { gets \\$chan line } else { set line {} # Undo the read... seek \\$chan \\$offset } SEE ALSO file(n), open(n), close(n), gets(n), seek(n), Tcl_StandardChannels(3) KEYWORDS access position, channel, seeking","title":"NAME"},{"location":"tell/#name","text":"tell - Return current access position for an open channel","title":"NAME"},{"location":"tell/#synopsis","text":"tell channelId","title":"SYNOPSIS"},{"location":"tell/#description","text":"Returns an integer giving the current access position in channelId . This value returned is a byte offset that can be passed to seek in order to set the channel to a particular position. Note that this value is in terms of bytes, not characters like read . The value returned is -1 for channels that do not support seeking. ChannelId must be an identifier for an open channel such as a Tcl standard channel ( stdin , stdout , or stderr ), the return value from an invocation of open or socket , or the result of a channel creation command provided by a Tcl extension.","title":"DESCRIPTION"},{"location":"tell/#example","text":"Read a line from a file channel only if it starts with foobar : # Save the offset in case we need to undo the read... set offset [ tell \\$chan] if {[read \\$chan 6] eq \\\"foobar\\\"} { gets \\$chan line } else { set line {} # Undo the read... seek \\$chan \\$offset }","title":"EXAMPLE"},{"location":"tell/#see-also","text":"file(n), open(n), close(n), gets(n), seek(n), Tcl_StandardChannels(3)","title":"SEE ALSO"},{"location":"tell/#keywords","text":"access position, channel, seeking","title":"KEYWORDS"},{"location":"throw/","text":"NAME throw - Generate a machine-readable error SYNOPSIS throw type message DESCRIPTION This command causes the current evaluation to be unwound with an error. The error created is described by the type and message arguments: type must contain a list of words describing the error in a form that is machine-readable (and which will form the error-code part of the result dictionary), and message should contain text that is intended for display to a human being. The stack will be unwound until the error is trapped by a suitable catch or try command. If it reaches the event loop without being trapped, it will be reported through the bgerror mechanism. If it reaches the top level of script evaluation in tclsh , it will be printed on the console before, in the non-interactive case, causing an exit (the behavior in other programs will depend on the details of how Tcl is embedded and used). By convention, the words in the type argument should go from most general to most specific. EXAMPLES The following produces an error that is identical to that produced by expr when trying to divide a value by zero. throw {ARITH DIVZERO {divide by zero}} {divide by zero} SEE ALSO catch(n), error(n), errorCode(n), errorInfo(n), return(n), try(n) KEYWORDS error, exception","title":"NAME"},{"location":"throw/#name","text":"throw - Generate a machine-readable error","title":"NAME"},{"location":"throw/#synopsis","text":"throw type message","title":"SYNOPSIS"},{"location":"throw/#description","text":"This command causes the current evaluation to be unwound with an error. The error created is described by the type and message arguments: type must contain a list of words describing the error in a form that is machine-readable (and which will form the error-code part of the result dictionary), and message should contain text that is intended for display to a human being. The stack will be unwound until the error is trapped by a suitable catch or try command. If it reaches the event loop without being trapped, it will be reported through the bgerror mechanism. If it reaches the top level of script evaluation in tclsh , it will be printed on the console before, in the non-interactive case, causing an exit (the behavior in other programs will depend on the details of how Tcl is embedded and used). By convention, the words in the type argument should go from most general to most specific.","title":"DESCRIPTION"},{"location":"throw/#examples","text":"The following produces an error that is identical to that produced by expr when trying to divide a value by zero. throw {ARITH DIVZERO {divide by zero}} {divide by zero}","title":"EXAMPLES"},{"location":"throw/#see-also","text":"catch(n), error(n), errorCode(n), errorInfo(n), return(n), try(n)","title":"SEE ALSO"},{"location":"throw/#keywords","text":"error, exception","title":"KEYWORDS"},{"location":"time/","text":"NAME time - Time the execution of a script SYNOPSIS time script ? count ? DESCRIPTION This command will call the Tcl interpreter count times to evaluate script (or once if count is not specified). It will then return a string of the form 503.2 microseconds per iteration which indicates the average amount of time required per iteration, in microseconds. Time is measured in elapsed time, not CPU time. EXAMPLE Estimate how long it takes for a simple Tcl for loop to count to a thousand: time { for {set i 0} {\\$i\\<1000} {incr i} { # empty body } } SEE ALSO clock(n) KEYWORDS script, time","title":"NAME"},{"location":"time/#name","text":"time - Time the execution of a script","title":"NAME"},{"location":"time/#synopsis","text":"time script ? count ?","title":"SYNOPSIS"},{"location":"time/#description","text":"This command will call the Tcl interpreter count times to evaluate script (or once if count is not specified). It will then return a string of the form 503.2 microseconds per iteration which indicates the average amount of time required per iteration, in microseconds. Time is measured in elapsed time, not CPU time.","title":"DESCRIPTION"},{"location":"time/#example","text":"Estimate how long it takes for a simple Tcl for loop to count to a thousand: time { for {set i 0} {\\$i\\<1000} {incr i} { # empty body } }","title":"EXAMPLE"},{"location":"time/#see-also","text":"clock(n)","title":"SEE ALSO"},{"location":"time/#keywords","text":"script, time","title":"KEYWORDS"},{"location":"timerate/","text":"NAME timerate - Calibrated performance measurements of script execution time SYNOPSIS timerate script ? time ? ? max-count ? timerate ? -direct ? ? -overhead double ? script ? time ? ? max-count ? timerate ? -calibrate ? ? -direct ? script ? time ? ? max-count ? DESCRIPTION The timerate command does calibrated performance measurement of a Tcl command or script, script . The script should be written so that it can be executed multiple times during the performance measurement process. Time is measured in elapsed time using the finest timer resolution as possible, not CPU time; if script interacts with the OS, the cost of that interaction is included. This command may be used to provide information as to how well a script or Tcl command is performing, and can help determine bottlenecks and fine-tune application performance. The first and second form will evaluate script until the interval time given in milliseconds elapses, or for 1000 milliseconds (1 second) if time is not specified. The parameter max-count could additionally impose a further restriction by the maximal number of iterations to evaluate the script. If max-count is specified, the evalution will stop either this count of iterations is reached or the time is exceeded. It will then return a canonical tcl-list of the form: 0.095977 \u00b5s/# 52095836 # 10419167 #/sec 5000.000 net-ms which indicates: the average amount of time required per iteration, in microseconds ([ lindex \\$result 0]) the count how many times it was executed ([ lindex \\$result 2]) the estimated rate per second ([ lindex \\$result 4]) the estimated real execution time without measurement overhead ([ lindex \\$result 6]) The following options may be supplied to the timerate command: -calibrate : To measure very fast scripts as exactly as possible, a calibration process may be required. The -calibrate option is used to calibrate timerate itself, calculating the estimated overhead of the given script as the default overhead for future invocations of the timerate command. If the time parameter is not specified, the calibrate procedure runs for up to 10 seconds. Note that calibration is not thread safe in the current implementation. -overhead double : The -overhead parameter supplies an estimate (in microseconds) of the measurement overhead of each iteration of the tested script. This quantity will be subtracted from the measured time prior to reporting results. This can be useful for removing the cost of interpreter state reset commands from the script being measured. -direct : The -direct option causes direct execution of the supplied script, without compilation, in a manner similar to the time command. It can be used to measure the cost of Tcl_EvalObjEx , of the invocation of canonical lists, and of the uncompiled versions of bytecoded commands. As opposed to the time commmand, which runs the tested script for a fixed number of iterations, the timerate command runs it for a fixed time. Additionally, the compiled variant of the script will be used during the entire measurement, as if the script were part of a compiled procedure, if the -direct option is not specified. The fixed time period and possibility of compilation allow for more precise results and prevent very long execution times by slow scripts, making it practical for measuring scripts with highly uncertain execution times. EXAMPLES Estimate how fast it takes for a simple Tcl for loop (including operations on variable i ) to count to ten: # calibrate timerate -calibrate {} # measure timerate { for {set i 0} {\\$i\\<10} {incr i} {} } 5000 Estimate how fast it takes for a simple Tcl for loop, ignoring the overhead of the management of the variable that controls the loop: # calibrate for overhead of variable operations set i 0; timerate -calibrate {expr {\\$i\\<10}; incr i} 1000 # measure timerate { for {set i 0} {\\$i\\<10} {incr i} {} } 5000 Estimate the speed of calculating the hour of the day using clock format only, ignoring overhead of the portion of the script that prepares the time for it to calculate: # calibrate timerate -calibrate {} # estimate overhead set tm 0 set ovh [lindex [ timerate { incr tm [expr {24*60*60}] }] 0] # measure using estimated overhead set tm 0 timerate -overhead \\$ovh { clock format \\$tm -format %H incr tm [expr {24*60*60}]; # overhead for this is ignored } 5000 SEE ALSO time(n) KEYWORDS performance measurement, script, time","title":"NAME"},{"location":"timerate/#name","text":"timerate - Calibrated performance measurements of script execution time","title":"NAME"},{"location":"timerate/#synopsis","text":"timerate script ? time ? ? max-count ? timerate ? -direct ? ? -overhead double ? script ? time ? ? max-count ? timerate ? -calibrate ? ? -direct ? script ? time ? ? max-count ?","title":"SYNOPSIS"},{"location":"timerate/#description","text":"The timerate command does calibrated performance measurement of a Tcl command or script, script . The script should be written so that it can be executed multiple times during the performance measurement process. Time is measured in elapsed time using the finest timer resolution as possible, not CPU time; if script interacts with the OS, the cost of that interaction is included. This command may be used to provide information as to how well a script or Tcl command is performing, and can help determine bottlenecks and fine-tune application performance. The first and second form will evaluate script until the interval time given in milliseconds elapses, or for 1000 milliseconds (1 second) if time is not specified. The parameter max-count could additionally impose a further restriction by the maximal number of iterations to evaluate the script. If max-count is specified, the evalution will stop either this count of iterations is reached or the time is exceeded. It will then return a canonical tcl-list of the form: 0.095977 \u00b5s/# 52095836 # 10419167 #/sec 5000.000 net-ms which indicates: the average amount of time required per iteration, in microseconds ([ lindex \\$result 0]) the count how many times it was executed ([ lindex \\$result 2]) the estimated rate per second ([ lindex \\$result 4]) the estimated real execution time without measurement overhead ([ lindex \\$result 6]) The following options may be supplied to the timerate command: -calibrate : To measure very fast scripts as exactly as possible, a calibration process may be required. The -calibrate option is used to calibrate timerate itself, calculating the estimated overhead of the given script as the default overhead for future invocations of the timerate command. If the time parameter is not specified, the calibrate procedure runs for up to 10 seconds. Note that calibration is not thread safe in the current implementation. -overhead double : The -overhead parameter supplies an estimate (in microseconds) of the measurement overhead of each iteration of the tested script. This quantity will be subtracted from the measured time prior to reporting results. This can be useful for removing the cost of interpreter state reset commands from the script being measured. -direct : The -direct option causes direct execution of the supplied script, without compilation, in a manner similar to the time command. It can be used to measure the cost of Tcl_EvalObjEx , of the invocation of canonical lists, and of the uncompiled versions of bytecoded commands. As opposed to the time commmand, which runs the tested script for a fixed number of iterations, the timerate command runs it for a fixed time. Additionally, the compiled variant of the script will be used during the entire measurement, as if the script were part of a compiled procedure, if the -direct option is not specified. The fixed time period and possibility of compilation allow for more precise results and prevent very long execution times by slow scripts, making it practical for measuring scripts with highly uncertain execution times.","title":"DESCRIPTION"},{"location":"timerate/#examples","text":"Estimate how fast it takes for a simple Tcl for loop (including operations on variable i ) to count to ten: # calibrate timerate -calibrate {} # measure timerate { for {set i 0} {\\$i\\<10} {incr i} {} } 5000 Estimate how fast it takes for a simple Tcl for loop, ignoring the overhead of the management of the variable that controls the loop: # calibrate for overhead of variable operations set i 0; timerate -calibrate {expr {\\$i\\<10}; incr i} 1000 # measure timerate { for {set i 0} {\\$i\\<10} {incr i} {} } 5000 Estimate the speed of calculating the hour of the day using clock format only, ignoring overhead of the portion of the script that prepares the time for it to calculate: # calibrate timerate -calibrate {} # estimate overhead set tm 0 set ovh [lindex [ timerate { incr tm [expr {24*60*60}] }] 0] # measure using estimated overhead set tm 0 timerate -overhead \\$ovh { clock format \\$tm -format %H incr tm [expr {24*60*60}]; # overhead for this is ignored } 5000","title":"EXAMPLES"},{"location":"timerate/#see-also","text":"time(n)","title":"SEE ALSO"},{"location":"timerate/#keywords","text":"performance measurement, script, time","title":"KEYWORDS"},{"location":"tm/","text":"NAME tm - Facilities for locating and loading of Tcl Modules SYNOPSIS ::tcl::tm::path add ?path...? ::tcl::tm::path remove ?path...? ::tcl::tm::path list ::tcl::tm::roots ?path...? DESCRIPTION This document describes the facilities for locating and loading Tcl Modules (see MODULE DEFINITION for the definition of a Tcl Module). The following commands are supported: ::tcl::tm::path add ? path ...? : The paths are added at the head to the list of module paths, in order of appearance. This means that the last argument ends up as the new head of the list. The command enforces the restriction that no path may be an ancestor directory of any other path on the list. If any of the new paths violates this restriction an error will be raised, before any of the paths have been added. In other words, if only one path argument violates the restriction then none will be added. If a path is already present as is, no error will be raised and no action will be taken. Paths are searched later in the order of their appearance in the list. As they are added to the front of the list they are searched in reverse order of addition. In other words, the paths added last are looked at first. ::tcl::tm::path remove ? path ...? : Removes the paths from the list of module paths. The command silently ignores all paths which are not on the list. ::tcl::tm::path list : Returns a list containing all registered module paths, in the order that they are searched for modules. ::tcl::tm::roots ? path ...? : Similar to path add , and layered on top of it. This command takes a list of paths, extends each with and for major version X of the Tcl interpreter and minor version y less than or equal to the minor version of the interpreter, and adds the resulting set of paths to the list of paths to search. This command is used internally by the system to set up the system-specific default paths. The command has been exposed to allow a build system to define additional root paths beyond those described by this document. MODULE DEFINITION A Tcl Module is a Tcl Package contained in a single file, and no other files required by it. This file has to be source able. In other words, a Tcl Module is always imported via: source module_file The load command is not directly used. This restriction is not an actual limitation, as some may believe. Ever since 8.4 the Tcl source command reads only until the first \\^Z character. This allows us to combine an arbitrary Tcl script with arbitrary binary data into one file, where the script processes the attached data in any it chooses to fully import and activate the package. The name of a module file has to match the regular expression: ([_[:alpha:]][:_[:alnum:]]*)-([[:digit:]].*)\\.tm The first capturing parentheses provides the name of the package, the second clause its version. In addition to matching the pattern, the extracted version number must not raise an error when used in the command: package vcompare \\$version 0 FINDING MODULES The directory tree for storing Tcl modules is separate from other parts of the filesystem and independent of auto_path . Tcl Modules are searched for in all directories listed in the result of the command ::tcl::tm::path list . This is called the Module path . Neither the auto_path nor the tcl_pkgPath variables are used. All directories on the module path have to obey one restriction: For any two directories, neither is an ancestor directory of the other. This is required to avoid ambiguities in package naming. If for example the two directories and were on the path a package named cool::ice could be found via the names cool::ice or ice , the latter potentially obscuring a package named ice , unqualified. Before the search is started, the name of the requested package is translated into a partial path, using the following algorithm: All occurrences of in the package name are replaced by the appropriate directory separator character for the platform we are on. On Unix, for example, this is Example: The requested package is encoding::base64 . The generated partial path is After this translation the package is looked for in all module paths, by combining them one-by-one, first to last with the partial path to form a complete search pattern. Note that the search algorithm rejects all files where the filename does not match the regular expression given in the section MODULE DEFINITION . For the remaining files provide scripts are generated and added to the package ifneeded database. The algorithm falls back to the previous unknown handler when none of the found module files satisfy the request. If the request was satisfied the fall-back is ignored. Note that packages in module form have no control over the index and provide script s entered into the package database for them. For a module file MF the index script is always: package ifneeded PNAME PVERSION [list source MF ] and the provide script embedded in the above is: source MF Both package name PNAME and package version PVERSION are extracted from the filename MF according to the definition below: MF = /module_path/ PNAME\u2032 - PVERSION .tm Where PNAME\u2032 is the partial path of the module as defined in section FINDING MODULES , and translated into PNAME by changing all directory separators to and module_path is the path (from the list of paths to search) that we found the module file under. Note also that we are here creating a connection between package names and paths. Tcl is case-sensitive when it comes to comparing package names, but there are filesystems which are not, like NTFS. Luckily these filesystems do store the case of the name, despite not using the information when comparing. Given the above we allow the names for packages in Tcl modules to have mixed-case, but also require that there are no collisions when comparing names in a case-insensitive manner. In other words, if a package Foo is deployed in the form of a Tcl Module, packages like foo , fOo , etc. are not allowed anymore. DEFAULT PATHS The default list of paths on the module path is computed by a tclsh as follows, where X is the major version of the Tcl interpreter and y is less than or equal to the minor version of the Tcl interpreter. All the default paths are added to the module path, even those paths which do not exist. Non-existent paths are filtered out during actual searches. This enables a user to create one of the paths searched when needed and all running applications will automatically pick up any modules placed in them. The paths are added in the order as they are listed below, and for lists of paths defined by an environment variable in the order they are found in the variable. SYSTEM SPECIFIC PATHS file normalize [info library]/../tcl X / X . y : In other words, the interpreter will look into a directory specified by its major version and whose minor versions are less than or equal to the minor version of the interpreter. For example for Tcl 8.4 the paths searched are: **\\[info library\\]/../tcl8/8.4** **\\[info library\\]/../tcl8/8.3** **\\[info library\\]/../tcl8/8.2** **\\[info library\\]/../tcl8/8.1** **\\[info library\\]/../tcl8/8.0** This definition assumes that a package defined for Tcl *X***.***y* can also be used by all interpreters which have the same major number *X* and a minor number greater than *y*. file normalize EXEC/tcl X / X . y : Where EXEC is file normalize [info nameofexecutable]/../lib or file normalize [::tcl::pkgconfig get libdir,runtime] This sets of paths is handled equivalently to the set coming before, except that it is anchored in **EXEC_PREFIX**. For a build with **PREFIX** = **EXEC_PREFIX** the two sets are identical. SITE SPECIFIC PATHS file normalize [info library]/../tcl X /site-tcl : Note that this is always a single entry because X is always a specific value (the current major version of Tcl). USER SPECIFIC PATHS \\$::env(TCL X _ y _TM_PATH) : A list of paths, separated by either : (Unix) or ; (Windows). This is user and site specific as this environment variable can be set not only by the user\\'s profile, but by system configuration scripts as well. \\$::env(TCL X . y _TM_PATH) : Same meaning and content as the previous variable. However the use of dot \\'.\\' to separate major and minor version number makes this name less to non-portable and its use is discouraged. Support of this variable has been kept only for backward compatibility with the original specification, i.e. TIP 189. These paths are seen and therefore shared by all Tcl shells in the \\$::env(PATH) of the user. Note that X and y follow the general rules set out above. In other words, Tcl 8.4, for example, will look at these 10 environment variables: \\$::env(TCL8.4_TM_PATH) \\$::env(TCL8_4_TM_PATH) \\$::env(TCL8.3_TM_PATH) \\$::env(TCL8_3_TM_PATH) \\$::env(TCL8.2_TM_PATH) \\$::env(TCL8_2_TM_PATH) \\$::env(TCL8.1_TM_PATH) \\$::env(TCL8_1_TM_PATH) \\$::env(TCL8.0_TM_PATH) \\$::env(TCL8_0_TM_PATH) SEE ALSO package(n), Tcl Improvement Proposal #189 (online at https://tip.tcl-lang.org/189.html), Tcl Improvement Proposal 190 (online at https://tip.tcl-lang.org/190.html) KEYWORDS modules, package","title":"NAME"},{"location":"tm/#name","text":"tm - Facilities for locating and loading of Tcl Modules","title":"NAME"},{"location":"tm/#synopsis","text":"::tcl::tm::path add ?path...? ::tcl::tm::path remove ?path...? ::tcl::tm::path list ::tcl::tm::roots ?path...?","title":"SYNOPSIS"},{"location":"tm/#description","text":"This document describes the facilities for locating and loading Tcl Modules (see MODULE DEFINITION for the definition of a Tcl Module). The following commands are supported: ::tcl::tm::path add ? path ...? : The paths are added at the head to the list of module paths, in order of appearance. This means that the last argument ends up as the new head of the list. The command enforces the restriction that no path may be an ancestor directory of any other path on the list. If any of the new paths violates this restriction an error will be raised, before any of the paths have been added. In other words, if only one path argument violates the restriction then none will be added. If a path is already present as is, no error will be raised and no action will be taken. Paths are searched later in the order of their appearance in the list. As they are added to the front of the list they are searched in reverse order of addition. In other words, the paths added last are looked at first. ::tcl::tm::path remove ? path ...? : Removes the paths from the list of module paths. The command silently ignores all paths which are not on the list. ::tcl::tm::path list : Returns a list containing all registered module paths, in the order that they are searched for modules. ::tcl::tm::roots ? path ...? : Similar to path add , and layered on top of it. This command takes a list of paths, extends each with and for major version X of the Tcl interpreter and minor version y less than or equal to the minor version of the interpreter, and adds the resulting set of paths to the list of paths to search. This command is used internally by the system to set up the system-specific default paths. The command has been exposed to allow a build system to define additional root paths beyond those described by this document.","title":"DESCRIPTION"},{"location":"tm/#module-definition","text":"A Tcl Module is a Tcl Package contained in a single file, and no other files required by it. This file has to be source able. In other words, a Tcl Module is always imported via: source module_file The load command is not directly used. This restriction is not an actual limitation, as some may believe. Ever since 8.4 the Tcl source command reads only until the first \\^Z character. This allows us to combine an arbitrary Tcl script with arbitrary binary data into one file, where the script processes the attached data in any it chooses to fully import and activate the package. The name of a module file has to match the regular expression: ([_[:alpha:]][:_[:alnum:]]*)-([[:digit:]].*)\\.tm The first capturing parentheses provides the name of the package, the second clause its version. In addition to matching the pattern, the extracted version number must not raise an error when used in the command: package vcompare \\$version 0","title":"MODULE DEFINITION"},{"location":"tm/#finding-modules","text":"The directory tree for storing Tcl modules is separate from other parts of the filesystem and independent of auto_path . Tcl Modules are searched for in all directories listed in the result of the command ::tcl::tm::path list . This is called the Module path . Neither the auto_path nor the tcl_pkgPath variables are used. All directories on the module path have to obey one restriction: For any two directories, neither is an ancestor directory of the other. This is required to avoid ambiguities in package naming. If for example the two directories and were on the path a package named cool::ice could be found via the names cool::ice or ice , the latter potentially obscuring a package named ice , unqualified. Before the search is started, the name of the requested package is translated into a partial path, using the following algorithm: All occurrences of in the package name are replaced by the appropriate directory separator character for the platform we are on. On Unix, for example, this is Example: The requested package is encoding::base64 . The generated partial path is After this translation the package is looked for in all module paths, by combining them one-by-one, first to last with the partial path to form a complete search pattern. Note that the search algorithm rejects all files where the filename does not match the regular expression given in the section MODULE DEFINITION . For the remaining files provide scripts are generated and added to the package ifneeded database. The algorithm falls back to the previous unknown handler when none of the found module files satisfy the request. If the request was satisfied the fall-back is ignored. Note that packages in module form have no control over the index and provide script s entered into the package database for them. For a module file MF the index script is always: package ifneeded PNAME PVERSION [list source MF ] and the provide script embedded in the above is: source MF Both package name PNAME and package version PVERSION are extracted from the filename MF according to the definition below: MF = /module_path/ PNAME\u2032 - PVERSION .tm Where PNAME\u2032 is the partial path of the module as defined in section FINDING MODULES , and translated into PNAME by changing all directory separators to and module_path is the path (from the list of paths to search) that we found the module file under. Note also that we are here creating a connection between package names and paths. Tcl is case-sensitive when it comes to comparing package names, but there are filesystems which are not, like NTFS. Luckily these filesystems do store the case of the name, despite not using the information when comparing. Given the above we allow the names for packages in Tcl modules to have mixed-case, but also require that there are no collisions when comparing names in a case-insensitive manner. In other words, if a package Foo is deployed in the form of a Tcl Module, packages like foo , fOo , etc. are not allowed anymore.","title":"FINDING MODULES"},{"location":"tm/#default-paths","text":"The default list of paths on the module path is computed by a tclsh as follows, where X is the major version of the Tcl interpreter and y is less than or equal to the minor version of the Tcl interpreter. All the default paths are added to the module path, even those paths which do not exist. Non-existent paths are filtered out during actual searches. This enables a user to create one of the paths searched when needed and all running applications will automatically pick up any modules placed in them. The paths are added in the order as they are listed below, and for lists of paths defined by an environment variable in the order they are found in the variable.","title":"DEFAULT PATHS"},{"location":"tm/#system-specific-paths","text":"file normalize [info library]/../tcl X / X . y : In other words, the interpreter will look into a directory specified by its major version and whose minor versions are less than or equal to the minor version of the interpreter. For example for Tcl 8.4 the paths searched are: **\\[info library\\]/../tcl8/8.4** **\\[info library\\]/../tcl8/8.3** **\\[info library\\]/../tcl8/8.2** **\\[info library\\]/../tcl8/8.1** **\\[info library\\]/../tcl8/8.0** This definition assumes that a package defined for Tcl *X***.***y* can also be used by all interpreters which have the same major number *X* and a minor number greater than *y*. file normalize EXEC/tcl X / X . y : Where EXEC is file normalize [info nameofexecutable]/../lib or file normalize [::tcl::pkgconfig get libdir,runtime] This sets of paths is handled equivalently to the set coming before, except that it is anchored in **EXEC_PREFIX**. For a build with **PREFIX** = **EXEC_PREFIX** the two sets are identical.","title":"SYSTEM SPECIFIC PATHS"},{"location":"tm/#site-specific-paths","text":"file normalize [info library]/../tcl X /site-tcl : Note that this is always a single entry because X is always a specific value (the current major version of Tcl).","title":"SITE SPECIFIC PATHS"},{"location":"tm/#user-specific-paths","text":"\\$::env(TCL X _ y _TM_PATH) : A list of paths, separated by either : (Unix) or ; (Windows). This is user and site specific as this environment variable can be set not only by the user\\'s profile, but by system configuration scripts as well. \\$::env(TCL X . y _TM_PATH) : Same meaning and content as the previous variable. However the use of dot \\'.\\' to separate major and minor version number makes this name less to non-portable and its use is discouraged. Support of this variable has been kept only for backward compatibility with the original specification, i.e. TIP 189. These paths are seen and therefore shared by all Tcl shells in the \\$::env(PATH) of the user. Note that X and y follow the general rules set out above. In other words, Tcl 8.4, for example, will look at these 10 environment variables: \\$::env(TCL8.4_TM_PATH) \\$::env(TCL8_4_TM_PATH) \\$::env(TCL8.3_TM_PATH) \\$::env(TCL8_3_TM_PATH) \\$::env(TCL8.2_TM_PATH) \\$::env(TCL8_2_TM_PATH) \\$::env(TCL8.1_TM_PATH) \\$::env(TCL8_1_TM_PATH) \\$::env(TCL8.0_TM_PATH) \\$::env(TCL8_0_TM_PATH)","title":"USER SPECIFIC PATHS"},{"location":"tm/#see-also","text":"package(n), Tcl Improvement Proposal #189 (online at https://tip.tcl-lang.org/189.html), Tcl Improvement Proposal","title":"SEE ALSO"},{"location":"tm/#190","text":"(online at https://tip.tcl-lang.org/190.html)","title":"190"},{"location":"tm/#keywords","text":"modules, package","title":"KEYWORDS"},{"location":"trace/","text":"NAME trace - Monitor variable accesses, command usages and command executions SYNOPSIS trace option ? arg arg ... ? DESCRIPTION This command causes Tcl commands to be executed whenever certain operations are invoked. The legal option s (which may be abbreviated) are: trace add type name ops ? args ? : Where type is command , execution , or variable . **trace add command** *name ops commandPrefix* : Arrange for *commandPrefix* to be executed (with additional arguments) whenever command *name* is modified in one of the ways given by the list *ops*. *Name* will be resolved using the usual namespace resolution rules used by commands. If the command does not exist, an error will be thrown. *Ops* indicates which operations are of interest, and is a list of one or more of the following items: **rename** : Invoke *commandPrefix* whenever the traced command is renamed. Note that renaming to the empty string is considered deletion, and will not be traced with **delete** : Invoke *commandPrefix* when the traced command is deleted. Commands can be deleted explicitly by using the **rename** command to rename the command to an empty string. Commands are also deleted when the interpreter is deleted, but traces will not be invoked because there is no interpreter in which to execute them. When the trace triggers, depending on the operations being traced, a number of arguments are appended to *commandPrefix* so that the actual command is as follows: *commandPrefix oldName newName op* *OldName* and *newName* give the traced command\\'s current (old) name, and the name to which it is being renamed (the empty string if this is a operation). *Op* indicates what operation is being performed on the command, and is one of **rename** or **delete** as defined above. The trace operation cannot be used to stop a command from being deleted. Tcl will always remove the command once the trace is complete. Recursive renaming or deleting will not cause further traces of the same type to be evaluated, so a delete trace which itself deletes the command, or a rename trace which itself renames the command will not cause further trace evaluations to occur. Both *oldName* and *newName* are fully qualified with any namespace(s) in which they appear. **trace add execution** *name ops commandPrefix* : Arrange for *commandPrefix* to be executed (with additional arguments) whenever command *name* is executed, with traces occurring at the points indicated by the list *ops*. *Name* will be resolved using the usual namespace resolution rules used by commands. If the command does not exist, an error will be thrown. *Ops* indicates which operations are of interest, and is a list of one or more of the following items: **enter** : Invoke *commandPrefix* whenever the command *name* is executed, just before the actual execution takes place. **leave** : Invoke *commandPrefix* whenever the command *name* is executed, just after the actual execution takes place. **enterstep** : Invoke *commandPrefix* for every Tcl command which is executed from the start of the execution of the procedure *name* until that procedure finishes. *CommandPrefix* is invoked just before the actual execution of the Tcl command being reported takes place. For example if we have then an *enterstep* trace would be invoked just before is executed. Setting an *enterstep* trace on a command *name* that does not refer to a procedure will not result in an error and is simply ignored. **leavestep** : Invoke *commandPrefix* for every Tcl command which is executed from the start of the execution of the procedure *name* until that procedure finishes. *CommandPrefix* is invoked just after the actual execution of the Tcl command being reported takes place. Setting a *leavestep* trace on a command *name* that does not refer to a procedure will not result in an error and is simply ignored. When the trace triggers, depending on the operations being traced, a number of arguments are appended to *commandPrefix* so that the actual command is as follows: For **enter** and **enterstep** operations: *commandPrefix command-string op* *Command-string* gives the complete current command being executed (the traced command for a **enter** operation, an arbitrary command for a **enterstep** operation), including all arguments in their fully expanded form. *Op* indicates what operation is being performed on the command execution, and is one of **enter** or **enterstep** as defined above. The trace operation can be used to stop the command from executing, by deleting the command in question. Of course when the command is subsequently executed, an error will occur. For **leave** and **leavestep** operations: *commandPrefix command-string code result op* *Command-string* gives the complete current command being executed (the traced command for a **enter** operation, an arbitrary command for a **enterstep** operation), including all arguments in their fully expanded form. *Code* gives the result code of that execution, and *result* the result string. *Op* indicates what operation is being performed on the command execution, and is one of **leave** or **leavestep** as defined above. Note that the creation of many **enterstep** or **leavestep** traces can lead to unintuitive results, since the invoked commands from one trace can themselves lead to further command invocations for other traces. *CommandPrefix* executes in the same context as the code that invoked the traced operation: thus the *commandPrefix*, if invoked from a procedure, will have access to the same local variables as code in the procedure. This context may be different than the context in which the trace was created. If *commandPrefix* invokes a procedure (which it normally does) then the procedure will have to use **upvar** or **uplevel** commands if it wishes to access the local variables of the code which invoked the trace operation. While *commandPrefix* is executing during an execution trace, traces on *name* are temporarily disabled. This allows the *commandPrefix* to execute *name* in its body without invoking any other traces again. If an error occurs while executing the *commandPrefix*, then the command *name* as a whole will return that same error. When multiple traces are set on *name*, then for *enter* and *enterstep* operations, the traced commands are invoked in the reverse order of how the traces were originally created; and for *leave* and *leavestep* operations, the traced commands are invoked in the original order of creation. The behavior of execution traces is currently undefined for a command *name* imported into another namespace. **trace add variable*** name ops commandPrefix* : Arrange for *commandPrefix* to be executed whenever variable *name* is accessed in one of the ways given by the list *ops*. *Name* may refer to a normal variable, an element of an array, or to an array as a whole (i.e. *name* may be just the name of an array, with no parenthesized index). If *name* refers to a whole array, then *commandPrefix* is invoked whenever any element of the array is manipulated. If the variable does not exist, it will be created but will not be given a value, so it will be visible to **namespace which** queries, but not to **info exists** queries. *Ops* indicates which operations are of interest, and is a list of one or more of the following items: **array** : Invoke *commandPrefix* whenever the variable is accessed or modified via the **array** command, provided that *name* is not a scalar variable at the time that the **array** command is invoked. If *name* is a scalar variable, the access via the **array** command will not trigger the trace. **read** : Invoke *commandPrefix* whenever the variable is read. **write** : Invoke *commandPrefix* whenever the variable is written. **unset** : Invoke *commandPrefix* whenever the variable is unset. Variables can be unset explicitly with the **unset** command, or implicitly when procedures return (all of their local variables are unset). Variables are also unset when interpreters are deleted, but traces will not be invoked because there is no interpreter in which to execute them. When the trace triggers, three arguments are appended to *commandPrefix* so that the actual command is as follows: *commandPrefix name1 name2 op* *Name1* gives the name for the variable being accessed. This is not necessarily the same as the name used in the **trace variable** command: the **upvar** command allows a procedure to reference a variable under a different name. If the trace was originally set on an array or array element, *name2* provides which index into the array was affected. This information is present even when *name1* refers to a scalar, which may happen if the **upvar** command was used to create a reference to a single array element. If an entire array is being deleted and the trace was registered on the overall array, rather than a single element, then *name1* gives the array name and *name2* is an empty string. *Op* indicates what operation is being performed on the variable, and is one of **read**, **write**, or **unset** as defined above. *CommandPrefix* executes in the same context as the code that invoked the traced operation: if the variable was accessed as part of a Tcl procedure, then *commandPrefix* will have access to the same local variables as code in the procedure. This context may be different than the context in which the trace was created. If *commandPrefix* invokes a procedure (which it normally does) then the procedure will have to use **upvar** or **uplevel** if it wishes to access the traced variable. Note also that *name1* may not necessarily be the same as the name used to set the trace on the variable; differences can occur if the access is made through a variable defined with the **upvar** command. For read and write traces, *commandPrefix* can modify the variable to affect the result of the traced operation. If *commandPrefix* modifies the value of a variable during a read or write trace, then the new value will be returned as the result of the traced operation. The return value from *commandPrefix* is ignored except that if it returns an error of any sort then the traced operation also returns an error with the same error message returned by the trace command (this mechanism can be used to implement read-only variables, for example). For write traces, *commandPrefix* is invoked after the variable\\'s value has been changed; it can write a new value into the variable to override the original value specified in the write operation. To implement read-only variables, *commandPrefix* will have to restore the old value of the variable. While *commandPrefix* is executing during a read or write trace, traces on the variable are temporarily disabled. This means that reads and writes invoked by *commandPrefix* will occur directly, without invoking *commandPrefix* (or any other traces) again. However, if *commandPrefix* unsets the variable then unset traces will be invoked. When an unset trace is invoked, the variable has already been deleted: it will appear to be undefined with no traces. If an unset occurs because of a procedure return, then the trace will be invoked in the variable context of the procedure being returned to: the stack frame of the returning procedure will no longer exist. Traces are not disabled during unset traces, so if an unset trace command creates a new trace and accesses the variable, the trace will be invoked. Any errors in unset traces are ignored. If there are multiple traces on a variable they are invoked in order of creation, most-recent first. If one trace returns an error, then no further traces are invoked for the variable. If an array element has a trace set, and there is also a trace set on the array as a whole, the trace on the overall array is invoked before the one on the element. Once created, the trace remains in effect either until the trace is removed with the **trace remove variable** command described below, until the variable is unset, or until the interpreter is deleted. Unsetting an element of array will remove any traces on that element, but will not remove traces on the overall array. This command returns an empty string. trace remove type name opList commandPrefix : Where type is either command , execution or variable . **trace remove command*** name opList commandPrefix* : If there is a trace set on command *name* with the operations and command given by *opList* and *commandPrefix*, then the trace is removed, so that *commandPrefix* will never again be invoked. Returns an empty string. If *name* does not exist, the command will throw an error. **trace remove execution*** name opList commandPrefix* : If there is a trace set on command *name* with the operations and command given by *opList* and *commandPrefix*, then the trace is removed, so that *commandPrefix* will never again be invoked. Returns an empty string. If *name* does not exist, the command will throw an error. **trace remove variable*** name opList commandPrefix* : If there is a trace set on variable *name* with the operations and command given by *opList* and *commandPrefix*, then the trace is removed, so that *commandPrefix* will never again be invoked. Returns an empty string. trace info type name : Where type is either command , execution or variable . **trace info command*** name* : Returns a list containing one element for each trace currently set on command *name*. Each element of the list is itself a list containing two elements, which are the *opList* and *commandPrefix* associated with the trace. If *name* does not have any traces set, then the result of the command will be an empty string. If *name* does not exist, the command will throw an error. **trace info execution*** name* : Returns a list containing one element for each trace currently set on command *name*. Each element of the list is itself a list containing two elements, which are the *opList* and *commandPrefix* associated with the trace. If *name* does not have any traces set, then the result of the command will be an empty string. If *name* does not exist, the command will throw an error. **trace info variable*** name* : Returns a list containing one element for each trace currently set on variable *name*. Each element of the list is itself a list containing two elements, which are the *opList* and *commandPrefix* associated with the trace. If *name* does not exist or does not have any traces set, then the result of the command will be an empty string. For backwards compatibility, three other subcommands are available: trace variable name ops command : This is equivalent to trace add variable name ops command . trace vdelete name ops command : This is equivalent to trace remove variable name ops command trace vinfo name : This is equivalent to trace info variable name These subcommands are deprecated and will likely be removed in a future version of Tcl. They use an older syntax in which array , read , write , unset are replaced by a , r , w and u respectively, and the ops argument is not a list, but simply a string concatenation of the operations, such as rwua . EXAMPLES Print a message whenever either of the global variables foo and bar are updated, even if they have a different local name at the time (which can be done with the upvar command): proc tracer {varname args} { upvar #0 \\$varname var puts \\\"\\$varname was updated to be \\\\\"\\$var\\\\\"\\\" } trace add variable foo write \\\"tracer foo\\\" trace add variable bar write \\\"tracer bar\\\" Ensure that the global variable foobar always contains the product of the global variables foo and bar : proc doMult args { global foo bar foobar set foobar [expr {\\$foo * \\$bar}] } trace add variable foo write doMult trace add variable bar write doMult Print a trace of what commands are executed during the processing of a Tcl procedure: proc x {} { y } proc y {} { z } proc z {} { puts hello } proc report args {puts [info level 0]} trace add execution x enterstep report x \u2192 report y enterstep report z enterstep report {puts hello} enterstep hello SEE ALSO set(n), unset(n) KEYWORDS read, command, rename, variable, write, trace, unset","title":"NAME"},{"location":"trace/#name","text":"trace - Monitor variable accesses, command usages and command executions","title":"NAME"},{"location":"trace/#synopsis","text":"trace option ? arg arg ... ?","title":"SYNOPSIS"},{"location":"trace/#description","text":"This command causes Tcl commands to be executed whenever certain operations are invoked. The legal option s (which may be abbreviated) are: trace add type name ops ? args ? : Where type is command , execution , or variable . **trace add command** *name ops commandPrefix* : Arrange for *commandPrefix* to be executed (with additional arguments) whenever command *name* is modified in one of the ways given by the list *ops*. *Name* will be resolved using the usual namespace resolution rules used by commands. If the command does not exist, an error will be thrown. *Ops* indicates which operations are of interest, and is a list of one or more of the following items: **rename** : Invoke *commandPrefix* whenever the traced command is renamed. Note that renaming to the empty string is considered deletion, and will not be traced with **delete** : Invoke *commandPrefix* when the traced command is deleted. Commands can be deleted explicitly by using the **rename** command to rename the command to an empty string. Commands are also deleted when the interpreter is deleted, but traces will not be invoked because there is no interpreter in which to execute them. When the trace triggers, depending on the operations being traced, a number of arguments are appended to *commandPrefix* so that the actual command is as follows: *commandPrefix oldName newName op* *OldName* and *newName* give the traced command\\'s current (old) name, and the name to which it is being renamed (the empty string if this is a operation). *Op* indicates what operation is being performed on the command, and is one of **rename** or **delete** as defined above. The trace operation cannot be used to stop a command from being deleted. Tcl will always remove the command once the trace is complete. Recursive renaming or deleting will not cause further traces of the same type to be evaluated, so a delete trace which itself deletes the command, or a rename trace which itself renames the command will not cause further trace evaluations to occur. Both *oldName* and *newName* are fully qualified with any namespace(s) in which they appear. **trace add execution** *name ops commandPrefix* : Arrange for *commandPrefix* to be executed (with additional arguments) whenever command *name* is executed, with traces occurring at the points indicated by the list *ops*. *Name* will be resolved using the usual namespace resolution rules used by commands. If the command does not exist, an error will be thrown. *Ops* indicates which operations are of interest, and is a list of one or more of the following items: **enter** : Invoke *commandPrefix* whenever the command *name* is executed, just before the actual execution takes place. **leave** : Invoke *commandPrefix* whenever the command *name* is executed, just after the actual execution takes place. **enterstep** : Invoke *commandPrefix* for every Tcl command which is executed from the start of the execution of the procedure *name* until that procedure finishes. *CommandPrefix* is invoked just before the actual execution of the Tcl command being reported takes place. For example if we have then an *enterstep* trace would be invoked just before is executed. Setting an *enterstep* trace on a command *name* that does not refer to a procedure will not result in an error and is simply ignored. **leavestep** : Invoke *commandPrefix* for every Tcl command which is executed from the start of the execution of the procedure *name* until that procedure finishes. *CommandPrefix* is invoked just after the actual execution of the Tcl command being reported takes place. Setting a *leavestep* trace on a command *name* that does not refer to a procedure will not result in an error and is simply ignored. When the trace triggers, depending on the operations being traced, a number of arguments are appended to *commandPrefix* so that the actual command is as follows: For **enter** and **enterstep** operations: *commandPrefix command-string op* *Command-string* gives the complete current command being executed (the traced command for a **enter** operation, an arbitrary command for a **enterstep** operation), including all arguments in their fully expanded form. *Op* indicates what operation is being performed on the command execution, and is one of **enter** or **enterstep** as defined above. The trace operation can be used to stop the command from executing, by deleting the command in question. Of course when the command is subsequently executed, an error will occur. For **leave** and **leavestep** operations: *commandPrefix command-string code result op* *Command-string* gives the complete current command being executed (the traced command for a **enter** operation, an arbitrary command for a **enterstep** operation), including all arguments in their fully expanded form. *Code* gives the result code of that execution, and *result* the result string. *Op* indicates what operation is being performed on the command execution, and is one of **leave** or **leavestep** as defined above. Note that the creation of many **enterstep** or **leavestep** traces can lead to unintuitive results, since the invoked commands from one trace can themselves lead to further command invocations for other traces. *CommandPrefix* executes in the same context as the code that invoked the traced operation: thus the *commandPrefix*, if invoked from a procedure, will have access to the same local variables as code in the procedure. This context may be different than the context in which the trace was created. If *commandPrefix* invokes a procedure (which it normally does) then the procedure will have to use **upvar** or **uplevel** commands if it wishes to access the local variables of the code which invoked the trace operation. While *commandPrefix* is executing during an execution trace, traces on *name* are temporarily disabled. This allows the *commandPrefix* to execute *name* in its body without invoking any other traces again. If an error occurs while executing the *commandPrefix*, then the command *name* as a whole will return that same error. When multiple traces are set on *name*, then for *enter* and *enterstep* operations, the traced commands are invoked in the reverse order of how the traces were originally created; and for *leave* and *leavestep* operations, the traced commands are invoked in the original order of creation. The behavior of execution traces is currently undefined for a command *name* imported into another namespace. **trace add variable*** name ops commandPrefix* : Arrange for *commandPrefix* to be executed whenever variable *name* is accessed in one of the ways given by the list *ops*. *Name* may refer to a normal variable, an element of an array, or to an array as a whole (i.e. *name* may be just the name of an array, with no parenthesized index). If *name* refers to a whole array, then *commandPrefix* is invoked whenever any element of the array is manipulated. If the variable does not exist, it will be created but will not be given a value, so it will be visible to **namespace which** queries, but not to **info exists** queries. *Ops* indicates which operations are of interest, and is a list of one or more of the following items: **array** : Invoke *commandPrefix* whenever the variable is accessed or modified via the **array** command, provided that *name* is not a scalar variable at the time that the **array** command is invoked. If *name* is a scalar variable, the access via the **array** command will not trigger the trace. **read** : Invoke *commandPrefix* whenever the variable is read. **write** : Invoke *commandPrefix* whenever the variable is written. **unset** : Invoke *commandPrefix* whenever the variable is unset. Variables can be unset explicitly with the **unset** command, or implicitly when procedures return (all of their local variables are unset). Variables are also unset when interpreters are deleted, but traces will not be invoked because there is no interpreter in which to execute them. When the trace triggers, three arguments are appended to *commandPrefix* so that the actual command is as follows: *commandPrefix name1 name2 op* *Name1* gives the name for the variable being accessed. This is not necessarily the same as the name used in the **trace variable** command: the **upvar** command allows a procedure to reference a variable under a different name. If the trace was originally set on an array or array element, *name2* provides which index into the array was affected. This information is present even when *name1* refers to a scalar, which may happen if the **upvar** command was used to create a reference to a single array element. If an entire array is being deleted and the trace was registered on the overall array, rather than a single element, then *name1* gives the array name and *name2* is an empty string. *Op* indicates what operation is being performed on the variable, and is one of **read**, **write**, or **unset** as defined above. *CommandPrefix* executes in the same context as the code that invoked the traced operation: if the variable was accessed as part of a Tcl procedure, then *commandPrefix* will have access to the same local variables as code in the procedure. This context may be different than the context in which the trace was created. If *commandPrefix* invokes a procedure (which it normally does) then the procedure will have to use **upvar** or **uplevel** if it wishes to access the traced variable. Note also that *name1* may not necessarily be the same as the name used to set the trace on the variable; differences can occur if the access is made through a variable defined with the **upvar** command. For read and write traces, *commandPrefix* can modify the variable to affect the result of the traced operation. If *commandPrefix* modifies the value of a variable during a read or write trace, then the new value will be returned as the result of the traced operation. The return value from *commandPrefix* is ignored except that if it returns an error of any sort then the traced operation also returns an error with the same error message returned by the trace command (this mechanism can be used to implement read-only variables, for example). For write traces, *commandPrefix* is invoked after the variable\\'s value has been changed; it can write a new value into the variable to override the original value specified in the write operation. To implement read-only variables, *commandPrefix* will have to restore the old value of the variable. While *commandPrefix* is executing during a read or write trace, traces on the variable are temporarily disabled. This means that reads and writes invoked by *commandPrefix* will occur directly, without invoking *commandPrefix* (or any other traces) again. However, if *commandPrefix* unsets the variable then unset traces will be invoked. When an unset trace is invoked, the variable has already been deleted: it will appear to be undefined with no traces. If an unset occurs because of a procedure return, then the trace will be invoked in the variable context of the procedure being returned to: the stack frame of the returning procedure will no longer exist. Traces are not disabled during unset traces, so if an unset trace command creates a new trace and accesses the variable, the trace will be invoked. Any errors in unset traces are ignored. If there are multiple traces on a variable they are invoked in order of creation, most-recent first. If one trace returns an error, then no further traces are invoked for the variable. If an array element has a trace set, and there is also a trace set on the array as a whole, the trace on the overall array is invoked before the one on the element. Once created, the trace remains in effect either until the trace is removed with the **trace remove variable** command described below, until the variable is unset, or until the interpreter is deleted. Unsetting an element of array will remove any traces on that element, but will not remove traces on the overall array. This command returns an empty string. trace remove type name opList commandPrefix : Where type is either command , execution or variable . **trace remove command*** name opList commandPrefix* : If there is a trace set on command *name* with the operations and command given by *opList* and *commandPrefix*, then the trace is removed, so that *commandPrefix* will never again be invoked. Returns an empty string. If *name* does not exist, the command will throw an error. **trace remove execution*** name opList commandPrefix* : If there is a trace set on command *name* with the operations and command given by *opList* and *commandPrefix*, then the trace is removed, so that *commandPrefix* will never again be invoked. Returns an empty string. If *name* does not exist, the command will throw an error. **trace remove variable*** name opList commandPrefix* : If there is a trace set on variable *name* with the operations and command given by *opList* and *commandPrefix*, then the trace is removed, so that *commandPrefix* will never again be invoked. Returns an empty string. trace info type name : Where type is either command , execution or variable . **trace info command*** name* : Returns a list containing one element for each trace currently set on command *name*. Each element of the list is itself a list containing two elements, which are the *opList* and *commandPrefix* associated with the trace. If *name* does not have any traces set, then the result of the command will be an empty string. If *name* does not exist, the command will throw an error. **trace info execution*** name* : Returns a list containing one element for each trace currently set on command *name*. Each element of the list is itself a list containing two elements, which are the *opList* and *commandPrefix* associated with the trace. If *name* does not have any traces set, then the result of the command will be an empty string. If *name* does not exist, the command will throw an error. **trace info variable*** name* : Returns a list containing one element for each trace currently set on variable *name*. Each element of the list is itself a list containing two elements, which are the *opList* and *commandPrefix* associated with the trace. If *name* does not exist or does not have any traces set, then the result of the command will be an empty string. For backwards compatibility, three other subcommands are available: trace variable name ops command : This is equivalent to trace add variable name ops command . trace vdelete name ops command : This is equivalent to trace remove variable name ops command trace vinfo name : This is equivalent to trace info variable name These subcommands are deprecated and will likely be removed in a future version of Tcl. They use an older syntax in which array , read , write , unset are replaced by a , r , w and u respectively, and the ops argument is not a list, but simply a string concatenation of the operations, such as rwua .","title":"DESCRIPTION"},{"location":"trace/#examples","text":"Print a message whenever either of the global variables foo and bar are updated, even if they have a different local name at the time (which can be done with the upvar command): proc tracer {varname args} { upvar #0 \\$varname var puts \\\"\\$varname was updated to be \\\\\"\\$var\\\\\"\\\" } trace add variable foo write \\\"tracer foo\\\" trace add variable bar write \\\"tracer bar\\\" Ensure that the global variable foobar always contains the product of the global variables foo and bar : proc doMult args { global foo bar foobar set foobar [expr {\\$foo * \\$bar}] } trace add variable foo write doMult trace add variable bar write doMult Print a trace of what commands are executed during the processing of a Tcl procedure: proc x {} { y } proc y {} { z } proc z {} { puts hello } proc report args {puts [info level 0]} trace add execution x enterstep report x \u2192 report y enterstep report z enterstep report {puts hello} enterstep hello","title":"EXAMPLES"},{"location":"trace/#see-also","text":"set(n), unset(n)","title":"SEE ALSO"},{"location":"trace/#keywords","text":"read, command, rename, variable, write, trace, unset","title":"KEYWORDS"},{"location":"transchan/","text":"NAME transchan - command handler API of channel transforms SYNOPSIS cmdPrefix option ? arg arg ... ? DESCRIPTION The Tcl-level handler for a channel transformation has to be a command with subcommands (termed an ensemble despite not implying that it must be created with namespace ensemble create ; this mechanism is not tied to namespace ensemble in any way). Note that cmdPrefix is whatever was specified in the call to chan push , and may consist of multiple arguments; this will be expanded to multiple words in place of the prefix. Of all the possible subcommands, the handler must support initialize and finalize . Transformations for writable channels must also support write , and transformations for readable channels must also support read . Note that in the descriptions below cmdPrefix may be more than one word, and handle is the value returned by the chan push call used to create the transformation. GENERIC SUBCOMMANDS The following subcommands are relevant to all types of channel. cmdPrefix clear handle : This optional subcommand is called to signify to the transformation that any data stored in internal buffers (either incoming or outgoing) must be cleared. It is called when a chan seek is performed on the channel being transformed. cmdPrefix finalize handle : This mandatory subcommand is called last for the given handle , and then never again, and it exists to allow for cleaning up any Tcl-level data structures associated with the transformation. Warning! Any errors thrown by this subcommand will be ignored. It is not guaranteed to be called if the interpreter is deleted. cmdPrefix initialize handle mode : This mandatory subcommand is called first, and then never again (for the given handle ). Its responsibility is to initialize all parts of the transformation at the Tcl level. The mode is a list containing any of read and write . **write** : implies that the channel is writable. **read** : implies that the channel is readable. The return value of the subcommand should be a list containing the names of all subcommands supported by this handler. Any error thrown by the subcommand will prevent the creation of the transformation. The thrown error will appear as error thrown by **chan push**. READ-RELATED SUBCOMMANDS These subcommands are used for handling transformations applied to readable channels; though strictly read is optional, it must be supported if any of the others is or the channel will be made non-readable. cmdPrefix drain handle : This optional subcommand is called whenever data in the transformation input (i.e. read) buffer has to be forced upward, i.e. towards the user or script. The result returned by the method is taken as the binary data to push upward to the level above this transformation (the reader or a higher-level transformation). In other words, when this method is called the transformation cannot defer the actual transformation operation anymore and has to transform all data waiting in its internal read buffers and return the result of that action. cmdPrefix limit? handle : This optional subcommand is called to allow the Tcl I/O engine to determine how far ahead it should read. If present, it should return an integer number greater than zero which indicates how many bytes ahead should be read, or an integer less than zero to indicate that the I/O engine may read as far ahead as it likes. cmdPrefix read handle buffer : This subcommand, which must be present if the transformation is to work with readable channels, is called whenever the base channel, or a transformation below this transformation, pushes data upward. The buffer contains the binary data which has been given to us from below. It is the responsibility of this subcommand to actually transform the data. The result returned by the subcommand is taken as the binary data to push further upward to the transformation above this transformation. This can also be the user or script that originally read from the channel. Note that the result is allowed to be empty, or even less than the data we received; the transformation is not required to transform everything given to it right now. It is allowed to store incoming data in internal buffers and to defer the actual transformation until it has more data. WRITE-RELATED SUBCOMMANDS These subcommands are used for handling transformations applied to writable channels; though strictly write is optional, it must be supported if any of the others is or the channel will be made non-writable. cmdPrefix flush handle : This optional subcommand is called whenever data in the transformation \\'write\\' buffer has to be forced downward, i.e. towards the base channel. The result returned by the subcommand is taken as the binary data to write to the transformation below the current transformation. This can be the base channel as well. In other words, when this subcommand is called the transformation cannot defer the actual transformation operation anymore and has to transform all data waiting in its internal write buffers and return the result of that action. cmdPrefix write handle buffer : This subcommand, which must be present if the transformation is to work with writable channels, is called whenever the user, or a transformation above this transformation, writes data downward. The buffer contains the binary data which has been written to us. It is the responsibility of this subcommand to actually transform the data. The result returned by the subcommand is taken as the binary data to write to the transformation below this transformation. This can be the base channel as well. Note that the result is allowed to be empty, or less than the data we got; the transformation is not required to transform everything which was written to it right now. It is allowed to store this data in internal buffers and to defer the actual transformation until it has more data. SEE ALSO chan(n), refchan(n) KEYWORDS API, channel, ensemble, prefix, transformation","title":"NAME"},{"location":"transchan/#name","text":"transchan - command handler API of channel transforms","title":"NAME"},{"location":"transchan/#synopsis","text":"cmdPrefix option ? arg arg ... ?","title":"SYNOPSIS"},{"location":"transchan/#description","text":"The Tcl-level handler for a channel transformation has to be a command with subcommands (termed an ensemble despite not implying that it must be created with namespace ensemble create ; this mechanism is not tied to namespace ensemble in any way). Note that cmdPrefix is whatever was specified in the call to chan push , and may consist of multiple arguments; this will be expanded to multiple words in place of the prefix. Of all the possible subcommands, the handler must support initialize and finalize . Transformations for writable channels must also support write , and transformations for readable channels must also support read . Note that in the descriptions below cmdPrefix may be more than one word, and handle is the value returned by the chan push call used to create the transformation.","title":"DESCRIPTION"},{"location":"transchan/#generic-subcommands","text":"The following subcommands are relevant to all types of channel. cmdPrefix clear handle : This optional subcommand is called to signify to the transformation that any data stored in internal buffers (either incoming or outgoing) must be cleared. It is called when a chan seek is performed on the channel being transformed. cmdPrefix finalize handle : This mandatory subcommand is called last for the given handle , and then never again, and it exists to allow for cleaning up any Tcl-level data structures associated with the transformation. Warning! Any errors thrown by this subcommand will be ignored. It is not guaranteed to be called if the interpreter is deleted. cmdPrefix initialize handle mode : This mandatory subcommand is called first, and then never again (for the given handle ). Its responsibility is to initialize all parts of the transformation at the Tcl level. The mode is a list containing any of read and write . **write** : implies that the channel is writable. **read** : implies that the channel is readable. The return value of the subcommand should be a list containing the names of all subcommands supported by this handler. Any error thrown by the subcommand will prevent the creation of the transformation. The thrown error will appear as error thrown by **chan push**.","title":"GENERIC SUBCOMMANDS"},{"location":"transchan/#read-related-subcommands","text":"These subcommands are used for handling transformations applied to readable channels; though strictly read is optional, it must be supported if any of the others is or the channel will be made non-readable. cmdPrefix drain handle : This optional subcommand is called whenever data in the transformation input (i.e. read) buffer has to be forced upward, i.e. towards the user or script. The result returned by the method is taken as the binary data to push upward to the level above this transformation (the reader or a higher-level transformation). In other words, when this method is called the transformation cannot defer the actual transformation operation anymore and has to transform all data waiting in its internal read buffers and return the result of that action. cmdPrefix limit? handle : This optional subcommand is called to allow the Tcl I/O engine to determine how far ahead it should read. If present, it should return an integer number greater than zero which indicates how many bytes ahead should be read, or an integer less than zero to indicate that the I/O engine may read as far ahead as it likes. cmdPrefix read handle buffer : This subcommand, which must be present if the transformation is to work with readable channels, is called whenever the base channel, or a transformation below this transformation, pushes data upward. The buffer contains the binary data which has been given to us from below. It is the responsibility of this subcommand to actually transform the data. The result returned by the subcommand is taken as the binary data to push further upward to the transformation above this transformation. This can also be the user or script that originally read from the channel. Note that the result is allowed to be empty, or even less than the data we received; the transformation is not required to transform everything given to it right now. It is allowed to store incoming data in internal buffers and to defer the actual transformation until it has more data.","title":"READ-RELATED SUBCOMMANDS"},{"location":"transchan/#write-related-subcommands","text":"These subcommands are used for handling transformations applied to writable channels; though strictly write is optional, it must be supported if any of the others is or the channel will be made non-writable. cmdPrefix flush handle : This optional subcommand is called whenever data in the transformation \\'write\\' buffer has to be forced downward, i.e. towards the base channel. The result returned by the subcommand is taken as the binary data to write to the transformation below the current transformation. This can be the base channel as well. In other words, when this subcommand is called the transformation cannot defer the actual transformation operation anymore and has to transform all data waiting in its internal write buffers and return the result of that action. cmdPrefix write handle buffer : This subcommand, which must be present if the transformation is to work with writable channels, is called whenever the user, or a transformation above this transformation, writes data downward. The buffer contains the binary data which has been written to us. It is the responsibility of this subcommand to actually transform the data. The result returned by the subcommand is taken as the binary data to write to the transformation below this transformation. This can be the base channel as well. Note that the result is allowed to be empty, or less than the data we got; the transformation is not required to transform everything which was written to it right now. It is allowed to store this data in internal buffers and to defer the actual transformation until it has more data.","title":"WRITE-RELATED SUBCOMMANDS"},{"location":"transchan/#see-also","text":"chan(n), refchan(n)","title":"SEE ALSO"},{"location":"transchan/#keywords","text":"API, channel, ensemble, prefix, transformation","title":"KEYWORDS"},{"location":"try/","text":"NAME try - Trap and process errors and exceptions SYNOPSIS try body ? handler... ? ? finally script ? DESCRIPTION This command executes the script body and, depending on what the outcome of that script is (normal exit, error, or some other exceptional result), runs a handler script to deal with the case. Once that has all happened, if the finally clause is present, the script it includes will be run and the result of the handler (or the body if no handler matched) is allowed to continue to propagate. Note that the finally clause is processed even if an error occurs and irrespective of which, if any, handler is used. The handler clauses are each expressed as several words, and must have one of the following forms: on code variableList script : This clause matches if the evaluation of body completed with the exception code code . The code may be expressed as an integer or one of the following literal words: ok , error , return , break , or continue . Those literals correspond to the integers 0 through 4 respectively. trap pattern variableList script : This clause matches if the evaluation of body resulted in an error and the prefix of the -errorcode from the interpreter\\'s status dictionary is equal to the pattern . The number of prefix words taken from the -errorcode is equal to the list-length of pattern , and inter-word spaces are normalized in both the -errorcode and pattern before comparison. The variableList word in each handler is always interpreted as a list of variable names. If the first word of the list is present and non-empty, it names a variable into which the result of the evaluation of body (from the main try ) will be placed; this will contain the human-readable form of any errors. If the second word of the list is present and non-empty, it names a variable into which the options dictionary of the interpreter at the moment of completion of execution of body will be placed. The script word of each handler is also always interpreted the same: as a Tcl script to evaluate if the clause is matched. If script is a literal and the handler is not the last one, the script of the following handler is invoked instead (just like with the switch command). Note that handler clauses are matched against in order, and that the first matching one is always selected. At most one handler clause will selected. As a consequence, an on error will mask any subsequent trap in the try . Also note that on error is equivalent to trap {} . If an exception (i.e. any non- ok result) occurs during the evaluation of either the handler or the finally clause, the original exception\\'s status dictionary will be added to the new exception\\'s status dictionary under the -during key. EXAMPLES Ensure that a file is closed no matter what: set f [open /some/file/name a] try { puts \\$f \\\"some message\\\" # ... } finally { close \\$f } Handle different reasons for a file to not be openable for reading: try { set f [open /some/file/name r] } trap {POSIX EISDIR} {} { puts \\\"failed to open /some/file/name: it\\'s a directory\\\" } trap {POSIX ENOENT} {} { puts \\\"failed to open /some/file/name: it doesn\\'t exist\\\" } SEE ALSO catch(n), error(n), return(n), throw(n) KEYWORDS cleanup, error, exception, final, resource management","title":"NAME"},{"location":"try/#name","text":"try - Trap and process errors and exceptions","title":"NAME"},{"location":"try/#synopsis","text":"try body ? handler... ? ? finally script ?","title":"SYNOPSIS"},{"location":"try/#description","text":"This command executes the script body and, depending on what the outcome of that script is (normal exit, error, or some other exceptional result), runs a handler script to deal with the case. Once that has all happened, if the finally clause is present, the script it includes will be run and the result of the handler (or the body if no handler matched) is allowed to continue to propagate. Note that the finally clause is processed even if an error occurs and irrespective of which, if any, handler is used. The handler clauses are each expressed as several words, and must have one of the following forms: on code variableList script : This clause matches if the evaluation of body completed with the exception code code . The code may be expressed as an integer or one of the following literal words: ok , error , return , break , or continue . Those literals correspond to the integers 0 through 4 respectively. trap pattern variableList script : This clause matches if the evaluation of body resulted in an error and the prefix of the -errorcode from the interpreter\\'s status dictionary is equal to the pattern . The number of prefix words taken from the -errorcode is equal to the list-length of pattern , and inter-word spaces are normalized in both the -errorcode and pattern before comparison. The variableList word in each handler is always interpreted as a list of variable names. If the first word of the list is present and non-empty, it names a variable into which the result of the evaluation of body (from the main try ) will be placed; this will contain the human-readable form of any errors. If the second word of the list is present and non-empty, it names a variable into which the options dictionary of the interpreter at the moment of completion of execution of body will be placed. The script word of each handler is also always interpreted the same: as a Tcl script to evaluate if the clause is matched. If script is a literal and the handler is not the last one, the script of the following handler is invoked instead (just like with the switch command). Note that handler clauses are matched against in order, and that the first matching one is always selected. At most one handler clause will selected. As a consequence, an on error will mask any subsequent trap in the try . Also note that on error is equivalent to trap {} . If an exception (i.e. any non- ok result) occurs during the evaluation of either the handler or the finally clause, the original exception\\'s status dictionary will be added to the new exception\\'s status dictionary under the -during key.","title":"DESCRIPTION"},{"location":"try/#examples","text":"Ensure that a file is closed no matter what: set f [open /some/file/name a] try { puts \\$f \\\"some message\\\" # ... } finally { close \\$f } Handle different reasons for a file to not be openable for reading: try { set f [open /some/file/name r] } trap {POSIX EISDIR} {} { puts \\\"failed to open /some/file/name: it\\'s a directory\\\" } trap {POSIX ENOENT} {} { puts \\\"failed to open /some/file/name: it doesn\\'t exist\\\" }","title":"EXAMPLES"},{"location":"try/#see-also","text":"catch(n), error(n), return(n), throw(n)","title":"SEE ALSO"},{"location":"try/#keywords","text":"cleanup, error, exception, final, resource management","title":"KEYWORDS"},{"location":"unknown/","text":"NAME unknown - Handle attempts to use non-existent commands SYNOPSIS unknown cmdName ? arg arg ... ? DESCRIPTION This command is invoked by the Tcl interpreter whenever a script tries to invoke a command that does not exist. The default implementation of unknown is a library procedure defined when Tcl initializes an interpreter. You can override the default unknown to change its functionality, or you can register a new handler for individual namespaces using the namespace unknown command. Note that there is no default implementation of unknown in a safe interpreter. If the Tcl interpreter encounters a command name for which there is not a defined command (in either the current namespace, or the global namespace), then Tcl checks for the existence of an unknown handler for the current namespace. By default, this handler is a command named ::unknown . If there is no such command, then the interpreter returns an error. If the unknown command exists (or a new handler has been registered for the current namespace), then it is invoked with arguments consisting of the fully-substituted name and arguments for the original non-existent command. The unknown command typically does things like searching through library directories for a command procedure with the name cmdName , or expanding abbreviated command names to full-length, or automatically executing unknown commands as sub-processes. In some cases (such as expanding abbreviations) unknown will change the original command slightly and then (re-)execute it. The result of the unknown command is used as the result for the original non-existent command. The default implementation of unknown behaves as follows. It first calls the auto_load library procedure to load the command. If this succeeds, then it executes the original command with its original arguments. If the auto-load fails then unknown calls auto_execok to see if there is an executable file by the name cmd . If so, it invokes the Tcl exec command with cmd and all the args as arguments. If cmd cannot be auto-executed, unknown checks to see if the command was invoked at top-level and outside of any script. If so, then unknown takes two additional steps. First, it sees if cmd has one of the following three forms: !! , ! event , or \\^ old \\^ new ? \\^ ?. If so, then unknown carries out history substitution in the same way that csh would for these constructs. Finally, unknown checks to see if cmd is a unique abbreviation for an existing Tcl command. If so, it expands the command name and executes the command with the original arguments. If none of the above efforts has been able to execute the command, unknown generates an error return. If the global variable auto_noload is defined, then the auto-load step is skipped. If the global variable auto_noexec is defined then the auto-exec step is skipped. Under normal circumstances the return value from unknown is the return value from the command that was eventually executed. EXAMPLE Arrange for the unknown command to have its standard behavior except for first logging the fact that a command was not found: # Save the original one so we can chain to it rename unknown _original_unknown # Provide our own implementation proc unknown args { puts stderr \\\"WARNING: unknown command: \\$args\\\" uplevel 1 [list _original_unknown {*}\\$args] } SEE ALSO info(n), proc(n), interp(n), library(n), namespace(n) KEYWORDS error, non-existent command, unknown","title":"NAME"},{"location":"unknown/#name","text":"unknown - Handle attempts to use non-existent commands","title":"NAME"},{"location":"unknown/#synopsis","text":"unknown cmdName ? arg arg ... ?","title":"SYNOPSIS"},{"location":"unknown/#description","text":"This command is invoked by the Tcl interpreter whenever a script tries to invoke a command that does not exist. The default implementation of unknown is a library procedure defined when Tcl initializes an interpreter. You can override the default unknown to change its functionality, or you can register a new handler for individual namespaces using the namespace unknown command. Note that there is no default implementation of unknown in a safe interpreter. If the Tcl interpreter encounters a command name for which there is not a defined command (in either the current namespace, or the global namespace), then Tcl checks for the existence of an unknown handler for the current namespace. By default, this handler is a command named ::unknown . If there is no such command, then the interpreter returns an error. If the unknown command exists (or a new handler has been registered for the current namespace), then it is invoked with arguments consisting of the fully-substituted name and arguments for the original non-existent command. The unknown command typically does things like searching through library directories for a command procedure with the name cmdName , or expanding abbreviated command names to full-length, or automatically executing unknown commands as sub-processes. In some cases (such as expanding abbreviations) unknown will change the original command slightly and then (re-)execute it. The result of the unknown command is used as the result for the original non-existent command. The default implementation of unknown behaves as follows. It first calls the auto_load library procedure to load the command. If this succeeds, then it executes the original command with its original arguments. If the auto-load fails then unknown calls auto_execok to see if there is an executable file by the name cmd . If so, it invokes the Tcl exec command with cmd and all the args as arguments. If cmd cannot be auto-executed, unknown checks to see if the command was invoked at top-level and outside of any script. If so, then unknown takes two additional steps. First, it sees if cmd has one of the following three forms: !! , ! event , or \\^ old \\^ new ? \\^ ?. If so, then unknown carries out history substitution in the same way that csh would for these constructs. Finally, unknown checks to see if cmd is a unique abbreviation for an existing Tcl command. If so, it expands the command name and executes the command with the original arguments. If none of the above efforts has been able to execute the command, unknown generates an error return. If the global variable auto_noload is defined, then the auto-load step is skipped. If the global variable auto_noexec is defined then the auto-exec step is skipped. Under normal circumstances the return value from unknown is the return value from the command that was eventually executed.","title":"DESCRIPTION"},{"location":"unknown/#example","text":"Arrange for the unknown command to have its standard behavior except for first logging the fact that a command was not found: # Save the original one so we can chain to it rename unknown _original_unknown # Provide our own implementation proc unknown args { puts stderr \\\"WARNING: unknown command: \\$args\\\" uplevel 1 [list _original_unknown {*}\\$args] }","title":"EXAMPLE"},{"location":"unknown/#see-also","text":"info(n), proc(n), interp(n), library(n), namespace(n)","title":"SEE ALSO"},{"location":"unknown/#keywords","text":"error, non-existent command, unknown","title":"KEYWORDS"},{"location":"unload/","text":"NAME unload - Unload machine code SYNOPSIS unload ? switches ? fileName \\ unload ? switches ? fileName prefix \\ unload ? switches ? fileName prefix interp DESCRIPTION This command tries to unload shared libraries previously loaded with load from the application\\'s address space. fileName is the name of the file containing the library file to be unload; it must be the same as the filename provided to load for loading the library. The prefix argument is the prefix (as determined by or passed to load ), and is used to compute the name of the unload procedure; if not supplied, it is computed from fileName in the same manner as load . The interp argument is the path name of the interpreter from which to unload the package (see the interp manual entry for details); if interp is omitted, it defaults to the interpreter in which the unload command was invoked. If the initial arguments to unload start with - then they are treated as switches. The following switches are currently supported: -nocomplain : Suppresses all error messages. If this switch is given, unload will never report an error. -keeplibrary : This switch will prevent unload from issuing the operating system call that will unload the library from the process. -\u2006- : Marks the end of switches. The argument following this one will be treated as a fileName even if it starts with a - . UNLOAD OPERATION When a file containing a shared library is loaded through the load command, Tcl associates two reference counts to the library file. The first counter shows how many times the library has been loaded into normal (trusted) interpreters while the second describes how many times the library has been loaded into safe interpreters. As a file containing a shared library can be loaded only once by Tcl (with the first load call on the file), these counters track how many interpreters use the library. Each subsequent call to load after the first simply increments the proper reference count. unload works in the opposite direction. As a first step, unload will check whether the library is unloadable: an unloadable library exports a special unload procedure. The name of the unload procedure is determined by prefix and whether or not the target interpreter is a safe one. For normal interpreters the name of the initialization procedure will have the form pfx _Unload , where pfx is the same as prefix except that the first letter is converted to upper case and all other letters are converted to lower case. For example, if prefix is foo or FOo , the initialization procedure\\'s name will be Foo_Unload . If the target interpreter is a safe interpreter, then the name of the initialization procedure will be pkg _SafeUnload instead of pkg _Unload . If unload determines that a library is not unloadable (or unload functionality has been disabled during compilation), an error will be returned. If the library is unloadable, then unload will call the unload procedure. If the unload procedure returns TCL_OK , unload will proceed and decrease the proper reference count (depending on the target interpreter type). When both reference counts have reached 0, the library will be detached from the process. UNLOAD HOOK PROTOTYPE The unload procedure must match the following prototype: typedef int Tcl_LibraryUnloadProc ( Tcl_Interp * interp , int flags ); The interp argument identifies the interpreter from which the library is to be unloaded. The unload procedure must return TCL_OK or TCL_ERROR to indicate whether or not it completed successfully; in the event of an error it should set the interpreter\\'s result to point to an error message. In this case, the result of the unload command will be the result returned by the unload procedure. The flags argument can be either TCL_UNLOAD_DETACH_FROM_INTERPRETER or TCL_UNLOAD_DETACH_FROM_PROCESS . In case the library will remain attached to the process after the unload procedure returns (i.e. because the library is used by other interpreters), TCL_UNLOAD_DETACH_FROM_INTERPRETER will be defined. However, if the library is used only by the target interpreter and the library will be detached from the application as soon as the unload procedure returns, the flags argument will be set to TCL_UNLOAD_DETACH_FROM_PROCESS . NOTES The unload command cannot unload libraries that are statically linked with the application. If fileName is an empty string, then the prefix argument must be specified. If prefix is omitted or specified as an empty string, Tcl tries to guess the prefix. This may be done differently on different platforms. The default guess, which is used on most UNIX platforms, is to take the last element of fileName , strip off the first three characters if they are lib , then strip off the next three characters if they are tcl9 , and use any following wordchars but not digits, converted to titlecase as the prefix. For example, the command unload libxyz4.2.so uses the prefix Xyz and the command unload bin/last.so {} uses the prefix Last . PORTABILITY ISSUES Unix \u2007\u2007\u2007\u2007\u2007 : Not all unix operating systems support library unloading. Under such an operating system unload returns an error (unless -nocomplain has been specified). BUGS If the same file is load ed by different fileName s, it will be loaded into the process\\'s address space multiple times. The behavior of this varies from system to system (some systems may detect the redundant loads, others may not). In case a library has been silently detached by the operating system (and as a result Tcl thinks the library is still loaded), it may be dangerous to use unload on such a library (as the library will be completely detached from the application while some interpreters will continue to use it). EXAMPLE If an unloadable module in the file foobar.dll had been loaded using the load command like this (on Windows): load c:/some/dir/foobar.dll then it would be unloaded like this: unload c:/some/dir/foobar.dll This allows a C code module to be installed temporarily into a long-running Tcl program and then removed again (either because it is no longer needed or because it is being updated with a new version) without having to shut down the overall Tcl process. SEE ALSO info sharedlibextension, load(n), safe(n) KEYWORDS binary code, unloading, safe interpreter, shared library","title":"NAME"},{"location":"unload/#name","text":"unload - Unload machine code","title":"NAME"},{"location":"unload/#synopsis","text":"unload ? switches ? fileName \\ unload ? switches ? fileName prefix \\ unload ? switches ? fileName prefix interp","title":"SYNOPSIS"},{"location":"unload/#description","text":"This command tries to unload shared libraries previously loaded with load from the application\\'s address space. fileName is the name of the file containing the library file to be unload; it must be the same as the filename provided to load for loading the library. The prefix argument is the prefix (as determined by or passed to load ), and is used to compute the name of the unload procedure; if not supplied, it is computed from fileName in the same manner as load . The interp argument is the path name of the interpreter from which to unload the package (see the interp manual entry for details); if interp is omitted, it defaults to the interpreter in which the unload command was invoked. If the initial arguments to unload start with - then they are treated as switches. The following switches are currently supported: -nocomplain : Suppresses all error messages. If this switch is given, unload will never report an error. -keeplibrary : This switch will prevent unload from issuing the operating system call that will unload the library from the process. -\u2006- : Marks the end of switches. The argument following this one will be treated as a fileName even if it starts with a - .","title":"DESCRIPTION"},{"location":"unload/#unload-operation","text":"When a file containing a shared library is loaded through the load command, Tcl associates two reference counts to the library file. The first counter shows how many times the library has been loaded into normal (trusted) interpreters while the second describes how many times the library has been loaded into safe interpreters. As a file containing a shared library can be loaded only once by Tcl (with the first load call on the file), these counters track how many interpreters use the library. Each subsequent call to load after the first simply increments the proper reference count. unload works in the opposite direction. As a first step, unload will check whether the library is unloadable: an unloadable library exports a special unload procedure. The name of the unload procedure is determined by prefix and whether or not the target interpreter is a safe one. For normal interpreters the name of the initialization procedure will have the form pfx _Unload , where pfx is the same as prefix except that the first letter is converted to upper case and all other letters are converted to lower case. For example, if prefix is foo or FOo , the initialization procedure\\'s name will be Foo_Unload . If the target interpreter is a safe interpreter, then the name of the initialization procedure will be pkg _SafeUnload instead of pkg _Unload . If unload determines that a library is not unloadable (or unload functionality has been disabled during compilation), an error will be returned. If the library is unloadable, then unload will call the unload procedure. If the unload procedure returns TCL_OK , unload will proceed and decrease the proper reference count (depending on the target interpreter type). When both reference counts have reached 0, the library will be detached from the process.","title":"UNLOAD OPERATION"},{"location":"unload/#unload-hook-prototype","text":"The unload procedure must match the following prototype: typedef int Tcl_LibraryUnloadProc ( Tcl_Interp * interp , int flags ); The interp argument identifies the interpreter from which the library is to be unloaded. The unload procedure must return TCL_OK or TCL_ERROR to indicate whether or not it completed successfully; in the event of an error it should set the interpreter\\'s result to point to an error message. In this case, the result of the unload command will be the result returned by the unload procedure. The flags argument can be either TCL_UNLOAD_DETACH_FROM_INTERPRETER or TCL_UNLOAD_DETACH_FROM_PROCESS . In case the library will remain attached to the process after the unload procedure returns (i.e. because the library is used by other interpreters), TCL_UNLOAD_DETACH_FROM_INTERPRETER will be defined. However, if the library is used only by the target interpreter and the library will be detached from the application as soon as the unload procedure returns, the flags argument will be set to TCL_UNLOAD_DETACH_FROM_PROCESS .","title":"UNLOAD HOOK PROTOTYPE"},{"location":"unload/#notes","text":"The unload command cannot unload libraries that are statically linked with the application. If fileName is an empty string, then the prefix argument must be specified. If prefix is omitted or specified as an empty string, Tcl tries to guess the prefix. This may be done differently on different platforms. The default guess, which is used on most UNIX platforms, is to take the last element of fileName , strip off the first three characters if they are lib , then strip off the next three characters if they are tcl9 , and use any following wordchars but not digits, converted to titlecase as the prefix. For example, the command unload libxyz4.2.so uses the prefix Xyz and the command unload bin/last.so {} uses the prefix Last .","title":"NOTES"},{"location":"unload/#portability-issues","text":"Unix \u2007\u2007\u2007\u2007\u2007 : Not all unix operating systems support library unloading. Under such an operating system unload returns an error (unless -nocomplain has been specified).","title":"PORTABILITY ISSUES"},{"location":"unload/#bugs","text":"If the same file is load ed by different fileName s, it will be loaded into the process\\'s address space multiple times. The behavior of this varies from system to system (some systems may detect the redundant loads, others may not). In case a library has been silently detached by the operating system (and as a result Tcl thinks the library is still loaded), it may be dangerous to use unload on such a library (as the library will be completely detached from the application while some interpreters will continue to use it).","title":"BUGS"},{"location":"unload/#example","text":"If an unloadable module in the file foobar.dll had been loaded using the load command like this (on Windows): load c:/some/dir/foobar.dll then it would be unloaded like this: unload c:/some/dir/foobar.dll This allows a C code module to be installed temporarily into a long-running Tcl program and then removed again (either because it is no longer needed or because it is being updated with a new version) without having to shut down the overall Tcl process.","title":"EXAMPLE"},{"location":"unload/#see-also","text":"info sharedlibextension, load(n), safe(n)","title":"SEE ALSO"},{"location":"unload/#keywords","text":"binary code, unloading, safe interpreter, shared library","title":"KEYWORDS"},{"location":"unset/","text":"NAME unset - Delete variables SYNOPSIS unset ? -nocomplain ? ? -- ? ? name name name ... ? DESCRIPTION This command removes one or more variables. Each name is a variable name, specified in any of the ways acceptable to the set command. If a name refers to an element of an array then that element is removed without affecting the rest of the array. If a name consists of an array name with no parenthesized index, then the entire array is deleted. The unset command returns an empty string as result. If -nocomplain is specified as the first argument, any possible errors are suppressed. The option may not be abbreviated, in order to disambiguate it from possible variable names. The option -- indicates the end of the options, and should be used if you wish to remove a variable with the same name as any of the options. If an error occurs during variable deletion, any variables after the named one causing the error are not deleted. An error can occur when the named variable does not exist, or the name refers to an array element but the variable is a scalar, or the name refers to a variable in a non-existent namespace. EXAMPLE Create an array containing a mapping from some numbers to their squares and remove the array elements for non-prime numbers: array set squares { 1 1 6 36 2 4 7 49 3 9 8 64 4 16 9 81 5 25 10 100 } puts \\\"The squares are:\\\" parray squares unset squares(1) squares(4) squares(6) unset squares(8) squares(9) squares(10) puts \\\"The prime squares are:\\\" parray squares SEE ALSO set(n), trace(n), upvar(n) KEYWORDS remove, variable","title":"NAME"},{"location":"unset/#name","text":"unset - Delete variables","title":"NAME"},{"location":"unset/#synopsis","text":"unset ? -nocomplain ? ? -- ? ? name name name ... ?","title":"SYNOPSIS"},{"location":"unset/#description","text":"This command removes one or more variables. Each name is a variable name, specified in any of the ways acceptable to the set command. If a name refers to an element of an array then that element is removed without affecting the rest of the array. If a name consists of an array name with no parenthesized index, then the entire array is deleted. The unset command returns an empty string as result. If -nocomplain is specified as the first argument, any possible errors are suppressed. The option may not be abbreviated, in order to disambiguate it from possible variable names. The option -- indicates the end of the options, and should be used if you wish to remove a variable with the same name as any of the options. If an error occurs during variable deletion, any variables after the named one causing the error are not deleted. An error can occur when the named variable does not exist, or the name refers to an array element but the variable is a scalar, or the name refers to a variable in a non-existent namespace.","title":"DESCRIPTION"},{"location":"unset/#example","text":"Create an array containing a mapping from some numbers to their squares and remove the array elements for non-prime numbers: array set squares { 1 1 6 36 2 4 7 49 3 9 8 64 4 16 9 81 5 25 10 100 } puts \\\"The squares are:\\\" parray squares unset squares(1) squares(4) squares(6) unset squares(8) squares(9) squares(10) puts \\\"The prime squares are:\\\" parray squares","title":"EXAMPLE"},{"location":"unset/#see-also","text":"set(n), trace(n), upvar(n)","title":"SEE ALSO"},{"location":"unset/#keywords","text":"remove, variable","title":"KEYWORDS"},{"location":"update/","text":"NAME update - Process pending events and idle callbacks SYNOPSIS update ? idletasks ? DESCRIPTION This command is used to bring the application by entering the event loop repeatedly until all pending events (including idle callbacks) have been processed. If the idletasks keyword is specified as an argument to the command, then no new events or errors are processed; only idle callbacks are invoked. This causes operations that are normally deferred, such as display updates and window layout calculations, to be performed immediately. The update idletasks command is useful in scripts where changes have been made to the application\\'s state and you want those changes to appear on the display immediately, rather than waiting for the script to complete. Most display updates are performed as idle callbacks, so update idletasks will cause them to run. However, there are some kinds of updates that only happen in response to events, such as those triggered by window size changes; these updates will not occur in update idletasks . The update command with no options is useful in scripts where you are performing a long-running computation but you still want the application to respond to events such as user interactions; if you occasionally call update then user input will be processed during the next call to update . EXAMPLE Run computations for about a second and then finish: set x 1000 set done 0 after 1000 set done 1 while {!\\$done} { # A very silly example! set x [expr {log(\\$x) ** 2.8}] # Test to see if our time-limit has been hit. This would # also give a chance for serving network sockets and, if # the Tk package is loaded, updating a user interface. update } SEE ALSO after(n), interp(n) KEYWORDS asynchronous I/O, event, flush, handler, idle, update","title":"NAME"},{"location":"update/#name","text":"update - Process pending events and idle callbacks","title":"NAME"},{"location":"update/#synopsis","text":"update ? idletasks ?","title":"SYNOPSIS"},{"location":"update/#description","text":"This command is used to bring the application by entering the event loop repeatedly until all pending events (including idle callbacks) have been processed. If the idletasks keyword is specified as an argument to the command, then no new events or errors are processed; only idle callbacks are invoked. This causes operations that are normally deferred, such as display updates and window layout calculations, to be performed immediately. The update idletasks command is useful in scripts where changes have been made to the application\\'s state and you want those changes to appear on the display immediately, rather than waiting for the script to complete. Most display updates are performed as idle callbacks, so update idletasks will cause them to run. However, there are some kinds of updates that only happen in response to events, such as those triggered by window size changes; these updates will not occur in update idletasks . The update command with no options is useful in scripts where you are performing a long-running computation but you still want the application to respond to events such as user interactions; if you occasionally call update then user input will be processed during the next call to update .","title":"DESCRIPTION"},{"location":"update/#example","text":"Run computations for about a second and then finish: set x 1000 set done 0 after 1000 set done 1 while {!\\$done} { # A very silly example! set x [expr {log(\\$x) ** 2.8}] # Test to see if our time-limit has been hit. This would # also give a chance for serving network sockets and, if # the Tk package is loaded, updating a user interface. update }","title":"EXAMPLE"},{"location":"update/#see-also","text":"after(n), interp(n)","title":"SEE ALSO"},{"location":"update/#keywords","text":"asynchronous I/O, event, flush, handler, idle, update","title":"KEYWORDS"},{"location":"uplevel/","text":"NAME uplevel - Execute a script in a different stack frame SYNOPSIS uplevel ? level ? arg ? arg ... ? DESCRIPTION All of the arg arguments are concatenated as if they had been passed to concat ; the result is then evaluated in the variable context indicated by level . Uplevel returns the result of that evaluation. If level is an integer then it gives a distance (up the procedure calling stack) to move before executing the command. If level consists of # followed by a integer then the level gives an absolute level. If level is omitted then it defaults to 1 . Level cannot be defaulted if the first command argument is an integer or starts with # . For example, suppose that procedure a was invoked from top-level, and that it called b , and that b called c . Suppose that c invokes the uplevel command. If level is 1 or #2 or omitted, then the command will be executed in the variable context of b . If level is 2 or #1 then the command will be executed in the variable context of a . If level is 3 or #0 then the command will be executed at top-level (only global variables will be visible). The uplevel command causes the invoking procedure to disappear from the procedure calling stack while the command is being executed. In the above example, suppose c invokes the command uplevel 1 {set x 43; d} where d is another Tcl procedure. The set command will modify the variable x in b \\'s context, and d will execute at level 3, as if called from b . If it in turn executes the command uplevel {set x 42} then the set command will modify the same variable x in b \\'s context: the procedure c does not appear to be on the call stack when d is executing. The info level command may be used to obtain the level of the current procedure. Uplevel makes it possible to implement new control constructs as Tcl procedures (for example, uplevel could be used to implement the while construct as a Tcl procedure). The namespace eval and apply commands offer other ways (besides procedure calls) that the Tcl naming context can change. They add a call frame to the stack to represent the namespace context. This means each namespace eval command counts as another call level for uplevel and upvar commands. For example, info level 1 will return a list describing a command that is either the outermost procedure call or the outermost namespace eval command. Also, uplevel #0 evaluates a script at top-level in the outermost namespace (the global namespace). EXAMPLE As stated above, the uplevel command is useful for creating new control constructs. This example shows how (without error handling) it can be used to create a do command that is the counterpart of while except for always performing the test after running the loop body: proc do {body while condition} { if {\\$while ne \\\"while\\\"} { error \\\"required word missing\\\" } set conditionCmd [list expr \\$condition] while {1} { uplevel 1 \\$body if {![ uplevel 1 \\$conditionCmd]} { break } } } SEE ALSO apply(n), namespace(n), upvar(n) KEYWORDS context, level, namespace, stack frame, variable","title":"NAME"},{"location":"uplevel/#name","text":"uplevel - Execute a script in a different stack frame","title":"NAME"},{"location":"uplevel/#synopsis","text":"uplevel ? level ? arg ? arg ... ?","title":"SYNOPSIS"},{"location":"uplevel/#description","text":"All of the arg arguments are concatenated as if they had been passed to concat ; the result is then evaluated in the variable context indicated by level . Uplevel returns the result of that evaluation. If level is an integer then it gives a distance (up the procedure calling stack) to move before executing the command. If level consists of # followed by a integer then the level gives an absolute level. If level is omitted then it defaults to 1 . Level cannot be defaulted if the first command argument is an integer or starts with # . For example, suppose that procedure a was invoked from top-level, and that it called b , and that b called c . Suppose that c invokes the uplevel command. If level is 1 or #2 or omitted, then the command will be executed in the variable context of b . If level is 2 or #1 then the command will be executed in the variable context of a . If level is 3 or #0 then the command will be executed at top-level (only global variables will be visible). The uplevel command causes the invoking procedure to disappear from the procedure calling stack while the command is being executed. In the above example, suppose c invokes the command uplevel 1 {set x 43; d} where d is another Tcl procedure. The set command will modify the variable x in b \\'s context, and d will execute at level 3, as if called from b . If it in turn executes the command uplevel {set x 42} then the set command will modify the same variable x in b \\'s context: the procedure c does not appear to be on the call stack when d is executing. The info level command may be used to obtain the level of the current procedure. Uplevel makes it possible to implement new control constructs as Tcl procedures (for example, uplevel could be used to implement the while construct as a Tcl procedure). The namespace eval and apply commands offer other ways (besides procedure calls) that the Tcl naming context can change. They add a call frame to the stack to represent the namespace context. This means each namespace eval command counts as another call level for uplevel and upvar commands. For example, info level 1 will return a list describing a command that is either the outermost procedure call or the outermost namespace eval command. Also, uplevel #0 evaluates a script at top-level in the outermost namespace (the global namespace).","title":"DESCRIPTION"},{"location":"uplevel/#example","text":"As stated above, the uplevel command is useful for creating new control constructs. This example shows how (without error handling) it can be used to create a do command that is the counterpart of while except for always performing the test after running the loop body: proc do {body while condition} { if {\\$while ne \\\"while\\\"} { error \\\"required word missing\\\" } set conditionCmd [list expr \\$condition] while {1} { uplevel 1 \\$body if {![ uplevel 1 \\$conditionCmd]} { break } } }","title":"EXAMPLE"},{"location":"uplevel/#see-also","text":"apply(n), namespace(n), upvar(n)","title":"SEE ALSO"},{"location":"uplevel/#keywords","text":"context, level, namespace, stack frame, variable","title":"KEYWORDS"},{"location":"variable/","text":"NAME variable - create and initialize a namespace variable SYNOPSIS variable name variable ? name value... ? DESCRIPTION This command is normally used within a namespace eval command to create one or more variables within a namespace. Each variable name is initialized with value . The value for the last variable is optional. If a variable name does not exist, it is created. In this case, if value is specified, it is assigned to the newly created variable. If no value is specified, the new variable is left undefined. If the variable already exists, it is set to value if value is specified or left unchanged if no value is given. Normally, name is unqualified (does not include the names of any containing namespaces), and the variable is created in the current namespace. If name includes any namespace qualifiers, the variable is created in the specified namespace. If the variable is not defined, it will be visible to the namespace which command, but not to the info exists command. If the variable command is executed inside a Tcl procedure, it creates local variables linked to the corresponding namespace variables (and therefore these variables are listed by info vars .) In this way the variable command resembles the global command, although the global command resolves variable names with respect to the global namespace instead of the current namespace of the procedure. If any value s are given, they are used to modify the values of the associated namespace variables. If a namespace variable does not exist, it is created and optionally initialized. A name argument cannot reference an element within an array. Instead, name should reference the entire array, and the initialization value should be left off. After the variable has been declared, elements within the array can be set using ordinary set or array commands. EXAMPLES Create a variable in a namespace: namespace eval foo { variable bar 12345 } Create an array in a namespace: namespace eval someNS { variable someAry array set someAry { someName someValue otherName otherValue } } Access variables in namespaces from a procedure: namespace eval foo { proc spong {} { # Variable in this namespace variable bar puts \\\"bar is \\$bar\\\" # Variable in another namespace variable ::someNS::someAry parray someAry } } SEE ALSO global(n), namespace(n), upvar(n) KEYWORDS global, namespace, procedure, variable","title":"NAME"},{"location":"variable/#name","text":"variable - create and initialize a namespace variable","title":"NAME"},{"location":"variable/#synopsis","text":"variable name variable ? name value... ?","title":"SYNOPSIS"},{"location":"variable/#description","text":"This command is normally used within a namespace eval command to create one or more variables within a namespace. Each variable name is initialized with value . The value for the last variable is optional. If a variable name does not exist, it is created. In this case, if value is specified, it is assigned to the newly created variable. If no value is specified, the new variable is left undefined. If the variable already exists, it is set to value if value is specified or left unchanged if no value is given. Normally, name is unqualified (does not include the names of any containing namespaces), and the variable is created in the current namespace. If name includes any namespace qualifiers, the variable is created in the specified namespace. If the variable is not defined, it will be visible to the namespace which command, but not to the info exists command. If the variable command is executed inside a Tcl procedure, it creates local variables linked to the corresponding namespace variables (and therefore these variables are listed by info vars .) In this way the variable command resembles the global command, although the global command resolves variable names with respect to the global namespace instead of the current namespace of the procedure. If any value s are given, they are used to modify the values of the associated namespace variables. If a namespace variable does not exist, it is created and optionally initialized. A name argument cannot reference an element within an array. Instead, name should reference the entire array, and the initialization value should be left off. After the variable has been declared, elements within the array can be set using ordinary set or array commands.","title":"DESCRIPTION"},{"location":"variable/#examples","text":"Create a variable in a namespace: namespace eval foo { variable bar 12345 } Create an array in a namespace: namespace eval someNS { variable someAry array set someAry { someName someValue otherName otherValue } } Access variables in namespaces from a procedure: namespace eval foo { proc spong {} { # Variable in this namespace variable bar puts \\\"bar is \\$bar\\\" # Variable in another namespace variable ::someNS::someAry parray someAry } }","title":"EXAMPLES"},{"location":"variable/#see-also","text":"global(n), namespace(n), upvar(n)","title":"SEE ALSO"},{"location":"variable/#keywords","text":"global, namespace, procedure, variable","title":"KEYWORDS"},{"location":"vwait/","text":"NAME vwait - Process events until a variable is written SYNOPSIS vwait varName vwait ? options ? ? varName ... ? DESCRIPTION This command enters the Tcl event loop to process events, blocking the application if no events are ready. It continues processing events until some event handler sets the value of the global variable varName . Once varName has been set, the vwait command will return as soon as the event handler that modified varName completes. The varName argument is always interpreted as a variable name with respect to the global namespace, but can refer to any namespace\\'s variables if the fully-qualified name is given. In the second more complex command form options allow for finer control of the wait operation and to deal with multiple event sources. Options can be made up of -- : Marks the end of options. All following arguments are handled as variable names. -all : All conditions for the wait operation must be met to complete the wait operation. Otherwise (the default) the first event completes the wait. -extended : An extended result in list form is returned, see below for explanation. -nofileevents : File events are not handled in the wait operation. -noidleevents : Idle handlers are not invoked during the wait operation. -notimerevents : Timer handlers are not serviced during the wait operation. -nowindowevents : Events of the windowing system are not handled during the wait operation. -readable channel : Channel must name a Tcl channel open for reading. If channel is or becomes readable the wait operation completes. -timeout milliseconds : The wait operation is constrained to milliseconds . -variable varName : VarName must be the name of a global variable. Writing or unsetting this variable completes the wait operation. -writable channel : Channel must name a Tcl channel open for writing. If channel is or becomes writable the wait operation completes. The result returned by vwait is for the simple form an empty string. If the -timeout option is specified, the result is the number of milliseconds remaining when the wait condition has been met, or -1 if the wait operation timed out. If the -extended option is specified, the result is made up of a Tcl list with an even number of elements. Odd elements take the values readable , timeleft , variable , and writable . Even elements are the corresponding variable and channel names or the remaining number of milliseconds. The list is ordered by the occurrences of the event(s) with the exception of timeleft which always comes last. In some cases the vwait command may not return immediately after varName et.al. is set. This happens if the event handler that sets varName does not complete immediately. For example, if an event handler sets varName and then itself calls vwait to wait for a different variable, then it may not return for a long time. During this time the top-level vwait is blocked waiting for the event handler to complete, so it cannot return either. (See the NESTED VWAITS BY EXAMPLE below.) To be clear, multiple vwait calls will nest and will not happen in parallel. The outermost call to vwait will not return until all the inner ones do. It is recommended that code should never nest vwait calls (by avoiding putting them in event callbacks) but when that is not possible, care should be taken to add interlock variables to the code to prevent all reentrant calls to vwait that are not strictly necessary. Be aware that the synchronous modes of operation of some Tcl packages (e.g., http ) use vwait internally; if using the event loop, it is best to use the asynchronous callback-based modes of operation of those packages where available. EXAMPLES Run the event-loop continually until some event calls exit . (You can use any variable not mentioned elsewhere, but the name forever reminds you at a glance of the intent.) vwait forever Wait five seconds for a connection to a server socket, otherwise close the socket and continue running the script: # Initialise the state after 5000 set state timeout set server [socket -server accept 12345] proc accept {args} { global state connectionInfo set state accepted set connectionInfo \\$args } # Wait for something to happen vwait state # Clean up events that could have happened close \\$server after cancel set state timeout # Do something based on how the vwait finished... switch \\$state { timeout { puts \\\"no connection on port 12345\\\" } accepted { puts \\\"connection: \\$connectionInfo\\\" puts [lindex \\$connectionInfo 0] \\\"Hello there!\\\" } } A command that will wait for some time delay by waiting for a namespace variable to be set. Includes an interlock to prevent nested waits. namespace eval example { variable v done proc wait {delay} { variable v if {\\$v ne \\\"waiting\\\"} { set v waiting after \\$delay [namespace code {set v done}] vwait [namespace which -variable v] } return \\$v } } When running inside a coroutine , an alternative to using vwait is to yield to an outer event loop and to get recommenced when the variable is set, or at an idle moment after that. coroutine task apply {{} { # simulate [after 1000] after 1000 [info coroutine] yield # schedule the setting of a global variable, as normal after 2000 {set var 1} # simulate [ vwait var] proc updatedVar {task args} { after idle \\$task trace remove variable ::var write \\\"updatedVar \\$task\\\" } trace add variable ::var write \\\"updatedVar [info coroutine]\\\" yield }} NESTED VWAITS BY EXAMPLE This example demonstrates what can happen when the vwait command is nested. The script will never finish because the waiting for the a variable never finishes; that vwait command is still waiting for a script scheduled with after to complete, which just happens to be running an inner vwait (for b ) even though the event that the outer vwait was waiting for (the setting of a ) has occurred. after 500 { puts \\\"waiting for b\\\" vwait b puts \\\"b was set\\\" } after 1000 { puts \\\"setting a\\\" set a 10 } puts \\\"waiting for a\\\" vwait a puts \\\"a was set\\\" puts \\\"setting b\\\" set b 42 If you run the above code, you get this output: waiting for a waiting for b setting a The script will never print until after it has printed because of the nesting of vwait commands, and yet b will not be set until after the outer vwait returns, so the script has deadlocked. The only ways to avoid this are to either structure the overall program in continuation-passing style or to use coroutine to make the continuations implicit. The first of these options would be written as: after 500 { puts \\\"waiting for b\\\" trace add variable b write {apply {args { global a b trace remove variable ::b write \\ [lrange [info level 0] 0 1] puts \\\"b was set\\\" set ::done ok }}} } after 1000 { puts \\\"setting a\\\" set a 10 } puts \\\"waiting for a\\\" trace add variable a write {apply {args { global a b trace remove variable a write [lrange [info level 0] 0 1] puts \\\"a was set\\\" puts \\\"setting b\\\" set b 42 }}} vwait done The second option, with coroutine and some helper procedures, is done like this: # A coroutine-based wait-for-variable command proc waitvar globalVar { trace add variable ::\\$globalVar write \\ [list apply {{v c args} { trace remove variable \\$v write \\ [lrange [info level 0] 0 3] after 0 \\$c }} ::\\$globalVar [info coroutine]] yield } # A coroutine-based wait-for-some-time command proc waittime ms { after \\$ms [info coroutine] yield } coroutine task-1 eval { puts \\\"waiting for a\\\" waitvar a puts \\\"a was set\\\" puts \\\"setting b\\\" set b 42 } coroutine task-2 eval { waittime 500 puts \\\"waiting for b\\\" waitvar b puts \\\"b was set\\\" set done ok } coroutine task-3 eval { waittime 1000 puts \\\"setting a\\\" set a 10 } vwait done SEE ALSO global(n), update(n) KEYWORDS asynchronous I/O, event, variable, wait","title":"NAME"},{"location":"vwait/#name","text":"vwait - Process events until a variable is written","title":"NAME"},{"location":"vwait/#synopsis","text":"vwait varName vwait ? options ? ? varName ... ?","title":"SYNOPSIS"},{"location":"vwait/#description","text":"This command enters the Tcl event loop to process events, blocking the application if no events are ready. It continues processing events until some event handler sets the value of the global variable varName . Once varName has been set, the vwait command will return as soon as the event handler that modified varName completes. The varName argument is always interpreted as a variable name with respect to the global namespace, but can refer to any namespace\\'s variables if the fully-qualified name is given. In the second more complex command form options allow for finer control of the wait operation and to deal with multiple event sources. Options can be made up of -- : Marks the end of options. All following arguments are handled as variable names. -all : All conditions for the wait operation must be met to complete the wait operation. Otherwise (the default) the first event completes the wait. -extended : An extended result in list form is returned, see below for explanation. -nofileevents : File events are not handled in the wait operation. -noidleevents : Idle handlers are not invoked during the wait operation. -notimerevents : Timer handlers are not serviced during the wait operation. -nowindowevents : Events of the windowing system are not handled during the wait operation. -readable channel : Channel must name a Tcl channel open for reading. If channel is or becomes readable the wait operation completes. -timeout milliseconds : The wait operation is constrained to milliseconds . -variable varName : VarName must be the name of a global variable. Writing or unsetting this variable completes the wait operation. -writable channel : Channel must name a Tcl channel open for writing. If channel is or becomes writable the wait operation completes. The result returned by vwait is for the simple form an empty string. If the -timeout option is specified, the result is the number of milliseconds remaining when the wait condition has been met, or -1 if the wait operation timed out. If the -extended option is specified, the result is made up of a Tcl list with an even number of elements. Odd elements take the values readable , timeleft , variable , and writable . Even elements are the corresponding variable and channel names or the remaining number of milliseconds. The list is ordered by the occurrences of the event(s) with the exception of timeleft which always comes last. In some cases the vwait command may not return immediately after varName et.al. is set. This happens if the event handler that sets varName does not complete immediately. For example, if an event handler sets varName and then itself calls vwait to wait for a different variable, then it may not return for a long time. During this time the top-level vwait is blocked waiting for the event handler to complete, so it cannot return either. (See the NESTED VWAITS BY EXAMPLE below.) To be clear, multiple vwait calls will nest and will not happen in parallel. The outermost call to vwait will not return until all the inner ones do. It is recommended that code should never nest vwait calls (by avoiding putting them in event callbacks) but when that is not possible, care should be taken to add interlock variables to the code to prevent all reentrant calls to vwait that are not strictly necessary. Be aware that the synchronous modes of operation of some Tcl packages (e.g., http ) use vwait internally; if using the event loop, it is best to use the asynchronous callback-based modes of operation of those packages where available.","title":"DESCRIPTION"},{"location":"vwait/#examples","text":"Run the event-loop continually until some event calls exit . (You can use any variable not mentioned elsewhere, but the name forever reminds you at a glance of the intent.) vwait forever Wait five seconds for a connection to a server socket, otherwise close the socket and continue running the script: # Initialise the state after 5000 set state timeout set server [socket -server accept 12345] proc accept {args} { global state connectionInfo set state accepted set connectionInfo \\$args } # Wait for something to happen vwait state # Clean up events that could have happened close \\$server after cancel set state timeout # Do something based on how the vwait finished... switch \\$state { timeout { puts \\\"no connection on port 12345\\\" } accepted { puts \\\"connection: \\$connectionInfo\\\" puts [lindex \\$connectionInfo 0] \\\"Hello there!\\\" } } A command that will wait for some time delay by waiting for a namespace variable to be set. Includes an interlock to prevent nested waits. namespace eval example { variable v done proc wait {delay} { variable v if {\\$v ne \\\"waiting\\\"} { set v waiting after \\$delay [namespace code {set v done}] vwait [namespace which -variable v] } return \\$v } } When running inside a coroutine , an alternative to using vwait is to yield to an outer event loop and to get recommenced when the variable is set, or at an idle moment after that. coroutine task apply {{} { # simulate [after 1000] after 1000 [info coroutine] yield # schedule the setting of a global variable, as normal after 2000 {set var 1} # simulate [ vwait var] proc updatedVar {task args} { after idle \\$task trace remove variable ::var write \\\"updatedVar \\$task\\\" } trace add variable ::var write \\\"updatedVar [info coroutine]\\\" yield }}","title":"EXAMPLES"},{"location":"vwait/#nested-vwaits-by-example","text":"This example demonstrates what can happen when the vwait command is nested. The script will never finish because the waiting for the a variable never finishes; that vwait command is still waiting for a script scheduled with after to complete, which just happens to be running an inner vwait (for b ) even though the event that the outer vwait was waiting for (the setting of a ) has occurred. after 500 { puts \\\"waiting for b\\\" vwait b puts \\\"b was set\\\" } after 1000 { puts \\\"setting a\\\" set a 10 } puts \\\"waiting for a\\\" vwait a puts \\\"a was set\\\" puts \\\"setting b\\\" set b 42 If you run the above code, you get this output: waiting for a waiting for b setting a The script will never print until after it has printed because of the nesting of vwait commands, and yet b will not be set until after the outer vwait returns, so the script has deadlocked. The only ways to avoid this are to either structure the overall program in continuation-passing style or to use coroutine to make the continuations implicit. The first of these options would be written as: after 500 { puts \\\"waiting for b\\\" trace add variable b write {apply {args { global a b trace remove variable ::b write \\ [lrange [info level 0] 0 1] puts \\\"b was set\\\" set ::done ok }}} } after 1000 { puts \\\"setting a\\\" set a 10 } puts \\\"waiting for a\\\" trace add variable a write {apply {args { global a b trace remove variable a write [lrange [info level 0] 0 1] puts \\\"a was set\\\" puts \\\"setting b\\\" set b 42 }}} vwait done The second option, with coroutine and some helper procedures, is done like this: # A coroutine-based wait-for-variable command proc waitvar globalVar { trace add variable ::\\$globalVar write \\ [list apply {{v c args} { trace remove variable \\$v write \\ [lrange [info level 0] 0 3] after 0 \\$c }} ::\\$globalVar [info coroutine]] yield } # A coroutine-based wait-for-some-time command proc waittime ms { after \\$ms [info coroutine] yield } coroutine task-1 eval { puts \\\"waiting for a\\\" waitvar a puts \\\"a was set\\\" puts \\\"setting b\\\" set b 42 } coroutine task-2 eval { waittime 500 puts \\\"waiting for b\\\" waitvar b puts \\\"b was set\\\" set done ok } coroutine task-3 eval { waittime 1000 puts \\\"setting a\\\" set a 10 } vwait done","title":"NESTED VWAITS BY EXAMPLE"},{"location":"vwait/#see-also","text":"global(n), update(n)","title":"SEE ALSO"},{"location":"vwait/#keywords","text":"asynchronous I/O, event, variable, wait","title":"KEYWORDS"},{"location":"while/","text":"NAME while - Execute script repeatedly as long as a condition is met SYNOPSIS while test body DESCRIPTION The while command evaluates test as an expression (in the same way that expr evaluates its argument). The value of the expression must a proper boolean value; if it is a true value then body is executed by passing it to the Tcl interpreter. Once body has been executed then test is evaluated again, and the process repeats until eventually test evaluates to a false boolean value. Continue commands may be executed inside body to terminate the current iteration of the loop, and break commands may be executed inside body to cause immediate termination of the while command. The while command always returns an empty string. Note: test should almost always be enclosed in braces. If not, variable substitutions will be made before the while command starts executing, which means that variable changes made by the loop body will not be considered in the expression. This is likely to result in an infinite loop. If test is enclosed in braces, variable substitutions are delayed until the expression is evaluated (before each loop iteration), so changes in the variables will be visible. For an example, try the following script with and without the braces around \\$x\\<10 : set x 0 while {\\$x\\<10} { puts \\\"x is \\$x\\\" incr x } EXAMPLE Read lines from a channel until we get to the end of the stream, and print them out with a line-number prepended: set lineCount 0 while {[gets \\$chan line] >= 0} { puts \\\"[incr lineCount]: \\$line\\\" } SEE ALSO break(n), continue(n), for(n), foreach(n) KEYWORDS boolean, loop, test, while","title":"NAME"},{"location":"while/#name","text":"while - Execute script repeatedly as long as a condition is met","title":"NAME"},{"location":"while/#synopsis","text":"while test body","title":"SYNOPSIS"},{"location":"while/#description","text":"The while command evaluates test as an expression (in the same way that expr evaluates its argument). The value of the expression must a proper boolean value; if it is a true value then body is executed by passing it to the Tcl interpreter. Once body has been executed then test is evaluated again, and the process repeats until eventually test evaluates to a false boolean value. Continue commands may be executed inside body to terminate the current iteration of the loop, and break commands may be executed inside body to cause immediate termination of the while command. The while command always returns an empty string. Note: test should almost always be enclosed in braces. If not, variable substitutions will be made before the while command starts executing, which means that variable changes made by the loop body will not be considered in the expression. This is likely to result in an infinite loop. If test is enclosed in braces, variable substitutions are delayed until the expression is evaluated (before each loop iteration), so changes in the variables will be visible. For an example, try the following script with and without the braces around \\$x\\<10 : set x 0 while {\\$x\\<10} { puts \\\"x is \\$x\\\" incr x }","title":"DESCRIPTION"},{"location":"while/#example","text":"Read lines from a channel until we get to the end of the stream, and print them out with a line-number prepended: set lineCount 0 while {[gets \\$chan line] >= 0} { puts \\\"[incr lineCount]: \\$line\\\" }","title":"EXAMPLE"},{"location":"while/#see-also","text":"break(n), continue(n), for(n), foreach(n)","title":"SEE ALSO"},{"location":"while/#keywords","text":"boolean, loop, test, while","title":"KEYWORDS"},{"location":"zipfs/","text":"NAME zipfs - Mount and work with ZIP files within Tcl SYNOPSIS package require tcl::zipfs ?1.0? zipfs canonical ?mntpnt? filename ?ZIPFS? zipfs exists filename zipfs find directoryName zipfs info filename zipfs list ?(-glob|-regexp)? ?pattern? zipfs lmkimg outfile inlist ?password infile? zipfs lmkzip outfile inlist ?password? zipfs mkimg outfile indir ?strip? ?password? ?infile? zipfs mkkey password zipfs mkzip outfile indir ?strip? ?password? zipfs mount ?mountpoint? ?zipfile? ?password? zipfs root zipfs unmount mountpoint DESCRIPTION The zipfs command (the sole public command provided by the built-in package with the same name) provides Tcl with the ability to mount the contents of a ZIP archive file as a virtual file system. ZIP archives support simple encryption, sufficient to prevent casual inspection of their contents but not able to prevent access by even a moderately determined attacker. zipfs canonical ? mountpoint ? filename ? inZipfs ? : This takes the name of a file, filename , and produces where it would be mapped into a zipfs mount as its result. If specified, mountpoint says within which mount the mapping will be done; if omitted, the main root of the zipfs system is used. The inZipfs argument is a an optional boolean which controls whether to fully canonicalise the name; it defaults to true. zipfs exists filename : Return 1 if the given filename exists in the mounted zipfs and 0 if it does not. zipfs find directoryName : Recursively lists files including and below the directory directoryName . The result list consists of relative path names starting from the given directory. This command is also used by the zipfs mkzip and zipfs mkimg commands. zipfs info file : Return information about the given file in the mounted zipfs. The information consists of: (1) the name of the ZIP archive file that contains the file, (2) the size of the file after decompressions, (3) the compressed size of the file, and (4) the offset of the compressed data in the ZIP archive file. Note: querying the mount point gives the start of the zip data as the offset in (4), which can be used to truncate the zip information from an executable. zipfs list ?( -glob | -regexp )? ? pattern ? : Return a list of all files in the mounted zipfs, or just those matching pattern (optionally controlled by the option parameters). The order of the names in the list is arbitrary. zipfs mount ? mountpoint ? ? zipfile ? ? password ? : The zipfs mount command mounts a ZIP archive file as a Tcl virtual filesystem at mountpoint . After this command executes, files contained in zipfile will appear to Tcl to be regular files at the mount point. With no *zipfile*, returns the zipfile mounted at *mountpoint*. With no *mountpoint*, return all zipfile/mount pairs. If *mountpoint* is specified as an empty string, mount on file path. **NB:** because the current working directory is a concept maintained by the operating system, using **cd** into a mounted archive will only work in the current process, and then not entirely consistently (e.g., if a shared library uses direct access to the OS rather than through Tcl\\'s filesystem API, it will not see the current directory as being inside the mount and will not be able to access the files inside the mount). zipfs root : Returns a constant string which indicates the mount point for zipfs volumes for the current platform. On Windows, this value is On Unix, this value is zipfs unmount mountpoint : Unmounts a previously mounted ZIP archive mounted to mountpoint . ZIP CREATION COMMANDS This package also provides several commands to aid the creation of ZIP archives as Tcl applications. zipfs mkzip outfile indir ? strip ? ? password ? : Creates a ZIP archive file named outfile from the contents of the input directory indir (contained regular files only) with optional ZIP password password . While processing the files below indir the optional file name prefix given in strip is stripped off the beginning of the respective file name. When stripping, it is common to remove either the whole source directory name or the name of its parent directory. **Caution:** the choice of the *indir* parameter (less the optional stripped prefix) determines the later root name of the archive\\'s content. zipfs mkimg outfile indir ? strip ? ? password ? ? infile ? : Creates an image (potentially a new executable file) similar to zipfs mkzip; see that command for a description of most parameters to this command, as they behave identically here. If the *infile* parameter is specified, this file is prepended in front of the ZIP archive, otherwise the file returned by **info nameofexecutable** (i.e., the executable file of the running process) is used. If the *password* parameter is not empty, an obfuscated version of that password (see **zipfs mkkey**) is placed between the image and ZIP chunks of the output file and the contents of the ZIP chunk are protected with that password. If the starting image has a ZIP archive already attached to it, it is removed from the copy in *outfile* before the new ZIP archive is added. If there is a file, **main.tcl**, in the root directory of the resulting archive and the image file that the archive is attached to is a **tclsh** (or **wish**) instance (true by default, but depends on your configuration), then the resulting image is an executable that will **source** the script in that **main.tcl** after mounting the ZIP archive, and will **exit** once that script has been executed. **Caution:** highly experimental, not usable on Android, only partially tested on Linux and Windows. zipfs mkkey password : Given the clear text password argument, an obfuscated string version is returned with the same format used in the zipfs mkimg command. zipfs lmkimg outfile inlist ? password infile ? : This command is like zipfs mkimg , but instead of an input directory, inlist must be a Tcl list where the odd elements are the names of files to be copied into the archive in the image, and the even elements are their respective names within that archive. zipfs lmkzip outfile inlist ? password ? : This command is like zipfs mkzip , but instead of an input directory, inlist must be a Tcl list where the odd elements are the names of files to be copied into the archive, and the even elements are their respective names within that archive. EXAMPLES Mounting an ZIP archive as an application directory and running code out of it before unmounting it again: set zip myApp.zip set base [file join [ zipfs root ] myApp] zipfs mount \\$base \\$zip # \\$base now has the contents of myApp.zip source [file join \\$base app.tcl] # use the contents, load libraries from it, etc... zipfs unmount \\$zip Creating a ZIP archive, given that a directory exists containing the content to put in the archive. Note that the source directory is given twice, in order to strip the exterior directory name from each filename in the archive. set sourceDirectory [file normalize myApp] set targetZip myApp.zip zipfs mkzip \\$targetZip \\$sourceDirectory \\$sourceDirectory Encryption can be applied to ZIP archives by providing a password when building the ZIP and when mounting it. set zip myApp.zip set sourceDir [file normalize myApp] set password \\\"hunter2\\\" set base [file join [ zipfs root ] myApp] # Create with password zipfs mkzip \\$targetZip \\$sourceDir \\$sourceDir \\$password # Mount with password zipfs mount \\$base \\$zip \\$password When creating an executable image with a password, the password is placed within the executable in a shrouded form so that the application can read files inside the embedded ZIP archive yet casual inspection cannot read it. set appDir [file normalize myApp] set img \\\"myApp.bin\\\" set password \\\"hunter2\\\" # Create some simple content to define a basic application file mkdir \\$appDir set f [open \\$appDir/main.tcl] puts \\$f { puts \\\"Hi. This is [info script]\\\" } close \\$f # Create the executable zipfs mkimg \\$img \\$appDir \\$appDir \\$password # Launch the executable, printing its output to stdout exec \\$img >@stdout # prints: Hi. This is //zipfs:/app/main.tcl SEE ALSO tclsh(1), file(n), zipfs(3), zlib(n) KEYWORDS compress, filesystem, zip","title":"NAME"},{"location":"zipfs/#name","text":"zipfs - Mount and work with ZIP files within Tcl","title":"NAME"},{"location":"zipfs/#synopsis","text":"package require tcl::zipfs ?1.0? zipfs canonical ?mntpnt? filename ?ZIPFS? zipfs exists filename zipfs find directoryName zipfs info filename zipfs list ?(-glob|-regexp)? ?pattern? zipfs lmkimg outfile inlist ?password infile? zipfs lmkzip outfile inlist ?password? zipfs mkimg outfile indir ?strip? ?password? ?infile? zipfs mkkey password zipfs mkzip outfile indir ?strip? ?password? zipfs mount ?mountpoint? ?zipfile? ?password? zipfs root zipfs unmount mountpoint","title":"SYNOPSIS"},{"location":"zipfs/#description","text":"The zipfs command (the sole public command provided by the built-in package with the same name) provides Tcl with the ability to mount the contents of a ZIP archive file as a virtual file system. ZIP archives support simple encryption, sufficient to prevent casual inspection of their contents but not able to prevent access by even a moderately determined attacker. zipfs canonical ? mountpoint ? filename ? inZipfs ? : This takes the name of a file, filename , and produces where it would be mapped into a zipfs mount as its result. If specified, mountpoint says within which mount the mapping will be done; if omitted, the main root of the zipfs system is used. The inZipfs argument is a an optional boolean which controls whether to fully canonicalise the name; it defaults to true. zipfs exists filename : Return 1 if the given filename exists in the mounted zipfs and 0 if it does not. zipfs find directoryName : Recursively lists files including and below the directory directoryName . The result list consists of relative path names starting from the given directory. This command is also used by the zipfs mkzip and zipfs mkimg commands. zipfs info file : Return information about the given file in the mounted zipfs. The information consists of: (1) the name of the ZIP archive file that contains the file, (2) the size of the file after decompressions, (3) the compressed size of the file, and (4) the offset of the compressed data in the ZIP archive file. Note: querying the mount point gives the start of the zip data as the offset in (4), which can be used to truncate the zip information from an executable. zipfs list ?( -glob | -regexp )? ? pattern ? : Return a list of all files in the mounted zipfs, or just those matching pattern (optionally controlled by the option parameters). The order of the names in the list is arbitrary. zipfs mount ? mountpoint ? ? zipfile ? ? password ? : The zipfs mount command mounts a ZIP archive file as a Tcl virtual filesystem at mountpoint . After this command executes, files contained in zipfile will appear to Tcl to be regular files at the mount point. With no *zipfile*, returns the zipfile mounted at *mountpoint*. With no *mountpoint*, return all zipfile/mount pairs. If *mountpoint* is specified as an empty string, mount on file path. **NB:** because the current working directory is a concept maintained by the operating system, using **cd** into a mounted archive will only work in the current process, and then not entirely consistently (e.g., if a shared library uses direct access to the OS rather than through Tcl\\'s filesystem API, it will not see the current directory as being inside the mount and will not be able to access the files inside the mount). zipfs root : Returns a constant string which indicates the mount point for zipfs volumes for the current platform. On Windows, this value is On Unix, this value is zipfs unmount mountpoint : Unmounts a previously mounted ZIP archive mounted to mountpoint .","title":"DESCRIPTION"},{"location":"zipfs/#zip-creation-commands","text":"This package also provides several commands to aid the creation of ZIP archives as Tcl applications. zipfs mkzip outfile indir ? strip ? ? password ? : Creates a ZIP archive file named outfile from the contents of the input directory indir (contained regular files only) with optional ZIP password password . While processing the files below indir the optional file name prefix given in strip is stripped off the beginning of the respective file name. When stripping, it is common to remove either the whole source directory name or the name of its parent directory. **Caution:** the choice of the *indir* parameter (less the optional stripped prefix) determines the later root name of the archive\\'s content. zipfs mkimg outfile indir ? strip ? ? password ? ? infile ? : Creates an image (potentially a new executable file) similar to zipfs mkzip; see that command for a description of most parameters to this command, as they behave identically here. If the *infile* parameter is specified, this file is prepended in front of the ZIP archive, otherwise the file returned by **info nameofexecutable** (i.e., the executable file of the running process) is used. If the *password* parameter is not empty, an obfuscated version of that password (see **zipfs mkkey**) is placed between the image and ZIP chunks of the output file and the contents of the ZIP chunk are protected with that password. If the starting image has a ZIP archive already attached to it, it is removed from the copy in *outfile* before the new ZIP archive is added. If there is a file, **main.tcl**, in the root directory of the resulting archive and the image file that the archive is attached to is a **tclsh** (or **wish**) instance (true by default, but depends on your configuration), then the resulting image is an executable that will **source** the script in that **main.tcl** after mounting the ZIP archive, and will **exit** once that script has been executed. **Caution:** highly experimental, not usable on Android, only partially tested on Linux and Windows. zipfs mkkey password : Given the clear text password argument, an obfuscated string version is returned with the same format used in the zipfs mkimg command. zipfs lmkimg outfile inlist ? password infile ? : This command is like zipfs mkimg , but instead of an input directory, inlist must be a Tcl list where the odd elements are the names of files to be copied into the archive in the image, and the even elements are their respective names within that archive. zipfs lmkzip outfile inlist ? password ? : This command is like zipfs mkzip , but instead of an input directory, inlist must be a Tcl list where the odd elements are the names of files to be copied into the archive, and the even elements are their respective names within that archive.","title":"ZIP CREATION COMMANDS"},{"location":"zipfs/#examples","text":"Mounting an ZIP archive as an application directory and running code out of it before unmounting it again: set zip myApp.zip set base [file join [ zipfs root ] myApp] zipfs mount \\$base \\$zip # \\$base now has the contents of myApp.zip source [file join \\$base app.tcl] # use the contents, load libraries from it, etc... zipfs unmount \\$zip Creating a ZIP archive, given that a directory exists containing the content to put in the archive. Note that the source directory is given twice, in order to strip the exterior directory name from each filename in the archive. set sourceDirectory [file normalize myApp] set targetZip myApp.zip zipfs mkzip \\$targetZip \\$sourceDirectory \\$sourceDirectory Encryption can be applied to ZIP archives by providing a password when building the ZIP and when mounting it. set zip myApp.zip set sourceDir [file normalize myApp] set password \\\"hunter2\\\" set base [file join [ zipfs root ] myApp] # Create with password zipfs mkzip \\$targetZip \\$sourceDir \\$sourceDir \\$password # Mount with password zipfs mount \\$base \\$zip \\$password When creating an executable image with a password, the password is placed within the executable in a shrouded form so that the application can read files inside the embedded ZIP archive yet casual inspection cannot read it. set appDir [file normalize myApp] set img \\\"myApp.bin\\\" set password \\\"hunter2\\\" # Create some simple content to define a basic application file mkdir \\$appDir set f [open \\$appDir/main.tcl] puts \\$f { puts \\\"Hi. This is [info script]\\\" } close \\$f # Create the executable zipfs mkimg \\$img \\$appDir \\$appDir \\$password # Launch the executable, printing its output to stdout exec \\$img >@stdout # prints: Hi. This is //zipfs:/app/main.tcl","title":"EXAMPLES"},{"location":"zipfs/#see-also","text":"tclsh(1), file(n), zipfs(3), zlib(n)","title":"SEE ALSO"},{"location":"zipfs/#keywords","text":"compress, filesystem, zip","title":"KEYWORDS"},{"location":"zlib/","text":"NAME zlib - compression and decompression operations SYNOPSIS zlib subcommand arg ... DESCRIPTION The zlib command provides access to the compression and check-summing facilities of the Zlib library by Jean-loup Gailly and Mark Adler. It has the following subcommands. COMPRESSION SUBCOMMANDS zlib compress string ? level ? : Returns the zlib-format compressed binary data of the binary string in string . If present, level gives the compression level to use (from 0, which is uncompressed, to 9, maximally compressed). zlib decompress string ? bufferSize ? : Returns the uncompressed version of the raw compressed binary data in string . If present, bufferSize is a hint as to what size of buffer is to be used to receive the data. zlib deflate string ? level ? : Returns the raw compressed binary data of the binary string in string . If present, level gives the compression level to use (from 0, which is uncompressed, to 9, maximally compressed). zlib gunzip string ? -headerVar varName ? : Return the uncompressed contents of binary string string , which must have been in gzip format. If -headerVar is given, store a dictionary describing the contents of the gzip header in the variable called varName . The keys of the dictionary that may be present are: **comment** : The comment field from the header, if present. **crc** : A boolean value describing whether a CRC of the header is computed. **filename** : The filename field from the header, if present. **os** : The operating system type code field from the header (if not the QW unknown value). See RFC 1952 for the meaning of these codes. **size** : The size of the uncompressed data. **time** : The time field from the header if non-zero, expected to be time that the file named by the **filename** field was modified. Suitable for use with **clock format**. **type** : The type of the uncompressed data (**binary** or **text**) if known. zlib gzip string ? -level level ? ? -header dict ? : Return the compressed contents of binary string string in gzip format. If -level is given, level gives the compression level to use (from 0, which is uncompressed, to 9, maximally compressed). If -header is given, dict is a dictionary containing values used for the gzip header. The following keys may be defined: **comment** : Add the given comment to the header of the gzip-format data. **crc** : A boolean saying whether to compute a CRC of the header. Note that if the data is to be interchanged with the **gzip** program, a header CRC should *not* be computed. **filename** : The name of the file that the data to be compressed came from. **os** : The operating system type code, which should be one of the values described in RFC 1952. **time** : The time that the file named in the **filename** key was last modified. This will be in the same as is returned by **clock seconds** or **file mtime**. **type** : The type of the data being compressed, being **binary** or **text**. zlib inflate string ? bufferSize ? : Returns the uncompressed version of the raw compressed binary data in string . If present, bufferSize is a hint as to what size of buffer is to be used to receive the data. CHANNEL SUBCOMMAND zlib push mode channel ? options ... ? : Pushes a compressing or decompressing transformation onto the channel channel . The transformation can be removed again with chan pop . The mode argument determines what type of transformation is pushed; the following are supported: **compress** : The transformation will be a compressing transformation that produces zlib-format data on *channel*, which must be writable. **decompress** : The transformation will be a decompressing transformation that reads zlib-format data from *channel*, which must be readable. **deflate** : The transformation will be a compressing transformation that produces raw compressed data on *channel*, which must be writable. **gunzip** : The transformation will be a decompressing transformation that reads gzip-format data from *channel*, which must be readable. **gzip** : The transformation will be a compressing transformation that produces gzip-format data on *channel*, which must be writable. **inflate** : The transformation will be a decompressing transformation that reads raw compressed data from *channel*, which must be readable. The following options may be set when creating a transformation via the to the **zlib push** command: **-dictionary*** binData* : Sets the compression dictionary to use when working with compressing or decompressing the data to be *binData*. Not valid for transformations that work with gzip-format data. The dictionary should consist of strings (byte sequences) that are likely to be encountered later in the data to be compressed, with the most commonly used strings preferably put towards the end of the dictionary. Tcl provides no mechanism for choosing a good such dictionary for a particular data sequence. **-header*** dictionary* : Passes a description of the gzip header to create, in the same format that **zlib gzip** understands. **-level*** compressionLevel* : How hard to compress the data. Must be an integer from 0 (uncompressed) to 9 (maximally compressed). **-limit*** readaheadLimit* : The maximum number of bytes ahead to read when decompressing. This option has become **irrelevant**. It was originally introduced to prevent Tcl from reading beyond the end of a compressed stream in multi-stream channels to ensure that the data after was left alone for further reading, at the cost of speed. Tcl now automatically returns any bytes it has read beyond the end of a compressed stream back to the channel, making them appear as unread to further readers. Both compressing and decompressing channel transformations add extra configuration options that may be accessed through **chan configure**. The options are: **-checksum*** checksum* : This read-only option gets the current checksum for the uncompressed data that the compression engine has seen so far. It is valid for both compressing and decompressing transforms, but not for the raw inflate and deflate formats. The compression algorithm depends on what format is being produced or consumed. **-dictionary*** binData* : This read-write options gets or sets the initial compression dictionary to use when working with compressing or decompressing the data to be *binData*. It is not valid for transformations that work with gzip-format data, and should not normally be set on compressing transformations other than at the point where the transformation is stacked. Note that this cannot be used to get the current active compression dictionary mid-stream, as that information is not exposed by the underlying library. **-flush*** type* : This write-only operation flushes the current state of the compressor to the underlying channel. It is only valid for compressing transformations. The *type* must be either **sync** or **full** for a normal flush or an expensive flush respectively. Flushing degrades the compression ratio, but makes it easier for a decompressor to recover more of the file in the case of data corruption. **-header*** dictionary* : This read-only option, only valid for decompressing transforms that are processing gzip-format data, returns the dictionary describing the header read off the data stream. **-limit*** readaheadLimit* : This read-write option is used by decompressing channels to control the maximum number of bytes ahead to read from the underlying data source. See above for more information. STREAMING SUBCOMMAND zlib stream mode ? options ? : Creates a streaming compression or decompression command based on the mode , and return the name of the command. For a description of how that command works, see STREAMING INSTANCE COMMAND below. The following modes and options are supported: **zlib stream compress** ?**-dictionary ***bindata*? ?**-level ***level*? : The stream will be a compressing stream that produces zlib-format output, using compression level *level* (if specified) which will be an integer from 0 to 9, and the compression dictionary *bindata* (if specified). **zlib stream decompress** ?**-dictionary ***bindata*? : The stream will be a decompressing stream that takes zlib-format input and produces uncompressed output. If *bindata* is supplied, it is a compression dictionary to use if required. **zlib stream deflate** ?**-dictionary ***bindata*? ?**-level ***level*? : The stream will be a compressing stream that produces raw output, using compression level *level* (if specified) which will be an integer from 0 to 9, and the compression dictionary *bindata* (if specified). Note that the raw compressed data includes no metadata about what compression dictionary was used, if any; that is a feature of the zlib-format data. **zlib stream gunzip** : The stream will be a decompressing stream that takes gzip-format input and produces uncompressed output. **zlib stream gzip** ?**-header ***header*? ?**-level ***level*? : The stream will be a compressing stream that produces gzip-format output, using compression level *level* (if specified) which will be an integer from 0 to 9, and the header descriptor dictionary *header* (if specified; for keys see **zlib gzip**). **zlib stream inflate** ?**-dictionary ***bindata*? : The stream will be a decompressing stream that takes raw compressed input and produces uncompressed output. If *bindata* is supplied, it is a compression dictionary to use. Note that there are no checks in place to determine whether the compression dictionary is correct. CHECKSUMMING SUBCOMMANDS zlib adler32 string ? initValue ? : Compute a checksum of binary string string using the Adler-32 algorithm. If given, initValue is used to initialize the checksum engine. zlib crc32 string ? initValue ? : Compute a checksum of binary string string using the CRC-32 algorithm. If given, initValue is used to initialize the checksum engine. STREAMING INSTANCE COMMAND Streaming compression instance commands are produced by the zlib stream command. They are used by calling their put subcommand one or more times to load data in, and their get subcommand one or more times to extract the transformed data. The full set of subcommands supported by a streaming instance command, stream , is as follows: stream add ? option... ? data : A short-cut for followed by stream checksum : Returns the checksum of the uncompressed data seen so far by this stream. stream close : Deletes this stream and frees up all resources associated with it. stream eof : Returns a boolean indicating whether the end of the stream (as determined by the compressed data itself) has been reached. Not all formats support detection of the end of the stream. stream finalize : A short-cut for <!-- --> stream flush : A short-cut for <!-- --> stream fullflush : A short-cut for <!-- --> stream get ? count ? : Return up to count bytes from stream \\'s internal buffers with the transformation applied. If count is omitted, the entire contents of the buffers are returned. stream header Return the gzip header description dictionary extracted from the stream. Only supported for streams created with their mode parameter set to gunzip . stream put ? option... ? data : Append the contents of the binary string data to stream \\'s internal buffers while applying the transformation. The following option s are supported (or an unambiguous prefix of them), which are used to modify the way in which the transformation is applied: **-dictionary*** binData* : Sets the compression dictionary to use when working with compressing or decompressing the data to be *binData*. **-finalize** : Mark the stream as finished, ensuring that all bytes have been wholly compressed or decompressed. For gzip streams, this also ensures that the footer is written to the stream. The stream will need to be reset before having more data written to it after this, though data can still be read out of the stream with the **get** subcommand. This option is mutually exclusive with the **-flush** and **-fullflush** options. **-flush** : Ensure that a decompressor consuming the bytes that the current (compressing) stream is producing will be able to produce all the bytes that have been compressed so far, at some performance penalty. This option is mutually exclusive with the **-finalize** and **-fullflush** options. **-fullflush** : Ensure that not only can a decompressor handle all the bytes produced so far (as with **-flush** above) but also that it can restart from this point if it detects that the stream is partially corrupt. This incurs a substantial performance penalty. This option is mutually exclusive with the **-finalize** and **-flush** options. stream reset : Puts any stream, including those that have been finalized or that have reached eof, back into a state where it can process more data. Throws away all internally buffered data. EXAMPLES To compress a Tcl string, it should be first converted to a particular charset encoding since the zlib command always operates on binary strings. set binData [encoding convertto utf-8 \\$string] set compData [ zlib compress \\$binData] When converting back, it is also important to reverse the charset encoding: set binData [ zlib decompress \\$compData] set string [encoding convertfrom utf-8 \\$binData] The compression operation from above can also be done with streams, which is especially helpful when you want to accumulate the data by stages: set strm [ zlib stream compress] \\$ strm put [encoding convertto utf-8 \\$string] # ... \\$ strm finalize set compData [\\$ strm get ] \\$ strm close SEE ALSO binary(n), chan(n), encoding(n), Tcl_ZlibDeflate(3), RFC1950 - RFC1952 KEYWORDS compress, decompress, deflate, gzip, inflate, zlib","title":"NAME"},{"location":"zlib/#name","text":"zlib - compression and decompression operations","title":"NAME"},{"location":"zlib/#synopsis","text":"zlib subcommand arg ...","title":"SYNOPSIS"},{"location":"zlib/#description","text":"The zlib command provides access to the compression and check-summing facilities of the Zlib library by Jean-loup Gailly and Mark Adler. It has the following subcommands.","title":"DESCRIPTION"},{"location":"zlib/#compression-subcommands","text":"zlib compress string ? level ? : Returns the zlib-format compressed binary data of the binary string in string . If present, level gives the compression level to use (from 0, which is uncompressed, to 9, maximally compressed). zlib decompress string ? bufferSize ? : Returns the uncompressed version of the raw compressed binary data in string . If present, bufferSize is a hint as to what size of buffer is to be used to receive the data. zlib deflate string ? level ? : Returns the raw compressed binary data of the binary string in string . If present, level gives the compression level to use (from 0, which is uncompressed, to 9, maximally compressed). zlib gunzip string ? -headerVar varName ? : Return the uncompressed contents of binary string string , which must have been in gzip format. If -headerVar is given, store a dictionary describing the contents of the gzip header in the variable called varName . The keys of the dictionary that may be present are: **comment** : The comment field from the header, if present. **crc** : A boolean value describing whether a CRC of the header is computed. **filename** : The filename field from the header, if present. **os** : The operating system type code field from the header (if not the QW unknown value). See RFC 1952 for the meaning of these codes. **size** : The size of the uncompressed data. **time** : The time field from the header if non-zero, expected to be time that the file named by the **filename** field was modified. Suitable for use with **clock format**. **type** : The type of the uncompressed data (**binary** or **text**) if known. zlib gzip string ? -level level ? ? -header dict ? : Return the compressed contents of binary string string in gzip format. If -level is given, level gives the compression level to use (from 0, which is uncompressed, to 9, maximally compressed). If -header is given, dict is a dictionary containing values used for the gzip header. The following keys may be defined: **comment** : Add the given comment to the header of the gzip-format data. **crc** : A boolean saying whether to compute a CRC of the header. Note that if the data is to be interchanged with the **gzip** program, a header CRC should *not* be computed. **filename** : The name of the file that the data to be compressed came from. **os** : The operating system type code, which should be one of the values described in RFC 1952. **time** : The time that the file named in the **filename** key was last modified. This will be in the same as is returned by **clock seconds** or **file mtime**. **type** : The type of the data being compressed, being **binary** or **text**. zlib inflate string ? bufferSize ? : Returns the uncompressed version of the raw compressed binary data in string . If present, bufferSize is a hint as to what size of buffer is to be used to receive the data.","title":"COMPRESSION SUBCOMMANDS"},{"location":"zlib/#channel-subcommand","text":"zlib push mode channel ? options ... ? : Pushes a compressing or decompressing transformation onto the channel channel . The transformation can be removed again with chan pop . The mode argument determines what type of transformation is pushed; the following are supported: **compress** : The transformation will be a compressing transformation that produces zlib-format data on *channel*, which must be writable. **decompress** : The transformation will be a decompressing transformation that reads zlib-format data from *channel*, which must be readable. **deflate** : The transformation will be a compressing transformation that produces raw compressed data on *channel*, which must be writable. **gunzip** : The transformation will be a decompressing transformation that reads gzip-format data from *channel*, which must be readable. **gzip** : The transformation will be a compressing transformation that produces gzip-format data on *channel*, which must be writable. **inflate** : The transformation will be a decompressing transformation that reads raw compressed data from *channel*, which must be readable. The following options may be set when creating a transformation via the to the **zlib push** command: **-dictionary*** binData* : Sets the compression dictionary to use when working with compressing or decompressing the data to be *binData*. Not valid for transformations that work with gzip-format data. The dictionary should consist of strings (byte sequences) that are likely to be encountered later in the data to be compressed, with the most commonly used strings preferably put towards the end of the dictionary. Tcl provides no mechanism for choosing a good such dictionary for a particular data sequence. **-header*** dictionary* : Passes a description of the gzip header to create, in the same format that **zlib gzip** understands. **-level*** compressionLevel* : How hard to compress the data. Must be an integer from 0 (uncompressed) to 9 (maximally compressed). **-limit*** readaheadLimit* : The maximum number of bytes ahead to read when decompressing. This option has become **irrelevant**. It was originally introduced to prevent Tcl from reading beyond the end of a compressed stream in multi-stream channels to ensure that the data after was left alone for further reading, at the cost of speed. Tcl now automatically returns any bytes it has read beyond the end of a compressed stream back to the channel, making them appear as unread to further readers. Both compressing and decompressing channel transformations add extra configuration options that may be accessed through **chan configure**. The options are: **-checksum*** checksum* : This read-only option gets the current checksum for the uncompressed data that the compression engine has seen so far. It is valid for both compressing and decompressing transforms, but not for the raw inflate and deflate formats. The compression algorithm depends on what format is being produced or consumed. **-dictionary*** binData* : This read-write options gets or sets the initial compression dictionary to use when working with compressing or decompressing the data to be *binData*. It is not valid for transformations that work with gzip-format data, and should not normally be set on compressing transformations other than at the point where the transformation is stacked. Note that this cannot be used to get the current active compression dictionary mid-stream, as that information is not exposed by the underlying library. **-flush*** type* : This write-only operation flushes the current state of the compressor to the underlying channel. It is only valid for compressing transformations. The *type* must be either **sync** or **full** for a normal flush or an expensive flush respectively. Flushing degrades the compression ratio, but makes it easier for a decompressor to recover more of the file in the case of data corruption. **-header*** dictionary* : This read-only option, only valid for decompressing transforms that are processing gzip-format data, returns the dictionary describing the header read off the data stream. **-limit*** readaheadLimit* : This read-write option is used by decompressing channels to control the maximum number of bytes ahead to read from the underlying data source. See above for more information.","title":"CHANNEL SUBCOMMAND"},{"location":"zlib/#streaming-subcommand","text":"zlib stream mode ? options ? : Creates a streaming compression or decompression command based on the mode , and return the name of the command. For a description of how that command works, see STREAMING INSTANCE COMMAND below. The following modes and options are supported: **zlib stream compress** ?**-dictionary ***bindata*? ?**-level ***level*? : The stream will be a compressing stream that produces zlib-format output, using compression level *level* (if specified) which will be an integer from 0 to 9, and the compression dictionary *bindata* (if specified). **zlib stream decompress** ?**-dictionary ***bindata*? : The stream will be a decompressing stream that takes zlib-format input and produces uncompressed output. If *bindata* is supplied, it is a compression dictionary to use if required. **zlib stream deflate** ?**-dictionary ***bindata*? ?**-level ***level*? : The stream will be a compressing stream that produces raw output, using compression level *level* (if specified) which will be an integer from 0 to 9, and the compression dictionary *bindata* (if specified). Note that the raw compressed data includes no metadata about what compression dictionary was used, if any; that is a feature of the zlib-format data. **zlib stream gunzip** : The stream will be a decompressing stream that takes gzip-format input and produces uncompressed output. **zlib stream gzip** ?**-header ***header*? ?**-level ***level*? : The stream will be a compressing stream that produces gzip-format output, using compression level *level* (if specified) which will be an integer from 0 to 9, and the header descriptor dictionary *header* (if specified; for keys see **zlib gzip**). **zlib stream inflate** ?**-dictionary ***bindata*? : The stream will be a decompressing stream that takes raw compressed input and produces uncompressed output. If *bindata* is supplied, it is a compression dictionary to use. Note that there are no checks in place to determine whether the compression dictionary is correct.","title":"STREAMING SUBCOMMAND"},{"location":"zlib/#checksumming-subcommands","text":"zlib adler32 string ? initValue ? : Compute a checksum of binary string string using the Adler-32 algorithm. If given, initValue is used to initialize the checksum engine. zlib crc32 string ? initValue ? : Compute a checksum of binary string string using the CRC-32 algorithm. If given, initValue is used to initialize the checksum engine.","title":"CHECKSUMMING SUBCOMMANDS"},{"location":"zlib/#streaming-instance-command","text":"Streaming compression instance commands are produced by the zlib stream command. They are used by calling their put subcommand one or more times to load data in, and their get subcommand one or more times to extract the transformed data. The full set of subcommands supported by a streaming instance command, stream , is as follows: stream add ? option... ? data : A short-cut for followed by stream checksum : Returns the checksum of the uncompressed data seen so far by this stream. stream close : Deletes this stream and frees up all resources associated with it. stream eof : Returns a boolean indicating whether the end of the stream (as determined by the compressed data itself) has been reached. Not all formats support detection of the end of the stream. stream finalize : A short-cut for <!-- --> stream flush : A short-cut for <!-- --> stream fullflush : A short-cut for <!-- --> stream get ? count ? : Return up to count bytes from stream \\'s internal buffers with the transformation applied. If count is omitted, the entire contents of the buffers are returned. stream header Return the gzip header description dictionary extracted from the stream. Only supported for streams created with their mode parameter set to gunzip . stream put ? option... ? data : Append the contents of the binary string data to stream \\'s internal buffers while applying the transformation. The following option s are supported (or an unambiguous prefix of them), which are used to modify the way in which the transformation is applied: **-dictionary*** binData* : Sets the compression dictionary to use when working with compressing or decompressing the data to be *binData*. **-finalize** : Mark the stream as finished, ensuring that all bytes have been wholly compressed or decompressed. For gzip streams, this also ensures that the footer is written to the stream. The stream will need to be reset before having more data written to it after this, though data can still be read out of the stream with the **get** subcommand. This option is mutually exclusive with the **-flush** and **-fullflush** options. **-flush** : Ensure that a decompressor consuming the bytes that the current (compressing) stream is producing will be able to produce all the bytes that have been compressed so far, at some performance penalty. This option is mutually exclusive with the **-finalize** and **-fullflush** options. **-fullflush** : Ensure that not only can a decompressor handle all the bytes produced so far (as with **-flush** above) but also that it can restart from this point if it detects that the stream is partially corrupt. This incurs a substantial performance penalty. This option is mutually exclusive with the **-finalize** and **-flush** options. stream reset : Puts any stream, including those that have been finalized or that have reached eof, back into a state where it can process more data. Throws away all internally buffered data.","title":"STREAMING INSTANCE COMMAND"},{"location":"zlib/#examples","text":"To compress a Tcl string, it should be first converted to a particular charset encoding since the zlib command always operates on binary strings. set binData [encoding convertto utf-8 \\$string] set compData [ zlib compress \\$binData] When converting back, it is also important to reverse the charset encoding: set binData [ zlib decompress \\$compData] set string [encoding convertfrom utf-8 \\$binData] The compression operation from above can also be done with streams, which is especially helpful when you want to accumulate the data by stages: set strm [ zlib stream compress] \\$ strm put [encoding convertto utf-8 \\$string] # ... \\$ strm finalize set compData [\\$ strm get ] \\$ strm close","title":"EXAMPLES"},{"location":"zlib/#see-also","text":"binary(n), chan(n), encoding(n), Tcl_ZlibDeflate(3), RFC1950 - RFC1952","title":"SEE ALSO"},{"location":"zlib/#keywords","text":"compress, decompress, deflate, gzip, inflate, zlib","title":"KEYWORDS"}]}