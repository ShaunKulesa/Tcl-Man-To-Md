<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://www.tcl.tk/man/tcl8.6.13/TclCmd/contents.html/expr/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>NAME - Tcl/Tk</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "NAME";
        var mkdocs_page_input_path = "expr.md";
        var mkdocs_page_url = "/man/tcl8.6.13/TclCmd/contents.html/expr/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Tcl/Tk
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../command.md">Commands</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Tcl/Tk</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>NAME</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="name">NAME</h1>
<p>expr - Evaluate an expression</p>
<h1 id="synopsis">SYNOPSIS</h1>
<p><strong>expr </strong><em>arg </em>?<em>arg arg ...</em>?</p>
<h1 id="description">DESCRIPTION</h1>
<p>Concatenates <em>arg</em>s, separated by a space, into an expression, and
evaluates that expression, returning its value. The operators permitted
in an expression include a subset of the operators permitted in C
expressions. For those operators common to both Tcl and C, Tcl applies
the same meaning and precedence as the corresponding C operators. The
value of an expression is often a numeric result, either an integer or a
floating-point value, but may also be a non-numeric value. For example,
the expression</p>
<p><strong>expr</strong> 8.2 + 6</p>
<p>evaluates to 14.2. Expressions differ from C expressions in the way that
operands are specified. Expressions also support non-numeric operands,
string comparisons, and some additional operators not found in C.</p>
<p>When the result of expression is an integer, it is in decimal form, and
when the result is a floating-point number, it is in the form produced
by the <strong>%g</strong> format specifier of <strong>format</strong>.</p>
<p>At any point in the expression except within double quotes or braces,
<strong>#</strong> is the beginning of a comment, which lasts to the end of the line
or the end of the expression, whichever comes first.</p>
<h2 id="operands">OPERANDS</h2>
<p>An expression consists of a combination of operands, operators,
parentheses and commas, possibly with whitespace between any of these
elements, which is ignored. Each operand is interpreted as a numeric
value if at all possible.</p>
<p>Each operand has one of the following forms:</p>
<blockquote>
<p>A <strong>numeric value</strong></p>
<p>:   </p>
<blockquote>
<p>Either integer or floating-point. The first two characters of an
integer may also be <strong>0d</strong> for decimal, <strong>0b</strong> for binary, <strong>0o</strong>
for octal or <strong>0x</strong> for hexadicimal.</p>
<p>A floating-point number may be take any of several common decimal
formats, and may use the decimal point <strong>.</strong>, <strong>e</strong> or <strong>E</strong> for
scientific notation, and the sign characters <strong>+</strong> and <strong>-</strong>. The
following are all valid floating-point numbers: 2.1, 3., 6e4,
7.91e+16. The strings <strong>Inf</strong> and <strong>NaN</strong>, in any combination of
case, are also recognized as floating point values. An operand that
doesn\'t have a numeric interpretation must be quoted with either
braces or with double quotes.</p>
<p>Digits in any numeric value may be separated with one or more
underscore characters, \"<strong>_</strong>\". A separator may only appear
between digits, not appear at the start of a numeric value, between
the leading 0 and radix specifier, or at the end of a numeric value.
Here are some examples:</p>
<p><strong>expr</strong> 100_000_000 <em>100000000</em> <strong>expr</strong> 0xffff_ffff <em>4294967295</em>
<strong>format</strong> 0x%x 0b1111_1110_1101_1011 <em>0xfedb</em></p>
</blockquote>
<p>A <strong>boolean value</strong></p>
<p>:   Using any form understood by <strong>string is</strong> <strong>boolean</strong>.</p>
<p>A <strong>variable</strong></p>
<p>:   Using standard <strong>\$</strong> notation. The value of the variable is the
    value of the operand.</p>
<p>A string enclosed in <strong>double-quotes</strong></p>
<p>:   Backslash, variable, and command substitution are performed
    according to the rules for <strong>Tcl</strong>.</p>
<p>A string enclosed in <strong>braces</strong>.</p>
<p>:   The operand is treated as a braced value according to the rule for
    braces in <strong>Tcl</strong>.</p>
<p>A Tcl command enclosed in <strong>brackets</strong></p>
<p>:   Command substitution is performed as according to the command
    substitution rule for <strong>Tcl</strong>.</p>
<p>A mathematical function such as <strong>sin(\$x)</strong>, whose arguments have any of the above</p>
<p>:   forms for operands. See <strong>MATH FUNCTIONS</strong> below for a discussion
    of how mathematical functions are handled.</p>
</blockquote>
<p>Because <strong>expr</strong> parses and performs substitutions on values that have
already been parsed and substituted by <strong>Tcl</strong>, it is usually best to
enclose expressions in braces to avoid the first round of substitutions
by <strong>Tcl</strong>.</p>
<p>Below are some examples of simple expressions where the value of <strong>a</strong>
is 3 and the value of <strong>b</strong> is 6. The command on the left side of each
line produces the value on the right side.</p>
<p><strong>expr</strong> {3.1 + \$a} <em>6.1</em> <strong>expr</strong> {2 + \"\$a.\$b\"} <em>5.6</em> <strong>expr</strong>
{4*[llength {6 2}]} <em>8</em> <strong>expr</strong> {{word one} \&lt; \"word \$a\"} <em>0</em></p>
<h2 id="operators">OPERATORS</h2>
<p>For operators having both a numeric mode and a string mode, the numeric
mode is chosen when all operands have a numeric interpretation. The
integer interpretation of an operand is preferred over the
floating-point interpretation. To ensure string operations on arbitrary
values it is generally a good idea to use <strong>eq</strong>, <strong>ne</strong>, or the
<strong>string</strong> command instead of more versatile operators such as <strong>==</strong>.</p>
<p>Unless otherwise specified, operators accept non-numeric operands. The
value of a boolean operation is 1 if true, 0 otherwise. See also
<strong>string is</strong> <strong>boolean</strong>. The valid operators, most of which are also
available as commands in the <strong>tcl::mathop</strong> namespace (see
<strong>mathop</strong>(n)), are listed below, grouped in decreasing order of
precedence:</p>
<p><strong>-  +  \~  !</strong></p>
<p>:   Unary minus, unary plus, bit-wise NOT, logical NOT. These operators
    may only be applied to numeric operands, and bit-wise NOT may only
    be applied to integers.</p>
<p><strong>**</strong></p>
<p>:   Exponentiation. Valid for numeric operands. The maximum exponent
    value that Tcl can handle if the first number is an integer > 1 is
    268435455.</p>
<p><strong>*  /  %</strong></p>
<p>:   Multiply and divide, which are valid for numeric operands, and
    remainder, which is valid for integers. The remainder, an absolute
    value smaller than the absolute value of the divisor, has the same
    sign as the divisor.</p>
<pre><code>When applied to integers, division and remainder can be considered
to partition the number line into a sequence of adjacent
non-overlapping pieces, where each piece is the size of the divisor;
the quotient identifies which piece the dividend lies within, and
the remainder identifies where within that piece the dividend lies.
A consequence of this is that the result of

is always -6, and the result of

is always 3.
</code></pre>
<p><strong>+  -</strong></p>
<p>:   Add and subtract. Valid for numeric operands.</p>
<p><strong>\&lt;\&lt;  >></strong></p>
<p>:   Left and right shift. Valid for integers. A right shift always
    propagates the sign bit.</p>
<p><strong>\&lt;  >  \&lt;=  >=</strong></p>
<p>:   Boolean numeric-preferring comparisons: less than, greater than,
    less than or equal, and greater than or equal. If either argument is
    not numeric, the comparison is done using UNICODE string comparison,
    as with the string comparison operators below, which have the same
    precedence.</p>
<p><strong>lt  gt  le  ge</strong></p>
<p>:   </p>
<p>Boolean string comparisons: less than, greater than, less than or equal,
and greater than or equal. These always compare values using their
UNICODE strings (also see <strong>string compare</strong>), unlike with the
numeric-preferring comparisons abov, which have the same precedence.</p>
<p><strong>==  !=</strong></p>
<p>:   Boolean equal and not equal.</p>
<p><strong>eq  ne</strong></p>
<p>:   Boolean string equal and string not equal.</p>
<p><strong>in  ni</strong></p>
<p>:   List containment and negated list containment. The first argument is
    interpreted as a string, the second as a list. <strong>in</strong> tests for
    membership in the list, and <strong>ni</strong> is the inverse.</p>
<p><strong>&amp;</strong></p>
<p>:   Bit-wise AND. Valid for integer operands.</p>
<p><strong>\^</strong></p>
<p>:   Bit-wise exclusive OR. Valid for integer operands.</p>
<p><strong>|</strong></p>
<p>:   Bit-wise OR. Valid for integer operands.</p>
<p><strong>&amp;&amp;</strong></p>
<p>:   Logical AND. If both operands are true, the result is 1, or 0
    otherwise. This operator evaluates lazily; it only evaluates its
    second operand if it must in order to determine its result. This
    operator evaluates lazily; it only evaluates its second operand if
    it must in order to determine its result.</p>
<p><strong>||</strong></p>
<p>:   Logical OR. If both operands are false, the result is 0, or 1
    otherwise. This operator evaluates lazily; it only evaluates its
    second operand if it must in order to determine its result.</p>
<p><em>x </em><strong>?</strong><em> y </em><strong>:</strong><em> z</em></p>
<p>:   If-then-else, as in C. If <em>x</em> is false , the result is the value of
    <em>y</em>. Otherwise the result is the value of <em>z</em>. This operator
    evaluates lazily; it evaluates only one of <em>y</em> or <em>z</em>.</p>
<p>The exponentiation operator promotes types in the same way that the
multiply and divide operators do, and the result is is the same as the
result of <strong>pow</strong>. Exponentiation groups right-to-left within a
precedence level. Other binary operators group left-to-right. For
example, the value of</p>
<p><strong>expr</strong> {4*2 \&lt; 7}</p>
<p>is 0, while the value of</p>
<p><strong>expr</strong> {2**3**2}</p>
<p>is 512.</p>
<p>As in C, <strong>&amp;&amp;</strong>, <strong>||</strong>, and <strong>?:</strong> feature</p>
<p>which means that operands are not evaluated if they are not needed to
determine the outcome. For example, in</p>
<p><strong>expr</strong> {\$v?[a]:[b]}</p>
<p>only one of <strong>[a]</strong> or <strong>[b]</strong> is evaluated, depending on the value
of <strong>\$v</strong>. This is not true of the normal Tcl parser, so it is normally
recommended to enclose the arguments to <strong>expr</strong> in braces. Without
braces, as in <strong>expr</strong> \$v ? [a] : [b] both <strong>[a]</strong> and <strong>[b]</strong>
are evaluated before <strong>expr</strong> is even called.</p>
<p>For more details on the results produced by each operator, see the
documentation for C.</p>
<h2 id="math-functions">MATH FUNCTIONS</h2>
<p>A mathematical function such as <strong>sin(\$x)</strong> is replaced with a call to
an ordinary Tcl command in the <strong>tcl::mathfunc</strong> namespace. The
evaluation of an expression such as</p>
<p><strong>expr</strong> {sin(\$x+\$y)}</p>
<p>is the same in every way as the evaluation of</p>
<p><strong>expr</strong> {[tcl::mathfunc::sin [<strong>expr</strong> {\$x+\$y}]]}</p>
<p>which in turn is the same as the evaluation of</p>
<p>tcl::mathfunc::sin [<strong>expr</strong> {\$x+\$y}]</p>
<p><strong>tcl::mathfunc::sin</strong> is resolved as described in <strong>NAMESPACE
RESOLUTION</strong> in the <strong>namespace</strong>(n) documentation. Given the default
value of <strong>namespace path</strong>, <strong>[namespace</strong>
current]::tcl::mathfunc::sin or <strong>::tcl::mathfunc::sin</strong> are the
typical resolutions.</p>
<p>As in C, a mathematical function may accept multiple arguments separated
by commas. Thus,</p>
<p><strong>expr</strong> {hypot(\$x,\$y)}</p>
<p>becomes</p>
<p>tcl::mathfunc::hypot \$x \$y</p>
<p>See the <strong>mathfunc</strong>(n) documentation for the math functions that are
available by default.</p>
<h2 id="types-overflow-and-precision">TYPES, OVERFLOW, AND PRECISION</h2>
<p>When needed to guarantee exact performance, internal computations
involving integers use the LibTomMath multiple precision integer
library. In Tcl releases prior to 8.5, integer calculations were
performed using one of the C types <em>long int</em> or <em>Tcl_WideInt</em>, causing
implicit range truncation in those calculations where values overflowed
the range of those types. Any code that relied on these implicit
truncations should instead call <strong>int()</strong> or <strong>wide()</strong>, which do
truncate.</p>
<p>Internal floating-point computations are performed using the <em>double</em> C
type. When converting a string to floating-point value, exponent
overflow is detected and results in the <em>double</em> value of <strong>Inf</strong> or
<strong>-Inf</strong> as appropriate. Floating-point overflow and underflow are
detected to the degree supported by the hardware, which is generally
fairly reliable.</p>
<p>Conversion among internal representations for integer, floating-point,
and string operands is done automatically as needed. For arithmetic
computations, integers are used until some floating-point number is
introduced, after which floating-point values are used. For example,</p>
<p><strong>expr</strong> {5 / 4}</p>
<p>returns 1, while</p>
<p><strong>expr</strong> {5 / 4.0} <strong>expr</strong> {5 / ( [string length \"abcd\"] + 0.0 )}</p>
<p>both return 1.25. A floating-point result can be distinguished from an
integer result by the presence of either</p>
<p>or</p>
<p><strong>expr</strong> {20.0/5.0}</p>
<p>returns <strong>4.0</strong>, not <strong>4</strong>.</p>
<h1 id="performance-considerations">PERFORMANCE CONSIDERATIONS</h1>
<p>Where an expression contains syntax that Tcl would otherwise perform
substitutions on, enclosing an expression in braces or otherwise quoting
it so that it\'s a static value allows the Tcl compiler to generate
bytecode for the expression, resulting in better speed and smaller
storage requirements. This also avoids issues that can arise if Tcl is
allowed to perform substitution on the value before <strong>expr</strong> is called.</p>
<p>In the following example, the value of the expression is 11 because the
Tcl parser first substitutes <strong>\$b</strong> and <strong>expr</strong> then substitutes
<strong>\$a</strong> as part of evaluating the expression</p>
<p>Enclosing the expression in braces would result in a syntax error as
<strong>\$b</strong> does not evaluate to a numeric value.</p>
<p>set a 3 set b {\$a + 2} <strong>expr</strong> \$b*4</p>
<p>When an expression is generated at runtime, like the one above is, the
bytecode compiler must ensure that new code is generated each time the
expression is evaluated. This is the most costly kind of expression from
a performance perspective. In such cases, consider directly using the
commands described in the <strong>mathfunc</strong>(n) or <strong>mathop</strong>(n) documentation
instead of <strong>expr</strong>.</p>
<p>Most expressions are not formed at runtime, but are literal strings or
contain substitutions that don\'t introduce other substitutions. To
allow the bytecode compiler to work with an expression as a string
literal at compilation time, ensure that it contains no substitutions or
that it is enclosed in braces or otherwise quoted to prevent Tcl from
performing substitutions, allowing <strong>expr</strong> to perform them instead.</p>
<p>If it is necessary to include a non-constant expression string within
the wider context of an otherwise-constant expression, the most
efficient technique is to put the varying part inside a recursive
<strong>expr</strong>, as this at least allows for the compilation of the outer part,
though it does mean that the varying part must itself be evaluated as a
separate expression. Thus, in this example the result is 20 and the
outer expression benefits from fully cached bytecode compilation.</p>
<p>set a 3 set b {\$a + 2} <strong>expr</strong> {[<strong>expr</strong> \$b] * 4}</p>
<p>In general, you should enclose your expression in braces wherever
possible, and where not possible, the argument to <strong>expr</strong> should be an
expression defined elsewhere as simply as possible. It is usually more
efficient and safer to use other techniques (e.g., the commands in the
<strong>tcl::mathop</strong> namespace) than it is to do complex expression
generation.</p>
<h1 id="examples">EXAMPLES</h1>
<p>A numeric comparison whose result is 1:</p>
<p><strong>expr</strong> {\"0x03\" > \"2\"}</p>
<p>A string comparison whose result is 1:</p>
<p><strong>expr</strong> {\"0y\" > \"0x12\"}</p>
<p>A forced string comparison whose result is 0:</p>
<p><strong>expr</strong> {\"0x03\" gt \"2\"}</p>
<p>Define a procedure that computes an</p>
<p>mathematical function:</p>
<p>proc tcl::mathfunc::calc {x y} { <strong>expr</strong> { (\$x**2 - \$y**2) /
exp(\$x**2 + \$y**2) } }</p>
<p>Convert polar coordinates into cartesian coordinates:</p>
<p># convert from (\$radius,\$angle) set x [<strong>expr</strong> { \$radius *
cos(\$angle) }] set y [<strong>expr</strong> { \$radius * sin(\$angle) }]</p>
<p>Convert cartesian coordinates into polar coordinates:</p>
<p># convert from (\$x,\$y) set radius [<strong>expr</strong> { hypot(\$y, \$x) }]
set angle [<strong>expr</strong> { atan2(\$y, \$x) }]</p>
<p>Print a message describing the relationship of two string values to each
other:</p>
<p>puts \"a and b are [<strong>expr</strong> {\$a eq \$b ? {equal} : {different}}]\"</p>
<p>Set a variable indicating whether an environment variable is defined and
has value of true:</p>
<p>set isTrue [<strong>expr</strong> { # Does the environment variable exist, and...
[info exists ::env(SOME_ENV_VAR)] &amp;&amp; # ...does it contain a proper
true value? [string is true -strict \$::env(SOME_ENV_VAR)] }]</p>
<p>Generate a random integer in the range 0..99 inclusive:</p>
<p>set randNum [<strong>expr</strong> { int(100 * rand()) }]</p>
<h1 id="see-also">SEE ALSO</h1>
<p>array(n), for(n), if(n), mathfunc(n), mathop(n), namespace(n), proc(n),
string(n), Tcl(n), while(n)</p>
<h1 id="keywords">KEYWORDS</h1>
<p>arithmetic, boolean, compare, expression, fuzzy comparison, integer
value</p>
<h1 id="copyright">COPYRIGHT</h1>
<pre><code>Copyright © 1993 The Regents of the University of California.
Copyright © 1994-2000 Sun Microsystems Incorporated.
Copyright © 2005 Kevin B. Kenny &lt;kennykb@acm.org&gt;. All rights reserved.
</code></pre>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
