<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://www.tcl.tk/man/tcl8.6.13/TclCmd/contents.html/define/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>NAME - Tcl/Tk</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "NAME";
        var mkdocs_page_input_path = "define.md";
        var mkdocs_page_url = "/man/tcl8.6.13/TclCmd/contents.html/define/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Tcl/Tk
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../command.md">Commands</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Tcl/Tk</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>NAME</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="name">NAME</h1>
<p>oo::define, oo::objdefine - define and configure classes and objects</p>
<h1 id="synopsis">SYNOPSIS</h1>
<pre><code>package require tcl::oo

oo::define class defScript
oo::define class subcommand arg ?arg ...?
oo::objdefine object defScript
oo::objdefine object subcommand arg ?arg ...?
</code></pre>
<h1 id="description">DESCRIPTION</h1>
<p>The <strong>oo::define</strong> command is used to control the configuration of
classes, and the <strong>oo::objdefine</strong> command is used to control the
configuration of objects (including classes as instance objects), with
the configuration being applied to the entity named in the <em>class</em> or
the <em>object</em> argument. Configuring a class also updates the
configuration of all subclasses of the class and all objects that are
instances of that class or which mix it in (as modified by any
per-instance configuration). The way in which the configuration is done
is controlled by either the <em>defScript</em> argument or by the <em>subcommand</em>
and following <em>arg</em> arguments; when the second is present, it is exactly
as if all the arguments from <em>subcommand</em> onwards are made into a list
and that list is used as the <em>defScript</em> argument.</p>
<p>Note that the constructor for <strong>oo::class</strong> will call <strong>oo::define</strong> on
the script argument that it is provided. This is a convenient way to
create and define a class in one step.</p>
<h1 id="configuring-classes">CONFIGURING CLASSES</h1>
<p>The following commands are supported in the <em>defScript</em> for
<strong>oo::define</strong>, each of which may also be used in the <em>subcommand</em> form:</p>
<p><strong>classmethod</strong><em> name</em> ?<em>argList bodyScrip</em>?</p>
<p>:   </p>
<p>This creates a class method, or (if <em>argList</em> and <em>bodyScript</em> are
omitted) promotes an existing method on the class object to be a class
method. The <em>name</em>, <em>argList</em> and <em>bodyScript</em> arguments are as in the
<strong>method</strong> definition, below.</p>
<blockquote>
<p>Class methods can be called on either the class itself or on the
instances of that class. When they are called, the current object (see
the <strong>sel</strong> and <strong>my</strong> commands) is the class on which they are called
or the class of the instance on which they are called, depending on
whether they are called on the class or an instance of the class,
respectively. If called on a subclass or instance of the subclass, the
current object is the subclass.</p>
<p>In a private definition context, the methods as invoked on classes are
<em>not</em> private, but the methods as invoked on instances of classes are
private.</p>
</blockquote>
<p><strong>constructor</strong><em> argList bodyScript</em></p>
<p>:   This creates or updates the constructor for a class. The formal
    arguments to the constructor (defined using the same format as for
    the Tcl <strong>proc</strong> command) will be <em>argList</em>, and the body of the
    constructor will be <em>bodyScript</em>. When the body of the constructor
    is evaluated, the current namespace of the constructor will be a
    namespace that is unique to the object being constructed. Within the
    constructor, the <strong>next</strong> command should be used to call the
    superclasses\' constructors. If <em>bodyScript</em> is the empty string,
    the constructor will be deleted.</p>
<pre><code>Classes do not need to have a constructor defined. If none is
specified, the superclass\'s constructor will be used instead.
</code></pre>
<p><strong>destructor</strong><em> bodyScript</em></p>
<p>:   This creates or updates the destructor for a class. Destructors take
    no arguments, and the body of the destructor will be <em>bodyScript</em>.
    The destructor is called when objects of the class are deleted, and
    when called will have the object\'s unique namespace as the current
    namespace. Destructors should use the <strong>next</strong> command to call the
    superclasses\' destructors. Note that destructors are not called in
    all situations (e.g. if the interpreter is destroyed). If
    <em>bodyScript</em> is the empty string, the destructor will be deleted.</p>
<pre><code>Note that errors during the evaluation of a destructor *are not
returned* to the code that causes the destruction of an object.
Instead, they are passed to the currently-defined **bgerror**
handler.
</code></pre>
<p><strong>export</strong><em> name </em>?<em>name ...</em>?</p>
<p>:   This arranges for each of the named methods, <em>name</em>, to be exported
    (i.e. usable outside an instance through the instance object\'s
    command) by the class being defined. Note that the methods
    themselves may be actually defined by a superclass; subclass exports
    override superclass visibility, and may in turn be overridden by
    instances.</p>
<p><strong>forward</strong><em> name cmdName </em>?<em>arg ...</em>?</p>
<p>:   This creates or updates a forwarded method called <em>name</em>. The method
    is defined be forwarded to the command called <em>cmdName</em>, with
    additional arguments, <em>arg</em> etc., added before those arguments
    specified by the caller of the method. The <em>cmdName</em> will always be
    resolved using the rules of the invoking objects\' namespaces, i.e.,
    when <em>cmdName</em> is not fully-qualified, the command will be searched
    for in each object\'s namespace, using the instances\' namespace\'s
    path, or by looking in the global namespace. The method will be
    exported if <em>name</em> starts with a lower-case letter, and non-exported
    otherwise.</p>
<pre><code>If in a private definition context (see the **private** definition
command, below), this command creates private forwarded methods.
</code></pre>
<p><strong>initialise</strong><em> script</em></p>
<p>:   </p>
<p><strong>initialize</strong><em> script</em></p>
<p>:   </p>
<p>This evaluates <em>script</em> in a context which supports local variables and
where the current namespace is the instance namespace of the class
object itself. This is useful for setting up, e.g., class-scoped
variables.</p>
<p><strong>method</strong><em> name </em>?<em>option</em>? <em>argList bodyScript</em></p>
<p>:   This creates or updates a method that is implemented as a
    procedure-like script. The name of the method is <em>name</em>, the formal
    arguments to the method (defined using the same format as for the
    Tcl <strong>proc</strong> command) will be <em>argList</em>, and the body of the method
    will be <em>bodyScript</em>. When the body of the method is evaluated, the
    current namespace of the method will be a namespace that is unique
    to the current object. The method will be exported if <em>name</em> starts
    with a lower-case letter, and non-exported otherwise; this behavior
    can be overridden via <strong>export</strong> and <strong>unexport</strong></p>
<p>or by specifying <strong>-export</strong>, <strong>-private</strong> or <strong>-unexport</strong> in the
optional parameter <em>option</em>.</p>
<blockquote>
<p>If in a private definition context (see the <strong>private</strong> definition
command, below) or if the <strong>-private</strong> flag is given for <em>option</em>,
this command creates private procedure-like methods.</p>
</blockquote>
<p><strong>private </strong><em>cmd arg...</em></p>
<p>:   </p>
<p><strong>private </strong><em>script</em></p>
<p>:   </p>
<p>This evaluates the <em>script</em> (or the list of command and arguments given
by <em>cmd</em> and <em>arg</em>s) in a context where the definitions made on the
current class will be private definitions.</p>
<blockquote>
<p>The following class definition commands are affected by <strong>private</strong>:
<strong>forward</strong>, <strong>method</strong>, <strong>self</strong>, and <strong>variable</strong>. Nesting
<strong>private</strong> inside <strong>private</strong> has no cumulative effect; the innermost
definition context is just a private definition context. All other
definition commands have no difference in behavior when used in a
private definition context.</p>
</blockquote>
<p><strong>self</strong><em> subcommand arg ...</em></p>
<p>:   </p>
<p><strong>self</strong><em> script</em></p>
<p>:   </p>
<p><strong>self</strong></p>
<p>:   This command is equivalent to calling <strong>oo::objdefine</strong> on the class
    being defined (see <strong>CONFIGURING OBJECTS</strong> below for a description
    of the supported values of <em>subcommand</em>). It follows the same
    general pattern of argument handling as the <strong>oo::define</strong> and
    <strong>oo::objdefine</strong> commands, and</p>
<p>operates identically to</p>
<blockquote>
<p>If no arguments at all are used, this gives the name of the class
currently being configured.</p>
<p>If in a private definition context (see the <strong>private</strong> definition
command, below), the definitions on the class object will also be made
in a private definition context.</p>
</blockquote>
<p><strong>superclass</strong> ?<em>-slotOperation</em>? ?<em>className ...</em>?</p>
<p>:   This slot (see <strong>SLOTTED DEFINITIONS</strong> below) allows the alteration
    of the superclasses of the class being defined. Each <em>className</em>
    argument names one class that is to be a superclass of the defined
    class. Note that objects must not be changed from being classes to
    being non-classes or vice-versa, that an empty parent class is
    equivalent to <strong>oo::object</strong>, and that the parent classes of
    <strong>oo::object</strong> and <strong>oo::class</strong> may not be modified. By default,
    this slot works by replacement.</p>
<p><strong>unexport</strong><em> name </em>?<em>name ...</em>?</p>
<p>:   This arranges for each of the named methods, <em>name</em>, to be not
    exported (i.e. not usable outside the instance through the instance
    object\'s command, but instead just through the <strong>my</strong> command
    visible in each object\'s context) by the class being defined. Note
    that the methods themselves may be actually defined by a superclass;
    subclass unexports override superclass visibility, and may be
    overridden by instance unexports.</p>
<p><strong>variable</strong> ?<em>-slotOperation</em>? ?<em>name ...</em>?</p>
<p>:   This slot (see <strong>SLOTTED DEFINITIONS</strong> below) arranges for each of
    the named variables to be automatically made available in the
    methods, constructor and destructor declared by the class being
    defined. Each variable name must not have any namespace separators
    and must not look like an array access. All variables will be
    actually present in the namespace of the instance object on which
    the method is executed. Note that the variable lists declared by a
    superclass or subclass are completely disjoint, as are variable
    lists declared by instances; the list of variable names is just for
    methods (and constructors and destructors) declared by this class.
    By default, this slot works by appending.</p>
<pre><code>If in a private definition context (see the **private** definition
command, below), this slot manipulates the list of private variable
bindings for this class. In a private variable binding, the name of
the variable within the instance object is different to the name
given in the definition; the name used in the definition is the name
that you use to access the variable within the methods of this
class, and the name of the variable in the instance namespace has a
unique prefix that makes accidental use from other classes extremely
unlikely.
</code></pre>
<h2 id="advanced-class-configuration-options">ADVANCED CLASS CONFIGURATION OPTIONS</h2>
<p>The following definitions are also supported, but are not required in
simple programs:</p>
<p><strong>definitionnamespace</strong> ?<em>kind</em>? <em>namespaceName</em></p>
<p>:   </p>
<p>This allows control over what namespace will be used by the
<strong>oo::define</strong> and <strong>oo::objdefine</strong> commands to look up the definition
commands they use. When any object has a definition operation applied to
it, <em>the class that</em> it is an instance of (and its superclasses and
mixins) is consulted for what definition namespace to use.
<strong>oo::define</strong> gets the class definition namespace, and
<strong>::oo::objdefine</strong> gets the instance definition namespace, but both
otherwise use the identical lookup operation.</p>
<blockquote>
<p>This sets the definition namespace of kind <em>kind</em> provided by the
current class to <em>namespaceName</em>. The <em>namespaceName</em> must refer to a
currently existing namespace, or must be the empty string (to stop the
current class from having such a namespace connected). The <em>kind</em>, if
supplied, must be either <strong>-class</strong> (the default) or <strong>-instance</strong> to
specify the whether the namespace for use with <strong>oo::define</strong> or
<strong>oo::objdefine</strong> respectively is being set.</p>
<p>The class <strong>oo::object</strong> has its instance namespace locked to
<strong>::oo::objdefine</strong>, and the class <strong>oo::class</strong> has its class
namespace locked to <strong>::oo::define</strong>. A consequence of this is that
effective use of this feature for classes requires the definition of a
metaclass.</p>
</blockquote>
<p><strong>deletemethod</strong><em> name</em> ?<em>name ...</em>?</p>
<p>:   This deletes each of the methods called <em>name</em> from a class. The
    methods must have previously existed in that class. Does not affect
    the superclasses of the class, nor does it affect the subclasses or
    instances of the class (except when they have a call chain through
    the class being modified) or the class object itself.</p>
<p><strong>filter</strong> ?<em>-slotOperation</em>? ?<em>methodName ...</em>?</p>
<p>:   This slot (see <strong>SLOTTED DEFINITIONS</strong> below) sets or updates the
    list of method names that are used to guard whether method call to
    instances of the class may be called and what the method\'s results
    are. Each <em>methodName</em> names a single filtering method (which may be
    exposed or not exposed); it is not an error for a non-existent
    method to be named since they may be defined by subclasses. By
    default, this slot works by appending.</p>
<p><strong>mixin</strong> ?<em>-slotOperation</em>? ?<em>className ...</em>?</p>
<p>:   This slot (see <strong>SLOTTED DEFINITIONS</strong> below) sets or updates the
    list of additional classes that are to be mixed into all the
    instances of the class being defined. Each <em>className</em> argument
    names a single class that is to be mixed in. By default, this slot
    works by replacement.</p>
<p><strong>renamemethod</strong><em> fromName toName</em></p>
<p>:   This renames the method called <em>fromName</em> in a class to <em>toName</em>.
    The method must have previously existed in the class, and <em>toName</em>
    must not previously refer to a method in that class. Does not affect
    the superclasses of the class, nor does it affect the subclasses or
    instances of the class (except when they have a call chain through
    the class being modified), or the class object itself. Does not
    change the export status of the method; if it was exported before,
    it will be afterwards.</p>
<h1 id="configuring-objects">CONFIGURING OBJECTS</h1>
<p>The following commands are supported in the <em>defScript</em> for
<strong>oo::objdefine</strong>, each of which may also be used in the <em>subcommand</em>
form:</p>
<p><strong>export</strong><em> name </em>?<em>name ...</em>?</p>
<p>:   This arranges for each of the named methods, <em>name</em>, to be exported
    (i.e. usable outside the object through the object\'s command) by
    the object being defined. Note that the methods themselves may be
    actually defined by a class or superclass; object exports override
    class visibility.</p>
<p><strong>forward</strong><em> name cmdName </em>?<em>arg ...</em>?</p>
<p>:   This creates or updates a forwarded object method called <em>name</em>. The
    method is defined be forwarded to the command called <em>cmdName</em>, with
    additional arguments, <em>arg</em> etc., added before those arguments
    specified by the caller of the method. Forwarded methods should be
    deleted using the <strong>method</strong> subcommand. The method will be exported
    if <em>name</em> starts with a lower-case letter, and non-exported
    otherwise.</p>
<pre><code>If in a private definition context (see the **private** definition
command, below), this command creates private forwarded methods.
</code></pre>
<p><strong>method</strong><em> name </em>?<em>option</em>? <em>argList bodyScript</em></p>
<p>:   This creates, updates or deletes an object method. The name of the
    method is <em>name</em>, the formal arguments to the method (defined using
    the same format as for the Tcl <strong>proc</strong> command) will be <em>argList</em>,
    and the body of the method will be <em>bodyScript</em>. When the body of
    the method is evaluated, the current namespace of the method will be
    a namespace that is unique to the object. The method will be
    exported if <em>name</em> starts with a lower-case letter, and non-exported
    otherwise;</p>
<p>this can be overridden by specifying <strong>-export</strong>, <strong>-private</strong> or
<strong>-unexport</strong> in the optional parameter <em>option</em>, or via the <strong>export</strong>
and <strong>unexport</strong> definitions.</p>
<blockquote>
<p>If in a private definition context (see the <strong>private</strong> definition
command, below) or if the <strong>-private</strong> flag is given for <em>option</em>,
this command creates private procedure-like methods.</p>
</blockquote>
<p><strong>mixin</strong> ?<em>-slotOperation</em>? ?<em>className ...</em>?</p>
<p>:   This slot (see <strong>SLOTTED DEFINITIONS</strong> below) sets or updates a
    per-object list of additional classes that are to be mixed into the
    object. Each argument, <em>className</em>, names a single class that is to
    be mixed in. By default, this slot works by replacement.</p>
<p><strong>private </strong><em>cmd arg...</em></p>
<p>:   </p>
<p><strong>private </strong><em>script</em></p>
<p>:   </p>
<p>This evaluates the <em>script</em> (or the list of command and arguments given
by <em>cmd</em> and <em>arg</em>s) in a context where the definitions made on the
current object will be private definitions.</p>
<blockquote>
<p>The following class definition commands are affected by <strong>private</strong>:
<strong>forward</strong>, <strong>method</strong>, and <strong>variable</strong>. Nesting <strong>private</strong> inside
<strong>private</strong> has no cumulative effect; the innermost definition context
is just a private definition context. All other definition commands
have no difference in behavior when used in a private definition
context.</p>
</blockquote>
<p><strong>unexport</strong><em> name </em>?<em>name ...</em>?</p>
<p>:   This arranges for each of the named methods, <em>name</em>, to be not
    exported (i.e. not usable outside the object through the object\'s
    command, but instead just through the <strong>my</strong> command visible in the
    object\'s context) by the object being defined. Note that the
    methods themselves may be actually defined by a class; instance
    unexports override class visibility.</p>
<p><strong>variable</strong> ?<em>-slotOperation</em>? ?<em>name ...</em>?</p>
<p>:   This slot (see <strong>SLOTTED DEFINITIONS</strong> below) arranges for each of
    the named variables to be automatically made available in the
    methods declared by the object being defined. Each variable name
    must not have any namespace separators and must not look like an
    array access. All variables will be actually present in the
    namespace of the object on which the method is executed. Note that
    the variable lists declared by the classes and mixins of which the
    object is an instance are completely disjoint; the list of variable
    names is just for methods declared by this object. By default, this
    slot works by appending.</p>
<pre><code>If in a private definition context (see the **private** definition
command, below), this slot manipulates the list of private variable
bindings for this object. In a private variable binding, the name of
the variable within the instance object is different to the name
given in the definition; the name used in the definition is the name
that you use to access the variable within the methods of this
instance object, and the name of the variable in the instance
namespace has a unique prefix that makes accidental use from
superclass methods extremely unlikely.
</code></pre>
<h2 id="advanced-object-configuration-options">ADVANCED OBJECT CONFIGURATION OPTIONS</h2>
<p>The following definitions are also supported, but are not required in
simple programs:</p>
<p><strong>class</strong><em> className</em></p>
<p>:   This allows the class of an object to be changed after creation.
    Note that the class\'s constructors are not called when this is
    done, and so the object may well be in an inconsistent state unless
    additional configuration work is done.</p>
<p><strong>deletemethod</strong><em> name</em> ?<em>name ...</em></p>
<p>:   This deletes each of the methods called <em>name</em> from an object. The
    methods must have previously existed in that object (e.g., because
    it was created through <strong>oo::objdefine method</strong>). Does not affect
    the classes that the object is an instance of, or remove the
    exposure of those class-provided methods in the instance of that
    class.</p>
<p><strong>filter</strong> ?<em>-slotOperation</em>? ?<em>methodName ...</em>?</p>
<p>:   This slot (see <strong>SLOTTED DEFINITIONS</strong> below) sets or updates the
    list of method names that are used to guard whether a method call to
    the object may be called and what the method\'s results are. Each
    <em>methodName</em> names a single filtering method (which may be exposed
    or not exposed); it is not an error for a non-existent method to be
    named. Note that the actual list of filters also depends on the
    filters set upon any classes that the object is an instance of. By
    default, this slot works by appending.</p>
<p><strong>renamemethod</strong><em> fromName toName</em></p>
<p>:   This renames the method called <em>fromName</em> in an object to <em>toName</em>.
    The method must have previously existed in the object, and <em>toName</em>
    must not previously refer to a method in that object. Does not
    affect the classes that the object is an instance of and cannot
    rename in an instance object the methods provided by those classes
    (though a <strong>oo::objdefine forward</strong>ed method may provide an
    equivalent capability). Does not change the export status of the
    method; if it was exported before, it will be afterwards.</p>
<p><strong>self </strong></p>
<p>:   </p>
<p>This gives the name of the object currently being configured.</p>
<h1 id="private-methods">PRIVATE METHODS</h1>
<p>When a class or instance has a private method, that private method can
only be invoked from within methods of that class or instance. Other
callers of the object\'s methods <em>cannot</em> invoke private methods, it is
as if the private methods do not exist. However, a private method of a
class <em>can</em> be invoked from the class\'s methods when those methods are
being used on another instance object; this means that a class can use
them to coordinate behaviour between several instances of itself without
interfering with how other classes (especially either subclasses or
superclasses) interact. Private methods precede all mixed in classes in
the method call order (as reported by <strong>self call</strong>).</p>
<h1 id="slotted-definitions">SLOTTED DEFINITIONS</h1>
<p>Some of the configurable definitions of a class or object are <em>slotted</em>
definitions. This means that the configuration is implemented by a slot
object, that is an instance of the class <strong>oo::Slot</strong>, which manages a
list of values (class names, variable names, etc.) that comprises the
contents of the slot. The class defines five operations (as methods)
that may be done on the slot:</p>
<p><em>slot</em> <strong>-append</strong> ?<em>member ...</em>?</p>
<p>:   This appends the given <em>member</em> elements to the slot definition.</p>
<p><em>slot</em> <strong>-clear</strong></p>
<p>:   This sets the slot definition to the empty list.</p>
<p><em>slot</em> <strong>-prepend</strong> ?<em>member ...</em>?</p>
<p>:   </p>
<p>This prepends the given <em>member</em> elements to the slot definition.</p>
<p><em>slot</em> <strong>-remove</strong> ?<em>member ...</em>?</p>
<p>:   </p>
<p>This removes the given <em>member</em> elements from the slot definition.</p>
<p><em>slot</em> <strong>-set</strong> ?<em>member ...</em>?</p>
<p>:   This replaces the slot definition with the given <em>member</em> elements.</p>
<p>A consequence of this is that any use of a slot\'s default operation
where the first member argument begins with a hyphen will be an error.
One of the above operations should be used explicitly in those
circumstances.</p>
<h2 id="slot-implementation">SLOT IMPLEMENTATION</h2>
<p>Internally, slot objects also define a method <strong>--default-operation</strong>
which is forwarded to the default operation of the slot (thus, for the
class</p>
<p>slot, this is forwarded to</p>
<p>and these methods which provide the implementation interface:</p>
<p><em>slot</em> <strong>Get</strong></p>
<p>:   Returns a list that is the current contents of the slot, but does
    not modify the slot. This method must always be called from a stack
    frame created by a call to <strong>oo::define</strong> or <strong>oo::objdefine</strong>. This
    method <em>should not</em> return an error unless it is called from outside
    a definition context or with the wrong number of arguments.</p>
<pre><code>The elements of the list should be fully resolved, if that is a
meaningful concept to the slot.
</code></pre>
<p><em>slot</em> <strong>Resolve</strong> <em>slotElement</em></p>
<p>:   </p>
<p>Returns <em>slotElement</em> with a resolution operation applied to it, but
does not modify the slot. For slots of simple strings, this is an
operation that does nothing, whereas for slots of classes, this maps a
class name to its fully-qualified class name. This method must always be
called from a stack frame created by a call to <strong>oo::define</strong> or
<strong>oo::objdefine</strong>. This method <em>should not</em> return an error unless it is
called from outside a definition context or with the wrong number of
arguments; unresolvable arguments should be returned as is (as not all
slot operations strictly require that values are resolvable to work).</p>
<blockquote>
<p>Implementations <em>should not</em> enforce uniqueness and ordering
constraints in this method; that is the responsibility of the <strong>Set</strong>
method.</p>
</blockquote>
<p><em>slot</em> <strong>Set </strong><em>elementList</em></p>
<p>:   Sets the contents of the slot to the list <em>elementList</em> and returns
    the empty string. This method must always be called from a stack
    frame created by a call to <strong>oo::define</strong> or <strong>oo::objdefine</strong>. This
    method may return an error if it rejects the change to the slot
    contents (e.g., because of invalid values) as well as if it is
    called from outside a definition context or with the wrong number of
    arguments.</p>
<pre><code>This method *may* reorder and filter the elements if this is
necessary in order to satisfy the underlying constraints of the
slot. (For example, slots of classes enforce a uniqueness constraint
that places each element in the earliest location in the slot that
it can.)
</code></pre>
<p>The implementation of these methods is slot-dependent (and responsible
for accessing the correct part of the class or object definition). Slots
also have an unknown method handler to tie all these pieces together,
and they hide their <strong>destroy</strong> method so that it is not invoked
inadvertently. It is <em>recommended</em> that any user changes to the slot
mechanism be restricted to defining new operations whose names start
with a hyphen.</p>
<p>Most slot operations will initially <strong>Resolve</strong> their argument list,
combine it with the results of the <strong>Get</strong> method, and then <strong>Set</strong> the
result. Some operations omit one or both of the first two steps;
omitting the third would result in an idempotent read-only operation
(but the standard mechanism for reading from slots is via <strong>info class</strong>
and <strong>info object</strong>).</p>
<h1 id="examples">EXAMPLES</h1>
<p>This example demonstrates how to use both forms of the <strong>oo::define</strong>
and <strong>oo::objdefine</strong> commands (they work in the same way), as well as
illustrating four of their subcommands.</p>
<p>oo::class create c c create o <strong>oo::define</strong> c <strong>method</strong> foo {} { puts
\"world\" } <strong>oo::objdefine</strong> o { <strong>method</strong> bar {} { my Foo \"hello \"
my foo } <strong>forward</strong> Foo ::puts -nonewline <strong>unexport</strong> foo } o bar <em>→
prints \"hello world\"</em> o foo <em>→ error \"unknown method foo\"</em> o Foo Bar
<em>→ error \"unknown method Foo\"</em> <strong>oo::objdefine</strong> o <strong>renamemethod</strong>
bar lollipop o lollipop <em>→ prints \"hello world\"</em></p>
<p>This example shows how additional classes can be mixed into an object.
It also shows how <strong>mixin</strong> is a slot that supports appending:</p>
<p>oo::object create inst inst m1 <em>→ error \"unknown method m1\"</em> inst m2
<em>→ error \"unknown method m2\"</em></p>
<p>oo::class create A { <strong>method</strong> m1 {} { puts \"red brick\" } }
<strong>oo::objdefine</strong> inst { <strong>mixin</strong> A } inst m1 <em>→ prints \"red brick\"</em>
inst m2 <em>→ error \"unknown method m2\"</em></p>
<p>oo::class create B { <strong>method</strong> m2 {} { puts \"blue brick\" } }
<strong>oo::objdefine</strong> inst { <strong>mixin -append</strong> B } inst m1 <em>→ prints \"red
brick\"</em> inst m2 <em>→ prints \"blue brick\"</em></p>
<p>This example shows how to create and use class variables. It is a class
that counts how many instances of itself have been made.</p>
<p>oo::class create Counted <strong>oo::define</strong> Counted { <strong>initialise</strong> {
variable count 0 }</p>
<p><strong>variable</strong> number <strong>constructor</strong> {} { classvariable count set number
[incr count] }</p>
<p><strong>method</strong> report {} { classvariable count puts \"This is instance
\$number of \$count\" } }</p>
<p>set a [Counted new] set b [Counted new] \$a report <em>→ This is
instance 1 of 2</em> set c [Counted new] \$b report <em>→ This is instance 2
of 3</em> \$c report <em>→ This is instance 3 of 3</em></p>
<p>This example demonstrates how to use class methods. (Note that the
constructor for <strong>oo::class</strong> calls <strong>oo::define</strong> on the class.)</p>
<p>oo::class create DBTable { <strong>classmethod</strong> find {description} { puts
\"DB: locate row from [self] matching \$description\" return [my
new] } <strong>classmethod</strong> insert {description} { puts \"DB: create row in
[self] matching \$description\" return [my new] } <strong>method</strong> update
{description} { puts \"DB: update row [self] with \$description\" }
<strong>method</strong> delete {} { puts \"DB: delete row [self]\" my destroy; #
Just delete the object, not the DB row } }</p>
<p>oo::class create Users { <strong>superclass</strong> DBTable } oo::class create
Groups { <strong>superclass</strong> DBTable }</p>
<p>set u1 [Users insert \"username=abc\"] <em>→ DB: create row from ::Users
matching username=abc</em> set u2 [Users insert \"username=def\"] <em>→ DB:
create row from ::Users matching username=def</em> \$u2 update
\"group=NULL\" <em>→ DB: update row ::oo::Obj124 with group=NULL</em> \$u1
delete <em>→ DB: delete row ::oo::Obj123</em> set g [Group find
\"groupname=webadmins\"] <em>→ DB: locate row ::Group with
groupname=webadmins</em> \$g update \"emailaddress=admins\" <em>→ DB: update
row ::oo::Obj125 with emailaddress=admins</em></p>
<p>This example shows how to make a custom definition for a class. Note
that it explicitly includes delegation to the existing definition
commands via <strong>namespace path</strong>.</p>
<p>namespace eval myDefinitions { # Delegate to existing definitions where
not overridden namespace path <strong>::oo::define</strong></p>
<p># A custom type of method proc exprmethod {name arguments body} {
tailcall <strong>method</strong> \$name \$arguments [list expr \$body] }</p>
<p># A custom way of building a constructor proc parameters args { uplevel
1 [list <strong>variable</strong> {*}\$args] set body [join [lmap a \$args {
string map [list VAR \$a] { set [my varname VAR] [expr
{double(\$VAR)}] } }] \";\"] tailcall <strong>constructor</strong> \$args \$body }
}</p>
<p># Bind the namespace into a (very simple) metaclass for use oo::class
create exprclass { <strong>superclass</strong> oo::class <strong>definitionnamespace</strong>
myDefinitions }</p>
<p># Use the custom definitions exprclass create quadratic { parameters a
b c exprmethod evaluate {x} { (\$a * \$x**2) + (\$b * \$x) + \$c } }</p>
<p># Showing the resulting class and object in action quadratic create
quad 1 2 3 for {set x 0} {\$x \&lt;= 4} {incr x} { puts [format \"quad(%d)
= %.2f\" \$x [quad evaluate \$x]] } <em>→ quad(0) = 3.00</em> <em>→ quad(1) =
6.00</em> <em>→ quad(2) = 11.00</em> <em>→ quad(3) = 18.00</em> <em>→ quad(4) = 27.00</em></p>
<h1 id="see-also">SEE ALSO</h1>
<p>next(n), oo::class(n), oo::object(n)</p>
<h1 id="keywords">KEYWORDS</h1>
<p>class, definition, method, object, slot</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
