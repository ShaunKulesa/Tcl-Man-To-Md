<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://www.tcl.tk/man/tcl8.6.13/TclCmd/contents.html/dict/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>NAME - Tcl/Tk</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "NAME";
        var mkdocs_page_input_path = "dict.md";
        var mkdocs_page_url = "/man/tcl8.6.13/TclCmd/contents.html/dict/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Tcl/Tk
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../command.md">Commands</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Tcl/Tk</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>NAME</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="name">NAME</h1>
<p>dict - Manipulate dictionaries</p>
<h1 id="synopsis">SYNOPSIS</h1>
<p><strong>dict </strong><em>option arg </em>?<em>arg ...</em>?</p>
<h1 id="description">DESCRIPTION</h1>
<p>Performs one of several operations on dictionary values or variables
containing dictionary values (see the <strong>DICTIONARY VALUES</strong> section
below for a description), depending on <em>option</em>. The legal <em>option</em>s
(which may be abbreviated) are:</p>
<p><strong>dict append </strong><em>dictionaryVariable key </em>?<em>string ...</em>?</p>
<p>:   This appends the given string (or strings) to the value that the
    given key maps to in the dictionary value contained in the given
    variable, writing the resulting dictionary value back to that
    variable. Non-existent keys are treated as if they map to an empty
    string. The updated dictionary value is returned.</p>
<p>If <em>dictionaryVariable</em> indicates an element that does not exist of an
array that has a default value set, the default value and will be used
as the value of the dictionary prior to the appending operation.</p>
<p><strong>dict create </strong>?<em>key value ...</em>?</p>
<p>:   Return a new dictionary that contains each of the key/value mappings
    listed as arguments (keys and values alternating, with each key
    being followed by its associated value.)</p>
<p><strong>dict exists </strong><em>dictionaryValue key </em>?<em>key ...</em>?</p>
<p>:   This returns a boolean value indicating whether the given key (or
    path of keys through a set of nested dictionaries) exists in the
    given dictionary value. This returns a true value exactly when
    <strong>dict</strong> get on that path will succeed.</p>
<p><strong>dict filter </strong><em>dictionaryValue filterType arg </em>?<em>arg ...</em>?</p>
<p>:   This takes a dictionary value and returns a new dictionary that
    contains just those key/value pairs that match the specified filter
    type (which may be abbreviated.) Supported filter types are:</p>
<pre><code>**dict filter ***dictionaryValue ***key** ?*globPattern \...*?

:   The key rule only matches those key/value pairs whose keys match
    any of the given patterns (in the style of **string match**.)

**dict filter ***dictionaryValue ***script {***keyVariable valueVariable***} ***script*

:   The script rule tests for matching by assigning the key to the
    *keyVariable* and the value to the *valueVariable*, and then
    evaluating the given script which should result in a boolean
    value (with the key/value pair only being included in the result
    of the **dict** filter when a true value is returned.) Note that
    the first argument after the rule selection word is a
    two-element list. If the *script* returns with a condition of
    **TCL_BREAK**, no further key/value pairs are considered for
    inclusion in the resulting dictionary, and a condition of
    **TCL_CONTINUE** is equivalent to a false result. The key/value
    pairs are tested in the order in which the keys were inserted
    into the dictionary.

**dict filter ***dictionaryValue ***value **?*globPattern \...*?

:   The value rule only matches those key/value pairs whose values
    match any of the given patterns (in the style of **string
    match**.)
</code></pre>
<p><strong>dict for {</strong><em>keyVariable valueVariable</em><strong>} </strong><em>dictionaryValue body</em></p>
<p>:   This command takes three arguments, the first a two-element list of
    variable names (for the key and value respectively of each mapping
    in the dictionary), the second the dictionary value to iterate
    across, and the third a script to be evaluated for each mapping with
    the key and value variables set appropriately (in the manner of
    <strong>foreach</strong>.) The result of the command is an empty string. If any
    evaluation of the body generates a <strong>TCL_BREAK</strong> result, no further
    pairs from the dictionary will be iterated over and the <strong>dict for</strong>
    command will terminate successfully immediately. If any evaluation
    of the body generates a <strong>TCL_CONTINUE</strong> result, this shall be
    treated exactly like a normal <strong>TCL_OK</strong> result. The order of
    iteration is the order in which the keys were inserted into the
    dictionary.</p>
<p><strong>dict get </strong><em>dictionaryValue </em>?<em>key ...</em>?</p>
<p>:   Given a dictionary value (first argument) and a key (second
    argument), this will retrieve the value for that key. Where several
    keys are supplied, the behaviour of the command shall be as if the
    result of <strong>dict get \$dictVal \$key</strong> was passed as the first
    argument to <strong>dict get</strong> with the remaining arguments as second (and
    possibly subsequent) arguments. This facilitates lookups in nested
    dictionaries. For example, the following two commands are
    equivalent:</p>
<pre><code>dict get \$dict foo bar spong dict get \[dict get \[dict get \$dict
foo\] bar\] spong

If no keys are provided, **dict get** will return a list containing
pairs of elements in a manner similar to **array get**. That is, the
first element of each pair would be the key and the second element
would be the value for that key.

It is an error to attempt to retrieve a value for a key that is not
present in the dictionary.
</code></pre>
<p><strong>dict getdef </strong><em>dictionaryValue </em>?<em>key ...</em>? <em>key default</em></p>
<p>:   </p>
<p><strong>dict getwithdefault </strong><em>dictionaryValue </em>?<em>key ...</em>? <em>key default</em></p>
<p>:   </p>
<p>This behaves the same as <strong>dict get</strong> (with at least one <em>key</em>
argument), returning the value that the key path maps to in the
dictionary <em>dictionaryValue</em>, except that instead of producing an error
because the <em>key</em> (or one of the <em>key</em>s on the key path) is absent, it
returns the <em>default</em> argument instead.</p>
<blockquote>
<p>Note that there must always be at least one <em>key</em> provided, and that
<strong>dict getdef</strong> and <strong>dict getwithdefault</strong> are aliases for each
other.</p>
</blockquote>
<p><strong>dict incr </strong><em>dictionaryVariable key </em>?<em>increment</em>?</p>
<p>:   This adds the given increment value (an integer that defaults to 1
    if not specified) to the value that the given key maps to in the
    dictionary value contained in the given variable, writing the
    resulting dictionary value back to that variable. Non-existent keys
    are treated as if they map to 0. It is an error to increment a value
    for an existing key if that value is not an integer. The updated
    dictionary value is returned.</p>
<p>If <em>dictionaryVariable</em> indicates an element that does not exist of an
array that has a default value set, the default value and will be used
as the value of the dictionary prior to the incrementing operation.</p>
<p><strong>dict info </strong><em>dictionaryValue</em></p>
<p>:   This returns information (intended for display to people) about the
    given dictionary though the format of this data is dependent on the
    implementation of the dictionary. For dictionaries that are
    implemented by hash tables, it is expected that this will return the
    string produced by <strong>Tcl_HashStats</strong>, similar to <strong>array
    statistics</strong>.</p>
<p><strong>dict keys </strong><em>dictionaryValue </em>?<em>globPattern</em>?</p>
<p>:   Return a list of all keys in the given dictionary value. If a
    pattern is supplied, only those keys that match it (according to the
    rules of <strong>string match</strong>) will be returned. The returned keys will
    be in the order that they were inserted into the dictionary.</p>
<p><strong>dict lappend </strong><em>dictionaryVariable key </em>?<em>value ...</em>?</p>
<p>:   This appends the given items to the list value that the given key
    maps to in the dictionary value contained in the given variable,
    writing the resulting dictionary value back to that variable.
    Non-existent keys are treated as if they map to an empty list, and
    it is legal for there to be no items to append to the list. It is an
    error for the value that the key maps to to not be representable as
    a list. The updated dictionary value is returned.</p>
<p>If <em>dictionaryVariable</em> indicates an element that does not exist of an
array that has a default value set, the default value and will be used
as the value of the dictionary prior to the list-appending operation.</p>
<p><strong>dict map </strong>{<em>keyVariable valueVariable</em>} <em>dictionaryValue body</em></p>
<p>:   This command applies a transformation to each element of a
    dictionary, returning a new dictionary. It takes three arguments:
    the first is a two-element list of variable names (for the key and
    value respectively of each mapping in the dictionary), the second
    the dictionary value to iterate across, and the third a script to be
    evaluated for each mapping with the key and value variables set
    appropriately (in the manner of <strong>lmap</strong>). In an iteration where the
    evaluated script completes normally (<strong>TCL_OK</strong>, as opposed to an
    <strong>error</strong>, etc.) the result of the script is put into an accumulator
    dictionary using the key that is the current contents of the
    <em>keyVariable</em> variable at that point. The result of the <strong>dict map</strong>
    command is the accumulator dictionary after all keys have been
    iterated over.</p>
<pre><code>If the evaluation of the body for any particular step generates a
**break**, no further pairs from the dictionary will be iterated
over and the **dict** map command will terminate successfully
immediately. If the evaluation of the body for a particular step
generates a **continue** result, the current iteration is aborted
and the accumulator dictionary is not modified. The order of
iteration is the natural order of the dictionary (typically the
order in which the keys were added to the dictionary; the order is
the same as that used in **dict for**).
</code></pre>
<p><strong>dict merge </strong>?<em>dictionaryValue ...</em>?</p>
<p>:   Return a dictionary that contains the contents of each of the
    <em>dictionaryValue</em> arguments. Where two (or more) dictionaries
    contain a mapping for the same key, the resulting dictionary maps
    that key to the value according to the last dictionary on the
    command line containing a mapping for that key.</p>
<p><strong>dict remove </strong><em>dictionaryValue </em>?<em>key ...</em>?</p>
<p>:   Return a new dictionary that is a copy of an old one passed in as
    first argument except without mappings for each of the keys listed.
    It is legal for there to be no keys to remove, and it also legal for
    any of the keys to be removed to not be present in the input
    dictionary in the first place.</p>
<p><strong>dict replace </strong><em>dictionaryValue </em>?<em>key value ...</em>?</p>
<p>:   Return a new dictionary that is a copy of an old one passed in as
    first argument except with some values different or some extra
    key/value pairs added. It is legal for this command to be called
    with no key/value pairs, but illegal for this command to be called
    with a key but no value.</p>
<p><strong>dict set </strong><em>dictionaryVariable key </em>?<em>key ...</em>? <em>value</em></p>
<p>:   This operation takes the name of a variable containing a dictionary
    value and places an updated dictionary value in that variable
    containing a mapping from the given key to the given value. When
    multiple keys are present, this operation creates or updates a chain
    of nested dictionaries. The updated dictionary value is returned.</p>
<p>If <em>dictionaryVariable</em> indicates an element that does not exist of an
array that has a default value set, the default value and will be used
as the value of the dictionary prior to the value insert/update
operation.</p>
<p><strong>dict size </strong><em>dictionaryValue</em></p>
<p>:   Return the number of key/value mappings in the given dictionary
    value.</p>
<p><strong>dict unset </strong><em>dictionaryVariable key </em>?<em>key ...</em>?</p>
<p>:   This operation (the companion to <strong>dict set</strong>) takes the name of a
    variable containing a dictionary value and places an updated
    dictionary value in that variable that does not contain a mapping
    for the given key. Where multiple keys are present, this describes a
    path through nested dictionaries to the mapping to remove. At least
    one key must be specified, but the last key on the key-path need not
    exist. All other components on the path must exist. The updated
    dictionary value is returned.</p>
<p>If <em>dictionaryVariable</em> indicates an element that does not exist of an
array that has a default value set, the default value and will be used
as the value of the dictionary prior to the value remove operation.</p>
<p><strong>dict update </strong><em>dictionaryVariable key varName </em>?<em>key varName ...</em>? <em>body</em></p>
<p>:   Execute the Tcl script in <em>body</em> with the value for each <em>key</em> (as
    found by reading the dictionary value in <em>dictionaryVariable</em>)
    mapped to the variable <em>varName</em>. There may be multiple
    <em>key</em>/<em>varName</em> pairs. If a <em>key</em> does not have a mapping, that
    corresponds to an unset <em>varName</em>. When <em>body</em> terminates, any
    changes made to the <em>varName</em>s is reflected back to the dictionary
    within <em>dictionaryVariable</em> (unless <em>dictionaryVariable</em> itself
    becomes unreadable, when all updates are silently discarded), even
    if the result of <em>body</em> is an error or some other kind of
    exceptional exit. The result of <strong>dict</strong> update is (unless some kind
    of error occurs) the result of the evaluation of <em>body</em>.</p>
<p>If <em>dictionaryVariable</em> indicates an element that does not exist of an
array that has a default value set, the default value and will be used
as the value of the dictionary prior to the update operation.</p>
<blockquote>
<p>Each <em>varName</em> is mapped in the scope enclosing the <strong>dict update</strong>;
it is recommended that this command only be used in a local scope
(<strong>proc</strong>edure, lambda term for <strong>apply</strong>, or method). Because of
this, the variables set by <strong>dict update</strong> will continue to exist
after the command finishes (unless explicitly <strong>unset</strong>). Note that
the mapping of values to variables does not use traces; changes to the
<em>dictionaryVariable</em>\'s contents only happen when <em>body</em> terminates.</p>
</blockquote>
<p><strong>dict values </strong><em>dictionaryValue </em>?<em>globPattern</em>?</p>
<p>:   Return a list of all values in the given dictionary value. If a
    pattern is supplied, only those values that match it (according to
    the rules of <strong>string match</strong>) will be returned. The returned values
    will be in the order of that the keys associated with those values
    were inserted into the dictionary.</p>
<p><strong>dict with </strong><em>dictionaryVariable </em>?<em>key ...</em>? <em>body</em></p>
<p>:   Execute the Tcl script in <em>body</em> with the value for each key in
    <em>dictionaryVariable</em> mapped (in a manner similarly to <strong>dict</strong>
    update) to a variable with the same name. Where one or more <em>key</em>s
    are available, these indicate a chain of nested dictionaries, with
    the innermost dictionary being the one opened out for the execution
    of <em>body</em>. As with <strong>dict update</strong>, making <em>dictionaryVariable</em>
    unreadable will make the updates to the dictionary be discarded, and
    this also happens if the contents of <em>dictionaryVariable</em> are
    adjusted so that the chain of dictionaries no longer exists. The
    result of <strong>dict with</strong> is (unless some kind of error occurs) the
    result of the evaluation of <em>body</em>.</p>
<p>If <em>dictionaryVariable</em> indicates an element that does not exist of an
array that has a default value set, the default value and will be used
as the value of the dictionary prior to the updating operation.</p>
<blockquote>
<p>The variables are mapped in the scope enclosing the <strong>dict with</strong>; it
is recommended that this command only be used in a local scope
(<strong>proc</strong>edure, lambda term for <strong>apply</strong>, or method). Because of
this, the variables set by <strong>dict with</strong> will continue to exist after
the command finishes (unless explicitly <strong>unset</strong>). Note that the
mapping of values to variables does not use traces; changes to the
<em>dictionaryVariable</em>\'s contents only happen when <em>body</em> terminates.</p>
<p>If the <em>dictionaryVariable</em> contains a value that is not a dictionary
at the point when the <em>body</em> terminates (which can easily happen if
the name is the same as any of the keys in dictionary) then an error
occurs at that point. This command is thus not recommended for use
when the keys in the dictionary are expected to clash with the
<em>dictionaryVariable</em> name itself. Where the contained key does map to
a dictionary, the net effect is to combine that inner dictionary into
the outer dictionary; see the <strong>EXAMPLES</strong> below for an illustration
of this.</p>
</blockquote>
<h1 id="dictionary-values">DICTIONARY VALUES</h1>
<p>Dictionaries are values that contain an efficient, order-preserving
mapping from arbitrary keys to arbitrary values. Each key in the
dictionary maps to a single value. They have a textual format that is
exactly that of any list with an even number of elements, with each
mapping in the dictionary being represented as two items in the list.
When a command takes a dictionary and produces a new dictionary based on
it (either returning it or writing it back into the variable that the
starting dictionary was read from) the new dictionary will have the same
order of keys, modulo any deleted keys and with new keys added on to the
end. When a string is interpreted as a dictionary and it would otherwise
have duplicate keys, only the last value for a particular key is used;
the others are ignored, meaning that,</p>
<p>and</p>
<p>are equivalent dictionaries (with different string representations).</p>
<p>Operations that derive a new dictionary from an old one (e.g., updates
like <strong>dict set</strong> and <strong>dict unset</strong>) preserve the order of keys in the
dictionary. The exceptions to this are for any new keys they add, which
are appended to the sequence, and any keys that are removed, which are
excised from the order.</p>
<h1 id="examples">EXAMPLES</h1>
<p>Basic dictionary usage:</p>
<p># Make a dictionary to map extensions to descriptions set filetypes
[<strong>dict create</strong> .txt \"Text File\" .tcl \"Tcl File\"]</p>
<p># Add/update the dictionary <strong>dict set</strong> filetypes .tcl \"Tcl Script\"
<strong>dict set</strong> filetypes .tm \"Tcl Module\" <strong>dict set</strong> filetypes .gif
\"GIF Image\" <strong>dict set</strong> filetypes .png \"PNG Image\"</p>
<p># Simple read from the dictionary set ext \".tcl\" set desc [<strong>dict
get</strong> \$filetypes \$ext] puts \"\$ext is for a \$desc\"</p>
<p># Somewhat more complex, with existence test foreach filename [glob
*] { set ext [file extension \$filename] if {[<strong>dict exists</strong>
\$filetypes \$ext]} { puts \"\$filename is a [<strong>dict get</strong> \$filetypes
\$ext]\" } }</p>
<p>Constructing and using nested dictionaries:</p>
<p># Data for one employee <strong>dict set</strong> employeeInfo 12345-A forenames
\"Joe\" <strong>dict set</strong> employeeInfo 12345-A surname \"Schmoe\" <strong>dict
set</strong> employeeInfo 12345-A street \"147 Short Street\" <strong>dict set</strong>
employeeInfo 12345-A city \"Springfield\" <strong>dict set</strong> employeeInfo
12345-A phone \"555-1234\" # Data for another employee <strong>dict set</strong>
employeeInfo 98372-J forenames \"Anne\" <strong>dict set</strong> employeeInfo
98372-J surname \"Other\" <strong>dict set</strong> employeeInfo 98372-J street
\"32995 Oakdale Way\" <strong>dict set</strong> employeeInfo 98372-J city
\"Springfield\" <strong>dict set</strong> employeeInfo 98372-J phone \"555-8765\" #
The above data probably ought to come from a database...</p>
<p># Print out some employee info set i 0 puts \"There are [<strong>dict size</strong>
\$employeeInfo] employees\" <strong>dict for</strong> {id info} \$employeeInfo {
puts \"Employee #[incr i]: \$id\" <strong>dict with</strong> info { puts \" Name:
\$forenames \$surname\" puts \" Address: \$street, \$city\" puts \"
Telephone: \$phone\" } } # Another way to iterate and pick out
names... foreach id [<strong>dict keys</strong> \$employeeInfo] { puts \"Hello,
[<strong>dict get</strong> \$employeeInfo \$id forenames]!\" }</p>
<p>A localizable version of <strong>string toupper</strong>:</p>
<p># Set up the basic C locale set capital [<strong>dict create</strong> C [<strong>dict
create</strong>]] foreach c [split {abcdefghijklmnopqrstuvwxyz} \"\"] {
<strong>dict set</strong> capital C \$c [string toupper \$c] }</p>
<p># English locales can luckily share the \"C\" locale <strong>dict set</strong>
capital en [<strong>dict get</strong> \$capital C] <strong>dict set</strong> capital en_US
[<strong>dict get</strong> \$capital C] <strong>dict set</strong> capital en_GB [<strong>dict get</strong>
\$capital C]</p>
<p># ... and so on for other supported languages ...</p>
<p># Now get the mapping for the current locale and use it. set
upperCaseMap [<strong>dict get</strong> \$capital \$env(LANG)] set upperCase
[string map \$upperCaseMap \$string]</p>
<p>Showing the detail of <strong>dict with</strong>:</p>
<p>proc sumDictionary {varName} { upvar 1 \$varName vbl foreach key
[<strong>dict keys</strong> \$vbl] { # Manufacture an entry in the subdictionary
<strong>dict set</strong> vbl \$key total 0 # Add the values and remove the old
<strong>dict with</strong> vbl \$key { set total [expr {\$x + \$y + \$z}] unset x y
z } } puts \"last total was \$total, for key \$key\" }</p>
<p>set myDict { a {x 1 y 2 z 3} b {x 6 y 5 z 4} }</p>
<p>sumDictionary myDict # prints: <em>last total was 15, for key b</em></p>
<p>puts \"dictionary is now \\"\$myDict\\"\" # prints: <em>dictionary is
now \"a {total 6} b {total 15}\"</em></p>
<p>When <strong>dict with</strong> is used with a key that clashes with the name of the
dictionary variable:</p>
<p>set foo {foo {a b} bar 2 baz 3} <strong>dict with</strong> foo {} puts \$foo #
prints: <em>a b foo {a b} bar 2 baz 3</em></p>
<h1 id="see-also">SEE ALSO</h1>
<p>append(n), array(n), foreach(n), incr(n), list(n), lappend(n), lmap(n),
set(n)</p>
<h1 id="keywords">KEYWORDS</h1>
<p>dictionary, create, update, lookup, iterate, filter, map</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
