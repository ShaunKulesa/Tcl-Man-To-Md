<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://www.tcl.tk/man/tcl8.6.13/TclCmd/contents.html/http/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>NAME - Tcl/Tk</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "NAME";
        var mkdocs_page_input_path = "http.md";
        var mkdocs_page_url = "/man/tcl8.6.13/TclCmd/contents.html/http/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Tcl/Tk
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../command.md">Commands</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Tcl/Tk</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>NAME</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="name">NAME</h1>
<p>http - Client-side implementation of the HTTP/1.1 protocol</p>
<h1 id="synopsis">SYNOPSIS</h1>
<p><strong>package require http</strong> ?<strong>2.10</strong>?</p>
<p><strong>::http::config</strong> ?<em>-option value</em> ...?</p>
<p><strong>::http::geturl </strong><em>url</em> ?<em>-option value</em> ...?</p>
<p><strong>::http::formatQuery</strong> <em>key value</em> ?<em>key value</em> ...?</p>
<p><strong>::http::quoteString</strong> <em>value</em></p>
<p><strong>::http::reset</strong> <em>token</em> ?<em>why</em>?</p>
<p><strong>::http::wait </strong><em>token</em></p>
<p><strong>::http::status </strong><em>token</em></p>
<p><strong>::http::size </strong><em>token</em></p>
<p><strong>::http::error </strong><em>token</em></p>
<p><strong>::http::postError </strong><em>token</em></p>
<p><strong>::http::cleanup </strong><em>token</em></p>
<p><strong>::http::requestLine</strong> <em>token</em></p>
<p><strong>::http::requestHeaders</strong> <em>token</em> ?<em>headerName</em>?</p>
<p><strong>::http::requestHeaderValue</strong> <em>token</em> <em>headerName</em></p>
<p><strong>::http::responseLine</strong> <em>token</em></p>
<p><strong>::http::responseCode</strong> <em>token</em></p>
<p><strong>::http::reasonPhrase</strong> <em>code</em></p>
<p><strong>::http::responseHeaders</strong> <em>token</em> ?<em>headerName</em>?</p>
<p><strong>::http::responseHeaderValue</strong> <em>token</em> <em>headerName</em></p>
<p><strong>::http::responseInfo</strong> <em>token</em></p>
<p><strong>::http::responseBody</strong> <em>token</em></p>
<p><strong>::http::register </strong><em>proto port command</em></p>
<p><strong>::http::registerError </strong><em>port</em> ?<em>message</em>?</p>
<p><strong>::http::unregister </strong><em>proto</em></p>
<p><strong>::http::code </strong><em>token</em></p>
<p><strong>::http::data </strong><em>token</em></p>
<p><strong>::http::meta </strong><em>token</em> ?<em>headerName</em>?</p>
<p><strong>::http::metaValue</strong> <em>token</em> <em>headerName</em></p>
<p><strong>::http::ncode </strong><em>token</em></p>
<h1 id="exported-commands">EXPORTED COMMANDS</h1>
<p>Namespace <strong>http</strong> exports the commands <strong>config</strong>, <strong>formatQuery</strong>,
<strong>geturl</strong>, <strong>postError</strong>, <strong>quoteString</strong>, <strong>reasonPhrase</strong>,
<strong>register</strong>, <strong>registerError</strong>, <strong>requestHeaders</strong>,
<strong>requestHeaderValue</strong>, <strong>requestLine</strong>, <strong>responseBody</strong>,
<strong>responseCode</strong>, <strong>responseHeaders</strong>, <strong>responseHeaderValue</strong>,
<strong>responseInfo</strong>, <strong>responseLine</strong>, <strong>reset</strong>, <strong>unregister</strong>, and
<strong>wait</strong>.</p>
<p>It does not export the commands <strong>cleanup</strong>, <strong>code</strong>, <strong>data</strong>,
<strong>error</strong>, <strong>meta</strong>, <strong>metaValue</strong>, <strong>ncode</strong>, <strong>size</strong>, or <strong>status</strong>.</p>
<h1 id="description">DESCRIPTION</h1>
<p>The <strong>http</strong> package provides the client side of the HTTP/1.1 protocol,
as defined in RFC 9110 to 9112, which supersede RFC 7230 to RFC 7235,
which in turn supersede RFC 2616. The package implements the GET, POST,
and HEAD operations of HTTP/1.1. It allows configuration of a proxy host
to get through firewalls. The package is compatible with the
<strong>Safesock</strong> security policy, so it can be used by untrusted applets to
do URL fetching from a restricted set of hosts. This package can be
extended to support additional HTTP transport protocols, such as HTTPS,
by providing a custom <strong>socket</strong> command, via <strong>::http::register</strong>.</p>
<p>The <strong>::http::geturl</strong> procedure does a HTTP transaction. Its <em>options *
determine whether a GET, POST, or HEAD transaction is performed. The
return value of </em><em>::http::geturl</em>* is a token for the transaction. The
token can be supplied as an argument to other commands, to manage the
transaction and examine its results.</p>
<p>If the <strong>-command</strong> option is specified, then the HTTP operation is done
in the background. <strong>::http::geturl</strong> returns immediately after
generating the HTTP request and the <strong>-command</strong> callback is invoked
when the transaction completes. For this to work, the Tcl event loop
must be active. In Tk applications this is always true. For pure-Tcl
applications, the caller can use <strong>::http::wait</strong> after calling
<strong>::http::geturl</strong> to start the event loop.</p>
<p><strong>Note:</strong> The event queue is even used without the <strong>-command</strong> option.
As a side effect, arbitrary commands may be processed while
<strong>http::geturl</strong> is running.</p>
<p>When the HTTP server has replied to the request, call the command
<strong>::http::responseInfo</strong>, which returns a <strong>dict</strong> of metadata that is
essential for identifying a successful transaction and making use of the
response. See section <strong>METADATA</strong> for details of the information
returned. The response itself is returned by command
<strong>::http::responseBody</strong>, unless it has been redirected to a file by the
<em>-channel</em> option of <strong>::http::geturl</strong>.</p>
<h1 id="commands">COMMANDS</h1>
<p><strong>::http::config</strong> ?<em>options</em>?</p>
<p>:   The <strong>::http::config</strong> command is used to set and query the name of
    the proxy server and port, and the User-Agent name used in the HTTP
    requests. If no options are specified, then the current
    configuration is returned. If a single argument is specified, then
    it should be one of the flags described below. In this case the
    current value of that setting is returned. Otherwise, the options
    should be a set of flags and values that define the configuration:</p>
<pre><code>**-accept** *mimetypes*

:   The Accept header of the request. The default is \*/\*, which
    means that all types of documents are accepted. Otherwise you
    can supply a comma-separated list of mime type patterns that you
    are willing to receive. For example,

**-cookiejar** *command*

:

The cookie store for the package to use to manage HTTP cookies.
*command* is a command prefix list; if the empty list (the default
value) is used, no cookies will be sent by requests or stored from
responses. The command indicated by *command*, if supplied, must
obey the **COOKIE JAR PROTOCOL** described below.

**-pipeline** *boolean*

:   Specifies whether HTTP/1.1 transactions on a persistent socket
    will be pipelined. See the **PERSISTENT SOCKETS** section for
    details. The default is 1.

**-postfresh** *boolean*

:   Specifies whether requests that use the **POST** method will
    always use a fresh socket, overriding the **-keepalive** option
    of command **http::geturl**. See the **PERSISTENT SOCKETS**
    section for details. The default is 0.

**-proxyauth** *string*

:   If non-empty, the string is supplied to the proxy server as the
    value of the request header Proxy-Authorization. This option can
    be used for HTTP Basic Authentication. If the proxy server
    requires authentication by another technique, e.g. Digest
    Authentication, the **-proxyauth** option is not useful. In that
    case the caller must expect a 407 response from the proxy,
    compute the authentication value to be supplied, and use the
    **-headers** option to supply it as the value of the
    Proxy-Authorization header.

**-proxyfilter** *command*

:   The command is a callback that is made during **::http::geturl**
    to determine if a proxy is required for a given host. One
    argument, a host name, is added to *command* when it is invoked.
    If a proxy is required, the callback should return a two-element
    list containing the proxy server and proxy port. Otherwise the
    filter command should return an empty list.

    The default value of **-proxyfilter** is
    **http::ProxyRequired**, and this command returns the values of
    the **-proxyhost** and **-proxyport** settings if they are
    non-empty. The options **-proxyhost**, **-proxyport**, and
    **-proxynot** are used only by **http::ProxyRequired**, and
    nowhere else in **::http::geturl**. A user-supplied
    **-proxyfilter** command may use these options, or alternatively
    it may obtain values from elsewhere in the calling script. In
    the latter case, any values provided for **-proxyhost**,
    **-proxyport**, and **-proxynot** are unused.

    The **::http::geturl** command runs the **-proxyfilter**
    callback inside a **catch** command. Therefore an error in the
    callback command does not call the **bgerror** handler. See the
    **ERRORS** section for details.

**-proxyhost** *hostname*

:   The host name or IP address of the proxy server, if any. If this
    value is the empty string, the URL host is contacted directly.
    See **-proxyfilter** for how the value is used.

**-proxynot** *list*

:   A Tcl list of domain names and IP addresses that should be
    accessed directly, not through the proxy server. The target
    hostname is compared with each list element using a
    case-insensitive **string match**. It is often convenient to use
    the wildcard \"\*\" at the start of a domain name (e.g.
    \*.example.com) or at the end of an IP address (e.g.
    192.168.0.\*). See **-proxyfilter** for how the value is used.

**-proxyport** *number*

:   The port number of the proxy server. See **-proxyfilter** for
    how the value is used.

**-repost** *boolean*

:   Specifies what to do if a POST request over a persistent
    connection fails because the server has half-closed the
    connection. If boolean **true**, the request will be
    automatically retried; if boolean **false** it will not, and the
    application that uses **http::geturl** is expected to seek user
    confirmation before retrying the POST. The value **true** should
    be used only under certain conditions. See the **PERSISTENT
    SOCKETS** section for details. The default is 0.

**-threadlevel** *level*

:   Specifies whether and how to use the **Thread** package.
    Possible values of *level* are 0, 1 or 2.

    0 - (the default) do not use Thread 1 - use Thread if it is
    available, do not use it if it is unavailable 2 - use Thread if
    it is available, raise an error if it is unavailable

    The Tcl **socket -async** command can block in adverse cases
    (e.g. a slow DNS lookup). Using the Thread package works around
    this problem, for both HTTP and HTTPS transactions. Values of
    *level* other than 0 are available only to the main interpreter
    in each thread. See section **THREADS** for more information.

**-urlencoding** *encoding*

:   The *encoding* used for creating the x-url-encoded URLs with
    **::http::formatQuery** and **::http::quoteString**. The default
    is **utf-8**, as specified by RFC 2718.

**-useragent** *string*

:   The value of the User-Agent header in the HTTP request. In an
    unsafe interpreter, the default value depends upon the operating
    system, and the version numbers of **http** and **Tcl**, and is
    (for example)

A safe interpreter cannot determine its operating system, and so the
default in a safe interpreter is to use a Windows 10 value with the
current version numbers of **http** and **Tcl**.

**-zip** *boolean*

:   If the value is boolean **true**, then by default requests will
    send a header

If the value is boolean **false**, then by default requests will
send a header

In either case the default can be overridden for an individual
request by supplying a custom **Accept-Encoding** header in the
**-headers** option of **http::geturl**. The default value is 1.
</code></pre>
<p><strong>::http::geturl</strong> <em>url</em> ?<em>options</em>?</p>
<p>:   The <strong>::http::geturl</strong> command is the main procedure in the package.
    The <strong>-query</strong> or <strong>-querychannel</strong> option causes a POST operation
    and the <strong>-validate</strong> option causes a HEAD operation; otherwise, a
    GET operation is performed. The <strong>::http::geturl</strong> command returns a
    <em>token</em> value that can be passed as an argument to other commands to
    get information about the transaction. See the <strong>METADATA</strong> and
    <strong>ERRORS</strong> section for details. The <strong>::http::geturl</strong> command
    blocks until the operation completes, unless the <strong>-command</strong> option
    specifies a callback that is invoked when the HTTP transaction
    completes. <strong>::http::geturl</strong> takes several options:</p>
<pre><code>**-binary** *boolean*

:   Specifies whether to force interpreting the URL data as binary.
    Normally this is auto-detected (anything not beginning with a
    **text** content type or whose content encoding is **gzip** or
    **deflate** is considered binary data).

**-blocksize** *size*

:   The block size used when reading the URL. At most *size* bytes
    are read at once. After each block, a call to the **-progress**
    callback is made (if that option is specified).

**-channel** *name*

:   Copy the URL contents to channel *name* instead of saving it in
    a Tcl variable for retrieval by **::http::responseBody**.

**-command** *callback*

:   The presence of this option causes **::http::geturl** to return
    immediately. After the HTTP transaction completes, the value of
    *callback* is expanded, an additional argument is added, and the
    resulting command is evaluated. The additional argument is the
    *token* returned from **::http::geturl**. This token is the name
    of an array that is described in the **STATE ARRAY** section.
    Here is a template for the callback:

    proc httpCallback {token} { upvar 0 \$token state \# Access
    state as a Tcl array defined in this proc \... return }

    The **::http::geturl** command runs the **-command** callback
    inside a **catch** command. Therefore an error in the callback
    command does not call the **bgerror** handler. See the
    **ERRORS** section for details.

**-guesstype** *boolean*

:   Attempt to guess the **Content-Type** and character set when a
    misconfigured server provides no information. The default value
    is *false* (do nothing). If boolean *true* then, if the server
    does not send a **Content-Type** header, or if it sends the
    value \"application/octet-stream\", **http::geturl** will
    attempt to guess appropriate values. This is not intended to
    become a general-purpose tool, and currently it is limited to
    detecting XML documents that begin with an XML declaration. In
    this case the **Content-Type** is changed to
    \"application/xml\", the binary flag state(binary) is changed to
    0, and the character set is changed to the one specified by the
    \"encoding\" tag of the XML line, or to utf-8 if no encoding is
    specified. Not used if a *-channel* is specified.

**-handler** *callback*

:   If this option is absent, **http::geturl** processes incoming
    data itself, either appending it to the state(body) variable or
    writing it to the -channel. But if the **-handler** option is
    present, **http::geturl** does not do this processing and
    instead calls *callback*. Whenever HTTP data is available, the
    value of *callback* is expanded, an additional two arguments are
    added, and the resulting command is evaluated. The two
    additional arguments are: the socket for the HTTP data and the
    *token* returned from **::http::geturl**. The token is the name
    of a global array that is described in the **STATE ARRAY**
    section. The procedure is expected to return the number of bytes
    read from the socket. Here is a template for the callback:

    proc httpHandlerCallback {socket token} { upvar 0 \$token state
    \# Access socket, and state as a Tcl array defined in this proc
    \# For example\... \... set data \[read \$socket 1000\] set
    nbytes \[string length \$data\] \... return \$nbytes }

    The **http::geturl** code for the **-handler** option is not
    compatible with either compression or chunked transfer-encoding.
    If **-handler** is specified, then to work around these issues
    **http::geturl** will reduce the HTTP protocol to 1.0, and
    override the **-zip** option (i.e. it will send the header
    **Accept-Encoding: identity** instead of **Accept-Encoding:
    gzip,deflate**).

    If options **-handler** and **-channel** are used together, the
    handler is responsible for copying the data from the HTTP socket
    to the specified channel. The name of the channel is available
    to the handler as element **-channel** of the token array.

    The **::http::geturl** command runs the **-handler** callback
    inside a **catch** command. Therefore an error in the callback
    command does not call the **bgerror** handler. See the
    **ERRORS** section for details.

**-headers** *keyvaluelist*

:   This option is used to add headers not already specified by
    **::http::config** to the HTTP request. The *keyvaluelist*
    argument must be a list with an even number of elements that
    alternate between keys and values. The keys become header field
    names. Newlines are stripped from the values so the header
    cannot be corrupted. For example, if *keyvaluelist* is **Pragma
    no-cache** then the following header is included in the HTTP
    request:

    Pragma: no-cache

**-keepalive** *boolean*

:   If boolean **true**, attempt to keep the connection open for
    servicing multiple requests. Default is 0.

**-method** *type*

:   Force the HTTP request method to *type*. **::http::geturl** will
    auto-select GET, POST or HEAD based on other options, but this
    option overrides that selection and enables choices like PUT and
    DELETE for WebDAV support.

    It is the caller\'s responsibility to ensure that the headers
    and request body (if any) conform to the requirements of the
    request method. For example, if using **-method** *POST* to send
    a POST with an empty request body, the caller must also supply
    the option

    -headers {Content-Length 0}

**-myaddr** *address*

:   Pass an specific local address to the underlying **socket** call
    in case multiple interfaces are available.

**-progress** *callback*

:   If the **-progress** option is present, then the *callback* is
    made after each transfer of data from the URL. The value of
    *callback* is expanded, an additional three arguments are added,
    and the resulting command is evaluated. The three additional
    arguments are: the *token* returned from **::http::geturl**, the
    expected total size of the contents from the **Content-Length**
    response header, and the current number of bytes transferred so
    far. The token is the name of a global array that is described
    in the **STATE ARRAY** section. The expected total size may be
    unknown, in which case zero is passed to the callback. Here is a
    template for the progress callback:

    proc httpProgress {token total current} { upvar 0 \$token state
    \# Access state as a Tcl array defined in this proc \... return
    }

**-protocol** *version*

:   Select the HTTP protocol version to use. This should be 1.0 or
    1.1 (the default). Should only be necessary for servers that do
    not understand or otherwise complain about HTTP/1.1.

**-query** *query*

:   This flag (if the value is non-empty) causes **::http::geturl**
    to do a POST request that passes the string *query* verbatim to
    the server as the request payload. The content format (and
    encoding) of *query* is announced by the request header
    **Content-Type** which is set by the option **-type**. Any value
    of **-type** is permitted, and it is the responsibility of the
    caller to supply *query* in the correct format.

    If **-type** is not specified, it defaults to
    *application/x-www-form-urlencoded*, which requires *query* to
    be an x-url-encoding formatted query-string (this **-type** and
    query format are used in a POST submitted from an html form).
    The **::http::formatQuery** procedure can be used to do the
    formatting.

**-queryblocksize** *size*

:   The block size used when posting query data to the URL. At most
    *size* bytes are written at once. After each block, a call to
    the **-queryprogress** callback is made (if that option is
    specified).

**-querychannel** *channelID*

:   This flag causes **::http::geturl** to do a POST request that
    passes the data contained in *channelID* to the server. The data
    contained in *channelID* must be an x-url-encoding formatted
    query unless the **-type** option below is used. If a
    **Content-Length** header is not specified via the **-headers**
    options, **::http::geturl** attempts to determine the size of
    the post data in order to create that header. If it is unable to
    determine the size, it returns an error.

**-queryprogress** *callback*

:   If the **-queryprogress** option is present, then the *callback*
    is made after each transfer of data to the URL in a POST request
    (i.e. a call to **::http::geturl** with option **-query** or
    **-querychannel**) and acts exactly like the **-progress**
    option (the callback format is the same).

**-strict** *boolean*

:   If true then the command will test that the URL complies with
    RFC 3986, i.e. that it has no characters that should be
    \"x-url-encoded\" (e.g. a space should be encoded to \"%20\").
    Default value is 1.

**-timeout** *milliseconds*

:   If *milliseconds* is non-zero, then **::http::geturl** sets up a
    timeout to occur after the specified number of milliseconds. A
    timeout results in a call to **::http::reset** and to the
    **-command** callback, if specified. The return value of
    **::http::status** (and the value of the *status* key in the
    dictionary returned by **::http::responseInfo**) is **timeout**
    after a timeout has occurred.

**-type** *mime-type*

:   Use *mime-type* as the **Content-Type** value, instead of the
    default value (**application/x-www-form-urlencoded**) during a
    POST operation.

**-validate** *boolean*

:   If *boolean* is non-zero, then **::http::geturl** does an HTTP
    HEAD request. This server returns the same status line and
    response headers as it would for a HTTP GET request, but omits
    the response entity (the URL \"contents\"). The response headers
    are available after the transaction using command
    **::http::responseHeaders** or, for selected information,
    **::http::responseInfo**.
</code></pre>
<p><strong>::http::formatQuery</strong> <em>key value</em> ?<em>key value</em> ...?</p>
<p>:   This procedure does x-url-encoding of query data. It takes an even
    number of arguments that are the keys and values of the query. It
    encodes the keys and values, and generates one string that has the
    proper &amp; and = separators. The result is suitable for the <strong>-query</strong>
    value passed to <strong>::http::geturl</strong>.</p>
<p><strong>::http::quoteString</strong> <em>value</em></p>
<p>:   This procedure does x-url-encoding of string. It takes a single
    argument and encodes it.</p>
<p><strong>::http::reset</strong> <em>token</em> ?<em>why</em>?</p>
<p>:   This command resets the HTTP transaction identified by <em>token</em>, if
    any. This sets the <strong>state(status)</strong> value to <em>why</em>, which defaults
    to <strong>reset</strong>, and then calls the registered <strong>-command</strong> callback.</p>
<p><strong>::http::wait</strong> <em>token</em></p>
<p>:   This command blocks and waits for the transaction to complete. This
    only works in trusted code because it uses <strong>vwait</strong>. Also, it is
    not useful for the case where <strong>::http::geturl</strong> is called <em>without</em>
    the <strong>-command</strong> option because in this case the <strong>::http::geturl</strong>
    call does not return until the HTTP transaction is complete, and
    thus there is nothing to wait for.</p>
<p><strong>::http::status</strong> <em>token</em></p>
<p>:   This command returns a description of the status of the HTTP
    transaction. The return value is the empty string until the HTTP
    transaction is completed; after completion it has one of the values
    ok, eof, error, timeout, and reset. The meaning of these values is
    described in the section <strong>ERRORS</strong> (below).</p>
<blockquote>
<p>The name \"status\" is not related to the terms \"status line\" and
\"status code\" that are defined for a HTTP response.</p>
</blockquote>
<p><strong>::http::size</strong> <em>token</em></p>
<p>:   This command returns the number of bytes received so far from the
    URL in the <strong>::http::geturl</strong> call.</p>
<p><strong>::http::error</strong> <em>token</em></p>
<p>:   This command returns the error information if the HTTP transaction
    failed, or the empty string if there was no error. The information
    is a Tcl list of the error message, stack trace, and error code.</p>
<p><strong>::http::postError</strong> <em>token</em></p>
<p>:   A POST request is a call to <strong>::http::geturl</strong> with either the
    <strong>-query</strong> or <strong>-querychannel</strong> option. The <strong>::http::postError</strong>
    command returns the error information generated when a HTTP POST
    request sends its request-body to the server; or the empty string if
    there was no error. The information is a Tcl list of the error
    message, stack trace, and error code. When this type of error
    occurs, the <strong>::http::geturl</strong> command continues the transaction and
    attempts to receive a response from the server.</p>
<p><strong>::http::cleanup</strong> <em>token</em></p>
<p>:   This procedure cleans up the state associated with the connection
    identified by <em>token</em>. After this call, the procedures like
    <strong>::http::responseBody</strong> cannot be used to get information about the
    operation. It is <em>strongly</em> recommended that you call this function
    after you are done with a given HTTP request. Not doing so will
    result in memory not being freed, and if your app calls
    <strong>::http::geturl</strong> enough times, the memory leak could cause a
    performance hit...or worse.</p>
<p><strong>::http::requestLine</strong> <em>token</em></p>
<p>:   This command returns the \"request line\" sent to the server. The
    \"request line\" is the first line of a HTTP client request, and has
    three elements separated by spaces: the HTTP method, the URL
    relative to the server, and the HTTP version. Examples:</p>
<blockquote>
<p>GET / HTTP/1.1 GET /introduction.html?subject=plumbing HTTP/1.1 POST
/forms/order.html HTTP/1.1</p>
</blockquote>
<p><strong>::http::requestHeaders</strong> <em>token</em> ?<em>headerName</em>?</p>
<p>:   This command returns the HTTP request header names and values, in
    the order that they were sent to the server, as a Tcl list of the
    form ?name value ...? Header names are case-insensitive and are
    converted to lower case. The return value is not a <strong>dict</strong> because
    some header names may occur more than once. If one argument is
    supplied, all request headers are returned. If two arguments are
    supplied, the second provides the value of a header name. Only
    headers with the requested name (converted to lower case) are
    returned. If no such headers are found, an empty list is returned.</p>
<p><strong>::http::requestHeaderValue</strong> <em>token</em> <em>headerName</em></p>
<p>:   This command returns the value of the HTTP request header named
    <em>headerName</em>. Header names are case-insensitive and are converted to
    lower case. If no such header exists, the return value is the empty
    string. If there are multiple headers named <em>headerName</em>, the result
    is obtained by joining the individual values with the string \", \"
    (comma and space), preserving their order.</p>
<p><strong>::http::responseLine</strong> <em>token</em></p>
<p>:   This command returns the first line of the server response: the HTTP
    \"status line\". The \"status line\" has three elements separated by
    spaces: the HTTP version, a three-digit numerical \"status code\",
    and a \"reason phrase\". Only the reason phrase may contain spaces.
    Examples:</p>
<blockquote>
<p>HTTP/1.1 200 OK HTTP/1.0 404 Not Found</p>
<p>The \"status code\" is a three-digit number in the range 100 to 599. A
value of 200 is the normal return from a GET request, and its matching
\"reason phrase\" is \"OK\". Codes beginning with 4 or 5 indicate
errors. Codes beginning with 3 are redirection errors. In this case
the <strong>Location</strong> response header specifies a new URL that contains the
requested information.</p>
<p>The \"reason phrase\" is a textual description of the \"status code\":
it may vary from server to server, and can be changed without
affecting the HTTP protocol. The recommended values (RFC 7231 and IANA
assignments) for each code are provided by the command
<strong>::http::reasonPhrase</strong>.</p>
</blockquote>
<p><strong>::http::responseCode</strong> <em>token</em></p>
<p>:   This command returns the \"status code\" (200, 404, etc.) of the
    server \"status line\". If a three-digit code cannot be found, the
    full status line is returned. See command <strong>::http::responseLine</strong>
    for more information on the \"status line\".</p>
<p><strong>::http::reasonPhrase</strong> <em>code</em></p>
<p>:   This command returns the IANA recommended \"reason phrase\" for a
    particular \"status code\" returned by a HTTP server. The argument
    <em>code</em> is a valid status code, and therefore is an integer in the
    range 100 to 599 inclusive. For numbers in this range with no
    assigned meaning, the command returns the value \"Unassigned\".
    Several status codes are used only in response to the methods
    defined by HTTP extensions such as WebDAV, and not in response to a
    HEAD, GET, or POST request method.</p>
<blockquote>
<p>The \"reason phrase\" returned by a HTTP server may differ from the
recommended value, without affecting the HTTP protocol. The value
returned by <strong>::http::geturl</strong> can be obtained by calling either
command <strong>::http::responseLine</strong> (which returns the full status line)
or command <strong>::http::responseInfo</strong> (which returns a dictionary, with
the \"reason phrase\" stored in key <em>reasonPhrase</em>).</p>
<p>A registry of valid status codes is maintained at
https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</p>
</blockquote>
<p><strong>::http::responseHeaders</strong> <em>token</em> ?<em>headerName</em>?</p>
<p>:   The response from a HTTP server includes metadata headers that
    describe the response body and the transaction itself. This command
    returns the HTTP response header names and values, in the order that
    they were received from the server, as a Tcl list of the form ?name
    value ...? Header names are case-insensitive and are converted to
    lower case. The return value is not a <strong>dict</strong> because some header
    names may occur more than once, notably <strong>Set-Cookie</strong>. If the
    second argument is not supplied, all response headers are returned.
    If the second argument is supplied, it provides the value of a
    header name. Only headers with the requested name (converted to
    lower case) are returned. If no such headers are found, an empty
    list is returned. See section <strong>METADATA</strong> for more information.</p>
<p><strong>::http::responseHeaderValue</strong> <em>token</em> <em>headerName</em></p>
<p>:   This command returns the value of the HTTP response header named
    <em>headerName</em>. Header names are case-insensitive and are converted to
    lower case. If no such header exists, the return value is the empty
    string. If there are multiple headers named <em>headerName</em>, the result
    is obtained by joining the individual values with the string \", \"
    (comma and space), preserving their order. Multiple headers with the
    same name may be processed in this manner, except <strong>Set-Cookie</strong>
    which does not conform to the comma-separated-list syntax and cannot
    be combined into a single value. Each <strong>Set-Cookie</strong> header must be
    treated individually, e.g. by processing the return value of
    <strong>::http::responseHeaders</strong> <em>token</em> <strong>Set-Cookie</strong>.</p>
<p><strong>::http::responseInfo</strong> <em>token</em></p>
<p>:   This command returns a <strong>dict</strong> of selected response metadata that
    are essential for identifying a successful transaction and making
    use of the response, along with other metadata that are
    informational. The keys of the <strong>dict</strong> are <em>stage</em>, <em>status</em>,
    <em>responseCode</em>, <em>reasonPhrase</em>, <em>contentType</em>, <em>binary</em>,
    <em>redirection</em>, <em>upgrade</em>, <em>error</em>, <em>postError</em>, <em>method</em>, <em>charset</em>,
    <em>compression</em>, <em>httpRequest</em>, <em>httpResponse</em>, <em>url</em>,
    <em>connectionRequest</em>, <em>connectionResponse</em>, <em>connectionActual</em>,
    <em>transferEncoding</em>, <em>totalPost</em>, <em>currentPost</em>, <em>totalSize</em>, and
    <em>currentSize</em>. The meaning of these keys is described in the section
    <strong>METADATA</strong> below.</p>
<pre><code>It is always worth checking the value of *binary* after a HTTP
transaction, to determine whether a misconfigured server has caused
http to interpret a text resource as a binary, or vice versa.

After a POST transaction, check the value of *postError* to verify
that the request body was uploaded without error.
</code></pre>
<p><strong>::http::responseBody</strong> <em>token</em></p>
<p>:   This command returns the entity sent by the HTTP server (unless
    <em>-channel</em> was used, in which case the entity was delivered to the
    channel, and the command returns the empty string).</p>
<pre><code>Other terms for \"entity\", with varying precision, include
\"representation of resource\", \"resource\", \"response body after
decoding\", \"payload\", \"message body after decoding\",
\"content(s)\", and \"file\".
</code></pre>
<p><strong>::http::register</strong> <em>proto port command</em></p>
<p>:   This procedure allows one to provide custom HTTP transport types
    such as HTTPS, by registering a prefix, the default port, and the
    command to execute to create the Tcl <strong>channel</strong>. E.g.:</p>
<pre><code>package require http package require tls

::http::register https 443 ::tls::socket

set token \[::http::geturl https://my.secure.site/\]
</code></pre>
<p><strong>::http::registerError</strong> <em>port</em> ?<em>message</em>?</p>
<p>:   This procedure allows a registered protocol handler to deliver an
    error message for use by <strong>http</strong>. Calling this command does not
    raise an error. The command is useful when a registered protocol
    detects an problem (for example, an invalid TLS certificate) that
    will cause an error to propagate to <strong>http</strong>. The command allows
    <strong>http</strong> to provide a precise error message rather than a general
    one. The command returns the value provided by the last call with
    argument <em>message</em>, or the empty string if no such call has been
    made.</p>
<p><strong>::http::unregister</strong> <em>proto</em></p>
<p>:   This procedure unregisters a protocol handler that was previously
    registered via <strong>::http::register</strong>, returning a two-item list of
    the default port and handler command that was previously installed
    (via <strong>::http::register</strong>) if there was such a handler, and an error
    if there was no such handler.</p>
<p><strong>::http::code</strong> <em>token</em></p>
<p>:   An alternative name for the command <strong>::http::responseLine</strong></p>
<p><strong>::http::data</strong> <em>token</em></p>
<p>:   An alternative name for the command <strong>::http::responseBody</strong>.</p>
<p><strong>::http::meta</strong> <em>token</em> ?<em>headerName</em>?</p>
<p>:   An alternative name for the command <strong>::http::responseHeaders</strong></p>
<p><strong>::http::ncode</strong> <em>token</em></p>
<p>:   An alternative name for the command <strong>::http::responseCode</strong></p>
<h1 id="errors">ERRORS</h1>
<p>The <strong>::http::geturl</strong> procedure will raise errors in the following
cases: invalid command line options, or an invalid URL. These errors
mean that it cannot even start the network transaction. For synchronous
<strong>::http::geturl</strong> calls (where <strong>-command</strong> is not specified), it will
raise an error if the URL is on a non-existent host or at a bad port on
an existing host. It will also raise an error for any I/O errors while
writing out the HTTP request line and headers, or reading the HTTP reply
headers or data. Because <strong>::http::geturl</strong> does not return a token in
these cases, it does all the required cleanup and there is no issue of
your app having to call <strong>::http::cleanup</strong>.</p>
<p>For asynchronous <strong>::http::geturl</strong> calls, all of the above error
situations apply, except that if there is any error while reading the
HTTP reply headers or data, no exception is thrown. This is because
after writing the HTTP headers, <strong>::http::geturl</strong> returns, and the rest
of the HTTP transaction occurs in the background. The command callback
can check if any error occurred during the read by calling
<strong>::http::responseInfo</strong> to check the transaction status.</p>
<p>Alternatively, if the main program flow reaches a point where it needs
to know the result of the asynchronous HTTP request, it can call
<strong>::http::wait</strong> and then check status and error, just as the
synchronous call does.</p>
<p>The <strong>::http::geturl</strong> command runs the <strong>-command</strong>, <strong>-handler</strong>, and
<strong>-proxyfilter</strong> callbacks inside a <strong>catch</strong> command. Therefore an
error in the callback command does not call the <strong>bgerror</strong> handler.
When debugging one of these callbacks, it may be convenient to report
errors by using a <strong>catch</strong> command within the callback command itself,
e.g. to write an error message to stdout.</p>
<p>In any case, you must still call <strong>::http::cleanup</strong> to delete the state
array when you are done.</p>
<p>There are other possible results of the HTTP transaction determined by
examining the status from <strong>::http::status</strong> (or the value of the
<em>status</em> key in the dictionary returned by <strong>::http::responseInfo</strong>).
These are described below.</p>
<p><strong>ok</strong></p>
<p>:   If the HTTP transaction completes entirely, then status will be
    <strong>ok</strong>. However, you should still check the <strong>::http::responseLine</strong>
    value to get the HTTP status. The <strong>::http::responseCode</strong> procedure
    provides just the numeric error (e.g., 200, 404 or 500) while the
    <strong>::http::responseLine</strong> procedure returns a value like</p>
<pre><code>&lt;!-- --&gt;
</code></pre>
<p><strong>eof</strong></p>
<p>:   If the server closes the socket without replying, then no error is
    raised, but the status of the transaction will be <strong>eof</strong>.</p>
<p><strong>error</strong></p>
<p>:   The error message, stack trace, and error code are accessible via
    <strong>::http::error</strong>. The error message is also provided by the value
    of the <em>error</em> key in the dictionary returned by
    <strong>::http::responseInfo</strong>.</p>
<p><strong>timeout</strong></p>
<p>:   A timeout occurred before the transaction could complete.</p>
<p><strong>reset</strong></p>
<p>:   The user has called <strong>::http::reset</strong>.</p>
<p><strong>\"\"</strong></p>
<p>:   (empty string) The transaction has not yet finished.</p>
<p>Another error possibility is that <strong>::http::geturl</strong> failed to write the
whole of the POST request body (<strong>-query</strong> or <strong>-querychannel</strong> data) to
the server. <strong>::http::geturl</strong> stores the error message for later
retrieval by the <strong>::http::postError</strong> or <strong>::http::responseInfo</strong>
commands, and then attempts to complete the transaction. If it can read
the server\'s response the status will be <strong>ok</strong>, but it is important to
call <strong>::http::postError</strong> or <strong>::http::responseInfo</strong> after every POST
to check that the data was sent in full. If the server has closed the
connection the status will be <strong>eof</strong>.</p>
<h1 id="metadata">METADATA</h1>
<h2 id="most-useful-metadata">MOST USEFUL METADATA</h2>
<p>When a HTTP server responds to a request, it supplies not only the
entity requested, but also metadata. This is provided by the first line
(the \"status line\") of the response, and by a number of HTTP headers.
Further metadata relates to how <strong>::http::geturl</strong> has processed the
response from the server.</p>
<p>The most important metadata can be accessed with the command
<strong>::http::responseInfo</strong>. This command returns a <strong>dict</strong> of metadata
that are essential for identifying a successful transaction and making
use of the response, along with other metadata that are informational.
The keys of the <strong>dict</strong> are:</p>
<blockquote>
<blockquote>
<p><strong>===== Essential Values =====</strong></p>
</blockquote>
</blockquote>
<p><strong>stage</strong></p>
<p>:   This value, set by <strong>::http::geturl</strong>, describes the stage that the
    transaction has reached. Values, in order of the transaction
    lifecycle, are: \"created\", \"connecting\", \"header\", \"body\",
    and \"complete\". The other <strong>dict</strong> keys will not be available
    until the value of <strong>stage</strong> is \"body\" or \"complete\". The key
    <strong>currentSize</strong> has its final value only when <strong>stage</strong> is
    \"complete\".</p>
<p><strong>status</strong></p>
<p>:   This value, set by <strong>::http::geturl</strong>, is \"ok\" for a successful
    transaction; \"eof\", \"error\", \"timeout\", or \"reset\" for an
    unsuccessful transaction; or \"\" if the transaction is still in
    progress. The value is the same as that returned by command
    <strong>::http::status</strong>. The meaning of these values is described in the
    section <strong>ERRORS</strong> (above).</p>
<p><strong>responseCode</strong></p>
<p>:   The \"HTTP status code\" sent by the server in the first line (the
    \"status line\") of the response. If the value cannot be extracted
    from the status line, the full status line is returned.</p>
<p><strong>reasonPhrase</strong></p>
<p>:   The \"reason phrase\" sent by the server as a description of the
    HTTP status code. If the value cannot be extracted from the status
    line, the full status line is returned.</p>
<p><strong>contentType</strong></p>
<p>:   The value of the <strong>Content-Type</strong> response header or, if the header
    was not supplied, the default value \"application/octet-stream\".</p>
<p><strong>binary</strong></p>
<p>:   This boolean value, set by <strong>::http::geturl</strong>, describes how the
    command has interpreted the entity returned by the server (after
    decoding any compression specified by the <strong>Content-Encoding</strong>
    response header). This decoded entity is accessible as the return
    value of the command <strong>::http::responseBody</strong>.</p>
<blockquote>
<p>The value is <strong>true</strong> if http has interpreted the decoded entity as
binary. The value returned by <strong>::http::responseBody</strong> is a Tcl binary
string. This is a suitable format for image data, zip files, etc.
<strong>::http::geturl</strong> chooses this value if the user has requested a
binary interpretation by passing the option <em>-binary</em> to the command,
or if the server has supplied a binary content type in a
<strong>Content-Type</strong> response header, or if the server has not supplied
any <strong>Content-Type</strong> header.</p>
<p>The value is <strong>false</strong> in other cases, and this means that http has
interpreted the decoded entity as text. The text has been converted,
from the character set notified by the server, into Tcl\'s internal
Unicode format; the value returned by <strong>::http::responseBody</strong> is an
ordinary Tcl string.</p>
<p>It is always worth checking the value of \"binary\" after a HTTP
transaction, to determine whether a misconfigured server has caused
http to interpret a text resource as a binary, or vice versa.</p>
</blockquote>
<p><strong>redirection</strong></p>
<p>:   The URL that is the redirection target. The value is that of the
    <strong>Location</strong> response header. This header is sent when a response
    has status code 3XX (redirection).</p>
<p><strong>upgrade</strong></p>
<p>:   If not empty, the value indicates the protocol(s) to which the
    server will switch after completion of this transaction, while
    continuing to use the same connection. When the server intends to
    switch protocols, it will also send the value \"101\" as the status
    code (the <strong>responseCode</strong> key), and the word \"upgrade\" as an
    element of the <strong>Connection</strong> response header (the
    <strong>connectionResponse</strong> key), and it will not send a response body.
    See the section <strong>PROTOCOL UPGRADES</strong> for more information.</p>
<p><strong>error</strong></p>
<p>:   The error message, if there is one. Further information, including a
    stack trace and error code, are available from command
    <strong>::http::error</strong>.</p>
<p><strong>postError</strong></p>
<p>:   The error message (if any) generated when a HTTP POST request sends
    its request-body to the server. Further information, including a
    stack trace and error code, are available from command
    <strong>::http::postError</strong>. A POST transaction may appear complete,
    according to the keys <strong>stage</strong>, <strong>status</strong>, and <strong>responseCode</strong>,
    but it is important to check this <strong>postError</strong> key in case an error
    occurred when uploading the request-body.</p>
<blockquote>
<blockquote>
<p><strong>===== Informational Values =====</strong></p>
</blockquote>
</blockquote>
<p><strong>method</strong></p>
<p>:   The HTTP method used in the request.</p>
<p><strong>charset</strong></p>
<p>:   The value of the charset attribute of the <strong>Content-Type</strong> response
    header. The charset value is used only for a text resource. If the
    server did not specify a charset, the value defaults to that of the
    variable <strong>::http::defaultCharset</strong>, which unless it has been
    deliberately modified by the caller is <strong>iso8859-1</strong>. Incoming text
    data is automatically converted from the character set defined by
    <strong>charset</strong> to Tcl\'s internal Unicode representation, i.e. to a Tcl
    string.</p>
<p><strong>compression</strong></p>
<p>:   A copy of the <strong>Content-Encoding</strong> response-header value.</p>
<p><strong>httpRequest</strong></p>
<p>:   The version of HTTP specified in the request (i.e. sent in the
    request line). The value is that of the option <strong>-protocol</strong>
    supplied to <strong>::http::geturl</strong> (default value \"1.1\"), unless the
    command reduced the value to \"1.0\" because it was passed the
    <strong>-handler</strong> option.</p>
<p><strong>httpResponse</strong></p>
<p>:   The version of HTTP used by the server (obtained from the response
    \"status line\"). The server uses this version of HTTP in its
    response, but ensures that this response is compatible with the HTTP
    version specified in the client\'s request. If the value cannot be
    extracted from the status line, the full status line is returned.</p>
<p><strong>url</strong></p>
<p>:   The requested URL, typically the URL supplied as an argument to
    <strong>::http::geturl</strong> but without its \"fragment\" (the final part of
    the URL beginning with \"#\").</p>
<p><strong>connectionRequest</strong></p>
<p>:   The value, if any, sent to the server in <strong>Connection</strong> request
    header(s).</p>
<p><strong>connectionResponse</strong></p>
<p>:   The value, if any, received from the server in <strong>Connection</strong>
    response header(s).</p>
<p><strong>connectionActual</strong></p>
<p>:   This value, set by <strong>::http::geturl</strong>, reports whether the
    connection was closed after the transaction (value \"close\"), or
    left open (value \"keep-alive\").</p>
<p><strong>transferEncoding</strong></p>
<p>:   The value of the Transfer-Encoding response header, if it is
    present. The value is either \"chunked\" (indicating HTTP/1.1
    \"chunked encoding\") or the empty string.</p>
<p><strong>totalPost</strong></p>
<p>:   The total length of the request body in a POST request.</p>
<p><strong>currentPost</strong></p>
<p>:   The number of bytes of the POST request body sent to the server so
    far. The value is the same as that returned by command
    <strong>::http::size</strong>.</p>
<p><strong>totalSize</strong></p>
<p>:   A copy of the <strong>Content-Length</strong> response-header value. The number
    of bytes specified in a <strong>Content-Length</strong> header, if one was sent.
    If none was sent, the value is 0. A correctly configured server
    omits this header if the transfer-encoding is \"chunked\", or (for
    older servers) if the server closes the connection when it reaches
    the end of the resource.</p>
<p><strong>currentSize</strong></p>
<p>:   The number of bytes fetched from the server so far.</p>
<h2 id="more-metadata">MORE METADATA</h2>
<p>The dictionary returned by <strong>::http::responseInfo</strong> is the most useful
subset of the available metadata. Other metadata include:</p>
<p>1. The full \"status line\" of the response, available as the return
value of command <strong>::http::responseLine</strong>.</p>
<p>2. The full response headers, available as the return value of command
<strong>::http::responseHeaders</strong>. This return value is a list of the
response-header names and values, in the order that they were received
from the server.</p>
<p>The return value is not a <strong>dict</strong> because some header names may occur
more than once, notably <strong>Set-Cookie</strong>. If the value is read into a
<strong>dict</strong> or into an array (using array set), only the last header with
each name will be preserved.</p>
<blockquote>
<p>Some of the header names (metadata keys) are listed below, but the
HTTP standard defines several more, and servers are free to add their
own. When a dictionary key is mentioned below, this refers to the
<strong>dict</strong> value returned by command <strong>::http::responseInfo</strong>.</p>
<p><strong>Content-Type</strong></p>
<p>:   The content type of the URL contents. Examples include
    <strong>text/html</strong>, <strong>image/gif,</strong> <strong>application/postscript</strong> and
    <strong>application/x-tcl</strong>. Text values typically specify a character
    set, e.g. <strong>text/html; charset=UTF-8</strong>. Dictionary key
    <em>contentType</em>.</p>
<p><strong>Content-Length</strong></p>
<p>:   The advertised size in bytes of the contents, available as
    dictionary key <em>totalSize</em>. The actual number of bytes read by
    <strong>::http::geturl</strong> so far is available as dictionary key
    <strong>currentSize</strong>.</p>
<p><strong>Content-Encoding</strong></p>
<p>:   The compression algorithm used for the contents. Examples include
    <strong>gzip</strong>, <strong>deflate</strong>. Dictionary key <em>content</em>.</p>
<p><strong>Location</strong></p>
<p>:   This header is sent when a response has status code 3XX
    (redirection). It provides the URL that is the redirection target.
    Dictionary key <em>redirection</em>.</p>
<p><strong>Set-Cookie</strong></p>
<p>:   This header is sent to offer a cookie to the client. Cookie
    management is done by the <strong>::http::config</strong> option <em>-cookiejar</em>,
    and so the <strong>Set-Cookie</strong> headers need not be parsed by user
    scripts. See section <strong>COOKIE JAR PROTOCOL</strong>.</p>
<p><strong>Connection</strong></p>
<p>:   The value can be supplied as a comma-separated list, or by
    multiple headers. The list often has only one element, either
    \"close\" or \"keep-alive\". The value \"upgrade\" indicates a
    successful upgrade request and is typically combined with the
    status code 101, an <strong>Upgrade</strong> response header, and no response
    body. Dictionary key <em>connectionResponse</em>.</p>
<p><strong>Upgrade</strong></p>
<p>:   The value indicates the protocol(s) to which the server will
    switch immediately after the empty line that terminates the 101
    response headers. Dictionary key <em>upgrade</em>.</p>
</blockquote>
<h2 id="even-more-metadata">EVEN MORE METADATA</h2>
<p>1. Details of the HTTP request. The request is determined by the
options supplied to <strong>::http::geturl</strong> and <strong>::http::config</strong>. However,
it is sometimes helpful to examine what <strong>::http::geturl</strong> actually sent
to the server, and this information is available through commands
<strong>::http::requestHeaders</strong> and <strong>::http::requestLine</strong>.</p>
<p>2. The state array: the internal variables of <strong>::http::geturl</strong>. It
may sometimes be helpful to examine this array. Details are given in the
next section.</p>
<h1 id="state-array">STATE ARRAY</h1>
<p>The <strong>::http::geturl</strong> procedure returns a <em>token</em> that can be used as
an argument to other <strong>::http::*</strong> commands, which examine and manage
the state of the HTTP transaction. For most purposes these commands are
sufficient. The <em>token</em> can also be used to access the internal state of
the transaction, which is stored in a Tcl array. This facility is most
useful when writing callback commands for the options <strong>-command</strong>,
<strong>-handler</strong>, <strong>-progress</strong>, or <strong>-queryprogress</strong>. Use the following
command inside the proc to define an easy-to-use array <em>state</em> as a
local variable within the proc</p>
<p>upvar 0 \$token state</p>
<p>Once the data associated with the URL is no longer needed, the state
array should be unset to free up storage. The <strong>::http::cleanup</strong>
procedure is provided for that purpose.</p>
<p>The following elements of the array are supported, and are the origin of
the values returned by commands as described below. When a dictionary
key is mentioned below, this refers to the <strong>dict</strong> value returned by
command <strong>::http::responseInfo</strong>.</p>
<blockquote>
<p><strong>binary</strong></p>
<p>:   For dictionary key <em>binary</em>.</p>
<p><strong>body</strong></p>
<p>:   For command <strong>::http::responseBody</strong>.</p>
<p><strong>charset</strong></p>
<p>:   For dictionary key <em>charset</em>.</p>
<p><strong>coding</strong></p>
<p>:   For dictionary key <em>compression</em>.</p>
<p><strong>connection</strong></p>
<p>:   For dictionary key <em>connectionActual</em>.</p>
<p><strong>currentsize</strong></p>
<p>:   For command <strong>::http::size</strong>; and for dictionary key
    <em>currentSize</em>.</p>
<p><strong>error</strong></p>
<p>:   For command <strong>::http::error</strong>; part is used in dictionary key
    <em>error</em>.</p>
<p><strong>http</strong></p>
<p>:   For command <strong>::http::responseLine</strong>.</p>
<p><strong>httpResponse</strong></p>
<p>:   For dictionary key <em>httpResponse</em>.</p>
<p><strong>meta</strong></p>
<p>:   For command <strong>::http::responseHeaders</strong>. Further discussion above
    in the section <strong>MORE METADATA</strong>.</p>
<p><strong>method</strong></p>
<p>:   For dictionary key <em>method</em>.</p>
<p><strong>posterror</strong></p>
<p>:   For dictionary key <em>postError</em>.</p>
<p><strong>postErrorFull</strong></p>
<p>:   For command <strong>::http::postError</strong>.</p>
<p><strong>-protocol</strong></p>
<p>:   For dictionary key <em>httpRequest</em>.</p>
<p><strong>querylength</strong></p>
<p>:   For dictionary key <em>totalPost</em>.</p>
<p><strong>queryoffset</strong></p>
<p>:   For dictionary key <em>currentPost</em>.</p>
<p><strong>reasonPhrase</strong></p>
<p>:   For dictionary key <em>reasonPhrase</em>.</p>
<p><strong>requestHeaders</strong></p>
<p>:   For command <strong>::http::requestHeaders</strong>.</p>
<p><strong>requestLine</strong></p>
<p>:   For command <strong>::http::requestLine</strong>.</p>
<p><strong>responseCode</strong></p>
<p>:   For dictionary key <em>responseCode</em>.</p>
<p><strong>state</strong></p>
<p>:   For dictionary key <em>stage</em>.</p>
<p><strong>status</strong></p>
<p>:   For command <strong>::http::status</strong>; and for dictionary key <em>status</em>.</p>
<p><strong>totalsize</strong></p>
<p>:   For dictionary key <em>totalSize</em>.</p>
<p><strong>transfer</strong></p>
<p>:   For dictionary key <em>transferEncoding</em>.</p>
<p><strong>type</strong></p>
<p>:   For dictionary key <em>contentType</em>.</p>
<p><strong>upgrade</strong></p>
<p>:   For dictionary key <em>upgrade</em>.</p>
<p><strong>url</strong></p>
<p>:   For dictionary key <em>url</em>.</p>
</blockquote>
<h1 id="persistent-connections">PERSISTENT CONNECTIONS</h1>
<h2 id="basics">BASICS</h2>
<p>See RFC 7230 Sec 6, which supersedes RFC 2616 Sec 8.1.</p>
<p>A persistent connection allows multiple HTTP/1.1 transactions to be
carried over the same TCP connection. Pipelining allows a client to make
multiple requests over a persistent connection without waiting for each
response. The server sends responses in the same order that the requests
were received.</p>
<p>If a POST request fails to complete, typically user confirmation is
needed before sending the request again. The user may wish to verify
whether the server was modified by the failed POST request, before
sending the same request again.</p>
<p>A HTTP request will use a persistent socket if the call to
<strong>http::geturl</strong> has the option <strong>-keepalive true</strong>. It will use
pipelining where permitted if the <strong>http::config</strong> option <strong>-pipeline</strong>
is boolean <strong>true</strong> (its default value).</p>
<p>The http package maintains no more than one persistent connection to
each server (i.e. each value of</p>
<p>If <strong>http::geturl</strong> is called to make a request over a persistent
connection while the connection is busy with another request, the new
request will be held in a queue until the connection is free.</p>
<p>The http package does not support HTTP/1.0 persistent connections
controlled by the <strong>Keep-Alive</strong> header.</p>
<h2 id="special-cases">SPECIAL CASES</h2>
<p>This subsection discusses issues related to closure of the persistent
connection by the server, automatic retry of failed requests, the
special treatment necessary for POST requests, and the options for
dealing with these cases.</p>
<p>In accordance with RFC 7230, <strong>http::geturl</strong> does not pipeline requests
that use the POST method. If a POST uses a persistent connection and is
not the first request on that connection, <strong>http::geturl</strong> waits until
it has received the response for the previous request; or (if
<strong>http::config</strong> option <strong>-postfresh</strong> is boolean <strong>true</strong>) it uses a
new connection for each POST.</p>
<p>If the server is processing a number of pipelined requests, and sends a
response header</p>
<p>with one of the responses (other than the last), then subsequent
responses are unfulfilled. <strong>http::geturl</strong> will send the unfulfilled
requests again over a new connection.</p>
<p>A difficulty arises when a HTTP client sends a request over a persistent
connection that has been idle for a while. The HTTP server may
half-close an apparently idle connection while the client is sending a
request, but before the request arrives at the server: in this case (an</p>
<p>the request will fail. The difficulty arises because the client cannot
be certain whether the POST modified the state of the server. For HEAD
or GET requests, <strong>http::geturl</strong> opens another connection and
retransmits the failed request. However, if the request was a POST, RFC
7230 forbids automatic retry by default, suggesting either user
confirmation, or confirmation by user-agent software that has semantic
understanding of the application. The <strong>http::config</strong> option
<strong>-repost</strong> allows for either possibility.</p>
<p>Asynchronous close events can occur only in a short interval of time.
The <strong>http</strong> package monitors each persistent connection for closure by
the server. Upon detection, the connection is also closed at the client
end, and subsequent requests will use a fresh connection.</p>
<p>If the <strong>http::geturl</strong> command is called with option <strong>-keepalive
true</strong>, then it will both try to use an existing persistent connection
(if one is available), and it will send the server a</p>
<p>request header asking to keep the connection open for future requests.</p>
<p>The <strong>http::config</strong> options <strong>-pipeline</strong>, <strong>-postfresh</strong>, and
<strong>-repost</strong> relate to persistent connections.</p>
<p>Option <strong>-pipeline</strong>, if boolean <strong>true</strong>, will pipeline GET and HEAD
requests made over a persistent connection. POST requests will not be
pipelined - if the POST is not the first transaction on the connection,
its request will not be sent until the previous response has finished.
GET and HEAD requests made after a POST will not be sent until the POST
response has been delivered, and will not be sent if the POST fails.</p>
<p>Option <strong>-postfresh</strong>, if boolean <strong>true</strong>, will override the
<strong>http::geturl</strong> option <strong>-keepalive</strong>, and always open a fresh
connection for a POST request.</p>
<p>Option <strong>-repost</strong>, if <strong>true</strong>, permits automatic retry of a POST
request that fails because it uses a persistent connection that the
server has half-closed (an</p>
<p>Subsequent GET and HEAD requests in a failed pipeline will also be
retried. <em>The </em><strong>-repost</strong><em> option should be used only if the
application understands</em> that the retry is appropriate - specifically,
the application must know that if the failed POST successfully modified
the state of the server, a repeat POST would have no adverse effect.</p>
<h1 id="cookie-jar-protocol">COOKIE JAR PROTOCOL</h1>
<p>Cookies are short key-value pairs used to implement sessions within the
otherwise-stateless HTTP protocol. (See RFC 6265 for details; Tcl does
not implement the Cookie2 protocol as that is rarely seen in the wild.)</p>
<p>Cookie storage managment commands ---</p>
<p>--- must support these subcommands which form the HTTP cookie storage
management protocol. Note that <em>cookieJar</em> below does not have to be a
command name; it is properly a command prefix (a Tcl list of words that
will be expanded in place) and admits many possible implementations.</p>
<p>Though not formally part of the protocol, it is expected that particular
values of <em>cookieJar</em> will correspond to sessions; it is up to the
caller of <strong>::http::config</strong> to decide what session applies and to
manage the deletion of said sessions when they are no longer desired
(which should be when they not configured as the current cookie jar).</p>
<p><em>cookieJar </em><strong>getCookies </strong><em>protocol host requestPath</em></p>
<p>:   This command asks the cookie jar what cookies should be supplied for
    a particular request. It should take the <em>protocol</em> (typically
    <strong>http</strong> or <strong>https</strong>), <em>host</em> name and <em>requestPath</em> (parsed from
    the <em>url</em> argument to <strong>::http::geturl</strong>) and return a list of
    cookie keys and values that describe the cookies to supply to the
    remote host. The list must have an even number of elements.</p>
<pre><code>There should only ever be at most one cookie with a particular key
for any request (typically the one with the most specific
*host*/domain match and most specific *requestPath*/path match), but
there may be many cookies with different names in any request.
</code></pre>
<p><em>cookieJar </em><strong>storeCookie </strong><em>cookieDictionary</em></p>
<p>:   This command asks the cookie jar to store a particular cookie that
    was returned by a request; the result of this command is ignored.
    The cookie (which will have been parsed by the http package) is
    described by a dictionary, <em>cookieDictionary</em>, that may have the
    following keys:</p>
<pre><code>**domain**

:   This is always present. Its value describes the domain hostname
    *or* prefix that the cookie should be returned for. The checking
    of the domain against the origin (below) should be careful since
    sites that issue cookies should only do so for domains related
    to themselves. Cookies that do not obey a relevant origin
    matching rule should be ignored.

**expires**

:   This is optional. If present, the cookie is intended to be a
    persistent cookie and the value of the option is the Tcl
    timestamp (in seconds from the same base as **clock seconds**)
    of when the cookie expires (which may be in the past, which
    should result in the cookie being deleted immediately). If
    absent, the cookie is intended to be a session cookie that
    should be not persisted beyond the lifetime of the cookie jar.

**hostonly**

:   This is always present. Its value is a boolean that describes
    whether the cookie is a single host cookie (true) or a
    domain-level cookie (false).

**httponly**

:   This is always present. Its value is a boolean that is true when
    the site wishes the cookie to only ever be used with HTTP (or
    HTTPS) traffic.

**key**

:   This is always present. Its value is the *key* of the cookie,
    which is part of the information that must be return when
    sending this cookie back in a future request.

**origin**

:   This is always present. Its value describes where the http
    package believes it received the cookie from, which may be
    useful for checking whether the cookie\'s domain is valid.

**path**

:   This is always present. Its value describes the path prefix of
    requests to the cookie domain where the cookie should be
    returned.

**secure**

:   This is always present. Its value is a boolean that is true when
    the cookie should only used on requests sent over secure
    channels (typically HTTPS).

**value**

:   This is always present. Its value is the value of the cookie,
    which is part of the information that must be return when
    sending this cookie back in a future request.

Other keys may always be ignored; they have no meaning in this
protocol.
</code></pre>
<h1 id="protocol-upgrades">PROTOCOL UPGRADES</h1>
<p>The HTTP/1.1 <strong>Connection</strong> and <strong>Upgrade</strong> request headers inform the
server that the client wishes to change the protocol used over the
existing connection (RFC 7230). This mechanism can be used to request a
WebSocket (RFC 6455), a higher version of the HTTP protocol (HTTP 2), or
TLS encryption. If the server accepts the upgrade request, its response
code will be 101.</p>
<p>To request a protocol upgrade when calling <strong>http::geturl</strong>, the
<strong>-headers</strong> option must supply appropriate values for <strong>Connection</strong>
and <strong>Upgrade</strong>, and the <strong>-command</strong> option must supply a command that
implements the requested protocol and can also handle the server
response if the server refuses the protocol upgrade. For upgrade
requests <strong>http::geturl</strong> ignores the value of option <strong>-keepalive</strong>,
and always uses the value <strong>0</strong> so that the upgrade request is not made
over a connection that is intended for multiple HTTP requests.</p>
<p>The Tcllib library <strong>websocket</strong> implements WebSockets, and makes the
necessary calls to commands in the <strong>http</strong> package.</p>
<p>There is currently no native Tcl client library for HTTP/2.</p>
<p>The <strong>Upgrade</strong> mechanism is not used to request TLS in web browsers,
because <strong>http</strong> and <strong>https</strong> are served over different ports. It is
used by protocols such as Internet Printing Protocol (IPP) that are
built on top of <strong>http(s)</strong> and use the same TCP port number for both
secure and insecure traffic.</p>
<p>In browsers, opportunistic encryption is instead implemented by the
<strong>Upgrade-Insecure-Requests</strong> client header. If a secure service is
available, the server response code is a 307 redirect, and the response
header <strong>Location</strong> specifies the target URL. The browser must call
<strong>http::geturl</strong> again in order to fetch this URL. See
https://w3c.github.io/webappsec-upgrade-insecure-requests/</p>
<h1 id="threads">THREADS</h1>
<h2 id="purpose">PURPOSE</h2>
<p>Command <strong>::http::geturl</strong> uses the Tcl <strong>::socket</strong> command with the
<em>-async</em> option to connect to a remote server, but the return from this
command can be delayed in adverse cases (e.g. a slow DNS lookup),
preventing the event loop from processing other events. This delay is
avoided if the <strong>::socket</strong> command is evaluated in another thread. The
Thread package is not part of Tcl but is provided in \"Batteries
Included\" distributions. Instead of the <strong>::socket</strong> command, the http
package uses <strong>::http::socket</strong> which makes connections in the manner
specified by the value of <em>-threadlevel</em> and the availability of package
Thread.</p>
<h2 id="with-tls-https">WITH TLS (HTTPS)</h2>
<p>The same <em>-threadlevel</em> configuration applies to both HTTP and HTTPS
connections. HTTPS is enabled by using the <strong>http::register</strong> command,
typically by specifying the <strong>::tls::socket</strong> command of the tls package
to handle TLS cryptography. The <strong>::tls::socket</strong> command connects to
the remote server by using the command specified by the value of
variable <strong>::tls::socketCmd</strong>, and this value defaults to \"::socket\".
If http::geturl finds that <strong>::tls::socketCmd</strong> has this value, it
replaces it with the value \"::http::socket\". If <strong>::tls::socketCmd</strong>
has a value other than \"::socket\", i.e. if the script or the Tcl
installation has replaced the value \"::socket\" with the name of a
different command, then http does not change the value. The script or
installation that modified <strong>::tls::socketCmd</strong> is responsible for
integrating <strong>::http::socket</strong> into its own replacement command.</p>
<h2 id="with-a-child-interpreter">WITH A CHILD INTERPRETER</h2>
<p>The peer thread can transfer the socket only to the main interpreter of
the script\'s thread. Therefore the thread-based <strong>::http::socket</strong>
works with non-zero <em>-threadlevel</em> values only if the script runs in the
main interpreter. A child interpreter must use <em>-threadlevel 0</em> unless
the parent interpreter has provided alternative facilities. The main
parent interpreter may grant full <em>-threadlevel</em> facilities to a child
interpreter, for example by aliasing, to <strong>::http::socket</strong> in the
child, a command that runs <strong>http::socket</strong> in the parent, and then
transfers the socket to the child.</p>
<h1 id="example">EXAMPLE</h1>
<p>This example creates a procedure to copy a URL to a file while printing
a progress meter, and prints the response headers associated with the
URL.</p>
<p>proc httpcopy { url file {chunk 4096} } { set out [open \$file w] set
token [<strong>::http::geturl</strong> \$url -channel \$out \ -progress
httpCopyProgress -blocksize \$chunk] close \$out</p>
<p># This ends the line started by httpCopyProgress puts stderr \"\"</p>
<p>upvar 0 \$token state set max 0 foreach {name value} \$state(meta) { if
{[string length \$name] > \$max} { set max [string length \$name] }
if {[regexp -nocase \^location\$ \$name]} { # Handle URL redirects
puts stderr \"Location:\$value\" return [httpcopy [string trim
\$value] \$file \$chunk] } } incr max foreach {name value}
\$state(meta) { puts [format \"%-*s %s\" \$max \$name: \$value] }</p>
<p>return \$token } proc httpCopyProgress {args} { puts -nonewline stderr .
flush stderr }</p>
<h1 id="see-also">SEE ALSO</h1>
<p>safe(n), socket(n), safesock(n)</p>
<h1 id="keywords">KEYWORDS</h1>
<p>internet, security policy, socket, www</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
