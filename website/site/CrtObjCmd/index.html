<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://www.tcl.tk/man/tcl8.6.13/TclCmd/contents.html/CrtObjCmd/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>NAME - Tcl/Tk</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "NAME";
        var mkdocs_page_input_path = "CrtObjCmd.md";
        var mkdocs_page_url = "/man/tcl8.6.13/TclCmd/contents.html/CrtObjCmd/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Tcl/Tk
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../command.md">Commands</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Tcl/Tk</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>NAME</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="name">NAME</h1>
<p>Tcl_CreateObjCommand, Tcl_CreateObjCommand2, Tcl_DeleteCommand,
Tcl_DeleteCommandFromToken, Tcl_GetCommandInfo,
Tcl_GetCommandInfoFromToken, Tcl_SetCommandInfo,
Tcl_SetCommandInfoFromToken, Tcl_GetCommandName, Tcl_GetCommandFullName,
Tcl_GetCommandFromObj - implement new commands in C</p>
<h1 id="synopsis">SYNOPSIS</h1>
<pre><code>#include &lt;tcl.h&gt;

Tcl_Command
Tcl_CreateObjCommand(interp, cmdName, proc, clientData, deleteProc)

Tcl_Command
Tcl_CreateObjCommand2(interp, cmdName, proc2, clientData, deleteProc)

int
Tcl_DeleteCommand(interp, cmdName)

int
Tcl_DeleteCommandFromToken(interp, token)

int
Tcl_GetCommandInfo(interp, cmdName, infoPtr)

int
Tcl_SetCommandInfo(interp, cmdName, infoPtr)

int
Tcl_GetCommandInfoFromToken(token, infoPtr)

int
Tcl_SetCommandInfoFromToken(token, infoPtr)

const char *
Tcl_GetCommandName(interp, token)

void
Tcl_GetCommandFullName(interp, token, objPtr)

Tcl_Command
Tcl_GetCommandFromObj(interp, objPtr)
</code></pre>
<h1 id="arguments">ARGUMENTS</h1>
<p>Interpreter in which to create a new command or that contains a command.</p>
<p>Name of command.</p>
<p>Implementation of the new command: <em>proc</em> will be called whenever
<em>cmdName</em> is invoked as a command.</p>
<p>Implementation of the new command: <em>proc2</em> will be called whenever
<em>cmdName</em> is invoked as a command.</p>
<p>Arbitrary one-word value to pass to <em>proc</em> and <em>deleteProc</em>.</p>
<p>Procedure to call before <em>cmdName</em> is deleted from the interpreter;
allows for command-specific cleanup. If NULL, then no procedure is
called before the command is deleted.</p>
<p>Token for command, returned by previous call to
<strong>Tcl_CreateObjCommand</strong>. The command must not have been deleted.</p>
<p>Pointer to structure containing various information about a Tcl command.</p>
<p>Value containing the name of a Tcl command.</p>
<p>Indicates the name of the type of command implementation associated with
a particular <em>proc</em>, or NULL to break the association.</p>
<h1 id="description">DESCRIPTION</h1>
<p><strong>Tcl_CreateObjCommand</strong> defines a new command in <em>interp</em> and
associates it with procedure <em>proc</em> such that whenever <em>name</em> is invoked
as a Tcl command (e.g., via a call to <strong>Tcl_EvalObjEx</strong>) the Tcl
interpreter will call <em>proc</em> to process the command.</p>
<p><strong>Tcl_CreateObjCommand</strong> deletes any existing command <em>name</em> already
associated with the interpreter (however see below for an exception
where the existing command is not deleted). It returns a token that may
be used to refer to the command in subsequent calls to
<strong>Tcl_GetCommandName</strong>. If <em>name</em> contains any <strong>::</strong> namespace
qualifiers, then the command is added to the specified namespace;
otherwise the command is added to the global namespace. If
<strong>Tcl_CreateObjCommand</strong> is called for an interpreter that is in the
process of being deleted, then it does not create a new command and it
returns NULL. <em>proc</em> should have arguments and result that match the
type <strong>Tcl_ObjCmdProc</strong>:</p>
<p>typedef int <strong>Tcl_ObjCmdProc</strong>( void *<em>clientData</em>, Tcl_Interp
*<em>interp</em>, int <em>objc</em>, Tcl_Obj *const <em>objv</em>[]);</p>
<p>When <em>proc</em> is invoked, the <em>clientData</em> and <em>interp</em> parameters will be
copies of the <em>clientData</em> and <em>interp</em> arguments given to
<strong>Tcl_CreateObjCommand</strong>. Typically, <em>clientData</em> points to an
application-specific data structure that describes what to do when the
command procedure is invoked. <em>Objc</em> and <em>objv</em> describe the arguments
to the command, <em>objc</em> giving the number of argument values (including
the command name) and <em>objv</em> giving the values of the arguments. The
<em>objv</em> array will contain <em>objc</em> values, pointing to the argument
values. Unlike <em>argv</em>[<em>argv</em>] used in a string-based command
procedure, <em>objv</em>[<em>objc</em>] will not contain NULL.</p>
<p>Additionally, when <em>proc</em> is invoked, it must not modify the contents of
the <em>objv</em> array by assigning new pointer values to any element of the
array (for example, <em>objv</em>[<strong>2</strong>] = <strong>NULL</strong>) because this will cause
memory to be lost and the runtime stack to be corrupted. The <strong>const</strong>
in the declaration of <em>objv</em> will cause ANSI-compliant compilers to
report any such attempted assignment as an error. However, it is
acceptable to modify the internal representation of any individual value
argument. For instance, the user may call <strong>Tcl_GetIntFromObj</strong> on
<em>objv</em>[<strong>2</strong>] to obtain the integer representation of that value; that
call may change the type of the value that <em>objv</em>[<strong>2</strong>] points at,
but will not change where <em>objv</em>[<strong>2</strong>] points.</p>
<p><em>proc</em> must return an integer code that is either <strong>TCL_OK</strong>,
<strong>TCL_ERROR</strong>, <strong>TCL_RETURN</strong>, <strong>TCL_BREAK</strong>, or <strong>TCL_CONTINUE</strong>. See
the Tcl overview man page for details on what these codes mean. Most
normal commands will only return <strong>TCL_OK</strong> or <strong>TCL_ERROR</strong>. In
addition, if <em>proc</em> needs to return a non-empty result, it can call
<strong>Tcl_SetObjResult</strong> to set the interpreter\'s result. In the case of a
<strong>TCL_OK</strong> return code this gives the result of the command, and in the
case of <strong>TCL_ERROR</strong> this gives an error message. Before invoking a
command procedure, <strong>Tcl_EvalObjEx</strong> sets interpreter\'s result to point
to a value representing an empty string, so simple commands can return
an empty result by doing nothing at all.</p>
<p>The contents of the <em>objv</em> array belong to Tcl and are not guaranteed to
persist once <em>proc</em> returns: <em>proc</em> should not modify them. Call
<strong>Tcl_SetObjResult</strong> if you want to return something from the <em>objv</em>
array.</p>
<p>Ordinarily, <strong>Tcl_CreateObjCommand</strong> deletes any existing command <em>name</em>
already associated with the interpreter. However, if the existing
command was created by a previous call to <strong>Tcl_CreateCommand</strong>,
<strong>Tcl_CreateObjCommand</strong> does not delete the command but instead
arranges for the Tcl interpreter to call the <strong>Tcl_ObjCmdProc</strong> <em>proc</em>
in the future. The old string-based <strong>Tcl_CmdProc</strong> associated with the
command is retained and its address can be obtained by subsequent
<strong>Tcl_GetCommandInfo</strong> calls. This is done for backwards compatibility.</p>
<p><em>DeleteProc</em> will be invoked when (if) <em>name</em> is deleted. This can occur
through a call to <strong>Tcl_DeleteCommand</strong>, <strong>Tcl_DeleteCommandFromToken</strong>,
or <strong>Tcl_DeleteInterp</strong>, or by replacing <em>name</em> in another call to
<strong>Tcl_CreateObjCommand</strong>. <em>DeleteProc</em> is invoked before the command is
deleted, and gives the application an opportunity to release any
structures associated with the command. <em>DeleteProc</em> should have
arguments and result that match the type <strong>Tcl_CmdDeleteProc</strong>:</p>
<p>typedef void <strong>Tcl_CmdDeleteProc</strong>( void *<em>clientData</em>);</p>
<p>The <em>clientData</em> argument will be the same as the <em>clientData</em> argument
passed to <strong>Tcl_CreateObjCommand</strong>.</p>
<p><strong>Tcl_CreateObjCommand2</strong> does the same as <strong>Tcl_CreateObjCommand</strong>,
except its <em>proc2</em> argument is of type <strong>Tcl_ObjCmdProc2</strong>.</p>
<p>typedef int <strong>Tcl_ObjCmdProc2</strong>( void *<em>clientData</em>, Tcl_Interp
*<em>interp</em>, ptrdiff_t <em>objc</em>, Tcl_Obj *const <em>objv</em>[]);</p>
<p><strong>Tcl_DeleteCommand</strong> deletes a command from a command interpreter. Once
the call completes, attempts to invoke <em>cmdName</em> in <em>interp</em> will result
in errors. If <em>cmdName</em> is not bound as a command in <em>interp</em> then
<strong>Tcl_DeleteCommand</strong> does nothing and returns -1; otherwise it returns
0. There are no restrictions on <em>cmdName</em>: it may refer to a built-in
command, an application-specific command, or a Tcl procedure. If <em>name</em>
contains any <strong>::</strong> namespace qualifiers, the command is deleted from
the specified namespace.</p>
<p>Given a token returned by <strong>Tcl_CreateObjCommand</strong>,
<strong>Tcl_DeleteCommandFromToken</strong> deletes the command from a command
interpreter. It will delete a command even if that command has been
renamed. Once the call completes, attempts to invoke the command in
<em>interp</em> will result in errors. If the command corresponding to <em>token</em>
has already been deleted from <em>interp</em> then <strong>Tcl_DeleteCommand</strong> does
nothing and returns -1; otherwise it returns 0.</p>
<p><strong>Tcl_GetCommandInfo</strong> checks to see whether its <em>cmdName</em> argument
exists as a command in <em>interp</em>. <em>cmdName</em> may include <strong>::</strong> namespace
qualifiers to identify a command in a particular namespace. If the
command is not found, then it returns 0. Otherwise it places information
about the command in the <strong>Tcl_CmdInfo</strong> structure pointed to by
<em>infoPtr</em> and returns 1. A <strong>Tcl_CmdInfo</strong> structure has the following
fields:</p>
<p>typedef struct { int <em>isNativeObjectProc</em>; Tcl_ObjCmdProc *<em>objProc</em>;
void *<em>objClientData</em>; Tcl_CmdProc *<em>proc</em>; void *<em>clientData</em>;
Tcl_CmdDeleteProc *<em>deleteProc</em>; void *<em>deleteData</em>; Tcl_Namespace
*<em>namespacePtr</em>; Tcl_ObjCmdProc2 *<em>objProc2</em>; void *<em>objClientData2</em>;
} <strong>Tcl_CmdInfo</strong>;</p>
<p>The <em>isNativeObjectProc</em> field has the value 2 if
<strong>Tcl_CreateObjCommand2</strong> was called to register the command; it has the
value 1 if <strong>Tcl_CreateObjCommand</strong> was called to register the command;
it is 0 if only <strong>Tcl_CreateCommand</strong> was called. It allows a program to
determine whether it is faster to call <em>objProc2</em>, <em>objProc</em> or <em>proc</em>:
<em>objProc2</em>/<em>objProc</em> is normally faster if <em>isNativeObjectProc</em> has the
value 2; <em>objProc</em>/<em>objProc</em> is normally faster if <em>isNativeObjectProc</em>
has the value 1. The fields <em>objProc</em> and <em>objClientData</em> have the same
meaning as the <em>proc</em> and <em>clientData</em> arguments to
<strong>Tcl_CreateObjCommand</strong>; they hold information about the value-based
command procedure that the Tcl interpreter calls to implement the
command. The fields <em>proc</em> and <em>clientData</em> hold information about the
string-based command procedure that implements the command. If
<strong>Tcl_CreateCommand</strong> was called for this command, this is the procedure
passed to it; otherwise, this is a compatibility procedure registered by
<strong>Tcl_CreateObjCommand</strong> that simply calls the command\'s value-based
procedure after converting its string arguments to Tcl values. The field
<em>deleteData</em> is the clientData value to pass to <em>deleteProc</em>; it is
normally the same as <em>clientData</em> but may be set independently using the
<strong>Tcl_SetCommandInfo</strong> procedure. The field <em>namespacePtr</em> holds a
pointer to the Tcl_Namespace that contains the command.</p>
<p><strong>Tcl_GetCommandInfoFromToken</strong> is identical to <strong>Tcl_GetCommandInfo</strong>
except that it uses a command token returned from
<strong>Tcl_CreateObjCommand</strong> in place of the command name. If the <em>token</em>
parameter is NULL, it returns 0; otherwise, it returns 1 and fills in
the structure designated by <em>infoPtr</em>.</p>
<p><strong>Tcl_SetCommandInfo</strong> is used to modify the procedures and clientData
values associated with a command. Its <em>cmdName</em> argument is the name of
a command in <em>interp</em>. <em>cmdName</em> may include <strong>::</strong> namespace qualifiers
to identify a command in a particular namespace. If this command does
not exist then <strong>Tcl_SetCommandInfo</strong> returns 0. Otherwise, it copies
the information from <em>*infoPtr</em> to Tcl\'s internal structure for the
command and returns 1.</p>
<p><strong>Tcl_SetCommandInfoFromToken</strong> is identical to <strong>Tcl_SetCommandInfo</strong>
except that it takes a command token as returned by
<strong>Tcl_CreateObjCommand</strong> instead of the command name. If the <em>token</em>
parameter is NULL, it returns 0. Otherwise, it copies the information
from <em>*infoPtr</em> to Tcl\'s internal structure for the command and
returns 1.</p>
<p>Note that <strong>Tcl_SetCommandInfo</strong> and <strong>Tcl_SetCommandInfoFromToken</strong>
both allow the clientData for a command\'s deletion procedure to be
given a different value than the clientData for its command procedure.</p>
<p>Note that neither <strong>Tcl_SetCommandInfo</strong> nor
<strong>Tcl_SetCommandInfoFromToken</strong> will change a command\'s namespace. Use
<strong>Tcl_Eval</strong> to call the <strong>rename</strong> command to do that.</p>
<p><strong>Tcl_GetCommandName</strong> provides a mechanism for tracking commands that
have been renamed. Given a token returned by <strong>Tcl_CreateObjCommand</strong>
when the command was created, <strong>Tcl_GetCommandName</strong> returns the string
name of the command. If the command has been renamed since it was
created, then <strong>Tcl_GetCommandName</strong> returns the current name. This name
does not include any <strong>::</strong> namespace qualifiers. The command
corresponding to <em>token</em> must not have been deleted. The string returned
by <strong>Tcl_GetCommandName</strong> is in dynamic memory owned by Tcl and is only
guaranteed to retain its value as long as the command is not deleted or
renamed; callers should copy the string if they need to keep it for a
long time.</p>
<p><strong>Tcl_GetCommandFullName</strong> produces the fully qualified name of a
command from a command token. The name, including all namespace
prefixes, is appended to the value specified by <em>objPtr</em>.</p>
<p><strong>Tcl_GetCommandFromObj</strong> returns a token for the command specified by
the name in a <strong>Tcl_Obj</strong>. The command name is resolved relative to the
current namespace. Returns NULL if the command is not found.</p>
<h1 id="reference-count-management">REFERENCE COUNT MANAGEMENT</h1>
<p>When the <em>proc</em> passed to <strong>Tcl_CreateObjCommand</strong> is called, the values
in its <em>objv</em> argument will have a reference count of at least 1, with
that guaranteed reference being from the Tcl evaluation stack. You
should not call <strong>Tcl_DecrRefCount</strong> on any of those values unless you
call <strong>Tcl_IncrRefCount</strong> on them first. Also, when the <em>proc</em> is
called, the interpreter result is guaranteed to be an empty string value
with a reference count of 1.</p>
<p><strong>Tcl_GetCommandFullName</strong> does not modify the reference count of its
<em>objPtr</em> argument, but does require that the object be unshared.</p>
<p><strong>Tcl_GetCommandFromObj</strong> does not modify the reference count of its
<em>objPtr</em> argument; it only reads.</p>
<h1 id="see-also">SEE ALSO</h1>
<p>Tcl_CreateCommand(3), Tcl_ResetResult(3), Tcl_SetObjResult(3)</p>
<h1 id="keywords">KEYWORDS</h1>
<p>bind, command, create, delete, namespace, value</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
