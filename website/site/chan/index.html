<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://www.tcl.tk/man/tcl8.6.13/TclCmd/contents.html/chan/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>NAME - Tcl/Tk</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "NAME";
        var mkdocs_page_input_path = "chan.md";
        var mkdocs_page_url = "/man/tcl8.6.13/TclCmd/contents.html/chan/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Tcl/Tk
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../command.md">Commands</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Tcl/Tk</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>NAME</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="name">NAME</h1>
<p>chan - Reads, writes and manipulates channels.</p>
<h1 id="synopsis">SYNOPSIS</h1>
<p><strong>chan </strong><em>operation</em> ?<em>arg arg ...</em>?</p>
<h1 id="description">DESCRIPTION</h1>
<p><strong>chan</strong> provides several operations for reading from, writing to, and
otherwise manipulating channels, e.g. those created by <strong>open</strong> and
<strong>socket</strong>, or the default channels <strong>stdin</strong>, <strong>stdout</strong> or <strong>stderr</strong>
which correspond respectively to the standard input, output, and error
streams of the process. Any unique abbreviation for <em>operation</em> is
acceptable. Available operations are:</p>
<p><strong>chan blocked </strong><em>channelName</em></p>
<p>:   Returns 1 when the channel is in non-blocking mode and the last
    input operation on the channel failed because it would have
    otherwise caused the process to block, and 0 otherwise. Each Tcl
    channel is in blocking mode unless configured otherwise.</p>
<p><strong>chan close </strong><em>channelName</em> ?<em>direction</em>?</p>
<p>:   Closes and destroys the named channel, deleting any existing event
    handlers established for the channel, and returns the empty string.
    If <em>direction</em> is given, it is</p>
<p>or</p>
<p>or any unique abbreviation of those words, and only that side of the
channel is closed. I.e. a read-write channel may become read-only or
write-only. Closing a read-only channel for reading, or closing a
write-only channel for writing is the same as simply closing the
channel. It is an error to close a read-only channel for writing or to
close a write-only channel for reading.</p>
<blockquote>
<p>When a channel is closed for writing, any buffered output on the
channel is flushed. When a channel is closed for reading, any buffered
input is discarded. When a channel is destroyed the underlying
resource is closed and the channel is thereafter unavailable.</p>
<p><strong>chan close</strong> fully flushes any output before closing the write side
of a channel unless it is non-blocking mode, where it returns
immediately and the channel is flushed in the background before
finally being closed.</p>
<p><strong>chan close</strong> may return an error if an error occurs while flushing
output. If a process in a command pipeline created by <strong>open</strong> returns
an error, <strong>chan close</strong> generates an error in the same manner as
<strong>exec</strong>.</p>
<p>Closing one side of a socket or command pipeline may lead to the
shutdown() or close() of the underlying system resource, leading to a
reaction from whatever is on the other side of the pipeline or socket.</p>
<p>If the channel for a command pipeline is in blocking mode, <strong>chan
close</strong> waits for the connected processes to complete.</p>
<p><strong>chan close</strong> only affects the current interpreter. If the channel is
open in any other interpreter, its state is unchanged there. See
<strong>interp</strong> for a description of channel sharing.</p>
<p>When the last interpreter sharing a channel is destroyed, the channel
is switched to blocking mode and fully flushed and then closed.</p>
</blockquote>
<p><strong>chan configure </strong><em>channelName</em> ?<em>optionName</em>? ?<em>value</em>? ?<em>optionName value</em>?...</p>
<p>:   Configures or reports the configuration of <em>channelName</em>.</p>
<pre><code>If no *optionName* or *value* arguments are given, **chan
configure** returns a dictionary of option names and values for the
channel. If *optionName* is supplied without a *value*, **chan
configure** returns the current value of the named option. If one or
more pairs of *optionName* and *value* are supplied, **chan
configure** sets each of the named options to the corresponding
*value* and returns the empty string.

The options described below are supported for all channels. Each
type of channel may provide additional options. Those options are
described in the relevant documentation. For example, additional
options are documented for **socket**, and also for serial devices
at **open**.

**-blocking** *boolean*

:   If **-blocking** is set to **true**, which is the default,
    reading from or writing to the channel may cause the process to
    block indefinitely. Otherwise, operations such as **chan gets**,
    **chan read**, **chan puts**, **chan** flush, and **chan close**
    take care not to block. Non-blocking mode in generally requires
    that the event loop is entered, e.g. by calling
    **Tcl_DoOneEvent** or **vwait** or by using Tk, to give Tcl a
    chance to process events on the channel.

**-buffering** *newValue*

:   If *newValue* is **full**, which is the default, output is
    buffered until the internal buffer is full or until **chan
    flush** is called. If *newValue* is **line**, output is flushed
    each time a end-of-line character is written. If *newValue* is
    **none**, output is flushed after every output operation. For
    **stdin**, **stdout**, and channels that connect to
    terminal-like devices, the default value is **line**. For
    **stderr** the default value is **none**.

**-buffersize** *newSize*

:   *newSize*, an integer no greater than one million, is the size
    in bytes of any input or output buffers subsequently allocated
    for this channel.

**-encoding** ?*name*?

:   Sets the encoding of the channel. *name* is either one of the
    names returned by **encoding names**, or

. Input is converted from the encoding into Unicode, and output is
converted from Unicode to the encoding.

&gt; **binary** is an alias for **iso8859-1**. This alone is not
&gt; sufficient for working with binary data. Use **-translation
&gt; binary** instead.
&gt;
&gt; The encoding of a new channel is the value of **encoding system**,
&gt; which returns the platform- and locale-dependent system encoding
&gt; used to interface with the operating system,

**-eofchar** *char*

:   *char* signals the end of the data when it is encountered in the
    input. If *char* is the empty string, there is no special
    character that marks the end of the data.

The default value is the empty string. The acceptable range is
\\x01 - \\x7f. A value outside this range results in an error.

**-profile** *profile*

:   Specifies the encoding profile to be used on the channel. The
    encoding transforms in use for the channel\'s input and output
    will then be subject to the rules of that profile. Any failures
    will result in a channel error. See **PROFILES** in the
    **encoding(n)** documentation for details about encoding
    profiles.

**-translation** *translation*

:

**-translation** **{***inTranslation outTranslation***}**

:   In Tcl a single line feed (\\n) represents the end of a line.
    However, at the destination the end of a line may be represented
    differently on different platforms, or even for different
    devices on the same platform. For example, under UNIX line feed
    is used in files and a carriage-return-linefeed sequence is
    normally used in network connections. Therefore, on input, e.g.
    with **chan gets** and **chan read**, each external end-of-line
    character is translated into a line feed. On output, e.g. with
    **chan puts**, each line feed is translated to the external
    end-of-line character. The default translation, **auto**,
    handles all the common cases, and **-translation** provides
    explicit control over the end-of-line character.

    Returns the input translation for a read-only channel, the
    output translation for a write-only channel, and both the input
    translation and the the output translation for a read-write
    channel. When two translations are given, they are the input and
    output translation, respectively. When only one translation is
    given for a read-write channel, it is the translation for both
    input and output. The following values are currently supported:

    **auto**

    :   The default. For input each occurrence of a line feed
        (**lf**), carriage return (**cr**), or carriage return
        followed by a line feed (**crlf**) is translated into a line
        feed. For output, each line feed is translated into a
        platform-specific representation: For all Unix variants it
        is **lf**, and for all Windows variants it is **crlf**,
        except that for sockets on all platforms it is **crlf** for
        both input and output.

    **binary**

    :   Like **lf**, no end-of-line translation is performed, but in
        addition, sets **-eofchar** to the empty string to disable
        it, sets **-encoding** to **iso8859-1**, and sets
        **-profile** to **strict** so the the channel is fully
        configured for binary input and output: Each byte read from
        the channel becomes the Unicode character having the same
        value as that byte, and each character written to the
        channel becomes a single byte in the output. This makes it
        possible to work seamlessly with binary data as long as each
        character in the data remains in the range of 0 to 255 so
        that there is no distinction between binary data and text.
        For example, A JPEG image can be read from a such a channel,
        manipulated, and then written back to such a channel.

    **cr**

    :   The end of a line is represented in the external data by a
        single carriage return character. For input, each carriage
        return is translated to a line feed, and for output each
        line feed character is translated to a carriage return.

    **crlf**

    :   The end of a line is represented in the external data by a
        carriage return character followed by a line feed. For
        input, each carriage-return-linefeed sequence is translated
        to a line feed. For output, each line feed is translated to
        a carriage-return-linefeed sequence. This translation is
        typically used for network connections, and also on Windows
        systems.

    **lf**

    :   The end of a line in the external data is represented by a
        line feed so no translations occur during either input or
        output. This translation is typically used on UNIX
        platforms,
</code></pre>
<p><strong>chan copy </strong><em>inputChan outputChan</em> ?<strong>-size </strong><em>size</em>? ?<strong>-command </strong><em>callback</em>?</p>
<p>:   Reads characters from <em>inputChan</em> and writes them to <em>outputChan</em>
    until all characters are copied, blocking until the copy is complete
    and returning the number of characters copied. Leverages internal
    buffers to avoid extra copies and to avoid buffering too much data
    in main memory when copying large files to slow destinations like
    network sockets.</p>
<pre><code>**-size** limits the number of characters copied.

If **-command** is gviven, **chan copy** returns immediately, works
in the background, and calls *callback* when the copy completes,
providing as an additional argument the number of characters written
to *outputChan*. If an error occurres during the background copy,
another argument provides message for the error. *inputChan* and
*outputChan* are automatically configured for non-blocking mode if
needed. Background copying only works correctly if events are being
processed, e.g. via **vwait** or Tk.

During a background copy no other read operation may be performed on
*inputChan*, and no write operation may be performed on
*outputChan*. However, write operations may by performed on
*inputChan* and read operations may be performed on *outputChan*, as
exhibited by the bidirectional copy example below.

If either *inputChan* or *outputChan* is closed while the copy is in
progress, copying ceases and **no** callback is made. If *inputChan*
is closed all data already queued is written to *outputChan*.

There should be no event handler established for *inputChan* because
it may become readable during a background copy. An attempt to read
or write from within an event handler results result in the error,
\"channel busy\". Any wrong-sided I/O attempted (by a **fileevent**
handler or otherwise) results in a

error.

EXAMPLES

:

The first example transfers the contents of one channel exactly to
another. Note that when copying one file to another, it is better to
use **file copy** which also copies file metadata (e.g. the file
access permissions) where possible.

fconfigure \$in -translation binary fconfigure \$out -translation
binary **fcopy** \$in \$out

This second example shows how the callback gets passed the number of
bytes transferred. It also uses vwait to put the application into
the event loop. Of course, this simplified example could be done
without the command callback.

proc Cleanup {in out bytes {error {}}} { global total set total
\$bytes close \$in close \$out if {\[string length \$error\] != 0} {
\# error occurred during the copy } } set in \[open \$file1\] set
out \[socket \$server \$port\] **fcopy** \$in \$out -command \[list
Cleanup \$in \$out\] vwait total

The third example copies in chunks and tests for end of file in the
command callback.

proc CopyMore {in out chunk bytes {error {}}} { global total done
incr total \$bytes if {(\[string length \$error\] != 0) \|\| \[eof
\$in\]} { set done \$total close \$in close \$out } else { **fcopy**
\$in \$out -size \$chunk \\ -command \[list CopyMore \$in \$out
\$chunk\] } } set in \[open \$file1\] set out \[socket \$server
\$port\] set chunk 1024 set total 0 **fcopy** \$in \$out -size
\$chunk \\ -command \[list CopyMore \$in \$out \$chunk\] vwait done

The fourth example starts an asynchronous, bidirectional fcopy
between two sockets. Those could also be pipes from two \[open
\"\|hal 9000\" r+\] (though their conversation would remain secret
to the script, since all four fileevent slots are busy).

set flows 2 proc Done {dir args} { global flows done puts \"\$dir is
over.\" incr flows -1 if {\$flows\&lt;=0} {set done 1} } **fcopy**
\$sok1 \$sok2 -command \[list Done UP\] **fcopy** \$sok2 \$sok1
-command \[list Done DOWN\] vwait done
</code></pre>
<p><strong>chan create </strong><em>mode cmdPrefix</em></p>
<p>:   Creates a new channel, called a <strong>reflected</strong> channel, with
    <em>cmdPrefix</em> as its handler, and returns the name of the channel.
    <strong>cmdPrefix</strong> is the first words of a command that provides the
    interface for a <strong>refchan</strong>.</p>
<pre><code>**Imode** is a list of one or more of the strings

or

, indicating whether the channel is a read channel, a write channel,
or both. It is an error if the handler does not support the chosen
mode.

The handler is called as needed from the global namespace at the top
level, and command resolution happens there at the time of the call.
If the handler is renamed or deleted any subsequent attempt to call
it is an error, which may not be able to describe the failure.

The handler is always called in the interpreter and thread it was
created in, even if the channel was shared with or moved into a
different interpreter in a different thread. This is achieved
through event dispatch, so if the event loop is not entered, e.g. by
calling **Tcl_DoOneEvent** or **vwait** or using Tk, the thread
performing the channel operation *blocks* indefinitely, resulting in
deadlock.

One side of a channel may be in one thread while the other side is
in a different thread, providing a stream-oriented bridge between
the threads. This provides a method for regular stream communication
between threads as an alternative to sending commands.

When the interpreter the handler is in is deleted each channel
associated with the handler is deleted as well, regardless of which
interpreter or thread it is currently in or shared with.

**chan create** is **safe** and is accessible to safe interpreters.
The handler is always called in the safe interpreter it was created
in.
</code></pre>
<p><strong>chan eof </strong><em>channelName</em></p>
<p>:   Returns 1 if the last read on the channel failed because the end of
    the data was already reached, and 0 otherwise.</p>
<p><strong>chan event </strong><em>channelName event</em> ?<em>script</em>?</p>
<p>:   Arranges for the given script, called a <strong>channel event hndler</strong>, to
    be called whenever the given event, one of</p>
<p>or</p>
<p>occurs on the given channel, replacing any script that was previously
set. If <em>script</em> is the empty string the current handler is deleted. It
is also deleted when the channel is closed. If <em>script</em> is omitted,
either the existing script or the empty string is returned. The event
loop must be entered, e.g. via <strong>vwait</strong> or <strong>update</strong>, or by using Tk,
for handlers to be evaluated.</p>
<blockquote>
<p><em>script</em> is evaluated at the global level in the interpreter it was
established in. Any resulting error is handled in the background, i.e.
via <strong>interp bgerror</strong>. In order to prevent an endless loop due to a
buggy handler, the handler is deleted if <em>script</em> returns an error so
that it is not evaluated again.</p>
<p>Without an event handler, <strong>chan gets</strong> or <strong>chan read</strong> on a channel
in blocking mode may block until data becomes available, become during
which the thread is unable to perform other work or respond to events
on other channels. This could cause the application to appear to</p>
<p>. Channel event handlers allow events on the channel to direct channel
handling so that the reader or writer can continue to perform other
processing while waiting for a channel to become available and then
handle channel operations when the channel is ready for the operation.</p>
<p>A</p>
<p>event occurs when there is data that can be read from the channel and
also when there is an error on the channel. The handler must check for
these conditions and handle them appropriately. For example, a handler
that does not check whether the end of the data has been reached may
be repeatedly evaluated in a busy loop until the channel is closed.</p>
<p>A</p>
<p>event occurs when at least one byte of data can be written, or if
there is an error on the channel. A client socket opened in
non-blocking mode becomes writable when it becomes connected or if the
connection fails.</p>
<p>Event-driven channel handling works best for channels in non-blocking
mode. A channel in blocking mode blocks when <strong>chan puts</strong> writes more
data than the channel can accept at the moment, and when <strong>chan gets</strong>
or <strong>chan read</strong> requests more data than is currently available. When
a channel blocks, the thread can not do any other processing or
service any other events. A channel in non-blocking mode allows a
thread to carry on with other work and get back to the channel at the
right time.</p>
</blockquote>
<p><strong>chan flush </strong><em>channelName</em></p>
<p>:   For a channel in blocking mode, flushes all buffered output to the
    destination, and then returns. For a channel in non-blocking mode,
    returns immediately while all buffered output is flushed in the
    background as soon as possible.</p>
<p><strong>chan gets </strong><em>channelName</em> ?<em>varName</em>?</p>
<p>:   Returns the next line from the channel, removing the trailing line
    feed, or if <em>varName</em> is given, assigns the line to that variable
    and returns the number of characters read. the line that was read,
    removing the trailing line feed, or returns the empty string if
    there is no data to return and the end of the file has been reached,
    or in non-blocking mode, if no complete line is currently available.
    If <em>varName</em> is given, assigns the line that was read to variable
    named <em>varName</em> and returns the number of characters that were read,
    or -1 if there no data available and the end of the channel was
    reached or the channel is in non-blocking mode.</p>
<pre><code>If the end of the channel is reached the data read so far is
returned or assigned to *varName*. When *varName* is not given,
**chan eof** may indicate that the empty string means that the end
of the data has been reached, and **chan blocked** may indicate that
that the empty string means there isn\'t currently enough data do
return the next line.
</code></pre>
<p><strong>chan names</strong> ?<em>pattern</em>?</p>
<p>:   Returns a list of all channel names, or if <em>pattern</em> is given, only
    those names that match according to the rules of <strong>string match</strong>.</p>
<p><strong>chan pending </strong><em>mode channelName</em></p>
<p>:   Returns the number of bytes of input when <em>mode</em> is</p>
<p>, or output when <em>mode</em> is</p>
<p>, that are currently internally buffered for the channel. Useful in a
readable event callback to impose limits on input line length to avoid a
potential denial-of-service attack where an extremely long line exceeds
the available memory to buffer it. Returns -1 if the channel was not
opened for the mode in question.</p>
<p><strong>chan pipe</strong></p>
<p>:   Creates a pipe, i.e. a readable channel and a writable channel, and
    returns the names of the readable channel and the writable channel.
    Data written to the writable channel can be read from the readable
    channel. Because the pipe is a real system-level pipe, it can be
    connected to other processes using redirection. For example, to
    redirect <strong>stderr</strong> from a subprocess into one channel, and
    <strong>stdout</strong> into another, <strong>exec</strong> with \"2>@\" and \">@\", each
    onto the writable side of a pipe, closing the writable side
    immediately thereafter so that EOF is signaled on the read side once
    the subprocess has closed its output, typically on exit.</p>
<pre><code>Due to buffering, data written to one side of a pipe might not
immediately become available on the other side. Tcl\'s own buffers
can be configured via **chan configure -buffering**, but overall
behaviour still depends on operating system buffers outside of
Tcl\'s control. Once the write side of the channel is closed, any
data remaining in the buffers is flushed through to the read side.
It may be useful to arrange for the connected process to flush at
some point after writing to the channel or to have it use some
system-provided mechanism to configure buffering. When two pipes are
connected to the same process, one to send data to the process, and
one to read data from the process, a deadlock may occur if the
channels are in blocking mode: If reading, the channel may block
waiting for data that can never come because buffers are only
flushed on subsequent writes, and if writing, the channel may block
while waiting for the buffers to become free, which can never happen
because the reader can not read while the writer is blocking. To
avoid this issue, either put the channels into non-blocking mode and
use event handlers, or place the read channel and the write channel
in separate interpreters in separate threads.
</code></pre>
<p><strong>chan pop </strong><em>channelName</em></p>
<p>:   Removes the topmost transformation handler from the channel if there
    is one, and closes the channel otherwise. The result is normally the
    empty string, but may be an error in some situations, e.g. when
    closing the underlying resource results in an error.</p>
<p><strong>chan postevent </strong><em>channelName eventSpec</em></p>
<p>:   For use by handlers established with <strong>chan create</strong>. Notifies Tcl
    that that one or more event(s) listed in <em>eventSpec</em>, each of which
    is either</p>
<p>or</p>
<p>, have occurred.</p>
<blockquote>
<p>For use only by handlers for a channel created by <strong>chan create</strong>. It
is an error to post an event for any other channel.</p>
<p>Since only the handler for a reflected channel channel should post
events it is an error to post an event from any interpreter other than
the interpreter that created the channel.</p>
<p>It is an error to post an event that the channel has no interest in.
See <strong>watch</strong> in the <strong>refchan</strong> documentation for more information</p>
<p><strong>chan postevent</strong> is available in safe interpreters, as any handler
for a reflected channel would have been created, and will be evaluated
in that interpreter as well.</p>
</blockquote>
<p><strong>chan push </strong><em>channelName cmdPrefix</em></p>
<p>:   Adds a new transformation handler on top of the channel and returns
    a handle for the transformation. <em>cmdPrefix</em> is the first words of a
    command that provides the interface documented for <strong>transchan</strong>,
    and transforms data on the channel, It is an error if handler does
    not support the mode(s) the channel is in.</p>
<p><strong>chan puts</strong> ?<strong>-nonewline</strong>? ?<em>channelName</em>? <em>string</em></p>
<p>:   Writes <em>string</em> and a line feed to the channel. If <strong>-nonewline</strong> is
    given, the trailing line feed is not written. The default channel is
    <strong>stdout</strong>.</p>
<pre><code>Each line feed in the output is translated according to the
configuration of **-translation**.

Because Tcl internally buffers output, characters written to a
channel may not immediately be available at the destination. Tcl
normally delays output until the buffer is full or the channel is
closed. **chan flush** forces output in the direction of the
destination.

When the output for a channel in blocking mode fills up, **chan
puts** blocks until space in the buffer is available again, but for
a channel in non-blocking mode, it returns immediately and the data
is written in the background as fast possible, constrained by the
speed at which as the destination accepts it. Output to a channel in
non-blocking mode only works properly when the application enters
the event loop, giving Tcl a chance to find out that the destination
is ready to accept more data. When a channel is in non-blocking
mode, Tcl\'s internal buffers can hold an arbitrary amount of data,
possibly consuming a large amount of memory. To avoid wasting
memory, channels in non-blocking mode should normally be handled
using **chan event**, where the application only invokes **chan
puts** after being recently notified through a file event handler
that the channel is ready for more output data.
</code></pre>
<p><strong>chan read </strong><em>channelName</em> ?<em>numChars</em>?</p>
<p>:   </p>
<p><strong>chan read </strong>?<strong>-nonewline</strong>? <em>channelName</em></p>
<p>:   Reads and returns the next <em>numChars</em> characters from the channel.
    If <em>numChars</em> is omitted, all available characters up to the end of
    the file are read, or if the channel is in non-blocking mode, all
    currently-available characters are read. If there is an error on the
    channel, reading ceases and an error is returned. If <em>numChars</em> is
    not given, <strong>-nonewline</strong> may be given, causing any any trailing
    line feed to be trimmed.</p>
<pre><code>If the channel is in non-blocking mode, fewer characters than
requested may be returned. If the channel is configured to use a
multi-byte encoding, bytes that do not form a complete character are
retained in the buffers until enough bytes to complete the character
accumulate, or the end of the data is reached. **-nonewline** is
ignored if characters are returned before reaching the end of the
file.

Each end-of-line sequence according to the value of **-translation**
is translated into a line feed.

When reading from a serial port, most applications should configure
the serial port channel to be in non-blocking mode, but not
necessarily use an event handler since most serial ports are
comparatively slow. It is entirely possible to get a **readable**
event for each individual character. In blocking mode, **chan read**
blocks forever when reading to the end of the data if there is no
**chan configure -eofchar** configured for the channel.
</code></pre>
<p><strong>chan seek </strong><em>channelName offset</em> ?<em>origin</em>?</p>
<p>:   Sets the current position for the data in the channel to integer
    <em>offset</em> bytes relative to <em>origin</em>. A negative offset moves the
    current position backwards from the origin. <em>origin</em> is one of the
    following:</p>
<pre><code>**start**

:   The origin is the start of the data. This is the default.

**current**

:   The origin is the current position.

**end**

:   The origin is the end of the data.

**Chan seek** flushes all buffered output even if the channel is in
non-blocking mode, discards any buffered and unread input, and
returns the empty string or an error if the channel does not support
seeking.

*offset* values are byte offsets, not character offsets. Unlike
**chan** read, both **chan seek** and **chan tell** operate in terms
of bytes, not characters,
</code></pre>
<p><strong>chan tell </strong><em>channelName</em></p>
<p>:   Returns the offset in bytes of the current position in the
    underlying data, or -1 if the channel does not suport seeking. The
    value can be passed to <strong>chan</strong> seek to set current position to that
    offset.</p>
<p><strong>chan truncate </strong><em>channelName</em> ?<em>length</em>?</p>
<p>:   Flushes the channel and truncates the data in the channel to
    <em>length</em> bytes, or to the current position in bytes if <em>length</em> is
    omitted.</p>
<h1 id="examples">EXAMPLES</h1>
<p>In the following example a file is opened using the encoding CP1252,
which is common on Windows, searches for a string, rewrites that part,
and truncates the file two lines later.</p>
<p>set f [open somefile.txt r+] <strong>chan configure</strong> \$f -encoding cp1252
set offset 0</p>
<p><em># Search for string \"FOOBAR\" in the file</em> while {[<strong>chan gets</strong> \$f
line] >= 0} { set idx [string first FOOBAR \$line] if {\$idx >= 0}
{ <em># Found it; rewrite line</em></p>
<p><strong>chan seek</strong> \$f [expr {\$offset + \$idx}] <strong>chan puts</strong> -nonewline
\$f BARFOO</p>
<p><em># Skip to end of following line, and truncate</em> <strong>chan gets</strong> \$f
<strong>chan gets</strong> \$f <strong>chan truncate</strong> \$f</p>
<p><em># Stop searching the file now</em> break }</p>
<p><em># Save offset of start of next line for later</em> set offset [<strong>chan
tell</strong> \$f] } <strong>chan close</strong> \$f</p>
<p>A network server that echoes its input line-by-line without preventing
servicing of other connections at the same time:</p>
<p># This is a very simple logger... proc log message { <strong>chan puts</strong>
stdout \$message }</p>
<p># This is called whenever a new client connects to the server proc
connect {chan host port} { set clientName [format \&lt;%s:%d> \$host
\$port] log \"connection from \$clientName\" <strong>chan configure</strong> \$chan
-blocking 0 -buffering line <strong>chan event</strong> \$chan readable [list
echoLine \$chan \$clientName] }</p>
<p># This is called whenever either at least one byte of input # data is
available, or the channel was closed by the client. proc echoLine {chan
clientName} { <strong>chan gets</strong> \$chan line if {[<strong>chan eof</strong> \$chan]} {
log \"finishing connection from \$clientName\" <strong>chan close</strong> \$chan }
elseif {![<strong>chan blocked</strong> \$chan]} { # Didn\'t block waiting for
end-of-line log \"\$clientName - \$line\" <strong>chan puts</strong> \$chan \$line }
}</p>
<p># Create the server socket and enter the event-loop to wait # for
incoming connections... socket -server connect 12345 vwait forever</p>
<h1 id="see-also">SEE ALSO</h1>
<p>close(n), eof(n), fblocked(n), fconfigure(n), fcopy(n), file(n),
fileevent(n), flush(n), gets(n), open(n), puts(n), read(n), seek(n),
socket(n), tell(n), refchan(n), transchan(n)</p>
<h1 id="keywords">KEYWORDS</h1>
<p>channel, input, output, events, offset</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
