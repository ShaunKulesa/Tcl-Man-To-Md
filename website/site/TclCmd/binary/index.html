<!DOCTYPE html>
<html lang="en">
    <head>
      <script>
	// Hack for scrolling window when linking to anchor tag with fixed nav header
        var shiftWindow = function() { scrollBy(0, -75) };
        window.addEventListener("hashchange", shiftWindow);
        function load() { if (window.location.hash) shiftWindow(); }
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://www.tcl.tk/man/TclCmd/binary/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Binary - Tcl/Tk</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="../../css/font-awesome.min.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
    <script src="../../js/base.js"></script> 
    </head>

    <body class="">

      <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
	<div class="container">
	<a class="navbar-brand" href="../..">Tcl/Tk</a>
	<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExample04" aria-controls="navbarsExample04" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
	</button>

	<div class="collapse navbar-collapse">

          <ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex">
            <li class="nav-item">
              <a class="nav-link" href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
		<i class="fa fa-search"></i> Search
              </a>
            </li>
          </ul>
	</div>
	</div>
      </nav><div id="content" class="container">
        
      <div class="row">
        <div class="col-md-9" role="main">


<nav aria-label="breadcrumb">
  <ol class="breadcrumb">
    
    <li class="breadcrumb-item active" aria-current="page">Binary</li>
  </ol>
</nav>


<p>\</p>
<h1 id="name">NAME</h1>
<p>binary - Insert and extract fields from binary strings</p>
<h1 id="synopsis">SYNOPSIS</h1>
<p><strong>binary decode </strong><em>format</em> ?<em>-option value ...</em>? <em>data</em>\
<strong>binary encode </strong><em>format</em> ?<em>-option value ...</em>? <em>data</em>\</p>
<p><strong>binary format </strong><em>formatString </em>?<em>arg arg ...</em>?\
<strong>binary scan </strong><em>string formatString </em>?<em>varName varName ...</em>?</p>
<p>\</p>
<h1 id="description">DESCRIPTION</h1>
<p>This command provides facilities for manipulating binary data. The
subcommand <strong>binary format</strong> creates a binary string from normal Tcl
values. For example, given the values 16 and 22, on a 32-bit
architecture, it might produce an 8-byte binary string consisting of two
4-byte integers, one for each of the numbers. The subcommand <strong>binary
scan</strong>, does the opposite: it extracts data from a binary string and
returns it as ordinary Tcl string values.</p>
<p>The <strong>binary encode</strong> and <strong>binary decode</strong> subcommands convert binary
data to or from string encodings such as base64 (used in MIME messages
for example).</p>
<p>Note that other operations on binary data, such as taking a subsequence
of it, getting its length, or reinterpreting it as a string in some
encoding, are done by other Tcl commands (respectively <strong>string range</strong>,
<strong>string length</strong> and <strong>encoding convertfrom</strong> in the example cases). A
binary string in Tcl is merely one where all the characters it contains
are in the range \u0000-\u00FF.</p>
<h1 id="binary-encode-and-decode">BINARY ENCODE AND DECODE</h1>
<p>When encoding binary data as a readable string, the starting binary data
is passed to the <strong>binary encode</strong> command, together with the name of
the encoding to use and any encoding-specific options desired. Data
which has been encoded can be converted back to binary form using
<strong>binary decode</strong>. The following formats and options are supported.</p>
<p><strong>base64</strong></p>
<p>:   The <strong>base64</strong> binary encoding is commonly used in mail messages and
    XML documents, and uses mostly upper and lower case letters and
    digits. It has the distinction of being able to be rewrapped
    arbitrarily without losing information.</p>
<div class="language-text highlight"><pre><span></span><code>During encoding, the following options are supported:

**-maxlen ***length*

:   Indicates that the output should be split into lines of no more
    than *length* characters. By default, lines are not split.

**-wrapchar ***character*

:   Indicates that, when lines are split because of the **-maxlen**
    option, *character* should be used to separate lines. By
    default, this is a newline character,

During decoding, the following options are supported:

**-strict**

:   Instructs the decoder to throw an error if it encounters any
    characters that are not strictly part of the encoding itself.
    Otherwise it ignores them. RFC 2045 calls for base64 decoders to
    be non-strict.
</code></pre></div>
<p><strong>hex</strong></p>
<p>:   The <strong>hex</strong> binary encoding converts each byte to a pair of
    hexadecimal digits that represent the byte value as a hexadecimal
    integer. When encoding, lower characters are used. When decoding,
    upper and lower characters are accepted.</p>
<div class="language-text highlight"><pre><span></span><code>No options are supported during encoding. During decoding, the
following options are supported:

**-strict**

:   Instructs the decoder to throw an error if it encounters
    whitespace characters. Otherwise it ignores them.
</code></pre></div>
<p><strong>uuencode</strong></p>
<p>:   The <strong>uuencode</strong> binary encoding used to be common for transfer of
    data between Unix systems and on USENET, but is less common these
    days, having been largely superseded by the <strong>base64</strong> binary
    encoding.</p>
<div class="language-text highlight"><pre><span></span><code>During encoding, the following options are supported (though
changing them may produce files that other implementations of
decoders cannot process):

**-maxlen ***length*

:   Indicates the maximum number of characters to produce for each
    encoded line. The valid range is 5 to 85. Line lengths outside
    that range cannot be accommodated by the encoding format. The
    default value is 61.

**-wrapchar ***character*

:   Indicates the character(s) to use to mark the end of each
    encoded line. Acceptable values are a sequence of zero or more
    characters from the set { \\x09 (TAB), \\x0B (VT), \\x0C (FF),
    \\x0D (CR) } followed by zero or one newline \\x0A (LF). Any
    other values are rejected because they would generate encoded
    text that could not be decoded. The default value is a single
    newline.

During decoding, the following options are supported:

**-strict**

:   Instructs the decoder to throw an error if it encounters
    anything outside of the standard encoding format. Without this
    option, the decoder tolerates some deviations, mostly to forgive
    reflows of lines between the encoder and decoder.

Note that neither the encoder nor the decoder handle the header and
footer of the uuencode format.
</code></pre></div>
<h1 id="binary-format">BINARY FORMAT</h1>
<p>The <strong>binary format</strong> command generates a binary string whose layout is
specified by the <em>formatString</em> and whose contents come from the
additional arguments. The resulting binary value is returned.</p>
<p>The <em>formatString</em> consists of a sequence of zero or more field
specifiers separated by zero or more spaces. Each field specifier is a
single type character followed by an optional flag character followed by
an optional numeric <em>count</em>. Most field specifiers consume one argument
to obtain the value to be formatted. The type character specifies how
the value is to be formatted. The <em>count</em> typically indicates how many
items of the specified type are taken from the value. If present, the
<em>count</em> is a non-negative decimal integer or <strong>*</strong>, which normally
indicates that all of the items in the value are to be used. If the
number of arguments does not match the number of fields in the format
string that consume arguments, then an error is generated. The flag
character is ignored for <strong>binary format</strong>.</p>
<p>Here is a small example to clarify the relation between the field
specifiers and the arguments:</p>
<div class="language-text highlight"><pre><span></span><code>binary format d3d {1.0 2.0 3.0 4.0} 0.1
</code></pre></div>
<p>The first argument is a list of four numbers, but because of the count
of 3 for the associated field specifier, only the first three will be
used. The second argument is associated with the second field specifier.
The resulting binary string contains the four numbers 1.0, 2.0, 3.0 and
0.1.</p>
<p>Each type-count pair moves an imaginary cursor through the binary data,
storing bytes at the current position and advancing the cursor to just
after the last byte stored. The cursor is initially at position 0 at the
beginning of the data. The type may be any one of the following
characters:</p>
<p>a.  Stores a byte string of length <em>count</em> in the output string. Every
    character is taken as modulo 256 (i.e. the low byte of every
    character is used, and the high byte discarded) so when storing
    character strings not wholly expressible using the characters
    \u0000-\u00ff, the <strong>encoding convertto</strong> command should be used
    first to change the string into an external representation if this
    truncation is not desired (i.e. if the characters are not part of
    the ISO 8859-1 character set.) If <em>arg</em> has fewer than <em>count</em>
    bytes, then additional zero bytes are used to pad out the field. If
    <em>arg</em> is longer than the specified length, the extra characters will
    be ignored. If <em>count</em> is <strong>*</strong>, then all of the bytes in <em>arg</em>
    will be formatted. If <em>count</em> is omitted, then one character will be
    formatted. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format a7a*a alpha bravo charlie

will return a string equivalent to **alpha\\000\\000bravoc**,

    binary format a* [encoding convertto utf-8 \u20ac]

will return a string equivalent to **\\342\\202\\254** (which is the
UTF-8 byte sequence for a Euro-currency character) and

    binary format a* [encoding convertto iso8859-15 \u20ac]

will return a string equivalent to **\\244** (which is the ISO
8859-15 byte sequence for a Euro-currency character). Contrast these
last two with:

    binary format a* \u20ac

which returns a string equivalent to **\\254** (i.e. **\\xac**) by
truncating the high-bits of the character, and which is probably not
what is desired.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
A.  This form is the same as <strong>a</strong> except that spaces are used for
    padding instead of nulls. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format A6A*A alpha bravo charlie

will return **alpha bravoc**.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
b.  Stores a string of <em>count</em> binary digits in low-to-high order within
    each byte in the output string. <em>Arg</em> must contain a sequence of
    <strong>1</strong> and <strong>0</strong> characters. The resulting bytes are emitted in first
    to last order with the bits being formatted in low-to-high order
    within each byte. If <em>arg</em> has fewer than <em>count</em> digits, then zeros
    will be used for the remaining bits. If <em>arg</em> has more than the
    specified number of digits, the extra digits will be ignored. If
    <em>count</em> is <strong>*</strong>, then all of the digits in <em>arg</em> will be
    formatted. If <em>count</em> is omitted, then one digit will be formatted.
    If the number of bits formatted does not end at a byte boundary, the
    remaining bits of the last byte will be zeros. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format b5b* 11100 111000011010

will return a string equivalent to **\\x07\\x87\\x05**.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
B.  This form is the same as <strong>b</strong> except that the bits are stored in
    high-to-low order within each byte. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format B5B* 11100 111000011010

will return a string equivalent to **\\xe0\\xe1\\xa0**.
</code></pre></div>
<p>C.  Stores a string of <em>count</em> hexadecimal digits in high-to-low within
    each byte in the output string. <em>Arg</em> must contain a sequence of
    characters in the set The resulting bytes are emitted in first to
    last order with the hex digits being formatted in high-to-low order
    within each byte. If <em>arg</em> has fewer than <em>count</em> digits, then zeros
    will be used for the remaining digits. If <em>arg</em> has more than the
    specified number of digits, the extra digits will be ignored. If
    <em>count</em> is <strong>*</strong>, then all of the digits in <em>arg</em> will be
    formatted. If <em>count</em> is omitted, then one digit will be formatted.
    If the number of digits formatted does not end at a byte boundary,
    the remaining bits of the last byte will be zeros. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format H3H*H2 ab DEF 987

will return a string equivalent to **\\xab\\x00\\xde\\xf0\\x98**.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
h.  This form is the same as <strong>H</strong> except that the digits are stored in
    low-to-high order within each byte. This is seldom required. For
    example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format h3h*h2 AB def 987

will return a string equivalent to **\\xba\\x00\\xed\\x0f\\x89**.
</code></pre></div>
<p>i.  Stores one or more 8-bit integer values in the output string. If no
    <em>count</em> is specified, then <em>arg</em> must consist of an integer value.
    If <em>count</em> is specified, <em>arg</em> must consist of a list containing at
    least that many integers. The low-order 8 bits of each integer are
    stored as a one-byte value at the cursor position. If <em>count</em> is
    <strong>*</strong>, then all of the integers in the list are formatted. If the
    number of elements in the list is greater than <em>count</em>, then the
    extra elements are ignored. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format c3cc* {3 -3 128 1} 260 {2 5}

will return a string equivalent to
**\\x03\\xfd\\x80\\x04\\x02\\x05**, whereas

    binary format c {2 5}

will generate an error.
</code></pre></div>
<p>j.  This form is the same as <strong>c</strong> except that it stores one or more
    16-bit integers in little-endian byte order in the output string.
    The low-order 16-bits of each integer are stored as a two-byte value
    at the cursor position with the least significant byte stored first.
    For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format s3 {3 -3 258 1}

will return a string equivalent to
**\\x03\\x00\\xfd\\xff\\x02\\x01**.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
S.  This form is the same as <strong>s</strong> except that it stores one or more
    16-bit integers in big-endian byte order in the output string. For
    example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format S3 {3 -3 258 1}

will return a string equivalent to
**\\x00\\x03\\xff\\xfd\\x01\\x02**.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
t.  This form (mnemonically <em>tiny</em>) is the same as <strong>s</strong> and <strong>S</strong>
    except that it stores the 16-bit integers in the output string in
    the native byte order of the machine where the Tcl script is
    running. To determine what the native byte order of the machine is,
    refer to the <strong>byteOrder</strong> element of the <strong>tcl_platform</strong> array.</p>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-6-1"><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
i.  This form is the same as <strong>c</strong> except that it stores one or more
    32-bit integers in little-endian byte order in the output string.
    The low-order 32-bits of each integer are stored as a four-byte
    value at the cursor position with the least significant byte stored
    first. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format i3 {3 -3 65536 1}

will return a string equivalent to
**\\x03\\x00\\x00\\x00\\xfd\\xff\\xff\\xff\\x00\\x00\\x01\\x00**
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-7-1"><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
I.  This form is the same as <strong>i</strong> except that it stores one or more one
    or more 32-bit integers in big-endian byte order in the output
    string. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format I3 {3 -3 65536 1}

will return a string equivalent to
**\\x00\\x00\\x00\\x03\\xff\\xff\\xff\\xfd\\x00\\x01\\x00\\x00**
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-8-1"><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
n.  This form (mnemonically <em>number</em> or <em>normal</em>) is the same as <strong>i</strong>
    and <strong>I</strong> except that it stores the 32-bit integers in the output
    string in the native byte order of the machine where the Tcl script
    is running. To determine what the native byte order of the machine
    is, refer to the <strong>byteOrder</strong> element of the <strong>tcl_platform</strong>
    array.</p>
<p>o.  This form is the same as <strong>c</strong> except that it stores one or more
    64-bit integers in little-endian byte order in the output string.
    The low-order 64-bits of each integer are stored as an eight-byte
    value at the cursor position with the least significant byte stored
    first. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format w 7810179016327718216

will return the string **HelloTcl**
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-9-1"><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
W.  This form is the same as <strong>w</strong> except that it stores one or more one
    or more 64-bit integers in big-endian byte order in the output
    string. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format Wc 4785469626960341345 110

will return the string **BigEndian**
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-10-1"><a id="__codelineno-10-1" name="__codelineno-10-1" href="#__codelineno-10-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
m.  This form (mnemonically the mirror of <strong>w</strong>) is the same as <strong>w</strong>
    and <strong>W</strong> except that it stores the 64-bit integers in the output
    string in the native byte order of the machine where the Tcl script
    is running. To determine what the native byte order of the machine
    is, refer to the <strong>byteOrder</strong> element of the <strong>tcl_platform</strong>
    array.</p>
<p>n.  This form is the same as <strong>c</strong> except that it stores one or more one
    or more single-precision floating point numbers in the machine\'s
    native representation in the output string. This representation is
    not portable across architectures, so it should not be used to
    communicate floating point numbers across the network. The size of a
    floating point number may vary across architectures, so the number
    of bytes that are generated may vary. If the value overflows the
    machine\'s native representation, then the value of FLT_MAX as
    defined by the system will be used instead. Because Tcl uses
    double-precision floating point numbers internally, there may be
    some loss of precision in the conversion to single-precision. For
    example, on a Windows system running on an Intel Pentium processor,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format f2 {1.6 3.4}

will return a string equivalent to
**\\xcd\\xcc\\xcc\\x3f\\x9a\\x99\\x59\\x40**.
</code></pre></div>
<p>o.  This form (mnemonically <em>real</em>) is the same as <strong>f</strong> except that it
    stores the single-precision floating point numbers in little-endian
    order. This conversion only produces meaningful output when used on
    machines which use the IEEE floating point representation (very
    common, but not universal.)</p>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-11-1"><a id="__codelineno-11-1" name="__codelineno-11-1" href="#__codelineno-11-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
R.  This form is the same as <strong>r</strong> except that it stores the
    single-precision floating point numbers in big-endian order.</p>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-12-1"><a id="__codelineno-12-1" name="__codelineno-12-1" href="#__codelineno-12-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
d.  This form is the same as <strong>f</strong> except that it stores one or more one
    or more double-precision floating point numbers in the machine\'s
    native representation in the output string. For example, on a
    Windows system running on an Intel Pentium processor,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format d1 {1.6}

will return a string equivalent to
**\\x9a\\x99\\x99\\x99\\x99\\x99\\xf9\\x3f**.
</code></pre></div>
<p>e.  This form (mnemonically the mirror of <strong>d</strong>) is the same as <strong>d</strong>
    except that it stores the double-precision floating point numbers in
    little-endian order. This conversion only produces meaningful output
    when used on machines which use the IEEE floating point
    representation (very common, but not universal.)</p>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-13-1"><a id="__codelineno-13-1" name="__codelineno-13-1" href="#__codelineno-13-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
Q.  This form is the same as <strong>q</strong> except that it stores the
    double-precision floating point numbers in big-endian order.</p>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-14-1"><a id="__codelineno-14-1" name="__codelineno-14-1" href="#__codelineno-14-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
x.  Stores <em>count</em> null bytes in the output string. If <em>count</em> is not
    specified, stores one null byte. If <em>count</em> is <strong>*</strong>, generates an
    error. This type does not consume an argument. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format a3xa3x2a3 abc def ghi

will return a string equivalent to **abc\\000def\\000\\000ghi**.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-15-1"><a id="__codelineno-15-1" name="__codelineno-15-1" href="#__codelineno-15-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
X.  Moves the cursor back <em>count</em> bytes in the output string. If <em>count</em>
    is <strong>*</strong> or is larger than the current cursor position, then the
    cursor is positioned at location 0 so that the next byte stored will
    be the first byte in the result string. If <em>count</em> is omitted then
    the cursor is moved back one byte. This type does not consume an
    argument. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format a3X*a3X2a3 abc def ghi

will return **dghi**.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-16-1"><a id="__codelineno-16-1" name="__codelineno-16-1" href="#__codelineno-16-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
1.  Moves the cursor to the absolute location in the output string
    specified by <em>count</em>. Position 0 refers to the first byte in the
    output string. If <em>count</em> refers to a position beyond the last byte
    stored so far, then null bytes will be placed in the uninitialized
    locations and the cursor will be placed at the specified location.
    If <em>count</em> is <strong>*</strong>, then the cursor is moved to the current end of
    the output string. If <em>count</em> is omitted, then an error will be
    generated. This type does not consume an argument. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary format a5@2a1@*a3@10a1 abcde f ghi j

will return **abfdeghi\\000\\000j**.
</code></pre></div>
<h1 id="binary-scan">BINARY SCAN</h1>
<p>The <strong>binary scan</strong> command parses fields from a binary string,
returning the number of conversions performed. <em>String</em> gives the input
bytes to be parsed (one byte per character, and characters not
representable as a byte have their high bits chopped) and <em>formatString</em>
indicates how to parse it. Each <em>varName</em> gives the name of a variable;
when a field is scanned from <em>string</em> the result is assigned to the
corresponding variable.</p>
<p>As with <strong>binary format</strong>, the <em>formatString</em> consists of a sequence of
zero or more field specifiers separated by zero or more spaces. Each
field specifier is a single type character followed by an optional flag
character followed by an optional numeric <em>count</em>. Most field specifiers
consume one argument to obtain the variable into which the scanned
values should be placed. The type character specifies how the binary
data is to be interpreted. The <em>count</em> typically indicates how many
items of the specified type are taken from the data. If present, the
<em>count</em> is a non-negative decimal integer or <strong>*</strong>, which normally
indicates that all of the remaining items in the data are to be used. If
there are not enough bytes left after the current cursor position to
satisfy the current field specifier, then the corresponding variable is
left untouched and <strong>binary scan</strong> returns immediately with the number
of variables that were set. If there are not enough arguments for all of
the fields in the format string that consume arguments, then an error is
generated. The flag character may be given to cause some types to be
read as unsigned values. The flag is accepted for all field types but is
ignored for non-integer fields.</p>
<p>A similar example as with <strong>binary format</strong> should explain the relation
between field specifiers and arguments in case of the binary scan
subcommand:</p>
<div class="language-text highlight"><pre><span></span><code>binary scan $bytes s3s first second
</code></pre></div>
<p>This command (provided the binary string in the variable <em>bytes</em> is long
enough) assigns a list of three integers to the variable <em>first</em> and
assigns a single value to the variable <em>second</em>. If <em>bytes</em> contains
fewer than 8 bytes (i.e. four 2-byte integers), no assignment to
<em>second</em> will be made, and if <em>bytes</em> contains fewer than 6 bytes (i.e.
three 2-byte integers), no assignment to <em>first</em> will be made. Hence:</p>
<div class="language-text highlight"><pre><span></span><code>puts [binary scan abcdefg s3s first second]
puts $first
puts $second
</code></pre></div>
<p>will print (assuming neither variable is set previously):</p>
<div class="language-text highlight"><pre><span></span><code>1
25185 25699 26213
can&#39;t read &quot;second&quot;: no such variable
</code></pre></div>
<p>It is <em>important</em> to note that the <strong>c</strong>, <strong>s</strong>, and <strong>S</strong> (and <strong>i</strong>
and <strong>I</strong> on 64bit systems) will be scanned into long data size values.
In doing this, values that have their high bit set (0x80 for chars,
0x8000 for shorts, 0x80000000 for ints), will be sign extended. Thus the
following will occur:</p>
<div class="language-text highlight"><pre><span></span><code>set signShort [binary format s1 0x8000]
binary scan $signShort s1 val; # val == 0xFFFF8000
</code></pre></div>
<p>If you require unsigned values you can include the flag character
following the field type. For example, to read an unsigned short value:</p>
<div class="language-text highlight"><pre><span></span><code>set signShort [binary format s1 0x8000]
binary scan $signShort su1 val; # val == 0x00008000
</code></pre></div>
<p>Each type-count pair moves an imaginary cursor through the binary data,
reading bytes from the current position. The cursor is initially at
position 0 at the beginning of the data. The type may be any one of the
following characters:</p>
<p>a.  The data is a byte string of length <em>count</em>. If <em>count</em> is <strong>*</strong>,
    then all of the remaining bytes in <em>string</em> will be scanned into the
    variable. If <em>count</em> is omitted, then one byte will be scanned. All
    bytes scanned will be interpreted as being characters in the range
    \u0000-\u00ff so the <strong>encoding convertfrom</strong> command will be
    needed if the string is not a binary string or a string encoded in
    ISO 8859-1. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary scan abcde\000fghi a6a10 var1 var2

will return **1** with the string equivalent to **abcde\\000**
stored in *var1* and *var2* left unmodified, and

    binary scan \342\202\254 a* var1
    set var2 [encoding convertfrom utf-8 $var1]

will store a Euro-currency character in *var2*.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-17-1"><a id="__codelineno-17-1" name="__codelineno-17-1" href="#__codelineno-17-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
A.  This form is the same as <strong>a</strong>, except trailing blanks and nulls are
    stripped from the scanned value before it is stored in the variable.
    For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary scan &quot;abc efghi  \000&quot; A* var1

will return **1** with **abc efghi** stored in *var1*.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-18-1"><a id="__codelineno-18-1" name="__codelineno-18-1" href="#__codelineno-18-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
b.  The data is turned into a string of <em>count</em> binary digits in
    low-to-high order represented as a sequence of and characters. The
    data bytes are scanned in first to last order with the bits being
    taken in low-to-high order within each byte. Any extra bits in the
    last byte are ignored. If <em>count</em> is <strong>*</strong>, then all of the
    remaining bits in <em>string</em> will be scanned. If <em>count</em> is omitted,
    then one bit will be scanned. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary scan \x07\x87\x05 b5b* var1 var2

will return **2** with **11100** stored in *var1* and
**1110000110100000** stored in *var2*.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-19-1"><a id="__codelineno-19-1" name="__codelineno-19-1" href="#__codelineno-19-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
B.  This form is the same as <strong>b</strong>, except the bits are taken in
    high-to-low order within each byte. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary scan \x70\x87\x05 B5B* var1 var2

will return **2** with **01110** stored in *var1* and
**1000011100000101** stored in *var2*.
</code></pre></div>
<p>C.  The data is turned into a string of <em>count</em> hexadecimal digits in
    high-to-low order represented as a sequence of characters in the set
    The data bytes are scanned in first to last order with the hex
    digits being taken in high-to-low order within each byte. Any extra
    bits in the last byte are ignored. If <em>count</em> is <strong>*</strong>, then all of
    the remaining hex digits in <em>string</em> will be scanned. If <em>count</em> is
    omitted, then one hex digit will be scanned. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary scan \x07\xC6\x05\x1f\x34 H3H* var1 var2

will return **2** with **07c** stored in *var1* and **051f34**
stored in *var2*.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-20-1"><a id="__codelineno-20-1" name="__codelineno-20-1" href="#__codelineno-20-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
h.  This form is the same as <strong>H</strong>, except the digits are taken in
    reverse (low-to-high) order within each byte. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary scan \x07\x86\x05\x12\x34 h3h* var1 var2

will return **2** with **706** stored in *var1* and **502143**
stored in *var2*.

Note that most code that wishes to parse the hexadecimal digits from
multiple bytes in order should use the **H** format.
</code></pre></div>
<p>i.  The data is turned into <em>count</em> 8-bit signed integers and stored in
    the corresponding variable as a list. If <em>count</em> is <strong>*</strong>, then all
    of the remaining bytes in <em>string</em> will be scanned. If <em>count</em> is
    omitted, then one 8-bit integer will be scanned. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary scan \x07\x86\x05 c2c* var1 var2

will return **2** with **7 -122** stored in *var1* and **5** stored
in *var2*. Note that the integers returned are signed, but they can
be converted to unsigned 8-bit quantities using an expression like:

    set num [expr { $num &amp; 0xFF }]
</code></pre></div>
<p>j.  The data is interpreted as <em>count</em> 16-bit signed integers
    represented in little-endian byte order. The integers are stored in
    the corresponding variable as a list. If <em>count</em> is <strong>*</strong>, then all
    of the remaining bytes in <em>string</em> will be scanned. If <em>count</em> is
    omitted, then one 16-bit integer will be scanned. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary scan \x05\x00\x07\x00\xf0\xff s2s* var1 var2

will return **2** with **5 7** stored in *var1* and **-16** stored
in *var2*. Note that the integers returned are signed, but they can
be converted to unsigned 16-bit quantities using an expression like:

    set num [expr { $num &amp; 0xFFFF }]
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-21-1"><a id="__codelineno-21-1" name="__codelineno-21-1" href="#__codelineno-21-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
S.  This form is the same as <strong>s</strong> except that the data is interpreted
    as <em>count</em> 16-bit signed integers represented in big-endian byte
    order. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary scan \x00\x05\x00\x07\xff\xf0 S2S* var1 var2

will return **2** with **5 7** stored in *var1* and **-16** stored
in *var2*.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-22-1"><a id="__codelineno-22-1" name="__codelineno-22-1" href="#__codelineno-22-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
t.  The data is interpreted as <em>count</em> 16-bit signed integers
    represented in the native byte order of the machine running the Tcl
    script. It is otherwise identical to <strong>s</strong> and <strong>S</strong>. To determine
    what the native byte order of the machine is, refer to the
    <strong>byteOrder</strong> element of the <strong>tcl_platform</strong> array.</p>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-23-1"><a id="__codelineno-23-1" name="__codelineno-23-1" href="#__codelineno-23-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
i.  The data is interpreted as <em>count</em> 32-bit signed integers
    represented in little-endian byte order. The integers are stored in
    the corresponding variable as a list. If <em>count</em> is <strong>*</strong>, then all
    of the remaining bytes in <em>string</em> will be scanned. If <em>count</em> is
    omitted, then one 32-bit integer will be scanned. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    set str \x05\x00\x00\x00\x07\x00\x00\x00\xf0\xff\xff\xff
    binary scan $str i2i* var1 var2

will return **2** with **5 7** stored in *var1* and **-16** stored
in *var2*. Note that the integers returned are signed, but they can
be converted to unsigned 32-bit quantities using an expression like:

    set num [expr { $num &amp; 0xFFFFFFFF }]
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-24-1"><a id="__codelineno-24-1" name="__codelineno-24-1" href="#__codelineno-24-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
I.  This form is the same as <strong>I</strong> except that the data is interpreted
    as <em>count</em> 32-bit signed integers represented in big-endian byte
    order. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    set str \x00\x00\x00\x05\x00\x00\x00\x07\xff\xff\xff\xf0
    binary scan $str I2I* var1 var2

will return **2** with **5 7** stored in *var1* and **-16** stored
in *var2*.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-25-1"><a id="__codelineno-25-1" name="__codelineno-25-1" href="#__codelineno-25-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
n.  The data is interpreted as <em>count</em> 32-bit signed integers
    represented in the native byte order of the machine running the Tcl
    script. It is otherwise identical to <strong>i</strong> and <strong>I</strong>. To determine
    what the native byte order of the machine is, refer to the
    <strong>byteOrder</strong> element of the <strong>tcl_platform</strong> array.</p>
<p>o.  The data is interpreted as <em>count</em> 64-bit signed integers
    represented in little-endian byte order. The integers are stored in
    the corresponding variable as a list. If <em>count</em> is <strong>*</strong>, then all
    of the remaining bytes in <em>string</em> will be scanned. If <em>count</em> is
    omitted, then one 64-bit integer will be scanned. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    set str \x05\x00\x00\x00\x07\x00\x00\x00\xf0\xff\xff\xff
    binary scan $str wi* var1 var2

will return **2** with **30064771077** stored in *var1* and **-16**
stored in *var2*. Note that the integers returned are signed and
cannot be represented by Tcl as unsigned values.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-26-1"><a id="__codelineno-26-1" name="__codelineno-26-1" href="#__codelineno-26-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
W.  This form is the same as <strong>w</strong> except that the data is interpreted
    as <em>count</em> 64-bit signed integers represented in big-endian byte
    order. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    set str \x00\x00\x00\x05\x00\x00\x00\x07\xff\xff\xff\xf0
    binary scan $str WI* var1 var2

will return **2** with **21474836487** stored in *var1* and **-16**
stored in *var2*.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-27-1"><a id="__codelineno-27-1" name="__codelineno-27-1" href="#__codelineno-27-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
m.  The data is interpreted as <em>count</em> 64-bit signed integers
    represented in the native byte order of the machine running the Tcl
    script. It is otherwise identical to <strong>w</strong> and <strong>W</strong>. To determine
    what the native byte order of the machine is, refer to the
    <strong>byteOrder</strong> element of the <strong>tcl_platform</strong> array.</p>
<p>n.  The data is interpreted as <em>count</em> single-precision floating point
    numbers in the machine\'s native representation. The floating point
    numbers are stored in the corresponding variable as a list. If
    <em>count</em> is <strong>*</strong>, then all of the remaining bytes in <em>string</em> will
    be scanned. If <em>count</em> is omitted, then one single-precision
    floating point number will be scanned. The size of a floating point
    number may vary across architectures, so the number of bytes that
    are scanned may vary. If the data does not represent a valid
    floating point number, the resulting value is undefined and compiler
    dependent. For example, on a Windows system running on an Intel
    Pentium processor,</p>
<div class="language-text highlight"><pre><span></span><code>    binary scan \x3f\xcc\xcc\xcd f var1

will return **1** with **1.6000000238418579** stored in *var1*.
</code></pre></div>
<p>o.  This form is the same as <strong>f</strong> except that the data is interpreted
    as <em>count</em> single-precision floating point number in little-endian
    order. This conversion is not portable to the minority of systems
    not using IEEE floating point representations.</p>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-28-1"><a id="__codelineno-28-1" name="__codelineno-28-1" href="#__codelineno-28-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
R.  This form is the same as <strong>f</strong> except that the data is interpreted
    as <em>count</em> single-precision floating point number in big-endian
    order. This conversion is not portable to the minority of systems
    not using IEEE floating point representations.</p>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-29-1"><a id="__codelineno-29-1" name="__codelineno-29-1" href="#__codelineno-29-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
d.  This form is the same as <strong>f</strong> except that the data is interpreted
    as <em>count</em> double-precision floating point numbers in the machine\'s
    native representation. For example, on a Windows system running on
    an Intel Pentium processor,</p>
<div class="language-text highlight"><pre><span></span><code>    binary scan \x9a\x99\x99\x99\x99\x99\xf9\x3f d var1

will return **1** with **1.6000000000000001** stored in *var1*.
</code></pre></div>
<p>e.  This form is the same as <strong>d</strong> except that the data is interpreted
    as <em>count</em> double-precision floating point number in little-endian
    order. This conversion is not portable to the minority of systems
    not using IEEE floating point representations.</p>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-30-1"><a id="__codelineno-30-1" name="__codelineno-30-1" href="#__codelineno-30-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
Q.  This form is the same as <strong>d</strong> except that the data is interpreted
    as <em>count</em> double-precision floating point number in big-endian
    order. This conversion is not portable to the minority of systems
    not using IEEE floating point representations.</p>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-31-1"><a id="__codelineno-31-1" name="__codelineno-31-1" href="#__codelineno-31-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
x.  Moves the cursor forward <em>count</em> bytes in <em>string</em>. If <em>count</em> is
    <strong>*</strong> or is larger than the number of bytes after the current
    cursor position, then the cursor is positioned after the last byte
    in <em>string</em>. If <em>count</em> is omitted, then the cursor is moved forward
    one byte. Note that this type does not consume an argument. For
    example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary scan \x01\x02\x03\x04 x2H* var1

will return **1** with **0304** stored in *var1*.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-32-1"><a id="__codelineno-32-1" name="__codelineno-32-1" href="#__codelineno-32-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
X.  Moves the cursor back <em>count</em> bytes in <em>string</em>. If <em>count</em> is
    <strong>*</strong> or is larger than the current cursor position, then the
    cursor is positioned at location 0 so that the next byte scanned
    will be the first byte in <em>string</em>. If <em>count</em> is omitted then the
    cursor is moved back one byte. Note that this type does not consume
    an argument. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary scan \x01\x02\x03\x04 c2XH* var1 var2

will return **2** with **1 2** stored in *var1* and **020304**
stored in *var2*.
</code></pre></div>
<p><div class="language-text highlight"><pre><span></span><code><span id="__span-33-1"><a id="__codelineno-33-1" name="__codelineno-33-1" href="#__codelineno-33-1"></a>&lt;!-- --&gt;
</span></code></pre></div>
1.  Moves the cursor to the absolute location in the data string
    specified by <em>count</em>. Note that position 0 refers to the first byte
    in <em>string</em>. If <em>count</em> refers to a position beyond the end of
    <em>string</em>, then the cursor is positioned after the last byte. If
    <em>count</em> is omitted, then an error will be generated. For example,</p>
<div class="language-text highlight"><pre><span></span><code>    binary scan \x01\x02\x03\x04 c2@1H* var1 var2

will return **2** with **1 2** stored in *var1* and **020304**
stored in *var2*.
</code></pre></div>
<h1 id="portability-issues">PORTABILITY ISSUES</h1>
<p>The <strong>r</strong>, <strong>R</strong>, <strong>q</strong> and <strong>Q</strong> conversions will only work reliably
for transferring data between computers which are all using IEEE
floating point representations. This is very common, but not universal.
To transfer floating-point numbers portably between all architectures,
use their textual representation (as produced by <strong>format</strong>) instead.</p>
<h1 id="examples">EXAMPLES</h1>
<p>This is a procedure to write a Tcl string to a binary-encoded channel as
UTF-8 data preceded by a length word:</p>
<div class="language-text highlight"><pre><span></span><code>proc writeString {channel string} {
    set data [encoding convertto utf-8 $string]
    puts -nonewline [binary format Ia* \
            [string length $data] $data]
}
</code></pre></div>
<p>This procedure reads a string from a channel that was written by the
previously presented <em>writeString</em> procedure:</p>
<div class="language-text highlight"><pre><span></span><code>proc readString {channel} {
    if {![binary scan [read $channel 4] I length]} {
        error &quot;missing length&quot;
    }
    set data [read $channel $length]
    return [encoding convertfrom utf-8 $data]
}
</code></pre></div>
<p>This converts the contents of a file (named in the variable <em>filename</em>)
to base64 and prints them:</p>
<div class="language-text highlight"><pre><span></span><code>set f [open $filename rb]
set data [read $f]
close $f
puts [binary encode base64 -maxlen 64 $data]
</code></pre></div>
<h1 id="see-also">SEE ALSO</h1>
<p>encoding(n), format(n), scan(n), string(n), tcl_platform(n)</p>
<h1 id="keywords">KEYWORDS</h1>
<p>binary, format, scan</p>

<ul class="metadata page-metadata" data-bi-name="page info" lang="en-us" dir="ltr">
  <li class="last-updated-holder displayDate loading">
    <span class="last-updated-text">Last updated:</span>
    <time role="presentation" datetime="2018-10-25T00:00:00.000Z" data-article-date-source="ms.date"></time>
  </li>
<!--
  <li class="readingTime">
    2 minutes to read
  </li>
-->
  <li class="contributors-holder">
    <span class="contributors-text">Contributors</span>
    <ul class="contributors" data-bi-name="contributors"></ul>
  </li>
</ul>
</div>
        <div class="col-md-3"><div class="navbar-light navbar-expand-md hidden-print sticky-top sticky-offset" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    <div id="toc-collapse" class="navbar-collapse collapse card">
        <ul class="nav flex-column bs-sidenav">
            <li class="nav-item main"><a class="nav-link" href="#name">NAME</a></li>
            <li class="nav-item main"><a class="nav-link" href="#synopsis">SYNOPSIS</a></li>
            <li class="nav-item main"><a class="nav-link" href="#description">DESCRIPTION</a></li>
            <li class="nav-item main"><a class="nav-link" href="#binary-encode-and-decode">BINARY ENCODE AND DECODE</a></li>
            <li class="nav-item main"><a class="nav-link" href="#binary-format">BINARY FORMAT</a></li>
            <li class="nav-item main"><a class="nav-link" href="#binary-scan">BINARY SCAN</a></li>
            <li class="nav-item main"><a class="nav-link" href="#portability-issues">PORTABILITY ISSUES</a></li>
            <li class="nav-item main"><a class="nav-link" href="#examples">EXAMPLES</a></li>
            <li class="nav-item main"><a class="nav-link" href="#see-also">SEE ALSO</a></li>
            <li class="nav-item main"><a class="nav-link" href="#keywords">KEYWORDS</a></li>
        </ul>
    </div>
</div></div>
      </div>
      </div>

      <footer class="col-md-12">
	<hr>
	<div class="container">
	</div>
      </footer>
      <script>
	var base_url = "../..",
            shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
      </script>
      <script src="../../js/base.js" defer></script>
      <script src="../../search/main.js" defer></script>

      <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <p class="h4 modal-title">Keyboard Shortcuts</p>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
