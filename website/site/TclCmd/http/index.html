<!DOCTYPE html>
<html lang="en">
    <head>
      <script>
	// Hack for scrolling window when linking to anchor tag with fixed nav header
        var shiftWindow = function() { scrollBy(0, -75) };
        window.addEventListener("hashchange", shiftWindow);
        function load() { if (window.location.hash) shiftWindow(); }
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://www.tcl.tk/man/TclCmd/http/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Http - Tcl/Tk</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="../../css/font-awesome.min.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
    <script src="../../js/base.js"></script> 
    </head>

    <body class="">

      <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
	<div class="container">
	<a class="navbar-brand" href="../..">Tcl/Tk</a>
	<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExample04" aria-controls="navbarsExample04" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
	</button>

	<div class="collapse navbar-collapse">

          <ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex">
            <li class="nav-item">
              <a class="nav-link" href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
		<i class="fa fa-search"></i> Search
              </a>
            </li>
          </ul>
	</div>
	</div>
      </nav><div id="content" class="container">
        
      <div class="row">
        <div class="col-md-9" role="main">


<nav aria-label="breadcrumb">
  <ol class="breadcrumb">
    
    <li class="breadcrumb-item active" aria-current="page">Http</li>
  </ol>
</nav>


<p>\</p>
<h1 id="name">NAME</h1>
<p>http - Client-side implementation of the HTTP/1.1 protocol</p>
<h1 id="synopsis">SYNOPSIS</h1>
<p><strong>package require http ?2.9?</strong></p>
<p><strong>::http::config ?</strong><em>-option value</em> ...?</p>
<p><strong>::http::geturl </strong><em>url</em> ?<em>-option value</em> ...?</p>
<p><strong>::http::formatQuery</strong> <em>key value</em> ?<em>key value</em> ...?</p>
<p><strong>::http::quoteString</strong> <em>value</em></p>
<p><strong>::http::reset</strong> <em>token</em> ?<em>why</em>?</p>
<p><strong>::http::wait </strong><em>token</em></p>
<p><strong>::http::status </strong><em>token</em></p>
<p><strong>::http::size </strong><em>token</em></p>
<p><strong>::http::code </strong><em>token</em></p>
<p><strong>::http::ncode </strong><em>token</em></p>
<p><strong>::http::meta </strong><em>token</em></p>
<p><strong>::http::data </strong><em>token</em></p>
<p><strong>::http::error </strong><em>token</em></p>
<p><strong>::http::cleanup </strong><em>token</em></p>
<p><strong>::http::register </strong><em>proto port command</em></p>
<p><strong>::http::registerError </strong><em>port</em> ?<em>message</em>?</p>
<p><strong>::http::unregister </strong><em>proto</em></p>
<h1 id="exported-commands">EXPORTED COMMANDS</h1>
<p>Namespace <strong>http</strong> exports the commands <strong>config</strong>, <strong>formatQuery</strong>,
<strong>geturl</strong>, <strong>quoteString</strong>, <strong>register</strong>, <strong>registerError</strong>, <strong>reset</strong>,
<strong>unregister</strong>, and <strong>wait</strong>.</p>
<p>It does not export the commands <strong>cleanup</strong>, <strong>code</strong>, <strong>data</strong>,
<strong>error</strong>, <strong>meta</strong>, <strong>ncode</strong>, <strong>size</strong>, or <strong>status</strong>.</p>
<p>\</p>
<h1 id="description">DESCRIPTION</h1>
<p>The <strong>http</strong> package provides the client side of the HTTP/1.1 protocol,
as defined in RFC 7230 to RFC 7235, which supersede RFC 2616. The
package implements the GET, POST, and HEAD operations of HTTP/1.1. It
allows configuration of a proxy host to get through firewalls. The
package is compatible with the <strong>Safesock</strong> security policy, so it can
be used by untrusted applets to do URL fetching from a restricted set of
hosts. This package can be extended to support additional HTTP transport
protocols, such as HTTPS, by providing a custom <strong>socket</strong> command, via
<strong>::http::register</strong>.</p>
<p>The <strong>::http::geturl</strong> procedure does a HTTP transaction. Its <em>options *
determine whether a GET, POST, or HEAD transaction is performed. The
return value of </em><em>::http::geturl</em><em> is a token for the transaction. The
value is also the name of an array in the ::http namespace that contains
state information about the transaction. The elements of this array are
described in the </em><em>STATE ARRAY</em>* section.</p>
<p>If the <strong>-command</strong> option is specified, then the HTTP operation is done
in the background. <strong>::http::geturl</strong> returns immediately after
generating the HTTP request and the callback is invoked when the
transaction completes. For this to work, the Tcl event loop must be
active. In Tk applications this is always true. For pure-Tcl
applications, the caller can use <strong>::http::wait</strong> after calling
<strong>::http::geturl</strong> to start the event loop.</p>
<p><strong>Note:</strong> The event queue is even used without the <strong>-command</strong> option.
As a side effect, arbitrary commands may be processed while
<strong>http::geturl</strong> is running.</p>
<h1 id="commands">COMMANDS</h1>
<p><strong>::http::config</strong> ?<em>options</em>?</p>
<p>:   The <strong>::http::config</strong> command is used to set and query the name of
    the proxy server and port, and the User-Agent name used in the HTTP
    requests. If no options are specified, then the current
    configuration is returned. If a single argument is specified, then
    it should be one of the flags described below. In this case the
    current value of that setting is returned. Otherwise, the options
    should be a set of flags and values that define the configuration:</p>
<div class="language-text highlight"><pre><span></span><code>**-accept** *mimetypes*

:   The Accept header of the request. The default is \*/\*, which
    means that all types of documents are accepted. Otherwise you
    can supply a comma-separated list of mime type patterns that you
    are willing to receive. For example,

**-pipeline** *boolean*

:   Specifies whether HTTP/1.1 transactions on a persistent socket
    will be pipelined. See the **PERSISTENT SOCKETS** section for
    details. The default is 1.

**-postfresh** *boolean*

:   Specifies whether requests that use the **POST** method will
    always use a fresh socket, overriding the **-keepalive** option
    of command **http::geturl**. See the **PERSISTENT SOCKETS**
    section for details. The default is 0.

**-proxyhost** *hostname*

:   The name of the proxy host, if any. If this value is the empty
    string, the URL host is contacted directly.

**-proxyport** *number*

:   The proxy port number.

**-proxyfilter** *command*

:   The command is a callback that is made during **::http::geturl**
    to determine if a proxy is required for a given host. One
    argument, a host name, is added to *command* when it is invoked.
    If a proxy is required, the callback should return a two-element
    list containing the proxy server and proxy port. Otherwise the
    filter should return an empty list. The default filter returns
    the values of the **-proxyhost** and **-proxyport** settings if
    they are non-empty.

    The **::http::geturl** command runs the **-proxyfilter**
    callback inside a **catch** command. Therefore an error in the
    callback command does not call the **bgerror** handler. See the
    **ERRORS** section for details.

**-repost** *boolean*

:   Specifies what to do if a POST request over a persistent
    connection fails because the server has half-closed the
    connection. If boolean **true**, the request will be
    automatically retried; if boolean **false** it will not, and the
    application that uses **http::geturl** is expected to seek user
    confirmation before retrying the POST. The value **true** should
    be used only under certain conditions. See the **PERSISTENT
    SOCKETS** section for details. The default is 0.

**-urlencoding** *encoding*

:   The *encoding* used for creating the x-url-encoded URLs with
    **::http::formatQuery** and **::http::quoteString**. The default
    is **utf-8**, as specified by RFC 2718. Prior to http 2.5 this
    was unspecified, and that behavior can be returned by specifying
    the empty string (**{}**), although *iso8859-1* is recommended
    to restore similar behavior but without the
    **::http::formatQuery** or **::http::quoteString** throwing an
    error processing non-latin-1 characters.

**-useragent** *string*

:   The value of the User-Agent header in the HTTP request. In an
    unsafe interpreter, the default value depends upon the operating
    system, and the version numbers of **http** and **Tcl**, and is
    (for example) A safe interpreter cannot determine its operating
    system, and so the default in a safe interpreter is to use a
    Windows 10 value with the current version numbers of **http**
    and **Tcl**.

**-zip** *boolean*

:   If the value is boolean **true**, then by default requests will
    send a header If the value is boolean **false**, then by default
    this header will not be sent. In either case the default can be
    overridden for an individual request by supplying a custom
    **Accept-Encoding** header in the **-headers** option of
    **http::geturl**. The default is 1.
</code></pre></div>
<p><strong>::http::geturl</strong> <em>url</em> ?<em>options</em>?</p>
<p>:   The <strong>::http::geturl</strong> command is the main procedure in the package.
    The <strong>-query</strong> option causes a POST operation and the <strong>-validate</strong>
    option causes a HEAD operation; otherwise, a GET operation is
    performed. The <strong>::http::geturl</strong> command returns a <em>token</em> value
    that can be used to get information about the transaction. See the
    <strong>STATE ARRAY</strong> and <strong>ERRORS</strong> section for details. The
    <strong>::http::geturl</strong> command blocks until the operation completes,
    unless the <strong>-command</strong> option specifies a callback that is invoked
    when the HTTP transaction completes. <strong>::http::geturl</strong> takes
    several options:</p>
<div class="language-text highlight"><pre><span></span><code>**-binary** *boolean*

:   Specifies whether to force interpreting the URL data as binary.
    Normally this is auto-detected (anything not beginning with a
    **text** content type or whose content encoding is **gzip** or
    **compress** is considered binary data).

**-blocksize** *size*

:   The block size used when reading the URL. At most *size* bytes
    are read at once. After each block, a call to the **-progress**
    callback is made (if that option is specified).

**-channel** *name*

:   Copy the URL contents to channel *name* instead of saving it in
    **state(body)**.

**-command** *callback*

:   Invoke *callback* after the HTTP transaction completes. This
    option causes **::http::geturl** to return immediately. The
    *callback* gets an additional argument that is the *token*
    returned from **::http::geturl**. This token is the name of an
    array that is described in the **STATE ARRAY** section. Here is
    a template for the callback:

        proc httpCallback {token} {
            upvar #0 $token state
            # Access state as a Tcl array
        }

    The **::http::geturl** command runs the **-command** callback
    inside a **catch** command. Therefore an error in the callback
    command does not call the **bgerror** handler. See the
    **ERRORS** section for details.

**-handler** *callback*

:   Invoke *callback* whenever HTTP data is available; if present,
    nothing else will be done with the HTTP data. This procedure
    gets two additional arguments: the socket for the HTTP data and
    the *token* returned from **::http::geturl**. The token is the
    name of a global array that is described in the **STATE ARRAY**
    section. The procedure is expected to return the number of bytes
    read from the socket. Here is a template for the callback:

        proc httpHandlerCallback {socket token} {
            upvar #0 $token state
            # Access socket, and state as a Tcl array
            # For example...
            ...
            set data [read $socket 1000]
            set nbytes [string length $data]
            ...
            return $nbytes
        }

    The **http::geturl** code for the **-handler** option is not
    compatible with either compression or chunked transfer-encoding.
    If **-handler** is specified, then to work around these issues
    **http::geturl** will reduce the HTTP protocol to 1.0, and
    override the **-zip** option (i.e. it will not send the header
    \&quot;**Accept-Encoding: gzip,deflate,compress**\&quot;).

    If options **-handler** and **-channel** are used together, the
    handler is responsible for copying the data from the HTTP socket
    to the specified channel. The name of the channel is available
    to the handler as element **-channel** of the token array.

    The **::http::geturl** command runs the **-handler** callback
    inside a **catch** command. Therefore an error in the callback
    command does not call the **bgerror** handler. See the
    **ERRORS** section for details.

**-headers** *keyvaluelist*

:   This option is used to add headers not already specified by
    **::http::config** to the HTTP request. The *keyvaluelist*
    argument must be a list with an even number of elements that
    alternate between keys and values. The keys become header field
    names. Newlines are stripped from the values so the header
    cannot be corrupted. For example, if *keyvaluelist* is **Pragma
    no-cache** then the following header is included in the HTTP
    request:

        Pragma: no-cache

**-keepalive** *boolean*

:   If boolean **true**, attempt to keep the connection open for
    servicing multiple requests. Default is 0.

**-method** *type*

:   Force the HTTP request method to *type*. **::http::geturl** will
    auto-select GET, POST or HEAD based on other options, but this
    option overrides that selection and enables choices like PUT and
    DELETE for WebDAV support.

    It is the caller\&#39;s responsibility to ensure that the headers
    and request body (if any) conform to the requirements of the
    request method. For example, if using **-method** *POST* to send
    a POST with an empty request body, the caller must also supply
    the option

**-myaddr** *address*

:   Pass an specific local address to the underlying **socket** call
    in case multiple interfaces are available.

**-progress** *callback*

:   The *callback* is made after each transfer of data from the URL.
    The callback gets three additional arguments: the *token* from
    **::http::geturl**, the expected total size of the contents from
    the **Content-Length** meta-data, and the current number of
    bytes transferred so far. The expected total size may be
    unknown, in which case zero is passed to the callback. Here is a
    template for the progress callback:

        proc httpProgress {token total current} {
            upvar #0 $token state
        }

**-protocol** *version*

:   Select the HTTP protocol version to use. This should be 1.0 or
    1.1 (the default). Should only be necessary for servers that do
    not understand or otherwise complain about HTTP/1.1.

**-query** *query*

:   This flag (if the value is non-empty) causes **::http::geturl**
    to do a POST request that passes the string *query* verbatim to
    the server as the request payload. The content format (and
    encoding) of *query* is announced by the request header
    **Content-Type** which is set by the option **-type**. Any value
    of **-type** is permitted, and it is the responsibility of the
    caller to supply *query* in the correct format.

    If **-type** is not specified, it defaults to
    *application/x-www-form-urlencoded*, which requires *query* to
    be an x-url-encoding formatted query-string (this **-type** and
    query format are used in a POST submitted from an html form).
    The **::http::formatQuery** procedure can be used to do the
    formatting.

**-queryblocksize** *size*

:   The block size used when posting query data to the URL. At most
    *size* bytes are written at once. After each block, a call to
    the **-queryprogress** callback is made (if that option is
    specified).

**-querychannel** *channelID*

:   This flag causes **::http::geturl** to do a POST request that
    passes the data contained in *channelID* to the server. The data
    contained in *channelID* must be an x-url-encoding formatted
    query unless the **-type** option below is used. If a
    Content-Length header is not specified via the **-headers**
    options, **::http::geturl** attempts to determine the size of
    the post data in order to create that header. If it is unable to
    determine the size, it returns an error.

**-queryprogress** *callback*

:   The *callback* is made after each transfer of data to the URL
    (i.e. POST) and acts exactly like the **-progress** option (the
    callback format is the same).

**-strict** *boolean*

:   Whether to enforce RFC 3986 URL validation on the request.
    Default is 1.

**-timeout** *milliseconds*

:   If *milliseconds* is non-zero, then **::http::geturl** sets up a
    timeout to occur after the specified number of milliseconds. A
    timeout results in a call to **::http::reset** and to the
    **-command** callback, if specified. The return value of
    **::http::status** is **timeout** after a timeout has occurred.

**-type** *mime-type*

:   Use *mime-type* as the **Content-Type** value, instead of the
    default value (**application/x-www-form-urlencoded**) during a
    POST operation.

**-validate** *boolean*

:   If *boolean* is non-zero, then **::http::geturl** does an HTTP
    HEAD request. This request returns meta information about the
    URL, but the contents are not returned. The meta information is
    available in the **state(meta) ** variable after the
    transaction. See the **STATE ARRAY** section for details.
</code></pre></div>
<p><strong>::http::formatQuery</strong> <em>key value</em> ?<em>key value</em> ...?</p>
<p>:   This procedure does x-url-encoding of query data. It takes an even
    number of arguments that are the keys and values of the query. It
    encodes the keys and values, and generates one string that has the
    proper &amp; and = separators. The result is suitable for the <strong>-query</strong>
    value passed to <strong>::http::geturl</strong>.</p>
<p><strong>::http::quoteString</strong> <em>value</em></p>
<p>:   This procedure does x-url-encoding of string. It takes a single
    argument and encodes it.</p>
<p><strong>::http::reset</strong> <em>token</em> ?<em>why</em>?</p>
<p>:   This command resets the HTTP transaction identified by <em>token</em>, if
    any. This sets the <strong>state(status)</strong> value to <em>why</em>, which defaults
    to <strong>reset</strong>, and then calls the registered <strong>-command</strong> callback.</p>
<p><strong>::http::wait</strong> <em>token</em></p>
<p>:   This is a convenience procedure that blocks and waits for the
    transaction to complete. This only works in trusted code because it
    uses <strong>vwait</strong>. Also, it is not useful for the case where
    <strong>::http::geturl</strong> is called <em>without</em> the <strong>-command</strong> option
    because in this case the <strong>::http::geturl</strong> call does not return
    until the HTTP transaction is complete, and thus there is nothing to
    wait for.</p>
<p><strong>::http::data</strong> <em>token</em></p>
<p>:   This is a convenience procedure that returns the <strong>body</strong> element
    (i.e., the URL data) of the state array.</p>
<p><strong>::http::error</strong> <em>token</em></p>
<p>:   This is a convenience procedure that returns the <strong>error</strong> element
    of the state array.</p>
<p><strong>::http::status</strong> <em>token</em></p>
<p>:   This is a convenience procedure that returns the <strong>status</strong> element
    of the state array.</p>
<p><strong>::http::code</strong> <em>token</em></p>
<p>:   This is a convenience procedure that returns the <strong>http</strong> element of
    the state array.</p>
<p><strong>::http::ncode</strong> <em>token</em></p>
<p>:   This is a convenience procedure that returns just the numeric return
    code (200, 404, etc.) from the <strong>http</strong> element of the state array.</p>
<p><strong>::http::size</strong> <em>token</em></p>
<p>:   This is a convenience procedure that returns the <strong>currentsize</strong>
    element of the state array, which represents the number of bytes
    received from the URL in the <strong>::http::geturl</strong> call.</p>
<p><strong>::http::meta</strong> <em>token</em></p>
<p>:   This is a convenience procedure that returns the <strong>meta</strong> element of
    the state array which contains the HTTP response headers. See below
    for an explanation of this element.</p>
<p><strong>::http::cleanup</strong> <em>token</em></p>
<p>:   This procedure cleans up the state associated with the connection
    identified by <em>token</em>. After this call, the procedures like
    <strong>::http::data</strong> cannot be used to get information about the
    operation. It is <em>strongly</em> recommended that you call this function
    after you are done with a given HTTP request. Not doing so will
    result in memory not being freed, and if your app calls
    <strong>::http::geturl</strong> enough times, the memory leak could cause a
    performance hit...or worse.</p>
<p><strong>::http::register</strong> <em>proto port command</em></p>
<p>:   This procedure allows one to provide custom HTTP transport types
    such as HTTPS, by registering a prefix, the default port, and the
    command to execute to create the Tcl <strong>channel</strong>. E.g.:</p>
<div class="language-text highlight"><pre><span></span><code>    package require http
    package require tls

    ::http::register https 443 ::tls::socket

    set token [::http::geturl https://my.secure.site/]
</code></pre></div>
<p><strong>::http::registerError</strong> <em>port</em> ?<em>message</em>?</p>
<p>:   This procedure allows a registered protocol handler to deliver an
    error message for use by <strong>http</strong>. Calling this command does not
    raise an error. The command is useful when a registered protocol
    detects an problem (for example, an invalid TLS certificate) that
    will cause an error to propagate to <strong>http</strong>. The command allows
    <strong>http</strong> to provide a precise error message rather than a general
    one. The command returns the value provided by the last call with
    argument <em>message</em>, or the empty string if no such call has been
    made.</p>
<p><strong>::http::unregister</strong> <em>proto</em></p>
<p>:   This procedure unregisters a protocol handler that was previously
    registered via <strong>::http::register</strong>, returning a two-item list of
    the default port and handler command that was previously installed
    (via <strong>::http::register</strong>) if there was such a handler, and an error
    if there was no such handler.</p>
<h1 id="errors">ERRORS</h1>
<p>The <strong>::http::geturl</strong> procedure will raise errors in the following
cases: invalid command line options, an invalid URL, a URL on a
non-existent host, or a URL at a bad port on an existing host. These
errors mean that it cannot even start the network transaction. It will
also raise an error if it gets an I/O error while writing out the HTTP
request header. For synchronous <strong>::http::geturl</strong> calls (where
<strong>-command</strong> is not specified), it will raise an error if it gets an I/O
error while reading the HTTP reply headers or data. Because
<strong>::http::geturl</strong> does not return a token in these cases, it does all
the required cleanup and there is no issue of your app having to call
<strong>::http::cleanup</strong>.</p>
<p>For asynchronous <strong>::http::geturl</strong> calls, all of the above error
situations apply, except that if there is any error while reading the
HTTP reply headers or data, no exception is thrown. This is because
after writing the HTTP headers, <strong>::http::geturl</strong> returns, and the rest
of the HTTP transaction occurs in the background. The command callback
can check if any error occurred during the read by calling
<strong>::http::status</strong> to check the status and if its <em>error</em>, calling
<strong>::http::error</strong> to get the error message.</p>
<p>Alternatively, if the main program flow reaches a point where it needs
to know the result of the asynchronous HTTP request, it can call
<strong>::http::wait</strong> and then check status and error, just as the callback
does.</p>
<p>The <strong>::http::geturl</strong> command runs the <strong>-command</strong>, <strong>-handler</strong>, and
<strong>-proxyfilter</strong> callbacks inside a <strong>catch</strong> command. Therefore an
error in the callback command does not call the <strong>bgerror</strong> handler.
When debugging one of these callbacks, it may be convenient to report
errors by using a <strong>catch</strong> command within the callback command itself,
e.g. to write an error message to stdout.</p>
<p>In any case, you must still call <strong>::http::cleanup</strong> to delete the state
array when you are done.</p>
<p>There are other possible results of the HTTP transaction determined by
examining the status from <strong>::http::status</strong>. These are described below.</p>
<p><strong>ok</strong></p>
<p>:   If the HTTP transaction completes entirely, then status will be
    <strong>ok</strong>. However, you should still check the <strong>::http::code</strong> value
    to get the HTTP status. The <strong>::http::ncode</strong> procedure provides
    just the numeric error (e.g., 200, 404 or 500) while the
    <strong>::http::code</strong> procedure returns a value like</p>
<p><strong>eof</strong></p>
<p>:   If the server closes the socket without replying, then no error is
    raised, but the status of the transaction will be <strong>eof</strong>.</p>
<p><strong>error</strong></p>
<p>:   The error message will also be stored in the <strong>error</strong> status array
    element, accessible via <strong>::http::error</strong>.</p>
<p><strong>timeout</strong></p>
<p>:   A timeout occurred before the transaction could complete</p>
<p><strong>reset</strong></p>
<p>:   user-reset</p>
<p>Another error possibility is that <strong>::http::geturl</strong> is unable to write
all the post query data to the server before the server responds and
closes the socket. The error message is saved in the <strong>posterror</strong>
status array element and then <strong>::http::geturl</strong> attempts to complete
the transaction. If it can read the server\'s response it will end up
with an <strong>ok</strong> status, otherwise it will have an <strong>eof</strong> status.</p>
<h1 id="state-array">STATE ARRAY</h1>
<p>The <strong>::http::geturl</strong> procedure returns a <em>token</em> that can be used to
get to the state of the HTTP transaction in the form of a Tcl array. Use
this construct to create an easy-to-use array variable:</p>
<div class="language-text highlight"><pre><span></span><code>upvar #0 $token state
</code></pre></div>
<p>Once the data associated with the URL is no longer needed, the state
array should be unset to free up storage. The <strong>::http::cleanup</strong>
procedure is provided for that purpose. The following elements of the
array are supported:</p>
<blockquote>
<p><strong>binary</strong></p>
<p>:   This is boolean <strong>true</strong> if (after decoding any compression
    specified by the response header) the HTTP response is binary. It
    is boolean <strong>false</strong> if the HTTP response is text.</p>
<p><strong>body</strong></p>
<p>:   The contents of the URL. This will be empty if the <strong>-channel</strong>
    option has been specified. This value is returned by the
    <strong>::http::data</strong> command.</p>
<p><strong>charset</strong></p>
<p>:   The value of the charset attribute from the <strong>Content-Type</strong>
    meta-data value. If none was specified, this defaults to the RFC
    standard <strong>iso8859-1</strong>, or the value of
    <strong>\$::http::defaultCharset</strong>. Incoming text data will be
    automatically converted from this charset to utf-8.</p>
<p><strong>coding</strong></p>
<p>:   A copy of the <strong>Content-Encoding</strong> meta-data value.</p>
<p><strong>currentsize</strong></p>
<p>:   The current number of bytes fetched from the URL. This value is
    returned by the <strong>::http::size</strong> command.</p>
<p><strong>error</strong></p>
<p>:   If defined, this is the error string seen when the HTTP
    transaction was aborted.</p>
<p><strong>http</strong></p>
<p>:   The HTTP status reply from the server. This value is returned by
    the <strong>::http::code</strong> command. The format of this value is:</p>
<div class="language-text highlight"><pre><span></span><code>    HTTP/1.1 code string

The *code* is a three-digit number defined in the HTTP standard. A
code of 200 is OK. Codes beginning with 4 or 5 indicate errors.
Codes beginning with 3 are redirection errors. In this case the
**Location** meta-data specifies a new URL that contains the
requested information.
</code></pre></div>
<p><strong>meta</strong></p>
<p>:   The HTTP protocol returns meta-data that describes the URL
    contents. The <strong>meta</strong> element of the state array is a list of the
    keys and values of the meta-data. This is in a format useful for
    initializing an array that just contains the meta-data:</p>
<div class="language-text highlight"><pre><span></span><code>    array set meta $state(meta)

Some of the meta-data keys are listed below, but the HTTP standard
defines more, and servers are free to add their own.

**Content-Type**

:   The type of the URL contents. Examples include **text/html**,
    **image/gif,** **application/postscript** and
    **application/x-tcl**.

**Content-Length**

:   The advertised size of the contents. The actual size obtained
    by **::http::geturl** is available as **state(currentsize)**.

**Location**

:   An alternate URL that contains the requested data.
</code></pre></div>
<p><strong>posterror</strong></p>
<p>:   The error, if any, that occurred while writing the post query data
    to the server.</p>
<p><strong>status</strong></p>
<p>:   See description in the chapter <strong>ERRORS</strong> above for a list and
    description of <strong>status</strong>. During the transaction this value is
    the empty string.</p>
<p><strong>totalsize</strong></p>
<p>:   A copy of the <strong>Content-Length</strong> meta-data value.</p>
<p><strong>type</strong></p>
<p>:   A copy of the <strong>Content-Type</strong> meta-data value.</p>
<p><strong>url</strong></p>
<p>:   The requested URL.</p>
</blockquote>
<h1 id="persistent-connections">PERSISTENT CONNECTIONS</h1>
<h2 id="basics">BASICS</h2>
<p>See RFC 7230 Sec 6, which supersedes RFC 2616 Sec 8.1.</p>
<p>A persistent connection allows multiple HTTP/1.1 transactions to be
carried over the same TCP connection. Pipelining allows a client to make
multiple requests over a persistent connection without waiting for each
response. The server sends responses in the same order that the requests
were received.</p>
<p>If a POST request fails to complete, typically user confirmation is
needed before sending the request again. The user may wish to verify
whether the server was modified by the failed POST request, before
sending the same request again.</p>
<p>A HTTP request will use a persistent socket if the call to
<strong>http::geturl</strong> has the option <strong>-keepalive true</strong>. It will use
pipelining where permitted if the <strong>http::config</strong> option <strong>-pipeline</strong>
is boolean <strong>true</strong> (its default value).</p>
<p>The http package maintains no more than one persistent connection to
each server (i.e. each value of If <strong>http::geturl</strong> is called to make a
request over a persistent connection while the connection is busy with
another request, the new request will be held in a queue until the
connection is free.</p>
<p>The http package does not support HTTP/1.0 persistent connections
controlled by the <strong>Keep-Alive</strong> header.</p>
<h2 id="special-cases">SPECIAL CASES</h2>
<p>This subsection discusses issues related to closure of the persistent
connection by the server, automatic retry of failed requests, the
special treatment necessary for POST requests, and the options for
dealing with these cases.</p>
<p>In accordance with RFC 7230, <strong>http::geturl</strong> does not pipeline requests
that use the POST method. If a POST uses a persistent connection and is
not the first request on that connection, <strong>http::geturl</strong> waits until
it has received the response for the previous request; or (if
<strong>http::config</strong> option <strong>-postfresh</strong> is boolean <strong>true</strong>) it uses a
new connection for each POST.</p>
<p>If the server is processing a number of pipelined requests, and sends a
response header with one of the responses (other than the last), then
subsequent responses are unfulfilled. <strong>http::geturl</strong> will send the
unfulfilled requests again over a new connection.</p>
<p>A difficulty arises when a HTTP client sends a request over a persistent
connection that has been idle for a while. The HTTP server may
half-close an apparently idle connection while the client is sending a
request, but before the request arrives at the server: in this case (an
the request will fail. The difficulty arises because the client cannot
be certain whether the POST modified the state of the server. For HEAD
or GET requests, <strong>http::geturl</strong> opens another connection and
retransmits the failed request. However, if the request was a POST, RFC
7230 forbids automatic retry by default, suggesting either user
confirmation, or confirmation by user-agent software that has semantic
understanding of the application. The <strong>http::config</strong> option
<strong>-repost</strong> allows for either possibility.</p>
<p>Asynchronous close events can occur only in a short interval of time.
The <strong>http</strong> package monitors each persistent connection for closure by
the server. Upon detection, the connection is also closed at the client
end, and subsequent requests will use a fresh connection.</p>
<p>If the <strong>http::geturl</strong> command is called with option <strong>-keepalive
true</strong>, then it will both try to use an existing persistent connection
(if one is available), and it will send the server a request header
asking to keep the connection open for future requests.</p>
<p>The <strong>http::config</strong> options <strong>-pipeline</strong>, <strong>-postfresh</strong>, and
<strong>-repost</strong> relate to persistent connections.</p>
<p>Option <strong>-pipeline</strong>, if boolean <strong>true</strong>, will pipeline GET and HEAD
requests made over a persistent connection. POST requests will not be
pipelined - if the POST is not the first transaction on the connection,
its request will not be sent until the previous response has finished.
GET and HEAD requests made after a POST will not be sent until the POST
response has been delivered, and will not be sent if the POST fails.</p>
<p>Option <strong>-postfresh</strong>, if boolean <strong>true</strong>, will override the
<strong>http::geturl</strong> option <strong>-keepalive</strong>, and always open a fresh
connection for a POST request.</p>
<p>Option <strong>-repost</strong>, if <strong>true</strong>, permits automatic retry of a POST
request that fails because it uses a persistent connection that the
server has half-closed (an Subsequent GET and HEAD requests in a failed
pipeline will also be retried. <em>The -repost option should be used only
if the application understands</em> that the retry is appropriate -
specifically, the application must know that if the failed POST
successfully modified the state of the server, a repeat POST would have
no adverse effect.</p>
<h1 id="protocol-upgrades">PROTOCOL UPGRADES</h1>
<p>The HTTP/1.1 <strong>Connection</strong> and <strong>Upgrade</strong> client headers inform the
server that the client wishes to change the protocol used over the
existing connection (RFC 7230). This mechanism can be used to request a
WebSocket (RFC 6455), a higher version of the HTTP protocol (HTTP 2), or
TLS encryption. If the server accepts the upgrade request, its response
code will be 101.</p>
<p>To request a protocol upgrade when calling <strong>http::geturl</strong>, the
<strong>-headers</strong> option must supply appropriate values for <strong>Connection</strong>
and <strong>Upgrade</strong>, and the <strong>-command</strong> option must supply a command that
implements the requested protocol and can also handle the server
response if the server refuses the protocol upgrade. For upgrade
requests <strong>http::geturl</strong> ignores the value of option <strong>-keepalive</strong>,
and always uses the value <strong>0</strong> so that the upgrade request is not made
over a connection that is intended for multiple HTTP requests.</p>
<p>The Tcllib library <strong>websocket</strong> implements WebSockets, and makes the
necessary calls to commands in the <strong>http</strong> package.</p>
<p>There is currently no native Tcl client library for HTTP/2.</p>
<p>The <strong>Upgrade</strong> mechanism is not used to request TLS in web browsers,
because <strong>http</strong> and <strong>https</strong> are served over different ports. It is
used by protocols such as Internet Printing Protocol (IPP) that are
built on top of <strong>http(s)</strong> and use the same TCP port number for both
secure and insecure traffic.</p>
<p>In browsers, opportunistic encryption is instead implemented by the
<strong>Upgrade-Insecure-Requests</strong> client header. If a secure service is
available, the server response code is a 307 redirect, and the response
header <strong>Location</strong> specifies the target URL. The browser must call
<strong>http::geturl</strong> again in order to fetch this URL. See
https://w3c.github.io/webappsec-upgrade-insecure-requests/</p>
<h1 id="example">EXAMPLE</h1>
<p>This example creates a procedure to copy a URL to a file while printing
a progress meter, and prints the meta-data associated with the URL.</p>
<div class="language-text highlight"><pre><span></span><code>proc httpcopy { url file {chunk 4096} } {
    set out [open $file w]
    set token [::http::geturl $url -channel $out \
            -progress httpCopyProgress -blocksize $chunk]
    close $out

    # This ends the line started by httpCopyProgress
    puts stderr &quot;&quot;

    upvar #0 $token state
    set max 0
    foreach {name value} $state(meta) {
        if {[string length $name] &gt; $max} {
            set max [string length $name]
        }
        if {[regexp -nocase ^location$ $name]} {
            # Handle URL redirects
            puts stderr &quot;Location:$value&quot;
            return [httpcopy [string trim $value] $file $chunk]
        }
    }
    incr max
    foreach {name value} $state(meta) {
        puts [format &quot;%-*s %s&quot; $max $name: $value]
    }

    return $token
}
proc httpCopyProgress {args} {
    puts -nonewline stderr .
    flush stderr
}
</code></pre></div>
<h1 id="see-also">SEE ALSO</h1>
<p>safe(n), socket(n), safesock(n)</p>
<h1 id="keywords">KEYWORDS</h1>
<p>internet, security policy, socket, www</p>

<ul class="metadata page-metadata" data-bi-name="page info" lang="en-us" dir="ltr">
  <li class="last-updated-holder displayDate loading">
    <span class="last-updated-text">Last updated:</span>
    <time role="presentation" datetime="2018-10-25T00:00:00.000Z" data-article-date-source="ms.date"></time>
  </li>
<!--
  <li class="readingTime">
    2 minutes to read
  </li>
-->
  <li class="contributors-holder">
    <span class="contributors-text">Contributors</span>
    <ul class="contributors" data-bi-name="contributors"></ul>
  </li>
</ul>
</div>
        <div class="col-md-3"><div class="navbar-light navbar-expand-md hidden-print sticky-top sticky-offset" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    <div id="toc-collapse" class="navbar-collapse collapse card">
        <ul class="nav flex-column bs-sidenav">
            <li class="nav-item main"><a class="nav-link" href="#name">NAME</a></li>
            <li class="nav-item main"><a class="nav-link" href="#synopsis">SYNOPSIS</a></li>
            <li class="nav-item main"><a class="nav-link" href="#exported-commands">EXPORTED COMMANDS</a></li>
            <li class="nav-item main"><a class="nav-link" href="#description">DESCRIPTION</a></li>
            <li class="nav-item main"><a class="nav-link" href="#commands">COMMANDS</a></li>
            <li class="nav-item main"><a class="nav-link" href="#errors">ERRORS</a></li>
            <li class="nav-item main"><a class="nav-link" href="#state-array">STATE ARRAY</a></li>
            <li class="nav-item main"><a class="nav-link" href="#persistent-connections">PERSISTENT CONNECTIONS</a></li>
                <li class="nav-item">
                    <a href="#basics" class="nav-link">BASICS</a>
                </li>
                <li class="nav-item">
                    <a href="#special-cases" class="nav-link">SPECIAL CASES</a>
                </li>
            <li class="nav-item main"><a class="nav-link" href="#protocol-upgrades">PROTOCOL UPGRADES</a></li>
            <li class="nav-item main"><a class="nav-link" href="#example">EXAMPLE</a></li>
            <li class="nav-item main"><a class="nav-link" href="#see-also">SEE ALSO</a></li>
            <li class="nav-item main"><a class="nav-link" href="#keywords">KEYWORDS</a></li>
        </ul>
    </div>
</div></div>
      </div>
      </div>

      <footer class="col-md-12">
	<hr>
	<div class="container">
	</div>
      </footer>
      <script>
	var base_url = "../..",
            shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
      </script>
      <script src="../../js/base.js" defer></script>
      <script src="../../search/main.js" defer></script>

      <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <p class="h4 modal-title">Keyboard Shortcuts</p>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
