<!DOCTYPE html>
<html lang="en">
    <head>
      <script>
	// Hack for scrolling window when linking to anchor tag with fixed nav header
        var shiftWindow = function() { scrollBy(0, -75) };
        window.addEventListener("hashchange", shiftWindow);
        function load() { if (window.location.hash) shiftWindow(); }
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://www.tcl.tk/man/TclCmd/refchan/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Refchan - Tcl/Tk</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="../../css/font-awesome.min.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
    <script src="../../js/base.js"></script> 
    </head>

    <body class="">

      <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
	<div class="container">
	<a class="navbar-brand" href="../..">Tcl/Tk</a>
	<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExample04" aria-controls="navbarsExample04" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
	</button>

	<div class="collapse navbar-collapse">

          <ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex">
            <li class="nav-item">
              <a class="nav-link" href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
		<i class="fa fa-search"></i> Search
              </a>
            </li>
          </ul>
	</div>
	</div>
      </nav><div id="content" class="container">
        
      <div class="row">
        <div class="col-md-9" role="main">


<nav aria-label="breadcrumb">
  <ol class="breadcrumb">
    
    <li class="breadcrumb-item active" aria-current="page">Refchan</li>
  </ol>
</nav>


<p>\</p>
<h1 id="name">NAME</h1>
<p>refchan - command handler API of reflected channels</p>
<h1 id="synopsis">SYNOPSIS</h1>
<p><strong>cmdPrefix </strong><em>option</em> ?<em>arg arg ...</em>?</p>
<p>\</p>
<h1 id="description">DESCRIPTION</h1>
<p>The Tcl-level handler for a reflected channel has to be a command with
subcommands (termed an <em>ensemble</em>, as it is a command such as that
created by <strong>namespace ensemble</strong> <strong>create</strong>, though the implementation
of handlers for reflected channel <em>is not</em> tied to <strong>namespace</strong>
ensembles in any way; see <strong>EXAMPLE</strong> below for how to build an
<strong>oo::class</strong> that supports the API). Note that <em>cmdPrefix</em> is whatever
was specified in the call to <strong>chan create</strong>, and may consist of
multiple arguments; this will be expanded to multiple words in place of
the prefix.</p>
<p>Of all the possible subcommands, the handler <em>must</em> support
<strong>initialize</strong>, <strong>finalize</strong>, and <strong>watch</strong>. Support for the other
subcommands is optional.</p>
<h2 id="mandatory-subcommands">MANDATORY SUBCOMMANDS</h2>
<p><em>cmdPrefix </em><strong>initialize </strong><em>channelId mode</em></p>
<p>:   An invocation of this subcommand will be the first call the
    <em>cmdPrefix</em> will receive for the specified new <em>channelId</em>. It is
    the responsibility of this subcommand to set up any internal data
    structures required to keep track of the channel and its state.</p>
<div class="language-text highlight"><pre><span></span><code>The return value of the method has to be a list containing the names
of all subcommands supported by the *cmdPrefix*. This also tells the
Tcl core which version of the API for reflected channels is used by
this command handler.

Any error thrown by the method will abort the creation of the
channel and no channel will be created. The thrown error will appear
as error thrown by **chan create**. Any exception other than an
**error** (e.g., **break**, etc.) is treated as (and converted to)
an error.

**Note:** If the creation of the channel was aborted due to failures
here, then the **finalize** subcommand will not be called.

The *mode* argument tells the handler whether the channel was opened
for reading, writing, or both. It is a list containing any of the
strings **read** or **write**. The list will always contain at least
one element.

The subcommand must throw an error if the chosen mode is not
supported by the *cmdPrefix*.
</code></pre></div>
<p><em>cmdPrefix </em><strong>finalize </strong><em>channelId</em></p>
<p>:   An invocation of this subcommand will be the last call the
    <em>cmdPrefix</em> will receive for the specified <em>channelId</em>. It will be
    generated just before the destruction of the data structures of the
    channel held by the Tcl core. The command handler <em>must not</em> access
    the <em>channelId</em> anymore in no way. Upon this subcommand being
    called, any internal resources allocated to this channel must be
    cleaned up.</p>
<div class="language-text highlight"><pre><span></span><code>The return value of this subcommand is ignored.

If the subcommand throws an error the command which caused its
invocation (usually **chan close**) will appear to have thrown this
error. Any exception beyond **error** (e.g., **break**, etc.) is
treated as (and converted to) an error.

This subcommand is not invoked if the creation of the channel was
aborted during **initialize** (See above).
</code></pre></div>
<p><em>cmdPrefix </em><strong>watch </strong><em>channelId eventspec</em></p>
<p>:   This subcommand notifies the <em>cmdPrefix</em> that the specified
    <em>channelId</em> is interested in the events listed in the <em>eventspec</em>.
    This argument is a list containing any of <strong>read</strong> and <strong>write</strong>.
    The list may be empty, which signals that the channel does not wish
    to be notified of any events. In that situation, the handler should
    disable event generation completely.</p>
<div class="language-text highlight"><pre><span></span><code>**Warning:** Any return value of the subcommand is ignored. This
includes all errors thrown by the subcommand, **break**,
**continue**, and custom return codes.

This subcommand interacts with **chan postevent**. Trying to post an
event which was not listed in the last call to **watch** will cause
**chan postevent** to throw an error.
</code></pre></div>
<h2 id="optional-subcommands">OPTIONAL SUBCOMMANDS</h2>
<p><em>cmdPrefix </em><strong>read </strong><em>channelId count</em></p>
<p>:   This <em>optional</em> subcommand is called when the user requests data
    from the channel <em>channelId</em>. <em>count</em> specifies how many <em>bytes</em>
    have been requested. If the subcommand is not supported then it is
    not possible to read from the channel handled by the command.</p>
<div class="language-text highlight"><pre><span></span><code>The return value of this subcommand is taken as the requested data
*bytes*. If the returned data contains more bytes than requested, an
error will be signaled and later thrown by the command which
performed the read (usually **gets** or **read**). However,
returning fewer bytes than requested is acceptable.

Note that returning nothing (0 bytes) is a signal to the higher
layers that **EOF** has been reached on the channel. To signal that
the channel is out of data right now, but has not yet reached
**EOF**, it is necessary to throw the error \&quot;EAGAIN\&quot;, i.e. to
either

    return -code error EAGAIN

or

    error EAGAIN

For extensibility any error whose value is a negative integer number
will cause the higher layers to set the C-level variable
\&quot;**errno**\&quot; to the absolute value of this number, signaling a
system error. However, note that the exact mapping between these
error numbers and their meanings is operating system dependent.

For example, while on Linux both

    return -code error -11

and

    error -11

are equivalent to the examples above, using the more readable string
\&quot;EAGAIN\&quot;, this is not true for BSD, where the equivalent number is
-35.

The symbolic string however is the same across systems, and
internally translated to the correct number. No other error value
has such a mapping to a symbolic string.

If the subcommand throws any other error, the command which caused
its invocation (usually **gets**, or **read**) will appear to have
thrown this error. Any exception beyond **error**, (e.g., **break**,
etc.) is treated as and converted to an error.
</code></pre></div>
<p><em>cmdPrefix </em><strong>write </strong><em>channelId data</em></p>
<p>:   This <em>optional</em> subcommand is called when the user writes data to
    the channel <em>channelId</em>. The <em>data</em> argument contains <em>bytes</em>, not
    characters. Any type of transformation (EOL, encoding) configured
    for the channel has already been applied at this point. If this
    subcommand is not supported then it is not possible to write to the
    channel handled by the command.</p>
<div class="language-text highlight"><pre><span></span><code>The return value of the subcommand is taken as the number of bytes
written by the channel. Anything non-numeric will cause an error to
be signaled and later thrown by the command which performed the
write. A negative value implies that the write failed. Returning a
value greater than the number of bytes given to the handler, or
zero, is forbidden and will cause the Tcl core to throw an error.

To signal that the channel is not able to accept data for writing
right now, it is necessary to throw the error \&quot;EAGAIN\&quot;, i.e. to
either

    return -code error EAGAIN

or

    error EAGAIN

For extensibility any error whose value is a negative integer number
will cause the higher layers to set the C-level variable
\&quot;**errno**\&quot; to the absolute value of this number, signaling a
system error. However, note that the exact mapping between these
error numbers and their meanings is operating system dependent.

For example, while on Linux both

    return -code error -11

and

    error -11

are equivalent to the examples above, using the more readable string
\&quot;EAGAIN\&quot;, this is not true for BSD, where the equivalent number is
-35.

The symbolic string however is the same across systems, and
internally translated to the correct number. No other error value
has such a mapping to a symbolic string.

If the subcommand throws any other error the command which caused
its invocation (usually **puts**) will appear to have thrown this
error. Any exception beyond **error** (e.g., **break**, etc.) is
treated as and converted to an error.
</code></pre></div>
<p><em>cmdPrefix </em><strong>seek </strong><em>channelId offset base</em></p>
<p>:   This <em>optional</em> subcommand is responsible for the handling of <strong>chan
    seek</strong> and <strong>chan tell</strong> requests on the channel <em>channelId</em>. If it
    is not supported then seeking will not be possible for the channel.</p>
<div class="language-text highlight"><pre><span></span><code>The *base* argument is the same as the equivalent argument of the
builtin **chan seek**, namely:

**start**

:   Seeking is relative to the beginning of the channel.

**current**

:   Seeking is relative to the current seek position.

**end**

:   Seeking is relative to the end of the channel.

The *offset* is an integer number specifying the amount of **bytes**
to seek forward or backward. A positive number should seek forward,
and a negative number should seek backward. A channel may provide
only limited seeking. For example sockets can seek forward, but not
backward.

The return value of the subcommand is taken as the (new) location of
the channel, counted from the start. This has to be an integer
number greater than or equal to zero. If the subcommand throws an
error the command which caused its invocation (usually **chan
seek**, or **chan tell**) will appear to have thrown this error. Any
exception beyond **error** (e.g., **break**, etc.) is treated as and
converted to an error.

The offset/base combination of 0/**current** signals a **chan tell**
request, i.e., seek nothing relative to the current location, making
the new location identical to the current one, which is then
returned.
</code></pre></div>
<p><em>cmdPrefix </em><strong>configure </strong><em>channelId option value</em></p>
<p>:   This <em>optional</em> subcommand is for setting the type-specific options
    of channel <em>channelId</em>. The <em>option</em> argument indicates the option
    to be written, and the <em>value</em> argument indicates the value to set
    the option to.</p>
<div class="language-text highlight"><pre><span></span><code>This subcommand will never try to update more than one option at a
time; that is behavior implemented in the Tcl channel core.

The return value of the subcommand is ignored.

If the subcommand throws an error the command which performed the
(re)configuration or query (usually **fconfigure** or **chan
configure**) will appear to have thrown this error. Any exception
beyond **error** (e.g., **break**, etc.) is treated as and converted
to an error.
</code></pre></div>
<p><em>cmdPrefix </em><strong>cget </strong><em>channelId option</em></p>
<p>:   This <em>optional</em> subcommand is used when reading a single
    type-specific option of channel <em>channelId</em>. If this subcommand is
    supported then the subcommand <strong>cgetall</strong> must be supported as well.</p>
<div class="language-text highlight"><pre><span></span><code>The subcommand should return the value of the specified *option*.

If the subcommand throws an error, the command which performed the
(re)configuration or query (usually **fconfigure** or **chan
configure**) will appear to have thrown this error. Any exception
beyond *error* (e.g., **break**, etc.) is treated as and converted
to an error.
</code></pre></div>
<p><em>cmdPrefix </em><strong>cgetall </strong><em>channelId</em></p>
<p>:   This <em>optional</em> subcommand is used for reading all type-specific
    options of channel <em>channelId</em>. If this subcommand is supported then
    the subcommand <strong>cget</strong> has to be supported as well.</p>
<div class="language-text highlight"><pre><span></span><code>The subcommand should return a list of all options and their values.
This list must have an even number of elements.

If the subcommand throws an error the command which performed the
(re)configuration or query (usually **fconfigure** or **chan
configure**) will appear to have thrown this error. Any exception
beyond **error** (e.g., **break**, etc.) is treated as and converted
to an error.
</code></pre></div>
<p><em>cmdPrefix </em><strong>blocking </strong><em>channelId mode</em></p>
<p>:   This <em>optional</em> subcommand handles changes to the blocking mode of
    the channel <em>channelId</em>. The <em>mode</em> is a boolean flag. A true value
    means that the channel has to be set to blocking, and a false value
    means that the channel should be non-blocking.</p>
<div class="language-text highlight"><pre><span></span><code>The return value of the subcommand is ignored.

If the subcommand throws an error the command which caused its
invocation (usually **fconfigure** or **chan configure**) will
appear to have thrown this error. Any exception beyond **error**
(e.g., **break**, etc.) is treated as and converted to an error.
</code></pre></div>
<h1 id="notes">NOTES</h1>
<p>Some of the functions supported in channels defined in Tcl\'s C
interface are not available to channels reflected to the Tcl level.</p>
<p>The function <strong>Tcl_DriverGetHandleProc</strong> is not supported; i.e.,
reflected channels do not have OS specific handles.</p>
<p>The function <strong>Tcl_DriverHandlerProc</strong> is not supported. This driver
function is relevant only for stacked channels, i.e., transformations.
Reflected channels are always base channels, not transformations.</p>
<p>The function <strong>Tcl_DriverFlushProc</strong> is not supported. This is because
the current generic I/O layer of Tcl does not use this function anywhere
at all. Therefore support at the Tcl level makes no sense either. This
may be altered in the future (through extending the API defined here and
changing its version number) should the function be used at some time in
the future.</p>
<h1 id="example">EXAMPLE</h1>
<p>This demonstrates how to make a channel that reads from a string.</p>
<div class="language-text highlight"><pre><span></span><code>oo::class create stringchan {
    variable data pos
    constructor {string {encoding {}}} {
        if {$encoding eq &quot;&quot;} {set encoding [encoding system]}
        set data [encoding convertto $encoding $string]
        set pos 0
    }

    method initialize {ch mode} {
        return &quot;initialize finalize watch read seek&quot;
    }
    method finalize {ch} {
        my destroy
    }
    method watch {ch events} {
        # Must be present but we ignore it because we do not
        # post any events
    }

    # Must be present on a readable channel
    method read {ch count} {
        set d [string range $data $pos [expr {$pos+$count-1}]]
        incr pos [string length $d]
        return $d
    }

    # This method is optional, but useful for the example below
    method seek {ch offset base} {
        switch $base {
            start {
                set pos $offset
            }
            current {
                incr pos $offset
            }
            end {
                set pos [string length $data]
                incr pos $offset
            }
        }
        if {$pos &lt; 0} {
            set pos 0
        } elseif {$pos &gt; [string length $data]} {
            set pos [string length $data]
        }
        return $pos
    }
}

# Now we create an instance...
set string &quot;The quick brown fox jumps over the lazy dog.\n&quot;
set ch [chan create read [stringchan new $string]]

puts [gets $ch];   # Prints the whole string

seek $ch -5 end;
puts [read $ch];   # Prints just the last word
</code></pre></div>
<h1 id="see-also">SEE ALSO</h1>
<p>chan(n), transchan(n)</p>
<h1 id="keywords">KEYWORDS</h1>
<p>API, channel, ensemble, prefix, reflection</p>

<ul class="metadata page-metadata" data-bi-name="page info" lang="en-us" dir="ltr">
  <li class="last-updated-holder displayDate loading">
    <span class="last-updated-text">Last updated:</span>
    <time role="presentation" datetime="2018-10-25T00:00:00.000Z" data-article-date-source="ms.date"></time>
  </li>
<!--
  <li class="readingTime">
    2 minutes to read
  </li>
-->
  <li class="contributors-holder">
    <span class="contributors-text">Contributors</span>
    <ul class="contributors" data-bi-name="contributors"></ul>
  </li>
</ul>
</div>
        <div class="col-md-3"><div class="navbar-light navbar-expand-md hidden-print sticky-top sticky-offset" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    <div id="toc-collapse" class="navbar-collapse collapse card">
        <ul class="nav flex-column bs-sidenav">
            <li class="nav-item main"><a class="nav-link" href="#name">NAME</a></li>
            <li class="nav-item main"><a class="nav-link" href="#synopsis">SYNOPSIS</a></li>
            <li class="nav-item main"><a class="nav-link" href="#description">DESCRIPTION</a></li>
                <li class="nav-item">
                    <a href="#mandatory-subcommands" class="nav-link">MANDATORY SUBCOMMANDS</a>
                </li>
                <li class="nav-item">
                    <a href="#optional-subcommands" class="nav-link">OPTIONAL SUBCOMMANDS</a>
                </li>
            <li class="nav-item main"><a class="nav-link" href="#notes">NOTES</a></li>
            <li class="nav-item main"><a class="nav-link" href="#example">EXAMPLE</a></li>
            <li class="nav-item main"><a class="nav-link" href="#see-also">SEE ALSO</a></li>
            <li class="nav-item main"><a class="nav-link" href="#keywords">KEYWORDS</a></li>
        </ul>
    </div>
</div></div>
      </div>
      </div>

      <footer class="col-md-12">
	<hr>
	<div class="container">
	</div>
      </footer>
      <script>
	var base_url = "../..",
            shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
      </script>
      <script src="../../js/base.js" defer></script>
      <script src="../../search/main.js" defer></script>

      <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <p class="h4 modal-title">Keyboard Shortcuts</p>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
