<!DOCTYPE html>
<html lang="en">
    <head>
      <script>
	// Hack for scrolling window when linking to anchor tag with fixed nav header
        var shiftWindow = function() { scrollBy(0, -75) };
        window.addEventListener("hashchange", shiftWindow);
        function load() { if (window.location.hash) shiftWindow(); }
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://www.tcl.tk/man/TclCmd/tm/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Tm - Tcl/Tk</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="../../css/font-awesome.min.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
    <script src="../../js/base.js"></script> 
    </head>

    <body class="">

      <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
	<div class="container">
	<a class="navbar-brand" href="../..">Tcl/Tk</a>
	<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExample04" aria-controls="navbarsExample04" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
	</button>

	<div class="collapse navbar-collapse">

          <ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex">
            <li class="nav-item">
              <a class="nav-link" href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
		<i class="fa fa-search"></i> Search
              </a>
            </li>
          </ul>
	</div>
	</div>
      </nav><div id="content" class="container">
        
      <div class="row">
        <div class="col-md-9" role="main">


<nav aria-label="breadcrumb">
  <ol class="breadcrumb">
    
    <li class="breadcrumb-item active" aria-current="page">Tm</li>
  </ol>
</nav>


<p>\</p>
<h1 id="name">NAME</h1>
<p>tm - Facilities for locating and loading of Tcl Modules</p>
<h1 id="synopsis">SYNOPSIS</h1>
<p><strong>::tcl::tm::path add </strong>?<em>path</em>...? <strong>::tcl::tm::path remove
</strong>?<em>path</em>...? <strong>::tcl::tm::path list</strong> <strong>::tcl::tm::roots
</strong>?<em>path</em>...?</p>
<p>\</p>
<h1 id="description">DESCRIPTION</h1>
<p>This document describes the facilities for locating and loading Tcl
Modules (see <strong>MODULE DEFINITION</strong> for the definition of a Tcl Module).
The following commands are supported:</p>
<p><strong>::tcl::tm::path add </strong>?<em>path</em>...?</p>
<p>:   The paths are added at the head to the list of module paths, in
    order of appearance. This means that the last argument ends up as
    the new head of the list.</p>
<div class="language-text highlight"><pre><span></span><code>The command enforces the restriction that no path may be an ancestor
directory of any other path on the list. If any of the new paths
violates this restriction an error will be raised, before any of the
paths have been added. In other words, if only one path argument
violates the restriction then none will be added.

If a path is already present as is, no error will be raised and no
action will be taken.

Paths are searched later in the order of their appearance in the
list. As they are added to the front of the list they are searched
in reverse order of addition. In other words, the paths added last
are looked at first.
</code></pre></div>
<p><strong>::tcl::tm::path remove </strong>?<em>path</em>...?</p>
<p>:   Removes the paths from the list of module paths. The command
    silently ignores all paths which are not on the list.</p>
<p><strong>::tcl::tm::path list</strong></p>
<p>:   Returns a list containing all registered module paths, in the order
    that they are searched for modules.</p>
<p><strong>::tcl::tm::roots </strong>?<em>path</em>...?</p>
<p>:   Similar to <strong>path add</strong>, and layered on top of it. This command
    takes a list of paths, extends each with and for major version <em>X</em>
    of the Tcl interpreter and minor version <em>y</em> less than or equal to
    the minor version of the interpreter, and adds the resulting set of
    paths to the list of paths to search.</p>
<div class="language-text highlight"><pre><span></span><code>This command is used internally by the system to set up the
system-specific default paths.

The command has been exposed to allow a build system to define
additional root paths beyond those described by this document.
</code></pre></div>
<h1 id="module-definition">MODULE DEFINITION</h1>
<p>A Tcl Module is a Tcl Package contained in a single file, and no other
files required by it. This file has to be <strong>source</strong>able. In other
words, a Tcl Module is always imported via:</p>
<div class="language-text highlight"><pre><span></span><code>source module_file
</code></pre></div>
<p>The <strong>load</strong> command is not directly used. This restriction is not an
actual limitation, as some may believe. Ever since 8.4 the Tcl
<strong>source</strong> command reads only until the first \^Z character. This allows
us to combine an arbitrary Tcl script with arbitrary binary data into
one file, where the script processes the attached data in any it chooses
to fully import and activate the package.</p>
<p>The name of a module file has to match the regular expression:</p>
<div class="language-text highlight"><pre><span></span><code>([_[:alpha:]][:_[:alnum:]]*)-([[:digit:]].*)\.tm
</code></pre></div>
<p>The first capturing parentheses provides the name of the package, the
second clause its version. In addition to matching the pattern, the
extracted version number must not raise an error when used in the
command:</p>
<div class="language-text highlight"><pre><span></span><code>package vcompare $version 0
</code></pre></div>
<h1 id="finding-modules">FINDING MODULES</h1>
<p>The directory tree for storing Tcl modules is separate from other parts
of the filesystem and independent of <strong>auto_path</strong>.</p>
<p>Tcl Modules are searched for in all directories listed in the result of
the command <strong>::tcl::tm::path list</strong>. This is called the <em>Module path</em>.
Neither the <strong>auto_path</strong> nor the <strong>tcl_pkgPath</strong> variables are used.
All directories on the module path have to obey one restriction:</p>
<blockquote>
<p>For any two directories, neither is an ancestor directory of the
other.</p>
</blockquote>
<p>This is required to avoid ambiguities in package naming. If for example
the two directories and were on the path a package named <strong>cool::ice</strong>
could be found via the names <strong>cool::ice</strong> or <strong>ice</strong>, the latter
potentially obscuring a package named <strong>ice</strong>, unqualified.</p>
<p>Before the search is started, the name of the requested package is
translated into a partial path, using the following algorithm:</p>
<blockquote>
<p>All occurrences of in the package name are replaced by the appropriate
directory separator character for the platform we are on. On Unix, for
example, this is</p>
</blockquote>
<p>Example:</p>
<blockquote>
<p>The requested package is <strong>encoding::base64</strong>. The generated partial
path is</p>
</blockquote>
<p>After this translation the package is looked for in all module paths, by
combining them one-by-one, first to last with the partial path to form a
complete search pattern. Note that the search algorithm rejects all
files where the filename does not match the regular expression given in
the section <strong>MODULE DEFINITION</strong>. For the remaining files <em>provide
scripts</em> are generated and added to the package ifneeded database.</p>
<p>The algorithm falls back to the previous unknown handler when none of
the found module files satisfy the request. If the request was satisfied
the fall-back is ignored.</p>
<p>Note that packages in module form have <em>no</em> control over the <em>index</em> and
<em>provide script</em>s entered into the package database for them. For a
module file <strong>MF</strong> the <em>index script</em> is always:</p>
<div class="language-text highlight"><pre><span></span><code>package ifneeded PNAME PVERSION [list source MF]
</code></pre></div>
<p>and the <em>provide script</em> embedded in the above is:</p>
<div class="language-text highlight"><pre><span></span><code>source MF
</code></pre></div>
<p>Both package name <strong>PNAME</strong> and package version <strong>PVERSION</strong> are
extracted from the filename <strong>MF</strong> according to the definition below:</p>
<div class="language-text highlight"><pre><span></span><code>MF = /module_path/PNAME′-PVERSION.tm
</code></pre></div>
<p>Where <strong>PNAME′</strong> is the partial path of the module as defined in section
<strong>FINDING MODULES</strong>, and translated into <strong>PNAME</strong> by changing all
directory separators to and <strong>module_path</strong> is the path (from the list
of paths to search) that we found the module file under.</p>
<p>Note also that we are here creating a connection between package names
and paths. Tcl is case-sensitive when it comes to comparing package
names, but there are filesystems which are not, like NTFS. Luckily these
filesystems do store the case of the name, despite not using the
information when comparing.</p>
<p>Given the above we allow the names for packages in Tcl modules to have
mixed-case, but also require that there are no collisions when comparing
names in a case-insensitive manner. In other words, if a package <strong>Foo</strong>
is deployed in the form of a Tcl Module, packages like <strong>foo</strong>, <strong>fOo</strong>,
etc. are not allowed anymore.</p>
<h1 id="default-paths">DEFAULT PATHS</h1>
<p>The default list of paths on the module path is computed by a <strong>tclsh</strong>
as follows, where <em>X</em> is the major version of the Tcl interpreter and
<em>y</em> is less than or equal to the minor version of the Tcl interpreter.</p>
<p>All the default paths are added to the module path, even those paths
which do not exist. Non-existent paths are filtered out during actual
searches. This enables a user to create one of the paths searched when
needed and all running applications will automatically pick up any
modules placed in them.</p>
<p>The paths are added in the order as they are listed below, and for lists
of paths defined by an environment variable in the order they are found
in the variable.</p>
<h2 id="system-specific-paths">SYSTEM SPECIFIC PATHS</h2>
<p><strong>file normalize [info library]/../tcl</strong><em>X</em><strong>/</strong><em>X</em><strong>.</strong><em>y</em></p>
<p>:   In other words, the interpreter will look into a directory specified
    by its major version and whose minor versions are less than or equal
    to the minor version of the interpreter.</p>
<div class="language-text highlight"><pre><span></span><code>For example for Tcl 8.4 the paths searched are:

    [info library]/../tcl8/8.4
    [info library]/../tcl8/8.3
    [info library]/../tcl8/8.2
    [info library]/../tcl8/8.1
    [info library]/../tcl8/8.0

This definition assumes that a package defined for Tcl *X***.***y*
can also be used by all interpreters which have the same major
number *X* and a minor number greater than *y*.
</code></pre></div>
<p><strong>file normalize EXEC/tcl</strong><em>X</em><strong>/</strong><em>X</em><strong>.</strong><em>y</em></p>
<p>:   Where <strong>EXEC</strong> is <strong>file normalize [info
    nameofexecutable]/../lib</strong> or <strong>file normalize [::tcl::pkgconfig
    get libdir,runtime]</strong></p>
<div class="language-text highlight"><pre><span></span><code>This sets of paths is handled equivalently to the set coming before,
except that it is anchored in **EXEC_PREFIX**. For a build with
**PREFIX** = **EXEC_PREFIX** the two sets are identical.
</code></pre></div>
<h2 id="site-specific-paths">SITE SPECIFIC PATHS</h2>
<p><strong>file normalize [info library]/../tcl</strong><em>X</em><strong>/site-tcl</strong></p>
<p>:   Note that this is always a single entry because <em>X</em> is always a
    specific value (the current major version of Tcl).</p>
<h2 id="user-specific-paths">USER SPECIFIC PATHS</h2>
<p><strong>\$::env(TCL</strong><em>X</em><strong>_</strong><em>y</em><strong>_TM_PATH)</strong></p>
<p>:   A list of paths, separated by either <strong>:</strong> (Unix) or <strong>;</strong>
    (Windows). This is user and site specific as this environment
    variable can be set not only by the user\'s profile, but by system
    configuration scripts as well.</p>
<p><strong>\$::env(TCL</strong><em>X</em><strong>.</strong><em>y</em><strong>_TM_PATH)</strong></p>
<p>:   Same meaning and content as the previous variable. However the use
    of dot \'.\' to separate major and minor version number makes this
    name less to non-portable and its use is discouraged. Support of
    this variable has been kept only for backward compatibility with the
    original specification, i.e. TIP 189.</p>
<p>These paths are seen and therefore shared by all Tcl shells in the
<strong>\$::env(PATH)</strong> of the user.</p>
<p>Note that <em>X</em> and <em>y</em> follow the general rules set out above. In other
words, Tcl 8.4, for example, will look at these 10 environment
variables:</p>
<div class="language-text highlight"><pre><span></span><code>$::env(TCL8.4_TM_PATH)  $::env(TCL8_4_TM_PATH)
$::env(TCL8.3_TM_PATH)  $::env(TCL8_3_TM_PATH)
$::env(TCL8.2_TM_PATH)  $::env(TCL8_2_TM_PATH)
$::env(TCL8.1_TM_PATH)  $::env(TCL8_1_TM_PATH)
$::env(TCL8.0_TM_PATH)  $::env(TCL8_0_TM_PATH)
</code></pre></div>
<h1 id="see-also">SEE ALSO</h1>
<p>package(n), Tcl Improvement Proposal #189 (online at
https://tip.tcl-lang.org/189.html), Tcl Improvement Proposal #190
(online at https://tip.tcl-lang.org/190.html)</p>
<h1 id="keywords">KEYWORDS</h1>
<p>modules, package</p>

<ul class="metadata page-metadata" data-bi-name="page info" lang="en-us" dir="ltr">
  <li class="last-updated-holder displayDate loading">
    <span class="last-updated-text">Last updated:</span>
    <time role="presentation" datetime="2018-10-25T00:00:00.000Z" data-article-date-source="ms.date"></time>
  </li>
<!--
  <li class="readingTime">
    2 minutes to read
  </li>
-->
  <li class="contributors-holder">
    <span class="contributors-text">Contributors</span>
    <ul class="contributors" data-bi-name="contributors"></ul>
  </li>
</ul>
</div>
        <div class="col-md-3"><div class="navbar-light navbar-expand-md hidden-print sticky-top sticky-offset" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    <div id="toc-collapse" class="navbar-collapse collapse card">
        <ul class="nav flex-column bs-sidenav">
            <li class="nav-item main"><a class="nav-link" href="#name">NAME</a></li>
            <li class="nav-item main"><a class="nav-link" href="#synopsis">SYNOPSIS</a></li>
            <li class="nav-item main"><a class="nav-link" href="#description">DESCRIPTION</a></li>
            <li class="nav-item main"><a class="nav-link" href="#module-definition">MODULE DEFINITION</a></li>
            <li class="nav-item main"><a class="nav-link" href="#finding-modules">FINDING MODULES</a></li>
            <li class="nav-item main"><a class="nav-link" href="#default-paths">DEFAULT PATHS</a></li>
                <li class="nav-item">
                    <a href="#system-specific-paths" class="nav-link">SYSTEM SPECIFIC PATHS</a>
                </li>
                <li class="nav-item">
                    <a href="#site-specific-paths" class="nav-link">SITE SPECIFIC PATHS</a>
                </li>
                <li class="nav-item">
                    <a href="#user-specific-paths" class="nav-link">USER SPECIFIC PATHS</a>
                </li>
            <li class="nav-item main"><a class="nav-link" href="#see-also">SEE ALSO</a></li>
            <li class="nav-item main"><a class="nav-link" href="#keywords">KEYWORDS</a></li>
        </ul>
    </div>
</div></div>
      </div>
      </div>

      <footer class="col-md-12">
	<hr>
	<div class="container">
	</div>
      </footer>
      <script>
	var base_url = "../..",
            shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
      </script>
      <script src="../../js/base.js" defer></script>
      <script src="../../search/main.js" defer></script>

      <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <p class="h4 modal-title">Keyboard Shortcuts</p>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
