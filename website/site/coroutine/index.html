<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://www.tcl.tk/man/tcl8.6.13/TclCmd/contents.html/coroutine/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>NAME - Tcl/Tk</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "NAME";
        var mkdocs_page_input_path = "coroutine.md";
        var mkdocs_page_url = "/man/tcl8.6.13/TclCmd/contents.html/coroutine/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Tcl/Tk
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../command.md">Commands</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Tcl/Tk</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>NAME</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="name">NAME</h1>
<p>coroutine, yield, yieldto, coroinject, coroprobe - Create and produce
values from coroutines</p>
<h1 id="synopsis">SYNOPSIS</h1>
<pre><code>coroutine name command ?arg...?
yield ?value?
yieldto command ?arg...?
name ?value...?

coroinject coroName command ?arg...?
coroprobe coroName command ?arg...?
</code></pre>
<h1 id="description">DESCRIPTION</h1>
<p>The <strong>coroutine</strong> command creates a new coroutine context (with
associated command) named <em>name</em> and executes that context by calling
<em>command</em>, passing in the other remaining arguments without further
interpretation. Once <em>command</em> returns normally or with an exception
(e.g., an error) the coroutine context <em>name</em> is deleted.</p>
<p>Within the context, values may be generated as results by using the
<strong>yield</strong> command; if no <em>value</em> is supplied, the empty string is used.
When that is called, the context will suspend execution and the
<strong>coroutine</strong> command will return the argument to <strong>yield</strong>. The
execution of the context can then be resumed by calling the context
command, optionally passing in the <em>single</em> value to use as the result
of the <strong>yield</strong> call that caused the context to be suspended. If the
coroutine context never yields and instead returns conventionally, the
result of the <strong>coroutine</strong> command will be the result of the evaluation
of the context.</p>
<p>The coroutine may also suspend its execution by use of the <strong>yieldto</strong>
command, which instead of returning, cedes execution to some command
called <em>command</em> (resolved in the context of the coroutine) and to which
<em>any</em> number of arguments may be passed. Since every coroutine has a
context command, <strong>yieldto</strong> can be used to transfer control directly
from one coroutine to another (this is only advisable if the two
coroutines are expecting this to happen) but <em>any</em> command may be the
target. If a coroutine is suspended by this mechanism, the coroutine
processing can be resumed by calling the context command optionally
passing in an arbitrary number of arguments. The return value of the
<strong>yieldto</strong> call will be the list of arguments passed to the context
command; it is up to the caller to decide what to do with those values.</p>
<p>The recommended way of writing a version of <strong>yield</strong> that allows
resumption with multiple arguments is by using <strong>yieldto</strong> and the
<strong>return</strong> command, like this:</p>
<p>proc yieldMultiple {value} { tailcall <strong>yieldto</strong> string cat \$value }</p>
<p>The coroutine can also be deleted by destroying the command <em>name</em>, and
the name of the current coroutine can be retrieved by using <strong>info
coroutine</strong>. If there are deletion traces on variables in the
coroutine\'s implementation, they will fire at the point when the
coroutine is explicitly deleted (or, naturally, if the command returns
conventionally).</p>
<p>At the point when <em>command</em> is called, the current namespace will be the
global namespace and there will be no stack frames above it (in the
sense of <strong>upvar</strong> and <strong>uplevel</strong>). However, which command to call will
be determined in the namespace that the <strong>coroutine</strong> command was called
from.</p>
<p>A suspended coroutine (i.e., one that has <strong>yield</strong>ed or <strong>yieldto</strong>-d)
may have its state inspected (or modified) at that point by using
<strong>coroprobe</strong> to run a command at the point where the coroutine is at.
The command takes the name of the coroutine to run the command in,
<em>coroName</em>, and the name of a command (any any arguments it requires) to
immediately run at that point. The result of that command is the result
of the <strong>coroprobe</strong> command, and the gross state of the coroutine
remains the same afterwards (i.e., the coroutine is still expecting the
results of a <strong>yield</strong> or <strong>yieldto</strong> as before) though variables may
have been changed.</p>
<p>Similarly, the <strong>coroinject</strong> command may be used to place a command to
be run inside a suspended coroutine (when it is resumed) to process
arguments, with quite a bit of similarity to <strong>coroprobe</strong>. However,
with <strong>coroinject</strong> there are several key differences:</p>
<ul>
<li></li>
</ul>
<p>The coroutine is not immediately resumed after the injection has been
done. A consequence of this is that multiple injections may be done
before the coroutine is resumed. There injected commands are performed
in <em>reverse</em> order of definition (that is, they are internally stored on
a stack).</p>
<ul>
<li></li>
</ul>
<p>An additional two arguments are appended to the list of arguments to be
run (that is, the <em>command</em> and its <em>args</em> are extended by two
elements). The first is the name of the command that suspended the
coroutine (<strong>yield</strong> or <strong>yieldto</strong>), and the second is the argument (or
list of arguments, in the case of <strong>yieldto</strong>) that is the current
resumption value.</p>
<ul>
<li></li>
</ul>
<p>The result of the injected command is used as the result of the
<strong>yield</strong> or <strong>yieldto</strong> that caused the coroutine to become suspended.
Where there are multiple injected commands, the result of one becomes
the resumption value processed by the next.</p>
<p>The injection is a one-off. It is not retained once it has been
executed. It may <strong>yield</strong> or <strong>yieldto</strong> as part of its execution.</p>
<p>Note that running coroutines may be neither probed nor injected; the
operations may only be applied to</p>
<h1 id="examples">EXAMPLES</h1>
<p>This example shows a coroutine that will produce an infinite sequence of
even values, and a loop that consumes the first ten of them.</p>
<p>proc allNumbers {} { <strong>yield</strong> set i 0 while 1 { <strong>yield</strong> \$i incr i 2
} } <strong>coroutine</strong> nextNumber allNumbers for {set i 0} {\$i \&lt; 10} {incr
i} { puts \"received [<em>nextNumber</em>]\" } rename nextNumber {}</p>
<p>In this example, the coroutine acts to add up the arguments passed to
it.</p>
<p><strong>coroutine</strong> accumulator apply {{} { set x 0 while 1 { incr x
[<strong>yield</strong> \$x] } }} for {set i 0} {\$i \&lt; 10} {incr i} { puts \"\$i
-> [<em>accumulator</em> \$i]\" }</p>
<p>This example demonstrates the use of coroutines to implement the classic
Sieve of Eratosthenes algorithm for finding prime numbers. Note the
creation of coroutines inside a coroutine.</p>
<p>proc filterByFactor {source n} { <strong>yield</strong> [info coroutine] while 1 {
set x [<em>\$source</em>] if {\$x % \$n} { <strong>yield</strong> \$x } } } <strong>coroutine</strong>
allNumbers apply {{} {while 1 {<strong>yield</strong> [incr x]}}} <strong>coroutine</strong>
eratosthenes apply {c { <strong>yield</strong> while 1 { set n [<em>\$c</em>] <strong>yield</strong>
\$n set c [<strong>coroutine</strong> prime\$n filterByFactor \$c \$n] } }}
allNumbers for {set i 1} {\$i \&lt;= 20} {incr i} { puts \"prime#\$i =
[<em>eratosthenes</em>]\" }</p>
<p>This example shows how a value can be passed around a group of three
coroutines that yield to each other:</p>
<p>proc juggler {name target {value \"\"}} { if {\$value eq \"\"} { set
value [<strong>yield</strong> [info coroutine]] } while {\$value ne \"\"} { puts
\"\$name : \$value\" set value [string range \$value 0 end-1] lassign
[<strong>yieldto</strong> <em>\$target</em> \$value] value } } <strong>coroutine</strong> j1 juggler
Larry [ <strong>coroutine</strong> j2 juggler Curly [ <strong>coroutine</strong> j3 juggler Moe
j1]] \"Nyuck!Nyuck!Nyuck!\"</p>
<p>This example shows a simple coroutine that collects non-empty values and
returns a list of them when not given an argument. It also shows how we
can look inside the coroutine to find out what it is doing, and how we
can modify the input on a one-off basis.</p>
<p>proc collectorImpl {} { set me [info coroutine] set accumulator {} for
{set val [<strong>yield</strong> \$me]} {\$val ne \"\"} {set val [<strong>yield</strong>]} {
lappend accumulator \$val } return \$accumulator }</p>
<p><strong>coroutine</strong> collect collectorImpl <em>collect</em> 123 <em>collect</em> \"abc def\"
<em>collect</em> 456</p>
<p>puts [<strong>coroprobe </strong><em>collect</em> set accumulator] # ==> 123 {abc def}
456</p>
<p><em>collect</em> \"pqr\"</p>
<p><strong>coroinject </strong><em>collect</em> apply {{type value} { puts \"Received
\'\$value\' at a \$type in [info coroutine]\" return [string toupper
\$value] }}</p>
<p><em>collect</em> rst # ==> Received \'rst\' at a yield in ::collect <em>collect</em>
xyz</p>
<p>puts [<em>collect</em>] # ==> 123 {abc def} 456 pqr RST xyz</p>
<p>This example shows a simple coroutine that collects non-empty values and
returns a list of them when not given an argument. It also shows how we
can look inside the coroutine to find out what it is doing.</p>
<h2 id="detailed-semantics">DETAILED SEMANTICS</h2>
<p>This example demonstrates that coroutines start from the global
namespace, and that <em>command</em> resolution happens before the coroutine
stack is created.</p>
<p>proc report {where level} { # Where was the caller called from? set ns
[uplevel 2 {namespace current}] <strong>yield</strong> \"made \$where \$level
context=\$ns name=[info coroutine]\" } proc example {} { report outer
[info level] } namespace eval demo { proc example {} { report inner
[info level] } proc makeExample {} { puts \"making from [info
level]\" puts [<strong>coroutine</strong> coroEg example] } makeExample }</p>
<p>Which produces the output below. In particular, we can see that stack
manipulation has occurred (comparing the levels from the first and
second line) and that the parent level in the coroutine is the global
namespace. We can also see that coroutine names are local to the current
namespace if not qualified, and that coroutines may yield at depth
(e.g., in called procedures).</p>
<p>making from 2 made inner 1 context=:: name=::demo::coroEg</p>
<h1 id="see-also">SEE ALSO</h1>
<p>apply(n), info(n), proc(n), return(n)</p>
<h1 id="keywords">KEYWORDS</h1>
<p>coroutine, generator</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
