<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://www.tcl.tk/man/tcl8.6.13/TclCmd/contents.html/DictObj/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>NAME - Tcl/Tk</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "NAME";
        var mkdocs_page_input_path = "DictObj.md";
        var mkdocs_page_url = "/man/tcl8.6.13/TclCmd/contents.html/DictObj/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Tcl/Tk
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../command.md">Commands</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Tcl/Tk</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>NAME</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="name">NAME</h1>
<p>Tcl_NewDictObj, Tcl_DictObjPut, Tcl_DictObjGet, Tcl_DictObjRemove,
Tcl_DictObjSize, Tcl_DictObjFirst, Tcl_DictObjNext, Tcl_DictObjDone,
Tcl_DictObjPutKeyList, Tcl_DictObjRemoveKeyList - manipulate Tcl values
as dictionaries</p>
<h1 id="synopsis">SYNOPSIS</h1>
<pre><code>#include &lt;tcl.h&gt;

Tcl_Obj *
Tcl_NewDictObj()

int
Tcl_DictObjGet(interp, dictPtr, keyPtr, valuePtrPtr)

int
Tcl_DictObjPut(interp, dictPtr, keyPtr, valuePtr)

int
Tcl_DictObjRemove(interp, dictPtr, keyPtr)

int
Tcl_DictObjSize(interp, dictPtr, sizePtr)

int
Tcl_DictObjFirst(interp, dictPtr, searchPtr,
                 keyPtrPtr, valuePtrPtr, donePtr)

void
Tcl_DictObjNext(searchPtr, keyPtrPtr, valuePtrPtr, donePtr)

void
Tcl_DictObjDone(searchPtr)

int
Tcl_DictObjPutKeyList(interp, dictPtr, keyc, keyv, valuePtr)

int
Tcl_DictObjRemoveKeyList(interp, dictPtr, keyc, keyv)
</code></pre>
<h1 id="arguments">ARGUMENTS</h1>
<p>If an error occurs while converting a value to be a dictionary value, an
error message is left in the interpreter\'s result value unless <em>interp</em>
is NULL.</p>
<p>Points to the dictionary value to be manipulated. If <em>dictPtr</em> does not
already point to a dictionary value, an attempt will be made to convert
it to one.</p>
<p>Points to the key for the key/value pair being manipulated within the
dictionary value.</p>
<p>Points to a variable that will have the key from a key/value pair placed
within it. May be NULL to indicate that the caller is not interested in
the key.</p>
<p>Points to the value for the key/value pair being manipulated within the
dictionary value (or sub-value, in the case of
<strong>Tcl_DictObjPutKeyList</strong>.)</p>
<p>Points to a variable that will have the value from a key/value pair
placed within it. For <strong>Tcl_DictObjFirst</strong> and <strong>Tcl_DictObjNext</strong>, this
may be NULL to indicate that the caller is not interested in the value.</p>
<p>Points to a variable that will have the number of key/value pairs
contained within the dictionary placed within it.</p>
<p>Pointer to record to use to keep track of progress in enumerating all
key/value pairs in a dictionary. The contents of the record will be
initialized by the call to <strong>Tcl_DictObjFirst</strong>. If the enumerating is
to be terminated before all values in the dictionary have been returned,
the search record <em>must</em> be passed to <strong>Tcl_DictObjDone</strong> to enable the
internal locks to be released.</p>
<p>Points to a variable that will have a non-zero value written into it
when the enumeration of the key/value pairs in a dictionary has
completed, and a zero otherwise.</p>
<p>Indicates the number of keys that will be supplied in the <em>keyv</em> array.</p>
<p>Array of <em>keyc</em> pointers to values that <strong>Tcl_DictObjPutKeyList</strong> and
<strong>Tcl_DictObjRemoveKeyList</strong> will use to locate the key/value pair to
manipulate within the sub-dictionaries of the main dictionary value
passed to them.</p>
<h1 id="description">DESCRIPTION</h1>
<p>Tcl dictionary values have an internal representation that supports
efficient mapping from keys to values and which guarantees that the
particular ordering of keys within the dictionary remains the same
modulo any keys being deleted (which removes them from the order) or
added (which adds them to the end of the order). If reinterpreted as a
list, the values at the even-valued indices in the list will be the keys
of the dictionary, and each will be followed (in the odd-valued index)
by the value associated with that key.</p>
<p>The procedures described in this man page are used to create, modify,
index, and iterate over dictionary values from C code.</p>
<p><strong>Tcl_NewDictObj</strong> creates a new, empty dictionary value. The string
representation of the value will be invalid, and the reference count of
the value will be zero.</p>
<p><strong>Tcl_DictObjGet</strong> looks up the given key within the given dictionary
and writes a pointer to the value associated with that key into the
variable pointed to by <em>valuePtrPtr</em>, or a NULL if the key has no
mapping within the dictionary. The result of this procedure is
<strong>TCL_OK</strong>, or <strong>TCL_ERROR</strong> if the <em>dictPtr</em> cannot be converted to a
dictionary.</p>
<p><strong>Tcl_DictObjPut</strong> updates the given dictionary so that the given key
maps to the given value; any key may exist at most once in any
particular dictionary. The dictionary must not be shared, but the key
and value may be. This procedure may increase the reference count of
both key and value if it proves necessary to store them. Neither key nor
value should be NULL. The result of this procedure is <strong>TCL_OK</strong>, or
<strong>TCL_ERROR</strong> if the <em>dictPtr</em> cannot be converted to a dictionary.</p>
<p><strong>Tcl_DictObjRemove</strong> updates the given dictionary so that the given key
has no mapping to any value. The dictionary must not be shared, but the
key may be. The key actually stored in the dictionary will have its
reference count decremented if it was present. It is not an error if the
key did not previously exist. The result of this procedure is
<strong>TCL_OK</strong>, or <strong>TCL_ERROR</strong> if the <em>dictPtr</em> cannot be converted to a
dictionary.</p>
<p><strong>Tcl_DictObjSize</strong> updates the given variable with the number of
key/value pairs currently in the given dictionary. The result of this
procedure is <strong>TCL_OK</strong>, or <strong>TCL_ERROR</strong> if the <em>dictPtr</em> cannot be
converted to a dictionary or if <em>sizePtr</em> points to a variable of type
<strong>int</strong> and the dict contains more than 2**31 key/value pairs.</p>
<p><strong>Tcl_DictObjFirst</strong> commences an iteration across all the key/value
pairs in the given dictionary, placing the key and value in the
variables pointed to by the <em>keyPtrPtr</em> and <em>valuePtrPtr</em> arguments
(which may be NULL to indicate that the caller is uninterested in they
key or variable respectively.) The next key/value pair in the dictionary
may be retrieved with <strong>Tcl_DictObjNext</strong>. Concurrent updates of the
dictionary\'s internal representation will not modify the iteration
processing unless the dictionary is unshared, when this will trigger
premature termination of the iteration instead (which Tcl scripts cannot
trigger via the <strong>dict</strong> command.) The <em>searchPtr</em> argument points to a
piece of context that is used to identify which particular iteration is
being performed, and is initialized by the call to <strong>Tcl_DictObjFirst</strong>.
The <em>donePtr</em> argument points to a variable that is updated to be zero
of there are further key/value pairs to be iterated over, or non-zero if
the iteration is complete. The order of iteration is
implementation-defined. If the <em>dictPtr</em> argument cannot be converted to
a dictionary, <strong>Tcl_DictObjFirst</strong> returns <strong>TCL_ERROR</strong> and the
iteration is not commenced, and otherwise it returns <strong>TCL_OK</strong>.</p>
<p>When <strong>Tcl_DictObjFirst</strong> is called upon a dictionary, a lock is placed
on the dictionary to enable that dictionary to be iterated over safely
without regard for whether the dictionary is modified during the
iteration. Because of this, once the iteration over a dictionary\'s keys
has finished (whether because all values have been iterated over as
indicated by the variable indicated by the <em>donePtr</em> argument being set
to one, or because no further values are required) the
<strong>Tcl_DictObjDone</strong> function must be called with the same <em>searchPtr</em> as
was passed to <strong>Tcl_DictObjFirst</strong> so that the internal locks can be
released. Once a particular <em>searchPtr</em> is passed to
<strong>Tcl_DictObjDone</strong>, passing it to <strong>Tcl_DictObjNext</strong> (without first
initializing it with <strong>Tcl_DictObjFirst</strong>) will result in no values
being produced and the variable pointed to by <em>donePtr</em> being set to
one. It is safe to call <strong>Tcl_DictObjDone</strong> multiple times on the same
<em>searchPtr</em> for each call to <strong>Tcl_DictObjFirst</strong>.</p>
<p>The procedures <strong>Tcl_DictObjPutKeyList</strong> and
<strong>Tcl_DictObjRemoveKeyList</strong> are the close analogues of
<strong>Tcl_DictObjPut</strong> and <strong>Tcl_DictObjRemove</strong> respectively, except that
instead of working with a single dictionary, they are designed to
operate on a nested tree of dictionaries, with inner dictionaries stored
as values inside outer dictionaries. The <em>keyc</em> and <em>keyv</em> arguments
specify a list of keys (with outermost keys first) that acts as a path
to the key/value pair to be affected. Note that there is no
corresponding operation for reading a value for a path as this is easy
to construct from repeated use of <strong>Tcl_DictObjGet</strong>. With
<strong>Tcl_DictObjPutKeyList</strong>, nested dictionaries are created for
non-terminal keys where they do not already exist. With
<strong>Tcl_DictObjRemoveKeyList</strong>, all non-terminal keys must exist and have
dictionaries as their values.</p>
<h1 id="reference-count-management">REFERENCE COUNT MANAGEMENT</h1>
<p><strong>Tcl_NewDictObj</strong> always returns a zero-reference object, much like
<strong>Tcl_NewObj</strong>.</p>
<p><strong>Tcl_DictObjPut</strong> does not modify the reference count of its <em>dictPtr</em>
argument, but does require that the object be unshared. If
<strong>Tcl_DictObjPut</strong> returns <strong>TCL_ERROR</strong> it does not manipulate any
reference counts; but if it returns <strong>TCL_OK</strong> then it definitely
increments the reference count of <em>valuePtr</em> and may increment the
reference count of <em>keyPtr</em>; the latter case happens exactly when the
key did not previously exist in the dictionary. Note however that this
function may set the interpreter result; if that is the only place that
is holding a reference to an object, it will be deleted.</p>
<p><strong>Tcl_DictObjGet</strong> only reads from its <em>dictPtr</em> and <em>keyPtr</em> arguments,
and does not manipulate their reference counts at all. If the
<em>valuePtrPtr</em> argument is not set to NULL (and the function doesn\'t
return <strong>TCL_ERROR</strong>), it will be set to a value with a reference count
of at least 1, with a reference owned by the dictionary. Note however
that this function may set the interpreter result; if that is the only
place that is holding a reference to an object, it will be deleted.</p>
<p><strong>Tcl_DictObjRemove</strong> does not modify the reference count of its
<em>dictPtr</em> argument, but does require that the object be unshared. It
does not manipulate the reference count of its <em>keyPtr</em> argument at all.
Note however that this function may set the interpreter result; if that
is the only place that is holding a reference to an object, it will be
deleted.</p>
<p><strong>Tcl_DictObjSize</strong> does not modify the reference count of its <em>dictPtr</em>
argument; it only reads. Note however that this function may set the
interpreter result; if that is the only place that is holding a
reference to the dictionary object, it will be deleted.</p>
<p><strong>Tcl_DictObjFirst</strong> does not modify the reference count of its
<em>dictPtr</em> argument; it only reads. The variables given by the
<em>keyPtrPtr</em> and <em>valuePtrPtr</em> arguments (if not NULL) will be updated to
contain references to the relevant values in the dictionary; their
reference counts will be at least 1 (due to the dictionary holding a
reference to them). It may also manipulate internal references; these
are not exposed to user code, but require a matching <strong>Tcl_DictObjDone</strong>
call. Note however that this function may set the interpreter result; if
that is the only place that is holding a reference to the dictionary
object, it will be deleted.</p>
<p>Similarly for <strong>Tcl_DictObjNext</strong>; the variables given by the
<em>keyPtrPtr</em> and <em>valuePtrPtr</em> arguments (if not NULL) will be updated to
contain references to the relevant values in the dictionary; their
reference counts will be at least 1 (due to the dictionary holding a
reference to them).</p>
<p><strong>Tcl_DictObjDone</strong> does not manipulate (user-visible) reference counts.</p>
<p><strong>Tcl_DictObjPutKeyList</strong> is similar to <strong>Tcl_DictObjPut</strong>; it does not
modify the reference count of its <em>dictPtr</em> argument, but does require
that the object be unshared. It may increment the reference count of any
value passed in the <em>keyv</em> argument, and will increment the reference
count of the <em>valuePtr</em> argument on success. It is recommended that
values passed via <em>keyv</em> and <em>valuePtr</em> do not have zero reference
counts. Note however that this function may set the interpreter result;
if that is the only place that is holding a reference to an object, it
will be deleted.</p>
<p><strong>Tcl_DictObjRemoveKeyList</strong> is similar to <strong>Tcl_DictObjRemove</strong>; it
does not modify the reference count of its <em>dictPtr</em> argument, but does
require that the object be unshared, and does not modify the reference
counts of any of the values passed in the <em>keyv</em> argument. Note however
that this function may set the interpreter result; if that is the only
place that is holding a reference to an object, it will be deleted.</p>
<h1 id="example">EXAMPLE</h1>
<p>Using the dictionary iteration interface to search determine if there is
a key that maps to itself:</p>
<p>Tcl_DictSearch search; Tcl_Obj *key, *value; int done;</p>
<p>/* * Assume interp and objPtr are parameters. This is the * idiomatic
way to start an iteration over the dictionary; it * sets a lock on the
internal representation that ensures that * there are no concurrent
modification issues when normal * reference count management is also
used. The lock is * released automatically when the loop is finished,
but must * be released manually when an exceptional exit from the loop
* is performed. However it is safe to try to release the lock * even
if we\'ve finished iterating over the loop. */ if
(<strong>Tcl_DictObjFirst</strong>(interp, objPtr, &amp;search, &amp;key, &amp;value, &amp;done) !=
TCL_OK) { return TCL_ERROR; } for (; !done ;
<strong>Tcl_DictObjNext</strong>(&amp;search, &amp;key, &amp;value, &amp;done)) { /* * Note that
strcmp() is not a good way of comparing * values and is just used here
for demonstration * purposes. */ if (!strcmp(Tcl_GetString(key),
Tcl_GetString(value))) { break; } } <strong>Tcl_DictObjDone</strong>(&amp;search);
Tcl_SetObjResult(interp, Tcl_NewBooleanObj(!done)); return TCL_OK;</p>
<h1 id="see-also">SEE ALSO</h1>
<p>Tcl_NewObj, Tcl_DecrRefCount, Tcl_IncrRefCount, Tcl_InitObjHashTable</p>
<h1 id="keywords">KEYWORDS</h1>
<p>dict, dict value, dictionary, dictionary value, hash table, iteration,
value</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
