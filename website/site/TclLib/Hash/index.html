<!DOCTYPE html>
<html lang="en">
    <head>
      <script>
	// Hack for scrolling window when linking to anchor tag with fixed nav header
        var shiftWindow = function() { scrollBy(0, -75) };
        window.addEventListener("hashchange", shiftWindow);
        function load() { if (window.location.hash) shiftWindow(); }
      </script>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://www.tcl.tk/man/TclLib/Hash/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Hash - Tcl/Tk</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="../../css/font-awesome.min.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
    <script src="../../js/base.js"></script> 
    </head>

    <body class="">

      <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
	<div class="container">
	<a class="navbar-brand" href="../..">Tcl/Tk</a>
	<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExample04" aria-controls="navbarsExample04" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
	</button>

	<div class="collapse navbar-collapse">

          <ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex">
            <li class="nav-item">
              <a class="nav-link" href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
		<i class="fa fa-search"></i> Search
              </a>
            </li>
          </ul>
	</div>
	</div>
      </nav><div id="content" class="container">
        
      <div class="row">
        <div class="col-md-9" role="main">


<nav aria-label="breadcrumb">
  <ol class="breadcrumb">
    
    <li class="breadcrumb-item active" aria-current="page">Hash</li>
  </ol>
</nav>


<p>\</p>
<h1 id="name">NAME</h1>
<p>Tcl_InitHashTable, Tcl_InitCustomHashTable, Tcl_InitObjHashTable,
Tcl_DeleteHashTable, Tcl_CreateHashEntry, Tcl_DeleteHashEntry,
Tcl_FindHashEntry, Tcl_GetHashValue, Tcl_SetHashValue, Tcl_GetHashKey,
Tcl_FirstHashEntry, Tcl_NextHashEntry, Tcl_HashStats - procedures to
manage hash tables</p>
<h1 id="synopsis">SYNOPSIS</h1>
<p><strong>#include \&lt;tcl.h></strong></p>
<p><strong>Tcl_InitHashTable</strong>(<em>tablePtr, keyType</em>)</p>
<p><strong>Tcl_InitCustomHashTable</strong>(<em>tablePtr, keyType, typePtr</em>)</p>
<p><strong>Tcl_InitObjHashTable</strong>(<em>tablePtr</em>)</p>
<p><strong>Tcl_DeleteHashTable</strong>(<em>tablePtr</em>)</p>
<p>Tcl_HashEntry * <strong>Tcl_CreateHashEntry</strong>(<em>tablePtr, key, newPtr</em>)</p>
<p><strong>Tcl_DeleteHashEntry</strong>(<em>entryPtr</em>)</p>
<p>Tcl_HashEntry * <strong>Tcl_FindHashEntry</strong>(<em>tablePtr, key</em>)</p>
<p>ClientData <strong>Tcl_GetHashValue</strong>(<em>entryPtr</em>)</p>
<p><strong>Tcl_SetHashValue</strong>(<em>entryPtr, value</em>)</p>
<p>void * <strong>Tcl_GetHashKey</strong>(<em>tablePtr, entryPtr</em>)</p>
<p>Tcl_HashEntry * <strong>Tcl_FirstHashEntry</strong>(<em>tablePtr, searchPtr</em>)</p>
<p>Tcl_HashEntry * <strong>Tcl_NextHashEntry</strong>(<em>searchPtr</em>)</p>
<p>char * <strong>Tcl_HashStats</strong>(<em>tablePtr</em>)</p>
<h1 id="arguments">ARGUMENTS</h1>
<p>Address of hash table structure (for all procedures but
<strong>Tcl_InitHashTable</strong>, this must have been initialized by previous call
to <strong>Tcl_InitHashTable</strong>).</p>
<p>Kind of keys to use for new hash table. Must be either
<strong>TCL_STRING_KEYS</strong>, <strong>TCL_ONE_WORD_KEYS</strong>, <strong>TCL_CUSTOM_TYPE_KEYS</strong>,
<strong>TCL_CUSTOM_PTR_KEYS</strong>, or an integer value greater than 1.</p>
<p>Address of structure which defines the behavior of the hash table.</p>
<p>Key to use for probe into table. Exact form depends on <em>keyType</em> used to
create table.</p>
<p>The word at <em>*newPtr</em> is set to 1 if a new entry was created and 0 if
there was already an entry for <em>key</em>.</p>
<p>Pointer to hash table entry.</p>
<p>New value to assign to hash table entry. Need not have type ClientData,
but must fit in same space as ClientData.</p>
<p>Pointer to record to use to keep track of progress in enumerating all
the entries in a hash table.</p>
<p>\</p>
<h1 id="description">DESCRIPTION</h1>
<p>A hash table consists of zero or more entries, each consisting of a key
and a value. Given the key for an entry, the hashing routines can very
quickly locate the entry, and hence its value. There may be at most one
entry in a hash table with a particular key, but many entries may have
the same value. Keys can take one of four forms: strings, one-word
values, integer arrays, or custom keys defined by a Tcl_HashKeyType
structure (See section <strong>THE TCL_HASHKEYTYPE STRUCTURE</strong> below). All of
the keys in a given table have the same form, which is specified when
the table is initialized.</p>
<p>The value of a hash table entry can be anything that fits in the same
space as a pointer. Values for hash table entries are managed entirely
by clients, not by the hash module itself. Typically each entry\'s value
is a pointer to a data structure managed by client code.</p>
<p>Hash tables grow gracefully as the number of entries increases, so that
there are always less than three entries per hash bucket, on average.
This allows for fast lookups regardless of the number of entries in a
table.</p>
<p>The core provides three functions for the initialization of hash tables,
Tcl_InitHashTable, Tcl_InitObjHashTable and Tcl_InitCustomHashTable.</p>
<p><strong>Tcl_InitHashTable</strong> initializes a structure that describes a new hash
table. The space for the structure is provided by the caller, not by the
hash module. The value of <em>keyType</em> indicates what kinds of keys will be
used for all entries in the table. All of the key types described later
are allowed, with the exception of <strong>TCL_CUSTOM_TYPE_KEYS</strong> and
<strong>TCL_CUSTOM_PTR_KEYS</strong>.</p>
<p><strong>Tcl_InitObjHashTable</strong> is a wrapper around <strong>Tcl_InitCustomHashTable</strong>
and initializes a hash table whose keys are Tcl_Obj *.</p>
<p><strong>Tcl_InitCustomHashTable</strong> initializes a structure that describes a new
hash table. The space for the structure is provided by the caller, not
by the hash module. The value of <em>keyType</em> indicates what kinds of keys
will be used for all entries in the table. <em>KeyType</em> must have one of
the following values:</p>
<p>TCL_STRING_KEYS</p>
<p>:   Keys are null-terminated strings. They are passed to hashing
    routines using the address of the first character of the string.</p>
<p>TCL_ONE_WORD_KEYS</p>
<p>:   Keys are single-word values; they are passed to hashing routines and
    stored in hash table entries as values. The pointer value is the
    key; it need not (and usually does not) actually point to a string.</p>
<p>TCL_CUSTOM_TYPE_KEYS</p>
<p>:   Keys are of arbitrary type, and are stored in the entry. Hashing and
    comparison is determined by <em>typePtr</em>. The Tcl_HashKeyType structure
    is described in the section <strong>THE TCL_HASHKEYTYPE STRUCTURE</strong> below.</p>
<p>TCL_CUSTOM_PTR_KEYS</p>
<p>:   Keys are pointers to an arbitrary type, and are stored in the entry.
    Hashing and comparison is determined by <em>typePtr</em>. The
    Tcl_HashKeyType structure is described in the section <strong>THE
    TCL_HASHKEYTYPE STRUCTURE</strong> below.</p>
<p>other</p>
<p>:   If <em>keyType</em> is not one of the above, then it must be an integer
    value greater than 1. In this case the keys will be arrays of
    values, where <em>keyType</em> gives the number of ints in each key. This
    allows structures to be used as keys. All keys must have the same
    size. Array keys are passed into hashing functions using the address
    of the first int in the array.</p>
<p><strong>Tcl_DeleteHashTable</strong> deletes all of the entries in a hash table and
frees up the memory associated with the table\'s bucket array and
entries. It does not free the actual table structure (pointed to by
<em>tablePtr</em>), since that memory is assumed to be managed by the client.
<strong>Tcl_DeleteHashTable</strong> also does not free or otherwise manipulate the
values of the hash table entries. If the entry values point to
dynamically-allocated memory, then it is the client\'s responsibility to
free these structures before deleting the table.</p>
<p><strong>Tcl_CreateHashEntry</strong> locates the entry corresponding to a particular
key, creating a new entry in the table if there was not already one with
the given key. If an entry already existed with the given key then
<em>*newPtr</em> is set to zero. If a new entry was created, then <em>*newPtr</em>
is set to a non-zero value and the value of the new entry will be set to
zero. The return value from <strong>Tcl_CreateHashEntry</strong> is a pointer to the
entry, which may be used to retrieve and modify the entry\'s value or to
delete the entry from the table.</p>
<p><strong>Tcl_DeleteHashEntry</strong> will remove an existing entry from a table. The
memory associated with the entry itself will be freed, but the client is
responsible for any cleanup associated with the entry\'s value, such as
freeing a structure that it points to.</p>
<p><strong>Tcl_FindHashEntry</strong> is similar to <strong>Tcl_CreateHashEntry</strong> except that
it does not create a new entry if the key doesn\'t exist; instead, it
returns NULL as result.</p>
<p><strong>Tcl_GetHashValue</strong> and <strong>Tcl_SetHashValue</strong> are used to read and write
an entry\'s value, respectively. Values are stored and retrieved as type
which is large enough to hold a pointer value. On almost all machines
this is large enough to hold an integer value too.</p>
<p><strong>Tcl_GetHashKey</strong> returns the key for a given hash table entry, either
as a pointer to a string, a one-word key, or as a pointer to the first
word of an array of integers, depending on the <em>keyType</em> used to create
a hash table. In all cases <strong>Tcl_GetHashKey</strong> returns a result with type
When the key is a string or array, the result of <strong>Tcl_GetHashKey</strong>
points to information in the table entry; this information will remain
valid until the entry is deleted or its table is deleted.</p>
<p><strong>Tcl_FirstHashEntry</strong> and <strong>Tcl_NextHashEntry</strong> may be used to scan all
of the entries in a hash table. A structure of type provided by the
client, is used to keep track of progress through the table.
<strong>Tcl_FirstHashEntry</strong> initializes the search record and returns the
first entry in the table (or NULL if the table is empty). Each
subsequent call to <strong>Tcl_NextHashEntry</strong> returns the next entry in the
table or NULL if the end of the table has been reached. A call to
<strong>Tcl_FirstHashEntry</strong> followed by calls to <strong>Tcl_NextHashEntry</strong> will
return each of the entries in the table exactly once, in an arbitrary
order. It is inadvisable to modify the structure of the table, e.g. by
creating or deleting entries, while the search is in progress, with the
exception of deleting the entry returned by <strong>Tcl_FirstHashEntry</strong> or
<strong>Tcl_NextHashEntry</strong>.</p>
<p><strong>Tcl_HashStats</strong> returns a dynamically-allocated string with overall
information about a hash table, such as the number of entries it
contains, the number of buckets in its hash array, and the utilization
of the buckets. It is the caller\'s responsibility to free the result
string by passing it to <strong>ckfree</strong>.</p>
<p>The header file <strong>tcl.h</strong> defines the actual data structures used to
implement hash tables. This is necessary so that clients can allocate
Tcl_HashTable structures and so that macros can be used to read and
write the values of entries. However, users of the hashing routines
should never refer directly to any of the fields of any of the
hash-related data structures; use the procedures and macros defined
here.</p>
<h1 id="the-tcl_hashkeytype-structure">THE TCL_HASHKEYTYPE STRUCTURE</h1>
<p>Extension writers can define new hash key types by defining four
procedures, initializing a <strong>Tcl_HashKeyType</strong> structure to describe the
type, and calling <strong>Tcl_InitCustomHashTable</strong>. The <strong>Tcl_HashKeyType</strong>
structure is defined as follows:</p>
<div class="language-text highlight"><pre><span></span><code>typedef struct Tcl_HashKeyType {
    int version;
    int flags;
    Tcl_HashKeyProc *hashKeyProc;
    Tcl_CompareHashKeysProc *compareKeysProc;
    Tcl_AllocHashEntryProc *allocEntryProc;
    Tcl_FreeHashEntryProc *freeEntryProc;
} Tcl_HashKeyType;
</code></pre></div>
<p>The <em>version</em> member is the version of the table. If this structure is
extended in future then the version can be used to distinguish between
different structures. It should be set to <strong>TCL_HASH_KEY_TYPE_VERSION</strong>.</p>
<p>The <em>flags</em> member is 0 or one or more of the following values OR\'ed
together:</p>
<p>TCL_HASH_KEY_RANDOMIZE_HASH</p>
<p>:   There are some things, pointers for example which do not hash well
    because they do not use the lower bits. If this flag is set then the
    hash table will attempt to rectify this by randomizing the bits and
    then using the upper N bits as the index into the table.</p>
<p>TCL_HASH_KEY_SYSTEM_HASH</p>
<p>:   This flag forces Tcl to use the memory allocation procedures
    provided by the operating system when allocating and freeing memory
    used to store the hash table data structures, and not any of Tcl\'s
    own customized memory allocation routines. This is important if the
    hash table is to be used in the implementation of a custom set of
    allocation routines, or something that a custom set of allocation
    routines might depend on, in order to avoid any circular dependency.</p>
<p>The <em>hashKeyProc</em> member contains the address of a function called to
calculate a hash value for the key.</p>
<div class="language-text highlight"><pre><span></span><code>typedef unsigned int Tcl_HashKeyProc(
        Tcl_HashTable *tablePtr,
        void *keyPtr);
</code></pre></div>
<p>If this is NULL then <em>keyPtr</em> is used and
<strong>TCL_HASH_KEY_RANDOMIZE_HASH</strong> is assumed.</p>
<p>The <em>compareKeysProc</em> member contains the address of a function called
to compare two keys.</p>
<div class="language-text highlight"><pre><span></span><code>typedef int Tcl_CompareHashKeysProc(
        void *keyPtr,
        Tcl_HashEntry *hPtr);
</code></pre></div>
<p>If this is NULL then the <em>keyPtr</em> pointers are compared. If the keys do
not match then the function returns 0, otherwise it returns 1.</p>
<p>The <em>allocEntryProc</em> member contains the address of a function called to
allocate space for an entry and initialize the key and clientData.</p>
<div class="language-text highlight"><pre><span></span><code>typedef Tcl_HashEntry *Tcl_AllocHashEntryProc(
        Tcl_HashTable *tablePtr,
        void *keyPtr);
</code></pre></div>
<p>If this is NULL then <strong>Tcl_Alloc</strong> is used to allocate enough space for
a Tcl_HashEntry, the key pointer is assigned to key.oneWordValue and the
clientData is set to NULL. String keys and array keys use this function
to allocate enough space for the entry and the key in one block, rather
than doing it in two blocks. This saves space for a pointer to the key
from the entry and another memory allocation. Tcl_Obj* keys use this
function to allocate enough space for an entry and increment the
reference count on the value.</p>
<p>The <em>freeEntryProc</em> member contains the address of a function called to
free space for an entry.</p>
<div class="language-text highlight"><pre><span></span><code>typedef void Tcl_FreeHashEntryProc(
        Tcl_HashEntry *hPtr);
</code></pre></div>
<p>If this is NULL then <strong>Tcl_Free</strong> is used to free the space for the
entry. Tcl_Obj* keys use this function to decrement the reference count
on the value.</p>
<h1 id="keywords">KEYWORDS</h1>
<p>hash table, key, lookup, search, value</p>

<ul class="metadata page-metadata" data-bi-name="page info" lang="en-us" dir="ltr">
  <li class="last-updated-holder displayDate loading">
    <span class="last-updated-text">Last updated:</span>
    <time role="presentation" datetime="2018-10-25T00:00:00.000Z" data-article-date-source="ms.date"></time>
  </li>
<!--
  <li class="readingTime">
    2 minutes to read
  </li>
-->
  <li class="contributors-holder">
    <span class="contributors-text">Contributors</span>
    <ul class="contributors" data-bi-name="contributors"></ul>
  </li>
</ul>
</div>
        <div class="col-md-3"><div class="navbar-light navbar-expand-md hidden-print sticky-top sticky-offset" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    <div id="toc-collapse" class="navbar-collapse collapse card">
        <ul class="nav flex-column bs-sidenav">
            <li class="nav-item main"><a class="nav-link" href="#name">NAME</a></li>
            <li class="nav-item main"><a class="nav-link" href="#synopsis">SYNOPSIS</a></li>
            <li class="nav-item main"><a class="nav-link" href="#arguments">ARGUMENTS</a></li>
            <li class="nav-item main"><a class="nav-link" href="#description">DESCRIPTION</a></li>
            <li class="nav-item main"><a class="nav-link" href="#the-tcl_hashkeytype-structure">THE TCL_HASHKEYTYPE STRUCTURE</a></li>
            <li class="nav-item main"><a class="nav-link" href="#keywords">KEYWORDS</a></li>
        </ul>
    </div>
</div></div>
      </div>
      </div>

      <footer class="col-md-12">
	<hr>
	<div class="container">
	</div>
      </footer>
      <script>
	var base_url = "../..",
            shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
      </script>
      <script src="../../js/base.js" defer></script>
      <script src="../../search/main.js" defer></script>

      <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <p class="h4 modal-title">Keyboard Shortcuts</p>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
