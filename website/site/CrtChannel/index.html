<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://www.tcl.tk/man/tcl8.6.13/TclCmd/contents.html/CrtChannel/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>NAME - Tcl/Tk</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "NAME";
        var mkdocs_page_input_path = "CrtChannel.md";
        var mkdocs_page_url = "/man/tcl8.6.13/TclCmd/contents.html/CrtChannel/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Tcl/Tk
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="" href="../command.md">Commands</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Tcl/Tk</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>NAME</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="name">NAME</h1>
<p>Tcl_CreateChannel, Tcl_GetChannelInstanceData, Tcl_GetChannelType,
Tcl_GetChannelName, Tcl_GetChannelHandle, Tcl_GetChannelMode,
Tcl_GetChannelBufferSize, Tcl_SetChannelBufferSize, Tcl_NotifyChannel,
Tcl_BadChannelOption, Tcl_ChannelName, Tcl_ChannelVersion,
Tcl_ChannelBlockModeProc, Tcl_ChannelClose2Proc, Tcl_ChannelInputProc,
Tcl_ChannelOutputProc, Tcl_ChannelWideSeekProc, Tcl_ChannelTruncateProc,
Tcl_ChannelSetOptionProc, Tcl_ChannelGetOptionProc,
Tcl_ChannelWatchProc, Tcl_ChannelGetHandleProc, Tcl_ChannelFlushProc,
Tcl_ChannelHandlerProc, Tcl_ChannelThreadActionProc,
Tcl_IsChannelShared, Tcl_IsChannelRegistered, Tcl_CutChannel,
Tcl_SpliceChannel, Tcl_IsChannelExisting, Tcl_ClearChannelHandlers,
Tcl_GetChannelThread, Tcl_ChannelBuffered - procedures for creating and
manipulating channels</p>
<h1 id="synopsis">SYNOPSIS</h1>
<pre><code>#include &lt;tcl.h&gt;

Tcl_Channel
Tcl_CreateChannel(typePtr, channelName, instanceData, mask)

void *
Tcl_GetChannelInstanceData(channel)

const Tcl_ChannelType *
Tcl_GetChannelType(channel)

const char *
Tcl_GetChannelName(channel)

int
Tcl_GetChannelHandle(channel, direction, handlePtr)

Tcl_ThreadId
Tcl_GetChannelThread(channel)

int
Tcl_GetChannelMode(channel)

int
Tcl_RemoveChannelMode(interp, channel, mode)

int
Tcl_GetChannelBufferSize(channel)

Tcl_SetChannelBufferSize(channel, size)

Tcl_NotifyChannel(channel, mask)

int
Tcl_BadChannelOption(interp, optionName, optionList)

int
Tcl_IsChannelShared(channel)

int
Tcl_IsChannelRegistered(interp, channel)

int
Tcl_IsChannelExisting(channelName)

void
Tcl_CutChannel(channel)

void
Tcl_SpliceChannel(channel)

void
Tcl_ClearChannelHandlers(channel)

int
Tcl_ChannelBuffered(channel)

const char *
Tcl_ChannelName(typePtr)

Tcl_ChannelTypeVersion
Tcl_ChannelVersion(typePtr)

Tcl_DriverBlockModeProc *
Tcl_ChannelBlockModeProc(typePtr)

Tcl_DriverClose2Proc *
Tcl_ChannelClose2Proc(typePtr)

Tcl_DriverInputProc *
Tcl_ChannelInputProc(typePtr)

Tcl_DriverOutputProc *
Tcl_ChannelOutputProc(typePtr)

Tcl_DriverWideSeekProc *
Tcl_ChannelWideSeekProc(typePtr)

Tcl_DriverThreadActionProc *
Tcl_ChannelThreadActionProc(typePtr)

Tcl_DriverTruncateProc *
Tcl_ChannelTruncateProc(typePtr)

Tcl_DriverSetOptionProc *
Tcl_ChannelSetOptionProc(typePtr)

Tcl_DriverGetOptionProc *
Tcl_ChannelGetOptionProc(typePtr)

Tcl_DriverWatchProc *
Tcl_ChannelWatchProc(typePtr)

Tcl_DriverGetHandleProc *
Tcl_ChannelGetHandleProc(typePtr)

Tcl_DriverFlushProc *
Tcl_ChannelFlushProc(typePtr)

Tcl_DriverHandlerProc *
Tcl_ChannelHandlerProc(typePtr)
</code></pre>
<h1 id="arguments">ARGUMENTS</h1>
<p>Points to a structure containing the addresses of procedures that can be
called to perform I/O and other functions on the channel.</p>
<p>The name of this channel, such as <strong>file3</strong>; must not be in use by any
other channel. Can be NULL, in which case the channel is created without
a name. If the created channel is assigned to one of the standard
channels (<strong>stdin</strong>, <strong>stdout</strong> or <strong>stderr</strong>), the assigned channel
name will be the name of the standard channel.</p>
<p>Arbitrary one-word value to be associated with this channel. This value
is passed to procedures in <em>typePtr</em> when they are invoked.</p>
<p>OR-ed combination of <strong>TCL_READABLE</strong> and <strong>TCL_WRITABLE</strong> to indicate
whether a channel is readable and writable.</p>
<p>The channel to operate on.</p>
<p><strong>TCL_READABLE</strong> means the input handle is wanted; <strong>TCL_WRITABLE</strong>
means the output handle is wanted.</p>
<p>Points to the location where the desired OS-specific handle should be
stored.</p>
<p>The size, in bytes, of buffers to allocate in this channel.</p>
<p>An OR-ed combination of <strong>TCL_READABLE</strong>, <strong>TCL_WRITABLE</strong> and
<strong>TCL_EXCEPTION</strong> that indicates events that have occurred on this
channel.</p>
<p>Current interpreter. (can be NULL)</p>
<p>Name of the invalid option.</p>
<p>Specific options list (space separated words, without</p>
<p>to append to the standard generic options list. Can be NULL for generic
options error message only.</p>
<h1 id="description">DESCRIPTION</h1>
<p>Tcl uses a two-layered channel architecture. It provides a generic upper
layer to enable C and Tcl programs to perform input and output using the
same APIs for a variety of files, devices, sockets etc. The generic C
APIs are described in the manual entry for <strong>Tcl_OpenFileChannel</strong>.</p>
<p>The lower layer provides type-specific channel drivers for each type of
device supported on each platform. This manual entry describes the C
APIs used to communicate between the generic layer and the type-specific
channel drivers. It also explains how new types of channels can be added
by providing new channel drivers.</p>
<p>Channel drivers consist of a number of components: First, each channel
driver provides a <strong>Tcl_ChannelType</strong> structure containing pointers to
functions implementing the various operations used by the generic layer
to communicate with the channel driver. The <strong>Tcl_ChannelType</strong>
structure and the functions referenced by it are described in the
section <strong>TCL_CHANNELTYPE</strong>, below.</p>
<p>Second, channel drivers usually provide a Tcl command to create
instances of that type of channel. For example, the Tcl <strong>open</strong> command
creates channels that use the file and command channel drivers, and the
Tcl <strong>socket</strong> command creates channels that use TCP sockets for network
communication.</p>
<p>Third, a channel driver optionally provides a C function to open channel
instances of that type. For example, <strong>Tcl_OpenFileChannel</strong> opens a
channel that uses the file channel driver, and <strong>Tcl_OpenTcpClient</strong>
opens a channel that uses the TCP network protocol. These creation
functions typically use <strong>Tcl_CreateChannel</strong> internally to open the
channel.</p>
<p>To add a new type of channel you must implement a C API or a Tcl command
that opens a channel by invoking <strong>Tcl_CreateChannel</strong>. When your driver
calls <strong>Tcl_CreateChannel</strong> it passes in a <strong>Tcl_ChannelType</strong> structure
describing the driver\'s I/O procedures. The generic layer will then
invoke the functions referenced in that structure to perform operations
on the channel.</p>
<p><strong>Tcl_CreateChannel</strong> opens a new channel and associates the supplied
<em>typePtr</em> and <em>instanceData</em> with it. The channel is opened in the mode
indicated by <em>mask</em>. For a discussion of channel drivers, their
operations and the <strong>Tcl_ChannelType</strong> structure, see the section
<strong>TCL_CHANNELTYPE</strong>, below.</p>
<p><strong>Tcl_CreateChannel</strong> interacts with the code managing the standard
channels. Once a standard channel was initialized either through a call
to <strong>Tcl_GetStdChannel</strong> or a call to <strong>Tcl_SetStdChannel</strong> closing this
standard channel will cause the next call to <strong>Tcl_CreateChannel</strong> to
make the new channel the new standard channel too. See
<strong>Tcl_StandardChannels</strong> for a general treatise about standard channels
and the behavior of the Tcl library with regard to them.</p>
<p><strong>Tcl_GetChannelInstanceData</strong> returns the instance data associated with
the channel in <em>channel</em>. This is the same as the <em>instanceData</em>
argument in the call to <strong>Tcl_CreateChannel</strong> that created this channel.</p>
<p><strong>Tcl_GetChannelType</strong> returns a pointer to the <strong>Tcl_ChannelType</strong>
structure used by the channel in the <em>channel</em> argument. This is the
same as the <em>typePtr</em> argument in the call to <strong>Tcl_CreateChannel</strong> that
created this channel.</p>
<p><strong>Tcl_GetChannelName</strong> returns a string containing the name associated
with the channel, or NULL if the <em>channelName</em> argument to
<strong>Tcl_CreateChannel</strong> was NULL.</p>
<p><strong>Tcl_GetChannelHandle</strong> places the OS-specific device handle associated
with <em>channel</em> for the given <em>direction</em> in the location specified by
<em>handlePtr</em> and returns <strong>TCL_OK</strong>. If the channel does not have a
device handle for the specified direction, then <strong>TCL_ERROR</strong> is
returned instead. Different channel drivers will return different types
of handle. Refer to the manual entries for each driver to determine what
type of handle is returned.</p>
<p><strong>Tcl_GetChannelThread</strong> returns the id of the thread currently managing
the specified <em>channel</em>. This allows channel drivers to send their file
events to the correct event queue even for a multi-threaded core.</p>
<p><strong>Tcl_GetChannelMode</strong> returns an OR-ed combination of <strong>TCL_READABLE</strong>
and <strong>TCL_WRITABLE</strong>, indicating whether the channel is open for input
and output.</p>
<p><strong>Tcl_RemoveChannelMode</strong> removes an access privilege from the channel,
either <strong>TCL_READABLE</strong> or <strong>TCL_WRITABLE</strong>, and returns a regular Tcl
result code, <strong>TCL_OK</strong>, or <strong>TCL_ERROR</strong>. The function throws an error
if either an invalid mode is specified or the result of the removal
would be an inaccessible channel. In that case an error message is left
in the interp argument, if not NULL.</p>
<p><strong>Tcl_GetChannelBufferSize</strong> returns the size, in bytes, of buffers
allocated to store input or output in <em>channel</em>. If the value was not
set by a previous call to <strong>Tcl_SetChannelBufferSize</strong>, described below,
then the default value of 4096 is returned.</p>
<p><strong>Tcl_SetChannelBufferSize</strong> sets the size, in bytes, of buffers that
will be allocated in subsequent operations on the channel to store input
or output. The <em>size</em> argument should be between one and one million,
allowing buffers of one byte to one million bytes. If <em>size</em> is outside
this range, <strong>Tcl_SetChannelBufferSize</strong> sets the buffer size to 4096.</p>
<p><strong>Tcl_NotifyChannel</strong> is called by a channel driver to indicate to the
generic layer that the events specified by <em>mask</em> have occurred on the
channel. Channel drivers are responsible for invoking this function
whenever the channel handlers need to be called for the channel (or
other pending tasks like a write flush should be performed). See
<strong>WATCHPROC</strong> below for more details.</p>
<p><strong>Tcl_BadChannelOption</strong> is called from driver specific <em>setOptionProc</em>
or <em>getOptionProc</em> to generate a complete error message.</p>
<p><strong>Tcl_ChannelBuffered</strong> returns the number of bytes of input currently
buffered in the internal buffer (push back area) of the channel itself.
It does not report about the data in the overall buffers for the stack
of channels the supplied channel is part of.</p>
<p><strong>Tcl_IsChannelShared</strong> checks the refcount of the specified <em>channel</em>
and returns whether the <em>channel</em> was shared among multiple interpreters
(result == 1) or not (result == 0).</p>
<p><strong>Tcl_IsChannelRegistered</strong> checks whether the specified <em>channel</em> is
registered in the given <em>interp</em>reter (result == 1) or not (result ==
0).</p>
<p><strong>Tcl_IsChannelExisting</strong> checks whether a channel with the specified
name is registered in the (thread)-global list of all channels (result
== 1) or not (result == 0).</p>
<p><strong>Tcl_CutChannel</strong> removes the specified <em>channel</em> from the
(thread)global list of all channels (of the current thread). Application
to a channel still registered in some interpreter is not allowed. Also
notifies the driver if <strong>Tcl_DriverThreadActionProc</strong> is defined for it.</p>
<p><strong>Tcl_SpliceChannel</strong> adds the specified <em>channel</em> to the (thread)global
list of all channels (of the current thread). Application to a channel
registered in some interpreter is not allowed. Also notifies the driver
if <strong>Tcl_DriverThreadActionProc</strong> is defined for it.</p>
<p><strong>Tcl_ClearChannelHandlers</strong> removes all channel handlers and event
scripts associated with the specified <em>channel</em>, thus shutting down all
event processing for this channel.</p>
<h1 id="tcl_channeltype">TCL_CHANNELTYPE</h1>
<p>A channel driver provides a <strong>Tcl_ChannelType</strong> structure that contains
pointers to functions that implement the various operations on a
channel; these operations are invoked as needed by the generic layer.
The structure was versioned starting in Tcl 8.3.2/8.4 to correct a
problem with stacked channel drivers. See the <strong>OLD CHANNEL TYPES</strong>
section below for details about the old structure.</p>
<p>The <strong>Tcl_ChannelType</strong> structure contains the following fields:</p>
<p>typedef struct Tcl_ChannelType { const char *<em>typeName</em>;
Tcl_ChannelTypeVersion <em>version</em>; void *<em>closeProc</em>; /* Not used any
more*/ Tcl_DriverInputProc *<em>inputProc</em>; Tcl_DriverOutputProc
*<em>outputProc</em>; void *<em>seekProc</em>; /* Not used any more */
Tcl_DriverSetOptionProc *<em>setOptionProc</em>; Tcl_DriverGetOptionProc
*<em>getOptionProc</em>; Tcl_DriverWatchProc *<em>watchProc</em>;
Tcl_DriverGetHandleProc *<em>getHandleProc</em>; Tcl_DriverClose2Proc
*<em>close2Proc</em>; Tcl_DriverBlockModeProc *<em>blockModeProc</em>;
Tcl_DriverFlushProc *<em>flushProc</em>; Tcl_DriverHandlerProc
*<em>handlerProc</em>; Tcl_DriverWideSeekProc *<em>wideSeekProc</em>;
Tcl_DriverThreadActionProc *<em>threadActionProc</em>; Tcl_DriverTruncateProc
*<em>truncateProc</em>; } <strong>Tcl_ChannelType</strong>;</p>
<p>It is not necessary to provide implementations for all channel
operations. Those which are not necessary may be set to NULL in the
struct: <em>blockModeProc</em>, <em>seekProc</em>, <em>setOptionProc</em>, <em>getOptionProc</em>,
<em>getHandleProc</em>, and <em>close2Proc</em>, in addition to <em>flushProc</em>,
<em>handlerProc</em>, <em>threadActionProc</em>, and <em>truncateProc</em>. Other functions
that cannot be implemented in a meaningful way should return <strong>EINVAL</strong>
when called, to indicate that the operations they represent are not
available. Also note that <em>wideSeekProc</em> can be NULL if <em>seekProc</em> is.</p>
<p>The user should only use the above structure for <strong>Tcl_ChannelType</strong>
instantiation. When referencing fields in a <strong>Tcl_ChannelType</strong>
structure, the following functions should be used to obtain the values:
<strong>Tcl_ChannelName</strong>, <strong>Tcl_ChannelVersion</strong>,
<strong>Tcl_ChannelBlockModeProc</strong>, <strong>Tcl_ChannelClose2Proc</strong>,
<strong>Tcl_ChannelInputProc</strong>, <strong>Tcl_ChannelOutputProc</strong>,
<strong>Tcl_ChannelWideSeekProc</strong>, <strong>Tcl_ChannelThreadActionProc</strong>,
<strong>Tcl_ChannelTruncateProc</strong>, <strong>Tcl_ChannelSetOptionProc</strong>,
<strong>Tcl_ChannelGetOptionProc</strong>, <strong>Tcl_ChannelWatchProc</strong>,
<strong>Tcl_ChannelGetHandleProc</strong>, <strong>Tcl_ChannelFlushProc</strong>, or
<strong>Tcl_ChannelHandlerProc</strong>.</p>
<p>The change to the structures was made in such a way that standard
channel types are binary compatible. However, channel types that use
stacked channels (i.e. TLS, Trf) have new versions to correspond to the
above change since the previous code for stacked channels had problems.</p>
<h2 id="typename">TYPENAME</h2>
<p>The <em>typeName</em> field contains a null-terminated string that identifies
the type of the device implemented by this driver, e.g. <strong>file</strong> or
<strong>socket</strong>.</p>
<p>This value can be retrieved with <strong>Tcl_ChannelName</strong>, which returns a
pointer to the string.</p>
<h2 id="version">VERSION</h2>
<p>The <em>version</em> field should be set to the version of the structure that
you require. <strong>TCL_CHANNEL_VERSION_5</strong> is the minimum supported.</p>
<p>This value can be retrieved with <strong>Tcl_ChannelVersion</strong>.</p>
<h2 id="blockmodeproc">BLOCKMODEPROC</h2>
<p>The <em>blockModeProc</em> field contains the address of a function called by
the generic layer to set blocking and nonblocking mode on the device.
<em>BlockModeProc</em> should match the following prototype:</p>
<p>typedef int <strong>Tcl_DriverBlockModeProc</strong>( void *<em>instanceData</em>, int
<em>mode</em>);</p>
<p>The <em>instanceData</em> is the same as the value passed to
<strong>Tcl_CreateChannel</strong> when this channel was created. The <em>mode</em> argument
is either <strong>TCL_MODE_BLOCKING</strong> or <strong>TCL_MODE_NONBLOCKING</strong> to set the
device into blocking or nonblocking mode. The function should return
zero if the operation was successful, or a nonzero POSIX error code if
the operation failed.</p>
<p>If the operation is successful, the function can modify the supplied
<em>instanceData</em> to record that the channel entered blocking or
nonblocking mode and to implement the blocking or nonblocking behavior.
For some device types, the blocking and nonblocking behavior can be
implemented by the underlying operating system; for other device types,
the behavior must be emulated in the channel driver.</p>
<p>This value can be retrieved with <strong>Tcl_ChannelBlockModeProc</strong>, which
returns a pointer to the function.</p>
<p>A channel driver <strong>not</strong> supplying a <em>blockModeProc</em> has to be very,
very careful. It has to tell the generic layer exactly which blocking
mode is acceptable to it, and should this also document for the user so
that the blocking mode of the channel is not changed to an unacceptable
value. Any confusion here may lead the interpreter into a (spurious and
difficult to find) deadlock.</p>
<h2 id="close2proc">CLOSE2PROC</h2>
<p>The <em>close2Proc</em> field contains the address of a function called by the
generic layer to clean up driver-related information when the channel is
closed. <em>Close2Proc</em> must match the following prototype:</p>
<p>typedef int <strong>Tcl_DriverClose2Proc</strong>( void *<em>instanceData</em>, Tcl_Interp
*<em>interp</em>, int <em>flags</em>);</p>
<p>If <em>flags</em> is 0, the <em>instanceData</em> argument is the same as the value
provided to <strong>Tcl_CreateChannel</strong> when the channel was created. The
function should release any storage maintained by the channel driver for
this channel, and close the input and output devices encapsulated by
this channel. All queued output will have been flushed to the device
before this function is called, and no further driver operations will be
invoked on this instance after calling the <em>closeProc</em>. If the close
operation is successful, the procedure should return zero; otherwise it
should return a nonzero POSIX error code. In addition, if an error
occurs and <em>interp</em> is not NULL, the procedure should store an error
message in the interpreter\'s result.</p>
<p>Alternatively, channels that support closing the read and write sides
independently may accept other flag values than 0. Then <em>close2Proc</em>
will be called with <em>flags</em> set to an OR\'ed combination of
<strong>TCL_CLOSE_READ</strong> or <strong>TCL_CLOSE_WRITE</strong> to indicate that the driver
should close the read and/or write side of the channel. The channel
driver may be invoked to perform additional operations on the channel
after <em>close2Proc</em> is called to close one or both sides of the channel.
In all cases, the <em>close2Proc</em> function should return zero if the close
operation was successful; otherwise it should return a nonzero POSIX
error code. In addition, if an error occurs and <em>interp</em> is not NULL,
the procedure should store an error message in the interpreter\'s
result.</p>
<p>The <em>close2Proc</em> value can be retrieved with <strong>Tcl_ChannelClose2Proc</strong>,
which returns a pointer to the function.</p>
<h2 id="inputproc">INPUTPROC</h2>
<p>The <em>inputProc</em> field contains the address of a function called by the
generic layer to read data from the file or device and store it in an
internal buffer. <em>InputProc</em> must match the following prototype:</p>
<p>typedef int <strong>Tcl_DriverInputProc</strong>( void *<em>instanceData</em>, char
*<em>buf</em>, int <em>bufSize</em>, int *<em>errorCodePtr</em>);</p>
<p><em>InstanceData</em> is the same as the value passed to <strong>Tcl_CreateChannel</strong>
when the channel was created. The <em>buf</em> argument points to an array of
bytes in which to store input from the device, and the <em>bufSize</em>
argument indicates how many bytes are available at <em>buf</em>.</p>
<p>The <em>errorCodePtr</em> argument points to an integer variable provided by
the generic layer. If an error occurs, the function should set the
variable to a POSIX error code that identifies the error that occurred.</p>
<p>The function should read data from the input device encapsulated by the
channel and store it at <em>buf</em>. On success, the function should return a
nonnegative integer indicating how many bytes were read from the input
device and stored at <em>buf</em>. On error, the function should return -1. If
an error occurs after some data has been read from the device, that data
is lost.</p>
<p>If <em>inputProc</em> can determine that the input device has some data
available but less than requested by the <em>bufSize</em> argument, the
function should only attempt to read as much data as is available and
return without blocking. If the input device has no data available
whatsoever and the channel is in nonblocking mode, the function should
return an <strong>EAGAIN</strong> error. If the input device has no data available
whatsoever and the channel is in blocking mode, the function should
block for the shortest possible time until at least one byte of data can
be read from the device; then, it should return as much data as it can
read without blocking.</p>
<p>This value can be retrieved with <strong>Tcl_ChannelInputProc</strong>, which returns
a pointer to the function.</p>
<h2 id="outputproc">OUTPUTPROC</h2>
<p>The <em>outputProc</em> field contains the address of a function called by the
generic layer to transfer data from an internal buffer to the output
device. <em>OutputProc</em> must match the following prototype:</p>
<p>typedef int <strong>Tcl_DriverOutputProc</strong>( void *<em>instanceData</em>, const char
*<em>buf</em>, int <em>toWrite</em>, int *<em>errorCodePtr</em>);</p>
<p><em>InstanceData</em> is the same as the value passed to <strong>Tcl_CreateChannel</strong>
when the channel was created. The <em>buf</em> argument contains an array of
bytes to be written to the device, and the <em>toWrite</em> argument indicates
how many bytes are to be written from the <em>buf</em> argument.</p>
<p>The <em>errorCodePtr</em> argument points to an integer variable provided by
the generic layer. If an error occurs, the function should set this
variable to a POSIX error code that identifies the error.</p>
<p>The function should write the data at <em>buf</em> to the output device
encapsulated by the channel. On success, the function should return a
nonnegative integer indicating how many bytes were written to the output
device. The return value is normally the same as <em>toWrite</em>, but may be
less in some cases such as if the output operation is interrupted by a
signal. If an error occurs the function should return -1. In case of
error, some data may have been written to the device.</p>
<p>If the channel is nonblocking and the output device is unable to absorb
any data whatsoever, the function should return -1 with an <strong>EAGAIN</strong>
error without writing any data.</p>
<p>This value can be retrieved with <strong>Tcl_ChannelOutputProc</strong>, which
returns a pointer to the function.</p>
<h2 id="wideseekproc">WIDESEEKPROC</h2>
<p>The <em>wideSeekProc</em> field contains the address of a function called by
the generic layer to move the access point at which subsequent input or
output operations will be applied. <em>WideSeekProc</em> must match the
following prototype:</p>
<p>typedef long long <strong>Tcl_DriverWideSeekProc</strong>( void *<em>instanceData</em>,
long long <em>offset</em>, int <em>seekMode</em>, int *<em>errorCodePtr</em>);</p>
<p>The <em>instanceData</em> argument is the same as the value given to
<strong>Tcl_CreateChannel</strong> when this channel was created. <em>Offset</em> and
<em>seekMode</em> have the same meaning as for the <strong>Tcl_Seek</strong> procedure
(described in the manual entry for <strong>Tcl_OpenFileChannel</strong>).</p>
<p>The <em>errorCodePtr</em> argument points to an integer variable provided by
the generic layer for returning <strong>errno</strong> values from the function. The
function should set this variable to a POSIX error code if an error
occurs. The function should store an <strong>EINVAL</strong> error code if the
channel type does not implement seeking.</p>
<p>The return value is the new access point or -1 in case of error. If an
error occurred, the function should not move the access point.</p>
<p>The <em>wideSseekProc</em> value can be retrieved with
<strong>Tcl_ChannelWideSeekProc</strong>, which returns a pointer to the function.</p>
<h2 id="setoptionproc">SETOPTIONPROC</h2>
<p>The <em>setOptionProc</em> field contains the address of a function called by
the generic layer to set a channel type specific option on a channel.
<em>setOptionProc</em> must match the following prototype:</p>
<p>typedef int <strong>Tcl_DriverSetOptionProc</strong>( void *<em>instanceData</em>,
Tcl_Interp *<em>interp</em>, const char *<em>optionName</em>, const char
*<em>newValue</em>);</p>
<p><em>optionName</em> is the name of an option to set, and <em>newValue</em> is the new
value for that option, as a string. The <em>instanceData</em> is the same as
the value given to <strong>Tcl_CreateChannel</strong> when this channel was created.
The function should do whatever channel type specific action is required
to implement the new value of the option.</p>
<p>Some options are handled by the generic code and this function is never
called to set them, e.g. <strong>-blockmode</strong>. Other options are specific to
each channel type and the <em>setOptionProc</em> procedure of the channel
driver will get called to implement them. The <em>setOptionProc</em> field can
be NULL, which indicates that this channel type supports no type
specific options.</p>
<p>If the option value is successfully modified to the new value, the
function returns <strong>TCL_OK</strong>. It should call <strong>Tcl_BadChannelOption</strong>
which itself returns <strong>TCL_ERROR</strong> if the <em>optionName</em> is unrecognized.
If <em>newValue</em> specifies a value for the option that is not supported or
if a system call error occurs, the function should leave an error
message in the result of <em>interp</em> if <em>interp</em> is not NULL. The function
should also call <strong>Tcl_SetErrno</strong> to store an appropriate POSIX error
code.</p>
<p>This value can be retrieved with <strong>Tcl_ChannelSetOptionProc</strong>, which
returns a pointer to the function.</p>
<h2 id="getoptionproc">GETOPTIONPROC</h2>
<p>The <em>getOptionProc</em> field contains the address of a function called by
the generic layer to get the value of a channel type specific option on
a channel. <em>getOptionProc</em> must match the following prototype:</p>
<p>typedef int <strong>Tcl_DriverGetOptionProc</strong>( void *<em>instanceData</em>,
Tcl_Interp *<em>interp</em>, const char *<em>optionName</em>, Tcl_DString
*<em>optionValue</em>);</p>
<p><em>OptionName</em> is the name of an option supported by this type of channel.
If the option name is not NULL, the function stores its current value,
as a string, in the Tcl dynamic string <em>optionValue</em>. If <em>optionName</em> is
NULL, the function stores in <em>optionValue</em> an alternating list of all
supported options and their current values. On success, the function
returns <strong>TCL_OK</strong>. It should call <strong>Tcl_BadChannelOption</strong> which itself
returns <strong>TCL_ERROR</strong> if the <em>optionName</em> is unrecognized. If a system
call error occurs, the function should leave an error message in the
result of <em>interp</em> if <em>interp</em> is not NULL. The function should also
call <strong>Tcl_SetErrno</strong> to store an appropriate POSIX error code.</p>
<p>Some options are handled by the generic code and this function is never
called to retrieve their value, e.g. <strong>-blockmode</strong>. Other options are
specific to each channel type and the <em>getOptionProc</em> procedure of the
channel driver will get called to implement them. The <em>getOptionProc</em>
field can be NULL, which indicates that this channel type supports no
type specific options.</p>
<p>This value can be retrieved with <strong>Tcl_ChannelGetOptionProc</strong>, which
returns a pointer to the function.</p>
<h2 id="watchproc">WATCHPROC</h2>
<p>The <em>watchProc</em> field contains the address of a function called by the
generic layer to initialize the event notification mechanism to notice
events of interest on this channel. <em>WatchProc</em> should match the
following prototype:</p>
<p>typedef void <strong>Tcl_DriverWatchProc</strong>( void *<em>instanceData</em>, int
<em>mask</em>);</p>
<p>The <em>instanceData</em> is the same as the value passed to
<strong>Tcl_CreateChannel</strong> when this channel was created. The <em>mask</em> argument
is an OR-ed combination of <strong>TCL_READABLE</strong>, <strong>TCL_WRITABLE</strong> and
<strong>TCL_EXCEPTION</strong>; it indicates events the caller is interested in
noticing on this channel.</p>
<p>The function should initialize device type specific mechanisms to notice
when an event of interest is present on the channel. When one or more of
the designated events occurs on the channel, the channel driver is
responsible for calling <strong>Tcl_NotifyChannel</strong> to inform the generic
channel module. The driver should take care not to starve other channel
drivers or sources of callbacks by invoking Tcl_NotifyChannel too
frequently. Fairness can be insured by using the Tcl event queue to
allow the channel event to be scheduled in sequence with other events.
See the description of <strong>Tcl_QueueEvent</strong> for details on how to queue an
event.</p>
<p>This value can be retrieved with <strong>Tcl_ChannelWatchProc</strong>, which returns
a pointer to the function.</p>
<h2 id="gethandleproc">GETHANDLEPROC</h2>
<p>The <em>getHandleProc</em> field contains the address of a function called by
the generic layer to retrieve a device-specific handle from the channel.
<em>GetHandleProc</em> should match the following prototype:</p>
<p>typedef int <strong>Tcl_DriverGetHandleProc</strong>( void *<em>instanceData</em>, int
<em>direction</em>, void **<em>handlePtr</em>);</p>
<p><em>InstanceData</em> is the same as the value passed to <strong>Tcl_CreateChannel</strong>
when this channel was created. The <em>direction</em> argument is either
<strong>TCL_READABLE</strong> to retrieve the handle used for input, or
<strong>TCL_WRITABLE</strong> to retrieve the handle used for output.</p>
<p>If the channel implementation has device-specific handles, the function
should retrieve the appropriate handle associated with the channel,
according the <em>direction</em> argument. The handle should be stored in the
location referred to by <em>handlePtr</em>, and <strong>TCL_OK</strong> should be returned.
If the channel is not open for the specified direction, or if the
channel implementation does not use device handles, the function should
return <strong>TCL_ERROR</strong>.</p>
<p>This value can be retrieved with <strong>Tcl_ChannelGetHandleProc</strong>, which
returns a pointer to the function.</p>
<h2 id="flushproc">FLUSHPROC</h2>
<p>The <em>flushProc</em> field is currently reserved for future use. It should be
set to NULL. <em>FlushProc</em> should match the following prototype:</p>
<p>typedef int <strong>Tcl_DriverFlushProc</strong>( void *<em>instanceData</em>);</p>
<p>This value can be retrieved with <strong>Tcl_ChannelFlushProc</strong>, which returns
a pointer to the function.</p>
<h2 id="handlerproc">HANDLERPROC</h2>
<p>The <em>handlerProc</em> field contains the address of a function called by the
generic layer to notify the channel that an event occurred. It should be
defined for stacked channel drivers that wish to be notified of events
that occur on the underlying (stacked) channel. <em>HandlerProc</em> should
match the following prototype:</p>
<p>typedef int <strong>Tcl_DriverHandlerProc</strong>( void *<em>instanceData</em>, int
<em>interestMask</em>);</p>
<p><em>InstanceData</em> is the same as the value passed to <strong>Tcl_CreateChannel</strong>
when this channel was created. The <em>interestMask</em> is an OR-ed
combination of <strong>TCL_READABLE</strong> or <strong>TCL_WRITABLE</strong>; it indicates what
type of event occurred on this channel.</p>
<p>This value can be retrieved with <strong>Tcl_ChannelHandlerProc</strong>, which
returns a pointer to the function.</p>
<h2 id="threadactionproc">THREADACTIONPROC</h2>
<p>The <em>threadActionProc</em> field contains the address of the function called
by the generic layer when a channel is created, closed, or going to move
to a different thread, i.e. whenever thread-specific driver state might
have to initialized or updated. It can be NULL. The action
<em>TCL_CHANNEL_THREAD_REMOVE</em> is used to notify the driver that it should
update or remove any thread-specific data it might be maintaining for
the channel.</p>
<p>The action <em>TCL_CHANNEL_THREAD_INSERT</em> is used to notify the driver that
it should update or initialize any thread-specific data it might be
maintaining using the calling thread as the associate. See
<strong>Tcl_CutChannel</strong> and <strong>Tcl_SpliceChannel</strong> for more detail.</p>
<p>typedef void <strong>Tcl_DriverThreadActionProc</strong>( void *<em>instanceData</em>, int
<em>action</em>);</p>
<p><em>InstanceData</em> is the same as the value passed to <strong>Tcl_CreateChannel</strong>
when this channel was created.</p>
<p>These values can be retrieved with <strong>Tcl_ChannelThreadActionProc</strong>,
which returns a pointer to the function.</p>
<h2 id="truncateproc">TRUNCATEPROC</h2>
<p>The <em>truncateProc</em> field contains the address of the function called by
the generic layer when a channel is truncated to some length. It can be
NULL.</p>
<p>typedef int <strong>Tcl_DriverTruncateProc</strong>( void *<em>instanceData</em>, long long
<em>length</em>);</p>
<p><em>InstanceData</em> is the same as the value passed to <strong>Tcl_CreateChannel</strong>
when this channel was created, and <em>length</em> is the new length of the
underlying file, which should not be negative. The result should be 0 on
success or an errno code (suitable for use with <strong>Tcl_SetErrno</strong>) on
failure.</p>
<p>These values can be retrieved with <strong>Tcl_ChannelTruncateProc</strong>, which
returns a pointer to the function.</p>
<h1 id="tcl_badchanneloption">TCL_BADCHANNELOPTION</h1>
<p>This procedure generates a</p>
<p>error message in an (optional) interpreter. It is used by channel
drivers when an invalid Set/Get option is requested. Its purpose is to
concatenate the generic options list to the specific ones and factorize
the generic options error message string.</p>
<p>It always returns <strong>TCL_ERROR</strong></p>
<p>An error message is generated in <em>interp</em>\'s result value to indicate
that a command was invoked with a bad option. The message has the form</p>
<p>bad option \"blah\": should be one of \&lt;...generic
options...>+\&lt;...specific options...></p>
<p>so you get for instance:</p>
<p>bad option \"-blah\": should be one of -blocking, -buffering,
-buffersize, -eofchar, -translation, -peername, or -sockname</p>
<p>when called with <em>optionList</em> equal to</p>
<p>is the <em>optionName</em> argument and</p>
<p>is a space separated list of specific option words. The function takes
good care of inserting minus signs before each option, commas after, and
an</p>
<p>before the last option.</p>
<h1 id="see-also">SEE ALSO</h1>
<p>Tcl_Close(3), Tcl_OpenFileChannel(3), Tcl_SetErrno(3),
Tcl_QueueEvent(3), Tcl_StackChannel(3), Tcl_GetStdChannel(3)</p>
<h1 id="keywords">KEYWORDS</h1>
<p>blocking, channel driver, channel registration, channel type,
nonblocking</p>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
